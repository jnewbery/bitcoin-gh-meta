[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage\nFor detailed information about the code coverage, see the [test coverage report](https://corecheck.dev/bitcoin/bitcoin/pulls/30315).\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\nA summary of reviews will appear here.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#29432](https://github.com/bitcoin/bitcoin/pull/29432) (Stratum v2 Template Provider (take 3) by Sjors)\n* [#29415](https://github.com/bitcoin/bitcoin/pull/29415) (Broadcast own transactions only via short-lived Tor or I2P connections by vasild)\n* [#26697](https://github.com/bitcoin/bitcoin/pull/26697) (logging: use bitset for categories by LarryRuane)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "created_at" : "2024-06-20T15:59:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30315#issuecomment-2181044150",
      "id" : 2181044150,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30315",
      "node_id" : "IC_kwDOABII586CABe2",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2181044150/reactions"
      },
      "updated_at" : "2024-06-20T17:55:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2181044150",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Would it make sense to add a `libbitcoin_net` library? Either at the same level as `libbitcoin_common` or on top of it. I could see how other node implementations could benefit from that, but it's also a way to limit `libbitcoin_common` in size. Afaik only `libbitcoin_node` needs networking (and `zmq`?), and a future `libbitcoin_sv2`, and maybe `libbitcoin_rpc`.",
      "created_at" : "2024-06-20T16:03:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30315#issuecomment-2181051477",
      "id" : 2181051477,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30315",
      "node_id" : "IC_kwDOABII586CADRV",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2181051477/reactions"
      },
      "updated_at" : "2024-06-20T16:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2181051477",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--85328a0da195eb286784d51f73fa0af9-->\n\nð§ At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/26477378291</sub>",
      "created_at" : "2024-06-20T16:05:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30315#issuecomment-2181055856",
      "id" : 2181055856,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30315",
      "node_id" : "IC_kwDOABII586CAEVw",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2181055856/reactions"
      },
      "updated_at" : "2024-06-20T16:05:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2181055856",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30315#discussion_r1647820313"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30315"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1647820313"
         }
      },
      "author_association" : "MEMBER",
      "body" : "11328075fe1783163fa5d3113a37f6b20ccd4c43: @sipa any thoughts on how to best do this?",
      "commit_id" : "11328075fe1783163fa5d3113a37f6b20ccd4c43",
      "created_at" : "2024-06-20T16:07:31Z",
      "diff_hunk" : "@@ -0,0 +1,513 @@\n+// Copyright (c) 2023-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sv2_transport.h>\n+\n+#include <common/net_message.h>\n+#include <logging.h>\n+#include <memusage.h>\n+#include <common/sv2_messages.h>\n+#include <common/sv2_noise.h>\n+#include <random.h>\n+#include <util/check.h>\n+#include <util/strencodings.h>\n+#include <util/vector.h>\n+\n+Sv2Transport::Sv2Transport(CKey static_key, Sv2SignatureNoiseMessage certificate) noexcept\n+    : m_cipher{Sv2Cipher(std::move(static_key), std::move(certificate))}, m_initiating{false},\n+      m_recv_state{RecvState::HANDSHAKE_STEP_1},\n+      m_send_state{SendState::HANDSHAKE_STEP_2},\n+      m_message{Sv2NetMsg(Sv2NetHeader{})}\n+{\n+    LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"Noise session receive state -> %s\\n\",\n+                    RecvStateAsString(m_recv_state));\n+}\n+\n+Sv2Transport::Sv2Transport(CKey static_key, XOnlyPubKey responder_authority_key) noexcept\n+    : m_cipher{Sv2Cipher(std::move(static_key), responder_authority_key)}, m_initiating{true},\n+      m_recv_state{RecvState::HANDSHAKE_STEP_2},\n+      m_send_state{SendState::HANDSHAKE_STEP_1},\n+      m_message{Sv2NetMsg(Sv2NetHeader{})}\n+{\n+    /** Start sending immediately since we're the initiator of the connection.\n+        This only happens in test code.\n+    */\n+    LOCK(m_send_mutex);\n+    StartSendingHandshake();\n+\n+}\n+\n+void Sv2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // Enforce allowed state transitions.\n+    switch (m_recv_state) {\n+    case RecvState::HANDSHAKE_STEP_1:\n+        Assume(recv_state == RecvState::HANDSHAKE_STEP_2);\n+        break;\n+    case RecvState::HANDSHAKE_STEP_2:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    case RecvState::APP:\n+        Assume(recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+    LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"Noise session receive state -> %s\\n\",\n+                  RecvStateAsString(m_recv_state));\n+\n+}\n+\n+void Sv2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // Enforce allowed state transitions.\n+    switch (m_send_state) {\n+    case SendState::HANDSHAKE_STEP_1:\n+        Assume(send_state == SendState::HANDSHAKE_STEP_2);\n+        break;\n+    case SendState::HANDSHAKE_STEP_2:\n+        Assume(send_state == SendState::READY);\n+        break;\n+    case SendState::READY:\n+        Assume(false); // Final state\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+    LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"Noise session send state -> %s\\n\",\n+                  SendStateAsString(m_send_state));\n+}\n+\n+void Sv2Transport::StartSendingHandshake() noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    AssertLockNotHeld(m_recv_mutex);\n+    Assume(m_send_state == SendState::HANDSHAKE_STEP_1);\n+    Assume(m_send_buffer.empty());\n+\n+    m_send_buffer.resize(Sv2HandshakeState::ELLSWIFT_PUB_KEY_SIZE);\n+    m_cipher.GetHandshakeState().WriteMsgEphemeralPK(MakeWritableByteSpan(m_send_buffer));\n+\n+    m_send_state = SendState::HANDSHAKE_STEP_2;\n+}\n+\n+void Sv2Transport::SendHandshakeReply() noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_send_state == SendState::HANDSHAKE_STEP_2);\n+\n+    Assume(m_send_buffer.empty());\n+    m_send_buffer.resize(Sv2HandshakeState::HANDSHAKE_STEP2_SIZE);\n+    m_cipher.GetHandshakeState().WriteMsgES(MakeWritableByteSpan(m_send_buffer));\n+\n+    m_cipher.FinishHandshake();\n+\n+    // LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"m_hash: %s\\n\", HexStr(m_cipher.m_hash));\n+\n+    // We can send and receive stuff now, unless the other side hangs up\n+    SetSendState(SendState::READY);\n+    Assume(m_recv_state == RecvState::HANDSHAKE_STEP_2);\n+    SetReceiveState(RecvState::APP);\n+}\n+\n+Transport::BytesToSend Sv2Transport::GetBytesToSend(bool have_next_message) const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    assert(false);\n+\n+    return {\n+        Span{m_send_buffer}.subspan(0,0),\n+        false,\n+        m_send_type\n+    };\n+}\n+\n+Sv2Transport::Sv2BytesToSend Sv2Transport::GetBytesToSendSv2(bool have_next_message) const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+\n+    Assume(m_send_pos <= m_send_buffer.size());\n+    return {\n+        Span{m_send_buffer}.subspan(m_send_pos),\n+        // We only have more to send after the current m_send_buffer if there is a (next)\n+        // message to be sent, and we're capable of sending packets. */\n+        have_next_message && m_send_state == SendState::READY\n+    };\n+}\n+\n+void Sv2Transport::MarkBytesSent(size_t bytes_sent) noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+\n+    // if (m_send_state == SendState::AWAITING_KEY && m_send_pos == 0 && bytes_sent > 0) {\n+    //     LogPrint(BCLog::NET, \"start sending v2 handshake to peer=%d\\n\", m_nodeid);\n+    // }\n+\n+    m_send_pos += bytes_sent;\n+    Assume(m_send_pos <= m_send_buffer.size());\n+    // Wipe the buffer when everything is sent.\n+    if (m_send_pos == m_send_buffer.size()) {\n+        m_send_pos = 0;\n+        ClearShrink(m_send_buffer);\n+    }\n+}\n+\n+bool Sv2Transport::SetMessageToSend(CSerializedNetMsg& msg) noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+\n+    // We only allow adding a new message to be sent when in the READY state (so the packet cipher\n+    // is available) and the send buffer is empty. This limits the number of messages in the send\n+    // buffer to just one, and leaves the responsibility for queueing them up to the caller.\n+    if (m_send_state != SendState::READY) {\n+        LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"SendState is not READY\\n\");\n+        return false;\n+    }\n+\n+    if (!m_send_buffer.empty()) {\n+        LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"Send buffer is not empty\\n\");\n+        return false;\n+    }\n+\n+    // The Sv2NetMsg is wrapped inside a dummy CSerializedNetMsg, extract it:\n+    Assume(msg.m_type == \"\");\n+    Sv2NetMsg sv2_msg;\n+    // sv2_msg << msg.data;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30315#discussion_r1647820313",
      "id" : 1647820313,
      "line" : 185,
      "node_id" : "PRRC_kwDOABII585iN74Z",
      "original_commit_id" : "d787c61afefccd73fe9c3d86f84b18b45d331bf2",
      "original_line" : 185,
      "original_position" : 185,
      "original_start_line" : null,
      "path" : "src/common/sv2_transport.cpp",
      "position" : 185,
      "pull_request_review_id" : 2130844873,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30315",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1647820313/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-06-20T16:16:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1647820313",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30315#discussion_r1647822168"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30315"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1647822168"
         }
      },
      "author_association" : "MEMBER",
      "body" : "11328075fe1783163fa5d3113a37f6b20ccd4c43: TODO: shoehorn our `Sv2NetMsg` into a dummy `CNetMessage`.",
      "commit_id" : "11328075fe1783163fa5d3113a37f6b20ccd4c43",
      "created_at" : "2024-06-20T16:09:06Z",
      "diff_hunk" : "@@ -0,0 +1,513 @@\n+// Copyright (c) 2023-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sv2_transport.h>\n+\n+#include <common/net_message.h>\n+#include <logging.h>\n+#include <memusage.h>\n+#include <common/sv2_messages.h>\n+#include <common/sv2_noise.h>\n+#include <random.h>\n+#include <util/check.h>\n+#include <util/strencodings.h>\n+#include <util/vector.h>\n+\n+Sv2Transport::Sv2Transport(CKey static_key, Sv2SignatureNoiseMessage certificate) noexcept\n+    : m_cipher{Sv2Cipher(std::move(static_key), std::move(certificate))}, m_initiating{false},\n+      m_recv_state{RecvState::HANDSHAKE_STEP_1},\n+      m_send_state{SendState::HANDSHAKE_STEP_2},\n+      m_message{Sv2NetMsg(Sv2NetHeader{})}\n+{\n+    LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"Noise session receive state -> %s\\n\",\n+                    RecvStateAsString(m_recv_state));\n+}\n+\n+Sv2Transport::Sv2Transport(CKey static_key, XOnlyPubKey responder_authority_key) noexcept\n+    : m_cipher{Sv2Cipher(std::move(static_key), responder_authority_key)}, m_initiating{true},\n+      m_recv_state{RecvState::HANDSHAKE_STEP_2},\n+      m_send_state{SendState::HANDSHAKE_STEP_1},\n+      m_message{Sv2NetMsg(Sv2NetHeader{})}\n+{\n+    /** Start sending immediately since we're the initiator of the connection.\n+        This only happens in test code.\n+    */\n+    LOCK(m_send_mutex);\n+    StartSendingHandshake();\n+\n+}\n+\n+void Sv2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // Enforce allowed state transitions.\n+    switch (m_recv_state) {\n+    case RecvState::HANDSHAKE_STEP_1:\n+        Assume(recv_state == RecvState::HANDSHAKE_STEP_2);\n+        break;\n+    case RecvState::HANDSHAKE_STEP_2:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    case RecvState::APP:\n+        Assume(recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+    LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"Noise session receive state -> %s\\n\",\n+                  RecvStateAsString(m_recv_state));\n+\n+}\n+\n+void Sv2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // Enforce allowed state transitions.\n+    switch (m_send_state) {\n+    case SendState::HANDSHAKE_STEP_1:\n+        Assume(send_state == SendState::HANDSHAKE_STEP_2);\n+        break;\n+    case SendState::HANDSHAKE_STEP_2:\n+        Assume(send_state == SendState::READY);\n+        break;\n+    case SendState::READY:\n+        Assume(false); // Final state\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+    LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"Noise session send state -> %s\\n\",\n+                  SendStateAsString(m_send_state));\n+}\n+\n+void Sv2Transport::StartSendingHandshake() noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    AssertLockNotHeld(m_recv_mutex);\n+    Assume(m_send_state == SendState::HANDSHAKE_STEP_1);\n+    Assume(m_send_buffer.empty());\n+\n+    m_send_buffer.resize(Sv2HandshakeState::ELLSWIFT_PUB_KEY_SIZE);\n+    m_cipher.GetHandshakeState().WriteMsgEphemeralPK(MakeWritableByteSpan(m_send_buffer));\n+\n+    m_send_state = SendState::HANDSHAKE_STEP_2;\n+}\n+\n+void Sv2Transport::SendHandshakeReply() noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_send_state == SendState::HANDSHAKE_STEP_2);\n+\n+    Assume(m_send_buffer.empty());\n+    m_send_buffer.resize(Sv2HandshakeState::HANDSHAKE_STEP2_SIZE);\n+    m_cipher.GetHandshakeState().WriteMsgES(MakeWritableByteSpan(m_send_buffer));\n+\n+    m_cipher.FinishHandshake();\n+\n+    // LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"m_hash: %s\\n\", HexStr(m_cipher.m_hash));\n+\n+    // We can send and receive stuff now, unless the other side hangs up\n+    SetSendState(SendState::READY);\n+    Assume(m_recv_state == RecvState::HANDSHAKE_STEP_2);\n+    SetReceiveState(RecvState::APP);\n+}\n+\n+Transport::BytesToSend Sv2Transport::GetBytesToSend(bool have_next_message) const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    assert(false);\n+\n+    return {\n+        Span{m_send_buffer}.subspan(0,0),\n+        false,\n+        m_send_type\n+    };\n+}\n+\n+Sv2Transport::Sv2BytesToSend Sv2Transport::GetBytesToSendSv2(bool have_next_message) const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+\n+    Assume(m_send_pos <= m_send_buffer.size());\n+    return {\n+        Span{m_send_buffer}.subspan(m_send_pos),\n+        // We only have more to send after the current m_send_buffer if there is a (next)\n+        // message to be sent, and we're capable of sending packets. */\n+        have_next_message && m_send_state == SendState::READY\n+    };\n+}\n+\n+void Sv2Transport::MarkBytesSent(size_t bytes_sent) noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+\n+    // if (m_send_state == SendState::AWAITING_KEY && m_send_pos == 0 && bytes_sent > 0) {\n+    //     LogPrint(BCLog::NET, \"start sending v2 handshake to peer=%d\\n\", m_nodeid);\n+    // }\n+\n+    m_send_pos += bytes_sent;\n+    Assume(m_send_pos <= m_send_buffer.size());\n+    // Wipe the buffer when everything is sent.\n+    if (m_send_pos == m_send_buffer.size()) {\n+        m_send_pos = 0;\n+        ClearShrink(m_send_buffer);\n+    }\n+}\n+\n+bool Sv2Transport::SetMessageToSend(CSerializedNetMsg& msg) noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+\n+    // We only allow adding a new message to be sent when in the READY state (so the packet cipher\n+    // is available) and the send buffer is empty. This limits the number of messages in the send\n+    // buffer to just one, and leaves the responsibility for queueing them up to the caller.\n+    if (m_send_state != SendState::READY) {\n+        LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"SendState is not READY\\n\");\n+        return false;\n+    }\n+\n+    if (!m_send_buffer.empty()) {\n+        LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"Send buffer is not empty\\n\");\n+        return false;\n+    }\n+\n+    // The Sv2NetMsg is wrapped inside a dummy CSerializedNetMsg, extract it:\n+    Assume(msg.m_type == \"\");\n+    Sv2NetMsg sv2_msg;\n+    // sv2_msg << msg.data;\n+\n+    // Construct ciphertext in send buffer.\n+    const size_t encrypted_msg_size = Sv2Cipher::EncryptedMessageSize(sv2_msg.m_msg.size());\n+    m_send_buffer.resize(SV2_HEADER_ENCRYPTED_SIZE + encrypted_msg_size);\n+    Span<std::byte> buffer_span{MakeWritableByteSpan(m_send_buffer)};\n+\n+    // Header\n+    DataStream ss_header_plain{};\n+    ss_header_plain << sv2_msg.m_sv2_header;\n+    LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"Header: %s\\n\", HexStr(ss_header_plain));\n+    Span<std::byte> header_encrypted{buffer_span.subspan(0, SV2_HEADER_ENCRYPTED_SIZE)};\n+    if (!m_cipher.EncryptMessage(ss_header_plain, header_encrypted)) {\n+        return false;\n+    }\n+\n+    // Payload\n+    Span<std::byte> payload_plain = MakeWritableByteSpan(sv2_msg.m_msg);\n+    // TODO: truncate very long messages, about 100 bytes at the start and end\n+    //       is probably enough for most debugging.\n+    // LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"Payload: %s\\n\", HexStr(payload_plain));\n+    Span<std::byte> payload_encrypted{buffer_span.subspan(SV2_HEADER_ENCRYPTED_SIZE, encrypted_msg_size)};\n+    if (!m_cipher.EncryptMessage(payload_plain, payload_encrypted)) {\n+        return false;\n+    }\n+\n+    // Release memory\n+    ClearShrink(msg.data);\n+\n+    return true;\n+}\n+\n+size_t Sv2Transport::GetSendMemoryUsage() const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+\n+    return sizeof(m_send_buffer) + memusage::DynamicUsage(m_send_buffer);\n+}\n+\n+bool Sv2Transport::ReceivedBytes(Span<const uint8_t>& msg_bytes) noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    AssertLockNotHeld(m_recv_mutex);\n+    /** How many bytes to allocate in the receive buffer at most above what is received so far. */\n+    static constexpr size_t MAX_RESERVE_AHEAD = 256 * 1024; // TODO: reduce to NOISE_MAX_CHUNK_SIZE?\n+\n+    LOCK(m_recv_mutex);\n+    // Process the provided bytes in msg_bytes in a loop. In each iteration a nonzero number of\n+    // bytes (decided by GetMaxBytesToProcess) are taken from the beginning om msg_bytes, and\n+    // appended to m_recv_buffer. Then, depending on the receiver state, one of the\n+    // ProcessReceived*Bytes functions is called to process the bytes in that buffer.\n+    while (!msg_bytes.empty()) {\n+        // Decide how many bytes to copy from msg_bytes to m_recv_buffer.\n+        size_t max_read = GetMaxBytesToProcess();\n+\n+        // Reserve space in the buffer if there is not enough.\n+        if (m_recv_buffer.size() + std::min(msg_bytes.size(), max_read) > m_recv_buffer.capacity()) {\n+            switch (m_recv_state) {\n+            case RecvState::HANDSHAKE_STEP_1:\n+                m_recv_buffer.reserve(Sv2HandshakeState::ELLSWIFT_PUB_KEY_SIZE);\n+                break;\n+            case RecvState::HANDSHAKE_STEP_2:\n+                m_recv_buffer.reserve(Sv2HandshakeState::HANDSHAKE_STEP2_SIZE);\n+                break;\n+            case RecvState::APP: {\n+                // During states where a packet is being received, as much as is expected but never\n+                // more than MAX_RESERVE_AHEAD bytes in addition to what is received so far.\n+                // This means attackers that want to cause us to waste allocated memory are limited\n+                // to MAX_RESERVE_AHEAD above the largest allowed message contents size, and to\n+                // MAX_RESERVE_AHEAD more than they've actually sent us.\n+                size_t alloc_add = std::min(max_read, msg_bytes.size() + MAX_RESERVE_AHEAD);\n+                m_recv_buffer.reserve(m_recv_buffer.size() + alloc_add);\n+                break;\n+            }\n+            case RecvState::APP_READY:\n+                // The buffer is empty in this state.\n+                Assume(m_recv_buffer.empty());\n+                break;\n+            }\n+        }\n+\n+        // Can't read more than provided input.\n+        max_read = std::min(msg_bytes.size(), max_read);\n+        // Copy data to buffer.\n+        m_recv_buffer.insert(m_recv_buffer.end(), UCharCast(msg_bytes.data()), UCharCast(msg_bytes.data() + max_read));\n+        msg_bytes = msg_bytes.subspan(max_read);\n+\n+        // Process data in the buffer.\n+        switch (m_recv_state) {\n+\n+        case RecvState::HANDSHAKE_STEP_1:\n+            if (!ProcessReceivedEphemeralKeyBytes()) return false;\n+            break;\n+\n+        case RecvState::HANDSHAKE_STEP_2:\n+            if (!ProcessReceivedHandshakeReplyBytes()) return false;\n+            break;\n+\n+        case RecvState::APP:\n+            if (!ProcessReceivedPacketBytes()) return false;\n+            break;\n+\n+        case RecvState::APP_READY:\n+            return true;\n+\n+        }\n+        // Make sure we have made progress before continuing.\n+        Assume(max_read > 0);\n+    }\n+\n+    return true;\n+}\n+\n+bool Sv2Transport::ProcessReceivedEphemeralKeyBytes() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::HANDSHAKE_STEP_1);\n+    Assume(m_recv_buffer.size() <= Sv2HandshakeState::ELLSWIFT_PUB_KEY_SIZE);\n+\n+    if (m_recv_buffer.size() == Sv2HandshakeState::ELLSWIFT_PUB_KEY_SIZE) {\n+        // Other side's key has been fully received, and can now be Diffie-Hellman\n+        // combined with our key. This is act 1 of the Noise Protocol handshake.\n+        // TODO handle failure\n+        // TODO: MakeByteSpan instead of MakeWritableByteSpan\n+        m_cipher.GetHandshakeState().ReadMsgEphemeralPK(MakeWritableByteSpan(m_recv_buffer));\n+        m_recv_buffer.clear();\n+        SetReceiveState(RecvState::HANDSHAKE_STEP_2);\n+\n+        LOCK(m_send_mutex);\n+        Assume(m_send_buffer.size() == 0);\n+\n+        // Send our act 2 handshake\n+        SendHandshakeReply();\n+    } else {\n+        // We still have to receive more key bytes.\n+    }\n+    return true;\n+}\n+\n+bool Sv2Transport::ProcessReceivedHandshakeReplyBytes() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::HANDSHAKE_STEP_2);\n+    Assume(m_recv_buffer.size() <= Sv2HandshakeState::HANDSHAKE_STEP2_SIZE);\n+\n+    if (m_recv_buffer.size() == Sv2HandshakeState::HANDSHAKE_STEP2_SIZE) {\n+        // TODO handle failure\n+        // TODO: MakeByteSpan instead of MakeWritableByteSpan\n+        bool res = m_cipher.GetHandshakeState().ReadMsgES(MakeWritableByteSpan(m_recv_buffer));\n+        if (!res) return false;\n+        m_recv_buffer.clear();\n+        m_cipher.FinishHandshake();\n+        SetReceiveState(RecvState::APP);\n+\n+        LOCK(m_send_mutex);\n+        Assume(m_send_buffer.size() == 0);\n+\n+        SetSendState(SendState::READY);\n+    } else {\n+        // We still have to receive more key bytes.\n+    }\n+    return true;\n+}\n+\n+size_t Sv2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::HANDSHAKE_STEP_1:\n+        // In this state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= Sv2HandshakeState::ELLSWIFT_PUB_KEY_SIZE);\n+        return Sv2HandshakeState::ELLSWIFT_PUB_KEY_SIZE - m_recv_buffer.size();\n+    case RecvState::HANDSHAKE_STEP_2:\n+        // In this state, we only allow the handshake reply into the receive buffer.\n+        Assume(m_recv_buffer.size() <= Sv2HandshakeState::HANDSHAKE_STEP2_SIZE);\n+        return Sv2HandshakeState::HANDSHAKE_STEP2_SIZE - m_recv_buffer.size();\n+    case RecvState::APP:\n+        // Decode a packet. Process the header first,\n+        // so that we know where the current packet ends (and we don't process bytes from the next\n+        // packet yet). Then, process the ciphertext bytes of the current packet.\n+        if (m_recv_buffer.size() < SV2_HEADER_ENCRYPTED_SIZE) {\n+            return SV2_HEADER_ENCRYPTED_SIZE - m_recv_buffer.size();\n+        } else {\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted header is left in the receive buffer.\n+            size_t expanded_size_with_header = SV2_HEADER_ENCRYPTED_SIZE + Sv2Cipher::EncryptedMessageSize(m_header.m_msg_len);\n+            return expanded_size_with_header - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    Assume(false); // unreachable\n+    return 0;\n+}\n+\n+bool Sv2Transport::ProcessReceivedPacketBytes() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::APP);\n+\n+    // The maximum permitted decrypted payload size for a packet\n+    static constexpr size_t MAX_CONTENTS_LEN = 16777215; // 24 bit unsigned;\n+\n+    Assume(m_recv_buffer.size() <= SV2_HEADER_ENCRYPTED_SIZE || m_header.m_msg_len > 0);\n+\n+    if (m_recv_buffer.size() == SV2_HEADER_ENCRYPTED_SIZE) {\n+        // Header received, decrypt it.\n+        std::array<std::byte, SV2_HEADER_PLAIN_SIZE> header_plain;\n+        if  (!m_cipher.DecryptMessage(MakeWritableByteSpan(m_recv_buffer), header_plain)) {\n+            LogPrintLevel(BCLog::SV2, BCLog::Level::Debug, \"Failed to decrypt header\\n\");\n+            return false;\n+        }\n+\n+        LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"Header: %s\\n\", HexStr(header_plain));\n+\n+        // Decode header\n+        DataStream ss_header{header_plain};\n+        node::Sv2NetHeader header;\n+        ss_header >> header;\n+        m_header = std::move(header);\n+\n+        // TODO: 16 MB is pretty large, maybe set lower limits for most or all message types?\n+        if (m_header.m_msg_len > MAX_CONTENTS_LEN) {\n+            LogTrace(BCLog::SV2, \"Packet too large (%u bytes)\\n\", m_header.m_msg_len);\n+            return false;\n+        }\n+\n+        // Disconnect for empty messages (TODO: check the spec)\n+        if (m_header.m_msg_len == 0) {\n+            LogTrace(BCLog::SV2, \"Empty message\\n\");\n+            return false;\n+        }\n+        LogTrace(BCLog::SV2, \"Expecting %d bytes payload (plain)\\n\", m_header.m_msg_len);\n+    } else if (m_recv_buffer.size() > SV2_HEADER_ENCRYPTED_SIZE &&\n+               m_recv_buffer.size() == SV2_HEADER_ENCRYPTED_SIZE + Sv2Cipher::EncryptedMessageSize(m_header.m_msg_len)) {\n+        /** Ciphertext received: decrypt into decode_buffer and deserialize into m_message.\n+          *\n+          * Note that it is impossible to reach this branch without hitting the\n+          * branch above first, as GetMaxBytesToProcess only allows up to\n+          * SV2_HEADER_ENCRYPTED_SIZE into the buffer before that point. */\n+        std::vector<std::uint8_t> payload;\n+        payload.resize(m_header.m_msg_len);\n+\n+        Span<std::byte> recv_span{MakeWritableByteSpan(m_recv_buffer).subspan(SV2_HEADER_ENCRYPTED_SIZE)};\n+        if (!m_cipher.DecryptMessage(recv_span, MakeWritableByteSpan(payload))) {\n+            LogPrintLevel(BCLog::SV2, BCLog::Level::Debug, \"Failed to decrypt message payload\\n\");\n+            return false;\n+        }\n+        LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"Payload: %s\\n\", HexStr(payload));\n+\n+        // Wipe the receive buffer where the next packet will be received into.\n+        ClearShrink(m_recv_buffer);\n+\n+        Sv2NetMsg message{std::move(m_header), std::move(payload)};\n+        m_message = std::move(message);\n+\n+        // At this point we have a valid message decrypted into m_message.\n+        SetReceiveState(RecvState::APP_READY);\n+    } else {\n+        // We either have less than 22 bytes, so we don't know the packet's length yet, or more\n+        // than 22 bytes but less than the packet's full ciphertext. Wait until those arrive.\n+        LogTrace(BCLog::SV2, \"Waiting for more bytes\\n\");\n+    }\n+    return true;\n+}\n+\n+bool Sv2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+CNetMessage Sv2Transport::GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    assert(false);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30315#discussion_r1647822168",
      "id" : 1647822168,
      "line" : 466,
      "node_id" : "PRRC_kwDOABII585iN8VY",
      "original_commit_id" : "d787c61afefccd73fe9c3d86f84b18b45d331bf2",
      "original_line" : 466,
      "original_position" : 466,
      "original_start_line" : null,
      "path" : "src/common/sv2_transport.cpp",
      "position" : 466,
      "pull_request_review_id" : 2130848013,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30315",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1647822168/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-06-20T16:16:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1647822168",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30315#discussion_r1647825951"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30315"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1647825951"
         }
      },
      "author_association" : "MEMBER",
      "body" : "11328075fe1783163fa5d3113a37f6b20ccd4c43: I don't remember why I decided on a custom implementation here.",
      "commit_id" : "11328075fe1783163fa5d3113a37f6b20ccd4c43",
      "created_at" : "2024-06-20T16:12:13Z",
      "diff_hunk" : "@@ -0,0 +1,513 @@\n+// Copyright (c) 2023-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sv2_transport.h>\n+\n+#include <common/net_message.h>\n+#include <logging.h>\n+#include <memusage.h>\n+#include <common/sv2_messages.h>\n+#include <common/sv2_noise.h>\n+#include <random.h>\n+#include <util/check.h>\n+#include <util/strencodings.h>\n+#include <util/vector.h>\n+\n+Sv2Transport::Sv2Transport(CKey static_key, Sv2SignatureNoiseMessage certificate) noexcept\n+    : m_cipher{Sv2Cipher(std::move(static_key), std::move(certificate))}, m_initiating{false},\n+      m_recv_state{RecvState::HANDSHAKE_STEP_1},\n+      m_send_state{SendState::HANDSHAKE_STEP_2},\n+      m_message{Sv2NetMsg(Sv2NetHeader{})}\n+{\n+    LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"Noise session receive state -> %s\\n\",\n+                    RecvStateAsString(m_recv_state));\n+}\n+\n+Sv2Transport::Sv2Transport(CKey static_key, XOnlyPubKey responder_authority_key) noexcept\n+    : m_cipher{Sv2Cipher(std::move(static_key), responder_authority_key)}, m_initiating{true},\n+      m_recv_state{RecvState::HANDSHAKE_STEP_2},\n+      m_send_state{SendState::HANDSHAKE_STEP_1},\n+      m_message{Sv2NetMsg(Sv2NetHeader{})}\n+{\n+    /** Start sending immediately since we're the initiator of the connection.\n+        This only happens in test code.\n+    */\n+    LOCK(m_send_mutex);\n+    StartSendingHandshake();\n+\n+}\n+\n+void Sv2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // Enforce allowed state transitions.\n+    switch (m_recv_state) {\n+    case RecvState::HANDSHAKE_STEP_1:\n+        Assume(recv_state == RecvState::HANDSHAKE_STEP_2);\n+        break;\n+    case RecvState::HANDSHAKE_STEP_2:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    case RecvState::APP:\n+        Assume(recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+    LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"Noise session receive state -> %s\\n\",\n+                  RecvStateAsString(m_recv_state));\n+\n+}\n+\n+void Sv2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // Enforce allowed state transitions.\n+    switch (m_send_state) {\n+    case SendState::HANDSHAKE_STEP_1:\n+        Assume(send_state == SendState::HANDSHAKE_STEP_2);\n+        break;\n+    case SendState::HANDSHAKE_STEP_2:\n+        Assume(send_state == SendState::READY);\n+        break;\n+    case SendState::READY:\n+        Assume(false); // Final state\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+    LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"Noise session send state -> %s\\n\",\n+                  SendStateAsString(m_send_state));\n+}\n+\n+void Sv2Transport::StartSendingHandshake() noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    AssertLockNotHeld(m_recv_mutex);\n+    Assume(m_send_state == SendState::HANDSHAKE_STEP_1);\n+    Assume(m_send_buffer.empty());\n+\n+    m_send_buffer.resize(Sv2HandshakeState::ELLSWIFT_PUB_KEY_SIZE);\n+    m_cipher.GetHandshakeState().WriteMsgEphemeralPK(MakeWritableByteSpan(m_send_buffer));\n+\n+    m_send_state = SendState::HANDSHAKE_STEP_2;\n+}\n+\n+void Sv2Transport::SendHandshakeReply() noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_send_state == SendState::HANDSHAKE_STEP_2);\n+\n+    Assume(m_send_buffer.empty());\n+    m_send_buffer.resize(Sv2HandshakeState::HANDSHAKE_STEP2_SIZE);\n+    m_cipher.GetHandshakeState().WriteMsgES(MakeWritableByteSpan(m_send_buffer));\n+\n+    m_cipher.FinishHandshake();\n+\n+    // LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"m_hash: %s\\n\", HexStr(m_cipher.m_hash));\n+\n+    // We can send and receive stuff now, unless the other side hangs up\n+    SetSendState(SendState::READY);\n+    Assume(m_recv_state == RecvState::HANDSHAKE_STEP_2);\n+    SetReceiveState(RecvState::APP);\n+}\n+\n+Transport::BytesToSend Sv2Transport::GetBytesToSend(bool have_next_message) const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    assert(false);\n+\n+    return {\n+        Span{m_send_buffer}.subspan(0,0),\n+        false,\n+        m_send_type\n+    };\n+}\n+\n+Sv2Transport::Sv2BytesToSend Sv2Transport::GetBytesToSendSv2(bool have_next_message) const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+\n+    Assume(m_send_pos <= m_send_buffer.size());\n+    return {\n+        Span{m_send_buffer}.subspan(m_send_pos),",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30315#discussion_r1647825951",
      "id" : 1647825951,
      "line" : 139,
      "node_id" : "PRRC_kwDOABII585iN9Qf",
      "original_commit_id" : "d787c61afefccd73fe9c3d86f84b18b45d331bf2",
      "original_line" : 139,
      "original_position" : 139,
      "original_start_line" : null,
      "path" : "src/common/sv2_transport.cpp",
      "position" : 139,
      "pull_request_review_id" : 2130854214,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30315",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1647825951/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-06-20T16:16:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1647825951",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "It compiles and the tests run, but it's not pretty.\r\n\r\nThe conversion between `Sv2NetMsg` and `CSerializedNetMsg` / `CNetMessage` is done in https://github.com/bitcoin/bitcoin/pull/30315/commits/7d937674de425d8e2525bac9e719ac93a775ea45, which is a bit of a hack at the moment.\r\n\r\nI also haven't put much thought into `Sv2NetMsg` ever since I took over #27854, so perhaps this design can be improved as well.",
      "created_at" : "2024-06-21T11:18:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30315#issuecomment-2182554706",
      "id" : 2182554706,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30315",
      "node_id" : "IC_kwDOABII586CFyRS",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2182554706/reactions"
      },
      "updated_at" : "2024-06-21T11:19:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2182554706",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   }
]
