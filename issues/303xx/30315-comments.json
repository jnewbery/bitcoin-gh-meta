[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage\nFor detailed information about the code coverage, see the [test coverage report](https://corecheck.dev/bitcoin/bitcoin/pulls/30315).\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\nA summary of reviews will appear here.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#29432](https://github.com/bitcoin/bitcoin/pull/29432) (Stratum v2 Template Provider (take 3) by Sjors)\n* [#29415](https://github.com/bitcoin/bitcoin/pull/29415) (Broadcast own transactions only via short-lived Tor or I2P connections by vasild)\n* [#26697](https://github.com/bitcoin/bitcoin/pull/26697) (logging: use bitset for categories by LarryRuane)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "created_at" : "2024-06-20T15:59:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30315#issuecomment-2181044150",
      "id" : 2181044150,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30315",
      "node_id" : "IC_kwDOABII586CABe2",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2181044150/reactions"
      },
      "updated_at" : "2024-06-20T17:55:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2181044150",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Would it make sense to add a `libbitcoin_net` library? Either at the same level as `libbitcoin_common` or on top of it. I could see how other node implementations could benefit from that, but it's also a way to limit `libbitcoin_common` in size. Afaik only `libbitcoin_node` needs networking (and `zmq`?), and a future `libbitcoin_sv2`, and maybe `libbitcoin_rpc`.",
      "created_at" : "2024-06-20T16:03:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30315#issuecomment-2181051477",
      "id" : 2181051477,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30315",
      "node_id" : "IC_kwDOABII586CADRV",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2181051477/reactions"
      },
      "updated_at" : "2024-06-20T16:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2181051477",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--85328a0da195eb286784d51f73fa0af9-->\n\nð§ At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/26477378291</sub>",
      "created_at" : "2024-06-20T16:05:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30315#issuecomment-2181055856",
      "id" : 2181055856,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30315",
      "node_id" : "IC_kwDOABII586CAEVw",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2181055856/reactions"
      },
      "updated_at" : "2024-06-20T16:05:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2181055856",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30315#discussion_r1647820313"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30315"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1647820313"
         }
      },
      "author_association" : "MEMBER",
      "body" : "11328075fe1783163fa5d3113a37f6b20ccd4c43: @sipa any thoughts on how to best do this?",
      "commit_id" : "11328075fe1783163fa5d3113a37f6b20ccd4c43",
      "created_at" : "2024-06-20T16:07:31Z",
      "diff_hunk" : "@@ -0,0 +1,513 @@\n+// Copyright (c) 2023-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sv2_transport.h>\n+\n+#include <common/net_message.h>\n+#include <logging.h>\n+#include <memusage.h>\n+#include <common/sv2_messages.h>\n+#include <common/sv2_noise.h>\n+#include <random.h>\n+#include <util/check.h>\n+#include <util/strencodings.h>\n+#include <util/vector.h>\n+\n+Sv2Transport::Sv2Transport(CKey static_key, Sv2SignatureNoiseMessage certificate) noexcept\n+    : m_cipher{Sv2Cipher(std::move(static_key), std::move(certificate))}, m_initiating{false},\n+      m_recv_state{RecvState::HANDSHAKE_STEP_1},\n+      m_send_state{SendState::HANDSHAKE_STEP_2},\n+      m_message{Sv2NetMsg(Sv2NetHeader{})}\n+{\n+    LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"Noise session receive state -> %s\\n\",\n+                    RecvStateAsString(m_recv_state));\n+}\n+\n+Sv2Transport::Sv2Transport(CKey static_key, XOnlyPubKey responder_authority_key) noexcept\n+    : m_cipher{Sv2Cipher(std::move(static_key), responder_authority_key)}, m_initiating{true},\n+      m_recv_state{RecvState::HANDSHAKE_STEP_2},\n+      m_send_state{SendState::HANDSHAKE_STEP_1},\n+      m_message{Sv2NetMsg(Sv2NetHeader{})}\n+{\n+    /** Start sending immediately since we're the initiator of the connection.\n+        This only happens in test code.\n+    */\n+    LOCK(m_send_mutex);\n+    StartSendingHandshake();\n+\n+}\n+\n+void Sv2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // Enforce allowed state transitions.\n+    switch (m_recv_state) {\n+    case RecvState::HANDSHAKE_STEP_1:\n+        Assume(recv_state == RecvState::HANDSHAKE_STEP_2);\n+        break;\n+    case RecvState::HANDSHAKE_STEP_2:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    case RecvState::APP:\n+        Assume(recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+    LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"Noise session receive state -> %s\\n\",\n+                  RecvStateAsString(m_recv_state));\n+\n+}\n+\n+void Sv2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // Enforce allowed state transitions.\n+    switch (m_send_state) {\n+    case SendState::HANDSHAKE_STEP_1:\n+        Assume(send_state == SendState::HANDSHAKE_STEP_2);\n+        break;\n+    case SendState::HANDSHAKE_STEP_2:\n+        Assume(send_state == SendState::READY);\n+        break;\n+    case SendState::READY:\n+        Assume(false); // Final state\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+    LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"Noise session send state -> %s\\n\",\n+                  SendStateAsString(m_send_state));\n+}\n+\n+void Sv2Transport::StartSendingHandshake() noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    AssertLockNotHeld(m_recv_mutex);\n+    Assume(m_send_state == SendState::HANDSHAKE_STEP_1);\n+    Assume(m_send_buffer.empty());\n+\n+    m_send_buffer.resize(Sv2HandshakeState::ELLSWIFT_PUB_KEY_SIZE);\n+    m_cipher.GetHandshakeState().WriteMsgEphemeralPK(MakeWritableByteSpan(m_send_buffer));\n+\n+    m_send_state = SendState::HANDSHAKE_STEP_2;\n+}\n+\n+void Sv2Transport::SendHandshakeReply() noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_send_state == SendState::HANDSHAKE_STEP_2);\n+\n+    Assume(m_send_buffer.empty());\n+    m_send_buffer.resize(Sv2HandshakeState::HANDSHAKE_STEP2_SIZE);\n+    m_cipher.GetHandshakeState().WriteMsgES(MakeWritableByteSpan(m_send_buffer));\n+\n+    m_cipher.FinishHandshake();\n+\n+    // LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"m_hash: %s\\n\", HexStr(m_cipher.m_hash));\n+\n+    // We can send and receive stuff now, unless the other side hangs up\n+    SetSendState(SendState::READY);\n+    Assume(m_recv_state == RecvState::HANDSHAKE_STEP_2);\n+    SetReceiveState(RecvState::APP);\n+}\n+\n+Transport::BytesToSend Sv2Transport::GetBytesToSend(bool have_next_message) const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    assert(false);\n+\n+    return {\n+        Span{m_send_buffer}.subspan(0,0),\n+        false,\n+        m_send_type\n+    };\n+}\n+\n+Sv2Transport::Sv2BytesToSend Sv2Transport::GetBytesToSendSv2(bool have_next_message) const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+\n+    Assume(m_send_pos <= m_send_buffer.size());\n+    return {\n+        Span{m_send_buffer}.subspan(m_send_pos),\n+        // We only have more to send after the current m_send_buffer if there is a (next)\n+        // message to be sent, and we're capable of sending packets. */\n+        have_next_message && m_send_state == SendState::READY\n+    };\n+}\n+\n+void Sv2Transport::MarkBytesSent(size_t bytes_sent) noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+\n+    // if (m_send_state == SendState::AWAITING_KEY && m_send_pos == 0 && bytes_sent > 0) {\n+    //     LogPrint(BCLog::NET, \"start sending v2 handshake to peer=%d\\n\", m_nodeid);\n+    // }\n+\n+    m_send_pos += bytes_sent;\n+    Assume(m_send_pos <= m_send_buffer.size());\n+    // Wipe the buffer when everything is sent.\n+    if (m_send_pos == m_send_buffer.size()) {\n+        m_send_pos = 0;\n+        ClearShrink(m_send_buffer);\n+    }\n+}\n+\n+bool Sv2Transport::SetMessageToSend(CSerializedNetMsg& msg) noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+\n+    // We only allow adding a new message to be sent when in the READY state (so the packet cipher\n+    // is available) and the send buffer is empty. This limits the number of messages in the send\n+    // buffer to just one, and leaves the responsibility for queueing them up to the caller.\n+    if (m_send_state != SendState::READY) {\n+        LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"SendState is not READY\\n\");\n+        return false;\n+    }\n+\n+    if (!m_send_buffer.empty()) {\n+        LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"Send buffer is not empty\\n\");\n+        return false;\n+    }\n+\n+    // The Sv2NetMsg is wrapped inside a dummy CSerializedNetMsg, extract it:\n+    Assume(msg.m_type == \"\");\n+    Sv2NetMsg sv2_msg;\n+    // sv2_msg << msg.data;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30315#discussion_r1647820313",
      "id" : 1647820313,
      "line" : 185,
      "node_id" : "PRRC_kwDOABII585iN74Z",
      "original_commit_id" : "d787c61afefccd73fe9c3d86f84b18b45d331bf2",
      "original_line" : 185,
      "original_position" : 185,
      "original_start_line" : null,
      "path" : "src/common/sv2_transport.cpp",
      "position" : 185,
      "pull_request_review_id" : 2130844873,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30315",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1647820313/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-06-20T16:16:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1647820313",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30315#discussion_r1647822168"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30315"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1647822168"
         }
      },
      "author_association" : "MEMBER",
      "body" : "11328075fe1783163fa5d3113a37f6b20ccd4c43: TODO: shoehorn our `Sv2NetMsg` into a dummy `CNetMessage`.",
      "commit_id" : "11328075fe1783163fa5d3113a37f6b20ccd4c43",
      "created_at" : "2024-06-20T16:09:06Z",
      "diff_hunk" : "@@ -0,0 +1,513 @@\n+// Copyright (c) 2023-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sv2_transport.h>\n+\n+#include <common/net_message.h>\n+#include <logging.h>\n+#include <memusage.h>\n+#include <common/sv2_messages.h>\n+#include <common/sv2_noise.h>\n+#include <random.h>\n+#include <util/check.h>\n+#include <util/strencodings.h>\n+#include <util/vector.h>\n+\n+Sv2Transport::Sv2Transport(CKey static_key, Sv2SignatureNoiseMessage certificate) noexcept\n+    : m_cipher{Sv2Cipher(std::move(static_key), std::move(certificate))}, m_initiating{false},\n+      m_recv_state{RecvState::HANDSHAKE_STEP_1},\n+      m_send_state{SendState::HANDSHAKE_STEP_2},\n+      m_message{Sv2NetMsg(Sv2NetHeader{})}\n+{\n+    LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"Noise session receive state -> %s\\n\",\n+                    RecvStateAsString(m_recv_state));\n+}\n+\n+Sv2Transport::Sv2Transport(CKey static_key, XOnlyPubKey responder_authority_key) noexcept\n+    : m_cipher{Sv2Cipher(std::move(static_key), responder_authority_key)}, m_initiating{true},\n+      m_recv_state{RecvState::HANDSHAKE_STEP_2},\n+      m_send_state{SendState::HANDSHAKE_STEP_1},\n+      m_message{Sv2NetMsg(Sv2NetHeader{})}\n+{\n+    /** Start sending immediately since we're the initiator of the connection.\n+        This only happens in test code.\n+    */\n+    LOCK(m_send_mutex);\n+    StartSendingHandshake();\n+\n+}\n+\n+void Sv2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // Enforce allowed state transitions.\n+    switch (m_recv_state) {\n+    case RecvState::HANDSHAKE_STEP_1:\n+        Assume(recv_state == RecvState::HANDSHAKE_STEP_2);\n+        break;\n+    case RecvState::HANDSHAKE_STEP_2:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    case RecvState::APP:\n+        Assume(recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+    LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"Noise session receive state -> %s\\n\",\n+                  RecvStateAsString(m_recv_state));\n+\n+}\n+\n+void Sv2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // Enforce allowed state transitions.\n+    switch (m_send_state) {\n+    case SendState::HANDSHAKE_STEP_1:\n+        Assume(send_state == SendState::HANDSHAKE_STEP_2);\n+        break;\n+    case SendState::HANDSHAKE_STEP_2:\n+        Assume(send_state == SendState::READY);\n+        break;\n+    case SendState::READY:\n+        Assume(false); // Final state\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+    LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"Noise session send state -> %s\\n\",\n+                  SendStateAsString(m_send_state));\n+}\n+\n+void Sv2Transport::StartSendingHandshake() noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    AssertLockNotHeld(m_recv_mutex);\n+    Assume(m_send_state == SendState::HANDSHAKE_STEP_1);\n+    Assume(m_send_buffer.empty());\n+\n+    m_send_buffer.resize(Sv2HandshakeState::ELLSWIFT_PUB_KEY_SIZE);\n+    m_cipher.GetHandshakeState().WriteMsgEphemeralPK(MakeWritableByteSpan(m_send_buffer));\n+\n+    m_send_state = SendState::HANDSHAKE_STEP_2;\n+}\n+\n+void Sv2Transport::SendHandshakeReply() noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_send_state == SendState::HANDSHAKE_STEP_2);\n+\n+    Assume(m_send_buffer.empty());\n+    m_send_buffer.resize(Sv2HandshakeState::HANDSHAKE_STEP2_SIZE);\n+    m_cipher.GetHandshakeState().WriteMsgES(MakeWritableByteSpan(m_send_buffer));\n+\n+    m_cipher.FinishHandshake();\n+\n+    // LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"m_hash: %s\\n\", HexStr(m_cipher.m_hash));\n+\n+    // We can send and receive stuff now, unless the other side hangs up\n+    SetSendState(SendState::READY);\n+    Assume(m_recv_state == RecvState::HANDSHAKE_STEP_2);\n+    SetReceiveState(RecvState::APP);\n+}\n+\n+Transport::BytesToSend Sv2Transport::GetBytesToSend(bool have_next_message) const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    assert(false);\n+\n+    return {\n+        Span{m_send_buffer}.subspan(0,0),\n+        false,\n+        m_send_type\n+    };\n+}\n+\n+Sv2Transport::Sv2BytesToSend Sv2Transport::GetBytesToSendSv2(bool have_next_message) const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+\n+    Assume(m_send_pos <= m_send_buffer.size());\n+    return {\n+        Span{m_send_buffer}.subspan(m_send_pos),\n+        // We only have more to send after the current m_send_buffer if there is a (next)\n+        // message to be sent, and we're capable of sending packets. */\n+        have_next_message && m_send_state == SendState::READY\n+    };\n+}\n+\n+void Sv2Transport::MarkBytesSent(size_t bytes_sent) noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+\n+    // if (m_send_state == SendState::AWAITING_KEY && m_send_pos == 0 && bytes_sent > 0) {\n+    //     LogPrint(BCLog::NET, \"start sending v2 handshake to peer=%d\\n\", m_nodeid);\n+    // }\n+\n+    m_send_pos += bytes_sent;\n+    Assume(m_send_pos <= m_send_buffer.size());\n+    // Wipe the buffer when everything is sent.\n+    if (m_send_pos == m_send_buffer.size()) {\n+        m_send_pos = 0;\n+        ClearShrink(m_send_buffer);\n+    }\n+}\n+\n+bool Sv2Transport::SetMessageToSend(CSerializedNetMsg& msg) noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+\n+    // We only allow adding a new message to be sent when in the READY state (so the packet cipher\n+    // is available) and the send buffer is empty. This limits the number of messages in the send\n+    // buffer to just one, and leaves the responsibility for queueing them up to the caller.\n+    if (m_send_state != SendState::READY) {\n+        LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"SendState is not READY\\n\");\n+        return false;\n+    }\n+\n+    if (!m_send_buffer.empty()) {\n+        LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"Send buffer is not empty\\n\");\n+        return false;\n+    }\n+\n+    // The Sv2NetMsg is wrapped inside a dummy CSerializedNetMsg, extract it:\n+    Assume(msg.m_type == \"\");\n+    Sv2NetMsg sv2_msg;\n+    // sv2_msg << msg.data;\n+\n+    // Construct ciphertext in send buffer.\n+    const size_t encrypted_msg_size = Sv2Cipher::EncryptedMessageSize(sv2_msg.m_msg.size());\n+    m_send_buffer.resize(SV2_HEADER_ENCRYPTED_SIZE + encrypted_msg_size);\n+    Span<std::byte> buffer_span{MakeWritableByteSpan(m_send_buffer)};\n+\n+    // Header\n+    DataStream ss_header_plain{};\n+    ss_header_plain << sv2_msg.m_sv2_header;\n+    LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"Header: %s\\n\", HexStr(ss_header_plain));\n+    Span<std::byte> header_encrypted{buffer_span.subspan(0, SV2_HEADER_ENCRYPTED_SIZE)};\n+    if (!m_cipher.EncryptMessage(ss_header_plain, header_encrypted)) {\n+        return false;\n+    }\n+\n+    // Payload\n+    Span<std::byte> payload_plain = MakeWritableByteSpan(sv2_msg.m_msg);\n+    // TODO: truncate very long messages, about 100 bytes at the start and end\n+    //       is probably enough for most debugging.\n+    // LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"Payload: %s\\n\", HexStr(payload_plain));\n+    Span<std::byte> payload_encrypted{buffer_span.subspan(SV2_HEADER_ENCRYPTED_SIZE, encrypted_msg_size)};\n+    if (!m_cipher.EncryptMessage(payload_plain, payload_encrypted)) {\n+        return false;\n+    }\n+\n+    // Release memory\n+    ClearShrink(msg.data);\n+\n+    return true;\n+}\n+\n+size_t Sv2Transport::GetSendMemoryUsage() const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+\n+    return sizeof(m_send_buffer) + memusage::DynamicUsage(m_send_buffer);\n+}\n+\n+bool Sv2Transport::ReceivedBytes(Span<const uint8_t>& msg_bytes) noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    AssertLockNotHeld(m_recv_mutex);\n+    /** How many bytes to allocate in the receive buffer at most above what is received so far. */\n+    static constexpr size_t MAX_RESERVE_AHEAD = 256 * 1024; // TODO: reduce to NOISE_MAX_CHUNK_SIZE?\n+\n+    LOCK(m_recv_mutex);\n+    // Process the provided bytes in msg_bytes in a loop. In each iteration a nonzero number of\n+    // bytes (decided by GetMaxBytesToProcess) are taken from the beginning om msg_bytes, and\n+    // appended to m_recv_buffer. Then, depending on the receiver state, one of the\n+    // ProcessReceived*Bytes functions is called to process the bytes in that buffer.\n+    while (!msg_bytes.empty()) {\n+        // Decide how many bytes to copy from msg_bytes to m_recv_buffer.\n+        size_t max_read = GetMaxBytesToProcess();\n+\n+        // Reserve space in the buffer if there is not enough.\n+        if (m_recv_buffer.size() + std::min(msg_bytes.size(), max_read) > m_recv_buffer.capacity()) {\n+            switch (m_recv_state) {\n+            case RecvState::HANDSHAKE_STEP_1:\n+                m_recv_buffer.reserve(Sv2HandshakeState::ELLSWIFT_PUB_KEY_SIZE);\n+                break;\n+            case RecvState::HANDSHAKE_STEP_2:\n+                m_recv_buffer.reserve(Sv2HandshakeState::HANDSHAKE_STEP2_SIZE);\n+                break;\n+            case RecvState::APP: {\n+                // During states where a packet is being received, as much as is expected but never\n+                // more than MAX_RESERVE_AHEAD bytes in addition to what is received so far.\n+                // This means attackers that want to cause us to waste allocated memory are limited\n+                // to MAX_RESERVE_AHEAD above the largest allowed message contents size, and to\n+                // MAX_RESERVE_AHEAD more than they've actually sent us.\n+                size_t alloc_add = std::min(max_read, msg_bytes.size() + MAX_RESERVE_AHEAD);\n+                m_recv_buffer.reserve(m_recv_buffer.size() + alloc_add);\n+                break;\n+            }\n+            case RecvState::APP_READY:\n+                // The buffer is empty in this state.\n+                Assume(m_recv_buffer.empty());\n+                break;\n+            }\n+        }\n+\n+        // Can't read more than provided input.\n+        max_read = std::min(msg_bytes.size(), max_read);\n+        // Copy data to buffer.\n+        m_recv_buffer.insert(m_recv_buffer.end(), UCharCast(msg_bytes.data()), UCharCast(msg_bytes.data() + max_read));\n+        msg_bytes = msg_bytes.subspan(max_read);\n+\n+        // Process data in the buffer.\n+        switch (m_recv_state) {\n+\n+        case RecvState::HANDSHAKE_STEP_1:\n+            if (!ProcessReceivedEphemeralKeyBytes()) return false;\n+            break;\n+\n+        case RecvState::HANDSHAKE_STEP_2:\n+            if (!ProcessReceivedHandshakeReplyBytes()) return false;\n+            break;\n+\n+        case RecvState::APP:\n+            if (!ProcessReceivedPacketBytes()) return false;\n+            break;\n+\n+        case RecvState::APP_READY:\n+            return true;\n+\n+        }\n+        // Make sure we have made progress before continuing.\n+        Assume(max_read > 0);\n+    }\n+\n+    return true;\n+}\n+\n+bool Sv2Transport::ProcessReceivedEphemeralKeyBytes() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::HANDSHAKE_STEP_1);\n+    Assume(m_recv_buffer.size() <= Sv2HandshakeState::ELLSWIFT_PUB_KEY_SIZE);\n+\n+    if (m_recv_buffer.size() == Sv2HandshakeState::ELLSWIFT_PUB_KEY_SIZE) {\n+        // Other side's key has been fully received, and can now be Diffie-Hellman\n+        // combined with our key. This is act 1 of the Noise Protocol handshake.\n+        // TODO handle failure\n+        // TODO: MakeByteSpan instead of MakeWritableByteSpan\n+        m_cipher.GetHandshakeState().ReadMsgEphemeralPK(MakeWritableByteSpan(m_recv_buffer));\n+        m_recv_buffer.clear();\n+        SetReceiveState(RecvState::HANDSHAKE_STEP_2);\n+\n+        LOCK(m_send_mutex);\n+        Assume(m_send_buffer.size() == 0);\n+\n+        // Send our act 2 handshake\n+        SendHandshakeReply();\n+    } else {\n+        // We still have to receive more key bytes.\n+    }\n+    return true;\n+}\n+\n+bool Sv2Transport::ProcessReceivedHandshakeReplyBytes() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::HANDSHAKE_STEP_2);\n+    Assume(m_recv_buffer.size() <= Sv2HandshakeState::HANDSHAKE_STEP2_SIZE);\n+\n+    if (m_recv_buffer.size() == Sv2HandshakeState::HANDSHAKE_STEP2_SIZE) {\n+        // TODO handle failure\n+        // TODO: MakeByteSpan instead of MakeWritableByteSpan\n+        bool res = m_cipher.GetHandshakeState().ReadMsgES(MakeWritableByteSpan(m_recv_buffer));\n+        if (!res) return false;\n+        m_recv_buffer.clear();\n+        m_cipher.FinishHandshake();\n+        SetReceiveState(RecvState::APP);\n+\n+        LOCK(m_send_mutex);\n+        Assume(m_send_buffer.size() == 0);\n+\n+        SetSendState(SendState::READY);\n+    } else {\n+        // We still have to receive more key bytes.\n+    }\n+    return true;\n+}\n+\n+size_t Sv2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::HANDSHAKE_STEP_1:\n+        // In this state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= Sv2HandshakeState::ELLSWIFT_PUB_KEY_SIZE);\n+        return Sv2HandshakeState::ELLSWIFT_PUB_KEY_SIZE - m_recv_buffer.size();\n+    case RecvState::HANDSHAKE_STEP_2:\n+        // In this state, we only allow the handshake reply into the receive buffer.\n+        Assume(m_recv_buffer.size() <= Sv2HandshakeState::HANDSHAKE_STEP2_SIZE);\n+        return Sv2HandshakeState::HANDSHAKE_STEP2_SIZE - m_recv_buffer.size();\n+    case RecvState::APP:\n+        // Decode a packet. Process the header first,\n+        // so that we know where the current packet ends (and we don't process bytes from the next\n+        // packet yet). Then, process the ciphertext bytes of the current packet.\n+        if (m_recv_buffer.size() < SV2_HEADER_ENCRYPTED_SIZE) {\n+            return SV2_HEADER_ENCRYPTED_SIZE - m_recv_buffer.size();\n+        } else {\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted header is left in the receive buffer.\n+            size_t expanded_size_with_header = SV2_HEADER_ENCRYPTED_SIZE + Sv2Cipher::EncryptedMessageSize(m_header.m_msg_len);\n+            return expanded_size_with_header - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    Assume(false); // unreachable\n+    return 0;\n+}\n+\n+bool Sv2Transport::ProcessReceivedPacketBytes() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::APP);\n+\n+    // The maximum permitted decrypted payload size for a packet\n+    static constexpr size_t MAX_CONTENTS_LEN = 16777215; // 24 bit unsigned;\n+\n+    Assume(m_recv_buffer.size() <= SV2_HEADER_ENCRYPTED_SIZE || m_header.m_msg_len > 0);\n+\n+    if (m_recv_buffer.size() == SV2_HEADER_ENCRYPTED_SIZE) {\n+        // Header received, decrypt it.\n+        std::array<std::byte, SV2_HEADER_PLAIN_SIZE> header_plain;\n+        if  (!m_cipher.DecryptMessage(MakeWritableByteSpan(m_recv_buffer), header_plain)) {\n+            LogPrintLevel(BCLog::SV2, BCLog::Level::Debug, \"Failed to decrypt header\\n\");\n+            return false;\n+        }\n+\n+        LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"Header: %s\\n\", HexStr(header_plain));\n+\n+        // Decode header\n+        DataStream ss_header{header_plain};\n+        node::Sv2NetHeader header;\n+        ss_header >> header;\n+        m_header = std::move(header);\n+\n+        // TODO: 16 MB is pretty large, maybe set lower limits for most or all message types?\n+        if (m_header.m_msg_len > MAX_CONTENTS_LEN) {\n+            LogTrace(BCLog::SV2, \"Packet too large (%u bytes)\\n\", m_header.m_msg_len);\n+            return false;\n+        }\n+\n+        // Disconnect for empty messages (TODO: check the spec)\n+        if (m_header.m_msg_len == 0) {\n+            LogTrace(BCLog::SV2, \"Empty message\\n\");\n+            return false;\n+        }\n+        LogTrace(BCLog::SV2, \"Expecting %d bytes payload (plain)\\n\", m_header.m_msg_len);\n+    } else if (m_recv_buffer.size() > SV2_HEADER_ENCRYPTED_SIZE &&\n+               m_recv_buffer.size() == SV2_HEADER_ENCRYPTED_SIZE + Sv2Cipher::EncryptedMessageSize(m_header.m_msg_len)) {\n+        /** Ciphertext received: decrypt into decode_buffer and deserialize into m_message.\n+          *\n+          * Note that it is impossible to reach this branch without hitting the\n+          * branch above first, as GetMaxBytesToProcess only allows up to\n+          * SV2_HEADER_ENCRYPTED_SIZE into the buffer before that point. */\n+        std::vector<std::uint8_t> payload;\n+        payload.resize(m_header.m_msg_len);\n+\n+        Span<std::byte> recv_span{MakeWritableByteSpan(m_recv_buffer).subspan(SV2_HEADER_ENCRYPTED_SIZE)};\n+        if (!m_cipher.DecryptMessage(recv_span, MakeWritableByteSpan(payload))) {\n+            LogPrintLevel(BCLog::SV2, BCLog::Level::Debug, \"Failed to decrypt message payload\\n\");\n+            return false;\n+        }\n+        LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"Payload: %s\\n\", HexStr(payload));\n+\n+        // Wipe the receive buffer where the next packet will be received into.\n+        ClearShrink(m_recv_buffer);\n+\n+        Sv2NetMsg message{std::move(m_header), std::move(payload)};\n+        m_message = std::move(message);\n+\n+        // At this point we have a valid message decrypted into m_message.\n+        SetReceiveState(RecvState::APP_READY);\n+    } else {\n+        // We either have less than 22 bytes, so we don't know the packet's length yet, or more\n+        // than 22 bytes but less than the packet's full ciphertext. Wait until those arrive.\n+        LogTrace(BCLog::SV2, \"Waiting for more bytes\\n\");\n+    }\n+    return true;\n+}\n+\n+bool Sv2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+CNetMessage Sv2Transport::GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    assert(false);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30315#discussion_r1647822168",
      "id" : 1647822168,
      "line" : 466,
      "node_id" : "PRRC_kwDOABII585iN8VY",
      "original_commit_id" : "d787c61afefccd73fe9c3d86f84b18b45d331bf2",
      "original_line" : 466,
      "original_position" : 466,
      "original_start_line" : null,
      "path" : "src/common/sv2_transport.cpp",
      "position" : 466,
      "pull_request_review_id" : 2130848013,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30315",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1647822168/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-06-20T16:16:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1647822168",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30315#discussion_r1647825951"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30315"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1647825951"
         }
      },
      "author_association" : "MEMBER",
      "body" : "11328075fe1783163fa5d3113a37f6b20ccd4c43: I don't remember why I decided on a custom implementation here.",
      "commit_id" : "11328075fe1783163fa5d3113a37f6b20ccd4c43",
      "created_at" : "2024-06-20T16:12:13Z",
      "diff_hunk" : "@@ -0,0 +1,513 @@\n+// Copyright (c) 2023-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sv2_transport.h>\n+\n+#include <common/net_message.h>\n+#include <logging.h>\n+#include <memusage.h>\n+#include <common/sv2_messages.h>\n+#include <common/sv2_noise.h>\n+#include <random.h>\n+#include <util/check.h>\n+#include <util/strencodings.h>\n+#include <util/vector.h>\n+\n+Sv2Transport::Sv2Transport(CKey static_key, Sv2SignatureNoiseMessage certificate) noexcept\n+    : m_cipher{Sv2Cipher(std::move(static_key), std::move(certificate))}, m_initiating{false},\n+      m_recv_state{RecvState::HANDSHAKE_STEP_1},\n+      m_send_state{SendState::HANDSHAKE_STEP_2},\n+      m_message{Sv2NetMsg(Sv2NetHeader{})}\n+{\n+    LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"Noise session receive state -> %s\\n\",\n+                    RecvStateAsString(m_recv_state));\n+}\n+\n+Sv2Transport::Sv2Transport(CKey static_key, XOnlyPubKey responder_authority_key) noexcept\n+    : m_cipher{Sv2Cipher(std::move(static_key), responder_authority_key)}, m_initiating{true},\n+      m_recv_state{RecvState::HANDSHAKE_STEP_2},\n+      m_send_state{SendState::HANDSHAKE_STEP_1},\n+      m_message{Sv2NetMsg(Sv2NetHeader{})}\n+{\n+    /** Start sending immediately since we're the initiator of the connection.\n+        This only happens in test code.\n+    */\n+    LOCK(m_send_mutex);\n+    StartSendingHandshake();\n+\n+}\n+\n+void Sv2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // Enforce allowed state transitions.\n+    switch (m_recv_state) {\n+    case RecvState::HANDSHAKE_STEP_1:\n+        Assume(recv_state == RecvState::HANDSHAKE_STEP_2);\n+        break;\n+    case RecvState::HANDSHAKE_STEP_2:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    case RecvState::APP:\n+        Assume(recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+    LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"Noise session receive state -> %s\\n\",\n+                  RecvStateAsString(m_recv_state));\n+\n+}\n+\n+void Sv2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // Enforce allowed state transitions.\n+    switch (m_send_state) {\n+    case SendState::HANDSHAKE_STEP_1:\n+        Assume(send_state == SendState::HANDSHAKE_STEP_2);\n+        break;\n+    case SendState::HANDSHAKE_STEP_2:\n+        Assume(send_state == SendState::READY);\n+        break;\n+    case SendState::READY:\n+        Assume(false); // Final state\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+    LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"Noise session send state -> %s\\n\",\n+                  SendStateAsString(m_send_state));\n+}\n+\n+void Sv2Transport::StartSendingHandshake() noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    AssertLockNotHeld(m_recv_mutex);\n+    Assume(m_send_state == SendState::HANDSHAKE_STEP_1);\n+    Assume(m_send_buffer.empty());\n+\n+    m_send_buffer.resize(Sv2HandshakeState::ELLSWIFT_PUB_KEY_SIZE);\n+    m_cipher.GetHandshakeState().WriteMsgEphemeralPK(MakeWritableByteSpan(m_send_buffer));\n+\n+    m_send_state = SendState::HANDSHAKE_STEP_2;\n+}\n+\n+void Sv2Transport::SendHandshakeReply() noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_send_state == SendState::HANDSHAKE_STEP_2);\n+\n+    Assume(m_send_buffer.empty());\n+    m_send_buffer.resize(Sv2HandshakeState::HANDSHAKE_STEP2_SIZE);\n+    m_cipher.GetHandshakeState().WriteMsgES(MakeWritableByteSpan(m_send_buffer));\n+\n+    m_cipher.FinishHandshake();\n+\n+    // LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"m_hash: %s\\n\", HexStr(m_cipher.m_hash));\n+\n+    // We can send and receive stuff now, unless the other side hangs up\n+    SetSendState(SendState::READY);\n+    Assume(m_recv_state == RecvState::HANDSHAKE_STEP_2);\n+    SetReceiveState(RecvState::APP);\n+}\n+\n+Transport::BytesToSend Sv2Transport::GetBytesToSend(bool have_next_message) const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    assert(false);\n+\n+    return {\n+        Span{m_send_buffer}.subspan(0,0),\n+        false,\n+        m_send_type\n+    };\n+}\n+\n+Sv2Transport::Sv2BytesToSend Sv2Transport::GetBytesToSendSv2(bool have_next_message) const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+\n+    Assume(m_send_pos <= m_send_buffer.size());\n+    return {\n+        Span{m_send_buffer}.subspan(m_send_pos),",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30315#discussion_r1647825951",
      "id" : 1647825951,
      "line" : 139,
      "node_id" : "PRRC_kwDOABII585iN9Qf",
      "original_commit_id" : "d787c61afefccd73fe9c3d86f84b18b45d331bf2",
      "original_line" : 139,
      "original_position" : 139,
      "original_start_line" : null,
      "path" : "src/common/sv2_transport.cpp",
      "position" : 139,
      "pull_request_review_id" : 2130854214,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30315",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1647825951/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-06-20T16:16:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1647825951",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "It compiles and the tests run, but it's not pretty.\r\n\r\nThe conversion between `Sv2NetMsg` and `CSerializedNetMsg` / `CNetMessage` is done in https://github.com/bitcoin/bitcoin/pull/30315/commits/7d937674de425d8e2525bac9e719ac93a775ea45, which is a bit of a hack at the moment.\r\n\r\nI also haven't put much thought into `Sv2NetMsg` ever since I took over #27854, so perhaps this design can be improved as well.",
      "created_at" : "2024-06-21T11:18:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30315#issuecomment-2182554706",
      "id" : 2182554706,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30315",
      "node_id" : "IC_kwDOABII586CFyRS",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2182554706/reactions"
      },
      "updated_at" : "2024-06-21T11:19:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2182554706",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I only had a very brief look, but my guess would be that it would be easier if `Sv2NetMsg` did not contain an `Sv2NetHeader`, and just stored type and message. The Sv2 Transport would then construct the header at submitting or sending time instead. This means `Sv2NetMsg` would be more of a dumb container for what higher-level code cares about, while the protocol details would be more abstracted away in the Transport.",
      "created_at" : "2024-06-21T13:34:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30315#issuecomment-2182768070",
      "id" : 2182768070,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30315",
      "node_id" : "IC_kwDOABII586CGmXG",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2182768070/reactions"
      },
      "updated_at" : "2024-06-21T13:34:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2182768070",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@sipa done and managed to clean up `sv2_messages.h` a bit in the process.",
      "created_at" : "2024-06-21T15:44:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30315#issuecomment-2182999892",
      "id" : 2182999892,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30315",
      "node_id" : "IC_kwDOABII586CHe9U",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2182999892/reactions"
      },
      "updated_at" : "2024-06-21T15:44:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2182999892",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30315#discussion_r1649141459"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30315"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649141459"
         }
      },
      "author_association" : "MEMBER",
      "body" : "639be6df22800d2e2a170c1af74d51951597834c: this `namespace` is outdated, since this isn't part of the `node` anymore.",
      "commit_id" : "e108385a6e0e1a9528c15ae8b668a91163e0af44",
      "created_at" : "2024-06-21T15:47:21Z",
      "diff_hunk" : "@@ -0,0 +1,221 @@\n+// Copyright (c) 2023-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_COMMON_SV2_MESSAGES_H\n+#define BITCOIN_COMMON_SV2_MESSAGES_H\n+\n+#include <common/net_message.h>\n+#include <span.h>\n+#include <streams.h>\n+#include <string>\n+#include <util/check.h>\n+\n+namespace node {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30315#discussion_r1649141459",
      "id" : 1649141459,
      "line" : 14,
      "node_id" : "PRRC_kwDOABII585iS-bT",
      "original_commit_id" : "e108385a6e0e1a9528c15ae8b668a91163e0af44",
      "original_line" : 14,
      "original_position" : 14,
      "original_start_line" : null,
      "path" : "src/common/sv2_messages.h",
      "position" : 14,
      "pull_request_review_id" : 2132948873,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30315",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649141459/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-06-21T15:47:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649141459",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30315#discussion_r1649237537"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30315"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649237537"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This trips up the address sanitizer: \r\nhttps://github.com/bitcoin/bitcoin/actions/runs/9616699499/job/26526819621?pr=30315#step:6:4956",
      "commit_id" : "2f673b5959cee168b808e23c6f5554e2f673db15",
      "created_at" : "2024-06-21T17:15:19Z",
      "diff_hunk" : "@@ -0,0 +1,388 @@\n+// Copyright (c) 2023-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sv2_noise.h>\n+#include <common/sv2_transport.h>\n+#include <logging.h>\n+#include <serialize.h>\n+#include <span.h>\n+#include <streams.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+#include <node/timeoffsets.h>\n+#include <util/bitdeque.h>\n+#include <util/strencodings.h>\n+#include <util/string.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <algorithm>\n+#include <ios>\n+#include <memory>\n+#include <optional>\n+#include <string>\n+\n+using namespace std::literals;\n+using node::Sv2NetMsg;\n+using node::Sv2CoinbaseOutputDataSizeMsg;\n+using node::Sv2MsgType;\n+\n+BOOST_FIXTURE_TEST_SUITE(sv2_transport_tests, RegTestingSetup)\n+\n+namespace {\n+\n+/** A class for scenario-based tests of Sv2Transport\n+ *\n+ * Each Sv2TransportTester encapsulates a Sv2Transport (the one being tested),\n+ * and can be told to interact with it. To do so, it also encapsulates a Sv2Cipher\n+ * to act as the other side. A second Sv2Transport is not used, as doing so would\n+ * not permit scenarios that involve sending invalid data.\n+ */\n+class Sv2TransportTester\n+{\n+    std::unique_ptr<Sv2Transport> m_transport; //!< Sv2Transport being tested\n+    std::unique_ptr<Sv2Cipher> m_peer_cipher;  //!< Cipher to help with the other side\n+    bool m_test_initiator;    //!< Whether m_transport is the initiator (true) or responder (false)\n+\n+    std::vector<uint8_t> m_to_send;  //!< Bytes we have queued up to send to m_transport->\n+    std::vector<uint8_t> m_received; //!< Bytes we have received from m_transport->\n+    std::deque<Sv2NetMsg> m_msg_to_send; //!< Messages to be sent *by* m_transport to us.\n+\n+public:\n+    /** Construct a tester object. test_initiator: whether the tested transport is initiator. */\n+\n+    explicit Sv2TransportTester(bool test_initiator) : m_test_initiator(test_initiator)\n+    {\n+        auto initiator_static_key{GenerateRandomKey()};\n+        auto responder_static_key{GenerateRandomKey()};\n+        auto responder_authority_key{GenerateRandomKey()};\n+\n+        // Create certificates\n+        auto epoch_now = std::chrono::system_clock::now().time_since_epoch();\n+        uint16_t version = 0;\n+        uint32_t valid_from = static_cast<uint32_t>(std::chrono::duration_cast<std::chrono::seconds>(epoch_now).count());\n+        uint32_t valid_to =  std::numeric_limits<unsigned int>::max();\n+\n+        auto responder_certificate = Sv2SignatureNoiseMessage(version, valid_from, valid_to,\n+                                    XOnlyPubKey(responder_static_key.GetPubKey()), responder_authority_key);\n+\n+        if (test_initiator) {\n+            m_transport = std::make_unique<Sv2Transport>(initiator_static_key, XOnlyPubKey(responder_authority_key.GetPubKey()));\n+            m_peer_cipher = std::make_unique<Sv2Cipher>(std::move(responder_static_key), std::move(responder_certificate));\n+        } else {\n+            m_transport = std::make_unique<Sv2Transport>(responder_static_key, responder_certificate);\n+            m_peer_cipher = std::make_unique<Sv2Cipher>(std::move(initiator_static_key), XOnlyPubKey(responder_authority_key.GetPubKey()));\n+        }\n+    }\n+\n+    /** Data type returned by Interact:\n+     *\n+     * - std::nullopt: transport error occurred\n+     * - otherwise: a vector of\n+     *   - std::nullopt: invalid message received\n+     *   - otherwise: a Sv2NetMsg retrieved\n+     */\n+    using InteractResult = std::optional<std::vector<std::optional<Sv2NetMsg>>>;\n+\n+    void LogProgress(bool should_progress, bool progress, bool pretend_no_progress) {\n+        if (!should_progress) {\n+            BOOST_TEST_MESSAGE(\"[Interact] !should_progress\");\n+        } else if  (!progress) {\n+            BOOST_TEST_MESSAGE(\"[Interact] should_progress && !progress\");\n+        } else if (pretend_no_progress) {\n+            BOOST_TEST_MESSAGE(\"[Interact] pretend !progress\");\n+        }\n+    }\n+\n+    /** Send/receive scheduled/available bytes and messages.\n+     *\n+     * This is the only function that interacts with the transport being tested; everything else is\n+     * scheduling things done by Interact(), or processing things learned by it.\n+     */\n+    InteractResult Interact()\n+    {\n+        std::vector<std::optional<Sv2NetMsg>> ret;\n+        while (true) {\n+            bool progress{false};\n+            // Send bytes from m_to_send to the transport.\n+            if (!m_to_send.empty()) {\n+                size_t n_bytes_to_send = 1 + InsecureRandRange(m_to_send.size());\n+                BOOST_TEST_MESSAGE(strprintf(\"[Interact] send %d of %d bytes\", n_bytes_to_send, m_to_send.size()));\n+                Span<const uint8_t> to_send = Span{m_to_send}.first(n_bytes_to_send);\n+                size_t old_len = to_send.size();\n+                if (!m_transport->ReceivedBytes(to_send)) {\n+                    BOOST_TEST_MESSAGE(\"[Interact] transport error\");\n+                    return std::nullopt;\n+                }\n+                if (old_len != to_send.size()) {\n+                    progress = true;\n+                    m_to_send.erase(m_to_send.begin(), m_to_send.begin() + (old_len - to_send.size()));\n+                }\n+            }\n+            // Retrieve messages received by the transport.\n+            bool should_progress = m_transport->ReceivedMessageComplete();\n+            bool pretend_no_progress = InsecureRandBool();\n+            LogProgress(should_progress, progress, pretend_no_progress);\n+            if (should_progress && (!progress || pretend_no_progress)) {\n+                bool dummy_reject_message = false;\n+                CNetMessage net_msg = m_transport->GetReceivedMessage(std::chrono::microseconds(0), dummy_reject_message);\n+                Sv2NetMsg msg(std::move(net_msg));\n+                ret.emplace_back(std::move(msg));\n+                progress = true;\n+            }\n+            // Enqueue a message to be sent by the transport to us.\n+            should_progress = !m_msg_to_send.empty();\n+            pretend_no_progress = InsecureRandBool();\n+            LogProgress(should_progress, progress, pretend_no_progress);\n+            if (should_progress && (!progress || pretend_no_progress)) {\n+                BOOST_TEST_MESSAGE(\"Shoehorn into CSerializedNetMsg\");\n+                CSerializedNetMsg msg{m_msg_to_send.front()};\n+                BOOST_TEST_MESSAGE(\"Call SetMessageToSend\");\n+                if (m_transport->SetMessageToSend(msg)) {\n+                    BOOST_TEST_MESSAGE(\"Finished SetMessageToSend\");\n+                    m_msg_to_send.pop_front();\n+                    progress = true;\n+                }\n+            }\n+            // Receive bytes from the transport.\n+            const auto& [recv_bytes, _more, _m_type] = m_transport->GetBytesToSend(!m_msg_to_send.empty());\n+            should_progress = !recv_bytes.empty();\n+            pretend_no_progress = InsecureRandBool();\n+            LogProgress(should_progress, progress, pretend_no_progress);\n+            if (should_progress && (!progress || pretend_no_progress)) {\n+                size_t to_receive = 1 + InsecureRandRange(recv_bytes.size());\n+                BOOST_TEST_MESSAGE(strprintf(\"[Interact] receive %d of %d bytes\", to_receive, recv_bytes.size()));\n+                m_received.insert(m_received.end(), recv_bytes.begin(), recv_bytes.begin() + to_receive);\n+                progress = true;\n+                m_transport->MarkBytesSent(to_receive);\n+            }\n+            if (!progress) break;\n+        }\n+        return ret;\n+    }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const uint8_t> data)\n+    {\n+        LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"Send: %s\\n\", HexStr(data));\n+        m_to_send.insert(m_to_send.end(), data.begin(), data.end());\n+    }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const std::byte> data) { Send(MakeUCharSpan(data)); }\n+\n+    /** Schedule a message to be sent to us by the transport. */\n+    void AddMessage(Sv2NetMsg msg)\n+    {\n+        m_msg_to_send.push_back(std::move(msg));\n+    }\n+\n+    /**\n+     * If we are the initiator, the send buffer should contain our ephemeral public\n+     * key. Pass this to the peer cipher and clear the buffer.\n+     *\n+     * If we are the responder, put the peer ephemeral public key on our receive buffer.\n+     */\n+    void ProcessHandshake1() {\n+        if (m_test_initiator) {\n+            BOOST_REQUIRE(m_received.size() == Sv2HandshakeState::ELLSWIFT_PUB_KEY_SIZE);\n+            m_peer_cipher->GetHandshakeState().ReadMsgEphemeralPK(MakeWritableByteSpan(m_received));\n+            m_received.clear();\n+        } else {\n+            BOOST_REQUIRE(m_to_send.empty());\n+            m_to_send.resize(Sv2HandshakeState::ELLSWIFT_PUB_KEY_SIZE);\n+            m_peer_cipher->GetHandshakeState().WriteMsgEphemeralPK(MakeWritableByteSpan(m_to_send));\n+        }\n+\n+    }\n+\n+    /** Expect key to have been received from transport and process it.\n+     *\n+     * Many other Sv2TransportTester functions cannot be called until after\n+     * ProcessHandshake2() has been called, as no encryption keys are set up before that point.\n+     */\n+    void ProcessHandshake2()\n+    {\n+        if (m_test_initiator) {\n+            BOOST_REQUIRE(m_to_send.empty());\n+\n+            // Have the peer cypher write the second part of the handshake into our receive buffer\n+            m_to_send.resize(Sv2HandshakeState::HANDSHAKE_STEP2_SIZE);\n+            m_peer_cipher->GetHandshakeState().WriteMsgES(MakeWritableByteSpan(m_to_send));\n+\n+            // At this point the peer is done with the handshake:\n+            m_peer_cipher->FinishHandshake();\n+        } else {\n+            BOOST_REQUIRE(m_received.size() == Sv2HandshakeState::HANDSHAKE_STEP2_SIZE);\n+            BOOST_REQUIRE(m_peer_cipher->GetHandshakeState().ReadMsgES(MakeWritableByteSpan(m_received)));\n+            m_received.clear();\n+\n+            m_peer_cipher->FinishHandshake();\n+        }\n+    }\n+\n+    /** Schedule an encrypted packet with specified content to be sent to transport\n+     *  (only after ReceiveKey). */\n+    void SendPacket(Sv2NetMsg msg)\n+    {\n+        // TODO: randomly break stuff\n+\n+        std::vector<std::byte> ciphertext;\n+        const size_t encrypted_payload_size = Sv2Cipher::EncryptedMessageSize(msg.size());\n+        ciphertext.resize(SV2_HEADER_ENCRYPTED_SIZE + encrypted_payload_size);\n+        Span<std::byte> buffer_span{MakeWritableByteSpan(ciphertext)};\n+\n+        // Header\n+        DataStream ss_header_plain{};\n+        ss_header_plain << Sv2NetHeader(msg);\n+        LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"Header: %s\\n\", HexStr(ss_header_plain));\n+        Span<std::byte> header_encrypted{buffer_span.subspan(0, SV2_HEADER_ENCRYPTED_SIZE)};\n+        BOOST_REQUIRE(m_peer_cipher->EncryptMessage(ss_header_plain, header_encrypted));\n+\n+        // Payload\n+        Span<const std::byte> payload_plain = MakeByteSpan(msg.data());\n+        // TODO: truncate very long messages, about 100 bytes at the start and end\n+        //       is probably enough for most debugging.\n+        LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"Payload: %s\\n\", HexStr(payload_plain));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30315#discussion_r1649237537",
      "id" : 1649237537,
      "line" : 247,
      "node_id" : "PRRC_kwDOABII585iTV4h",
      "original_commit_id" : "2f673b5959cee168b808e23c6f5554e2f673db15",
      "original_line" : 247,
      "original_position" : 247,
      "original_start_line" : null,
      "path" : "src/test/sv2_transport_tests.cpp",
      "position" : 247,
      "pull_request_review_id" : 2133107146,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30315",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649237537/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-06-21T17:15:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649237537",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30315#discussion_r1649241912"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30315"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649241912"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Pretty sure you mean `MakeByteSpan(msg)`, not `MakeByteSpan(msg.data())`.",
      "commit_id" : "2f673b5959cee168b808e23c6f5554e2f673db15",
      "created_at" : "2024-06-21T17:20:20Z",
      "diff_hunk" : "@@ -0,0 +1,388 @@\n+// Copyright (c) 2023-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sv2_noise.h>\n+#include <common/sv2_transport.h>\n+#include <logging.h>\n+#include <serialize.h>\n+#include <span.h>\n+#include <streams.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+#include <node/timeoffsets.h>\n+#include <util/bitdeque.h>\n+#include <util/strencodings.h>\n+#include <util/string.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <algorithm>\n+#include <ios>\n+#include <memory>\n+#include <optional>\n+#include <string>\n+\n+using namespace std::literals;\n+using node::Sv2NetMsg;\n+using node::Sv2CoinbaseOutputDataSizeMsg;\n+using node::Sv2MsgType;\n+\n+BOOST_FIXTURE_TEST_SUITE(sv2_transport_tests, RegTestingSetup)\n+\n+namespace {\n+\n+/** A class for scenario-based tests of Sv2Transport\n+ *\n+ * Each Sv2TransportTester encapsulates a Sv2Transport (the one being tested),\n+ * and can be told to interact with it. To do so, it also encapsulates a Sv2Cipher\n+ * to act as the other side. A second Sv2Transport is not used, as doing so would\n+ * not permit scenarios that involve sending invalid data.\n+ */\n+class Sv2TransportTester\n+{\n+    std::unique_ptr<Sv2Transport> m_transport; //!< Sv2Transport being tested\n+    std::unique_ptr<Sv2Cipher> m_peer_cipher;  //!< Cipher to help with the other side\n+    bool m_test_initiator;    //!< Whether m_transport is the initiator (true) or responder (false)\n+\n+    std::vector<uint8_t> m_to_send;  //!< Bytes we have queued up to send to m_transport->\n+    std::vector<uint8_t> m_received; //!< Bytes we have received from m_transport->\n+    std::deque<Sv2NetMsg> m_msg_to_send; //!< Messages to be sent *by* m_transport to us.\n+\n+public:\n+    /** Construct a tester object. test_initiator: whether the tested transport is initiator. */\n+\n+    explicit Sv2TransportTester(bool test_initiator) : m_test_initiator(test_initiator)\n+    {\n+        auto initiator_static_key{GenerateRandomKey()};\n+        auto responder_static_key{GenerateRandomKey()};\n+        auto responder_authority_key{GenerateRandomKey()};\n+\n+        // Create certificates\n+        auto epoch_now = std::chrono::system_clock::now().time_since_epoch();\n+        uint16_t version = 0;\n+        uint32_t valid_from = static_cast<uint32_t>(std::chrono::duration_cast<std::chrono::seconds>(epoch_now).count());\n+        uint32_t valid_to =  std::numeric_limits<unsigned int>::max();\n+\n+        auto responder_certificate = Sv2SignatureNoiseMessage(version, valid_from, valid_to,\n+                                    XOnlyPubKey(responder_static_key.GetPubKey()), responder_authority_key);\n+\n+        if (test_initiator) {\n+            m_transport = std::make_unique<Sv2Transport>(initiator_static_key, XOnlyPubKey(responder_authority_key.GetPubKey()));\n+            m_peer_cipher = std::make_unique<Sv2Cipher>(std::move(responder_static_key), std::move(responder_certificate));\n+        } else {\n+            m_transport = std::make_unique<Sv2Transport>(responder_static_key, responder_certificate);\n+            m_peer_cipher = std::make_unique<Sv2Cipher>(std::move(initiator_static_key), XOnlyPubKey(responder_authority_key.GetPubKey()));\n+        }\n+    }\n+\n+    /** Data type returned by Interact:\n+     *\n+     * - std::nullopt: transport error occurred\n+     * - otherwise: a vector of\n+     *   - std::nullopt: invalid message received\n+     *   - otherwise: a Sv2NetMsg retrieved\n+     */\n+    using InteractResult = std::optional<std::vector<std::optional<Sv2NetMsg>>>;\n+\n+    void LogProgress(bool should_progress, bool progress, bool pretend_no_progress) {\n+        if (!should_progress) {\n+            BOOST_TEST_MESSAGE(\"[Interact] !should_progress\");\n+        } else if  (!progress) {\n+            BOOST_TEST_MESSAGE(\"[Interact] should_progress && !progress\");\n+        } else if (pretend_no_progress) {\n+            BOOST_TEST_MESSAGE(\"[Interact] pretend !progress\");\n+        }\n+    }\n+\n+    /** Send/receive scheduled/available bytes and messages.\n+     *\n+     * This is the only function that interacts with the transport being tested; everything else is\n+     * scheduling things done by Interact(), or processing things learned by it.\n+     */\n+    InteractResult Interact()\n+    {\n+        std::vector<std::optional<Sv2NetMsg>> ret;\n+        while (true) {\n+            bool progress{false};\n+            // Send bytes from m_to_send to the transport.\n+            if (!m_to_send.empty()) {\n+                size_t n_bytes_to_send = 1 + InsecureRandRange(m_to_send.size());\n+                BOOST_TEST_MESSAGE(strprintf(\"[Interact] send %d of %d bytes\", n_bytes_to_send, m_to_send.size()));\n+                Span<const uint8_t> to_send = Span{m_to_send}.first(n_bytes_to_send);\n+                size_t old_len = to_send.size();\n+                if (!m_transport->ReceivedBytes(to_send)) {\n+                    BOOST_TEST_MESSAGE(\"[Interact] transport error\");\n+                    return std::nullopt;\n+                }\n+                if (old_len != to_send.size()) {\n+                    progress = true;\n+                    m_to_send.erase(m_to_send.begin(), m_to_send.begin() + (old_len - to_send.size()));\n+                }\n+            }\n+            // Retrieve messages received by the transport.\n+            bool should_progress = m_transport->ReceivedMessageComplete();\n+            bool pretend_no_progress = InsecureRandBool();\n+            LogProgress(should_progress, progress, pretend_no_progress);\n+            if (should_progress && (!progress || pretend_no_progress)) {\n+                bool dummy_reject_message = false;\n+                CNetMessage net_msg = m_transport->GetReceivedMessage(std::chrono::microseconds(0), dummy_reject_message);\n+                Sv2NetMsg msg(std::move(net_msg));\n+                ret.emplace_back(std::move(msg));\n+                progress = true;\n+            }\n+            // Enqueue a message to be sent by the transport to us.\n+            should_progress = !m_msg_to_send.empty();\n+            pretend_no_progress = InsecureRandBool();\n+            LogProgress(should_progress, progress, pretend_no_progress);\n+            if (should_progress && (!progress || pretend_no_progress)) {\n+                BOOST_TEST_MESSAGE(\"Shoehorn into CSerializedNetMsg\");\n+                CSerializedNetMsg msg{m_msg_to_send.front()};\n+                BOOST_TEST_MESSAGE(\"Call SetMessageToSend\");\n+                if (m_transport->SetMessageToSend(msg)) {\n+                    BOOST_TEST_MESSAGE(\"Finished SetMessageToSend\");\n+                    m_msg_to_send.pop_front();\n+                    progress = true;\n+                }\n+            }\n+            // Receive bytes from the transport.\n+            const auto& [recv_bytes, _more, _m_type] = m_transport->GetBytesToSend(!m_msg_to_send.empty());\n+            should_progress = !recv_bytes.empty();\n+            pretend_no_progress = InsecureRandBool();\n+            LogProgress(should_progress, progress, pretend_no_progress);\n+            if (should_progress && (!progress || pretend_no_progress)) {\n+                size_t to_receive = 1 + InsecureRandRange(recv_bytes.size());\n+                BOOST_TEST_MESSAGE(strprintf(\"[Interact] receive %d of %d bytes\", to_receive, recv_bytes.size()));\n+                m_received.insert(m_received.end(), recv_bytes.begin(), recv_bytes.begin() + to_receive);\n+                progress = true;\n+                m_transport->MarkBytesSent(to_receive);\n+            }\n+            if (!progress) break;\n+        }\n+        return ret;\n+    }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const uint8_t> data)\n+    {\n+        LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"Send: %s\\n\", HexStr(data));\n+        m_to_send.insert(m_to_send.end(), data.begin(), data.end());\n+    }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const std::byte> data) { Send(MakeUCharSpan(data)); }\n+\n+    /** Schedule a message to be sent to us by the transport. */\n+    void AddMessage(Sv2NetMsg msg)\n+    {\n+        m_msg_to_send.push_back(std::move(msg));\n+    }\n+\n+    /**\n+     * If we are the initiator, the send buffer should contain our ephemeral public\n+     * key. Pass this to the peer cipher and clear the buffer.\n+     *\n+     * If we are the responder, put the peer ephemeral public key on our receive buffer.\n+     */\n+    void ProcessHandshake1() {\n+        if (m_test_initiator) {\n+            BOOST_REQUIRE(m_received.size() == Sv2HandshakeState::ELLSWIFT_PUB_KEY_SIZE);\n+            m_peer_cipher->GetHandshakeState().ReadMsgEphemeralPK(MakeWritableByteSpan(m_received));\n+            m_received.clear();\n+        } else {\n+            BOOST_REQUIRE(m_to_send.empty());\n+            m_to_send.resize(Sv2HandshakeState::ELLSWIFT_PUB_KEY_SIZE);\n+            m_peer_cipher->GetHandshakeState().WriteMsgEphemeralPK(MakeWritableByteSpan(m_to_send));\n+        }\n+\n+    }\n+\n+    /** Expect key to have been received from transport and process it.\n+     *\n+     * Many other Sv2TransportTester functions cannot be called until after\n+     * ProcessHandshake2() has been called, as no encryption keys are set up before that point.\n+     */\n+    void ProcessHandshake2()\n+    {\n+        if (m_test_initiator) {\n+            BOOST_REQUIRE(m_to_send.empty());\n+\n+            // Have the peer cypher write the second part of the handshake into our receive buffer\n+            m_to_send.resize(Sv2HandshakeState::HANDSHAKE_STEP2_SIZE);\n+            m_peer_cipher->GetHandshakeState().WriteMsgES(MakeWritableByteSpan(m_to_send));\n+\n+            // At this point the peer is done with the handshake:\n+            m_peer_cipher->FinishHandshake();\n+        } else {\n+            BOOST_REQUIRE(m_received.size() == Sv2HandshakeState::HANDSHAKE_STEP2_SIZE);\n+            BOOST_REQUIRE(m_peer_cipher->GetHandshakeState().ReadMsgES(MakeWritableByteSpan(m_received)));\n+            m_received.clear();\n+\n+            m_peer_cipher->FinishHandshake();\n+        }\n+    }\n+\n+    /** Schedule an encrypted packet with specified content to be sent to transport\n+     *  (only after ReceiveKey). */\n+    void SendPacket(Sv2NetMsg msg)\n+    {\n+        // TODO: randomly break stuff\n+\n+        std::vector<std::byte> ciphertext;\n+        const size_t encrypted_payload_size = Sv2Cipher::EncryptedMessageSize(msg.size());\n+        ciphertext.resize(SV2_HEADER_ENCRYPTED_SIZE + encrypted_payload_size);\n+        Span<std::byte> buffer_span{MakeWritableByteSpan(ciphertext)};\n+\n+        // Header\n+        DataStream ss_header_plain{};\n+        ss_header_plain << Sv2NetHeader(msg);\n+        LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"Header: %s\\n\", HexStr(ss_header_plain));\n+        Span<std::byte> header_encrypted{buffer_span.subspan(0, SV2_HEADER_ENCRYPTED_SIZE)};\n+        BOOST_REQUIRE(m_peer_cipher->EncryptMessage(ss_header_plain, header_encrypted));\n+\n+        // Payload\n+        Span<const std::byte> payload_plain = MakeByteSpan(msg.data());\n+        // TODO: truncate very long messages, about 100 bytes at the start and end\n+        //       is probably enough for most debugging.\n+        LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"Payload: %s\\n\", HexStr(payload_plain));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30315#discussion_r1649241912",
      "id" : 1649241912,
      "in_reply_to_id" : 1649237537,
      "line" : 247,
      "node_id" : "PRRC_kwDOABII585iTW84",
      "original_commit_id" : "2f673b5959cee168b808e23c6f5554e2f673db15",
      "original_line" : 247,
      "original_position" : 247,
      "original_start_line" : null,
      "path" : "src/test/sv2_transport_tests.cpp",
      "position" : 247,
      "pull_request_review_id" : 2133114380,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30315",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649241912/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-06-21T17:20:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649241912",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--85328a0da195eb286784d51f73fa0af9-->\n\nð§ At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/26526802432</sub>",
      "created_at" : "2024-06-21T18:14:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30315#issuecomment-2183220018",
      "id" : 2183220018,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30315",
      "node_id" : "IC_kwDOABII586CIUsy",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2183220018/reactions"
      },
      "updated_at" : "2024-06-21T18:14:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2183220018",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30315#discussion_r1649293172"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30315"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649293172"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I did! Did I? Should be fixed now.",
      "commit_id" : "cb40e0b3823161f0df6a4fdcb36895fb44f770de",
      "created_at" : "2024-06-21T18:15:05Z",
      "diff_hunk" : "@@ -0,0 +1,388 @@\n+// Copyright (c) 2023-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sv2_noise.h>\n+#include <common/sv2_transport.h>\n+#include <logging.h>\n+#include <serialize.h>\n+#include <span.h>\n+#include <streams.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+#include <node/timeoffsets.h>\n+#include <util/bitdeque.h>\n+#include <util/strencodings.h>\n+#include <util/string.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <algorithm>\n+#include <ios>\n+#include <memory>\n+#include <optional>\n+#include <string>\n+\n+using namespace std::literals;\n+using node::Sv2NetMsg;\n+using node::Sv2CoinbaseOutputDataSizeMsg;\n+using node::Sv2MsgType;\n+\n+BOOST_FIXTURE_TEST_SUITE(sv2_transport_tests, RegTestingSetup)\n+\n+namespace {\n+\n+/** A class for scenario-based tests of Sv2Transport\n+ *\n+ * Each Sv2TransportTester encapsulates a Sv2Transport (the one being tested),\n+ * and can be told to interact with it. To do so, it also encapsulates a Sv2Cipher\n+ * to act as the other side. A second Sv2Transport is not used, as doing so would\n+ * not permit scenarios that involve sending invalid data.\n+ */\n+class Sv2TransportTester\n+{\n+    std::unique_ptr<Sv2Transport> m_transport; //!< Sv2Transport being tested\n+    std::unique_ptr<Sv2Cipher> m_peer_cipher;  //!< Cipher to help with the other side\n+    bool m_test_initiator;    //!< Whether m_transport is the initiator (true) or responder (false)\n+\n+    std::vector<uint8_t> m_to_send;  //!< Bytes we have queued up to send to m_transport->\n+    std::vector<uint8_t> m_received; //!< Bytes we have received from m_transport->\n+    std::deque<Sv2NetMsg> m_msg_to_send; //!< Messages to be sent *by* m_transport to us.\n+\n+public:\n+    /** Construct a tester object. test_initiator: whether the tested transport is initiator. */\n+\n+    explicit Sv2TransportTester(bool test_initiator) : m_test_initiator(test_initiator)\n+    {\n+        auto initiator_static_key{GenerateRandomKey()};\n+        auto responder_static_key{GenerateRandomKey()};\n+        auto responder_authority_key{GenerateRandomKey()};\n+\n+        // Create certificates\n+        auto epoch_now = std::chrono::system_clock::now().time_since_epoch();\n+        uint16_t version = 0;\n+        uint32_t valid_from = static_cast<uint32_t>(std::chrono::duration_cast<std::chrono::seconds>(epoch_now).count());\n+        uint32_t valid_to =  std::numeric_limits<unsigned int>::max();\n+\n+        auto responder_certificate = Sv2SignatureNoiseMessage(version, valid_from, valid_to,\n+                                    XOnlyPubKey(responder_static_key.GetPubKey()), responder_authority_key);\n+\n+        if (test_initiator) {\n+            m_transport = std::make_unique<Sv2Transport>(initiator_static_key, XOnlyPubKey(responder_authority_key.GetPubKey()));\n+            m_peer_cipher = std::make_unique<Sv2Cipher>(std::move(responder_static_key), std::move(responder_certificate));\n+        } else {\n+            m_transport = std::make_unique<Sv2Transport>(responder_static_key, responder_certificate);\n+            m_peer_cipher = std::make_unique<Sv2Cipher>(std::move(initiator_static_key), XOnlyPubKey(responder_authority_key.GetPubKey()));\n+        }\n+    }\n+\n+    /** Data type returned by Interact:\n+     *\n+     * - std::nullopt: transport error occurred\n+     * - otherwise: a vector of\n+     *   - std::nullopt: invalid message received\n+     *   - otherwise: a Sv2NetMsg retrieved\n+     */\n+    using InteractResult = std::optional<std::vector<std::optional<Sv2NetMsg>>>;\n+\n+    void LogProgress(bool should_progress, bool progress, bool pretend_no_progress) {\n+        if (!should_progress) {\n+            BOOST_TEST_MESSAGE(\"[Interact] !should_progress\");\n+        } else if  (!progress) {\n+            BOOST_TEST_MESSAGE(\"[Interact] should_progress && !progress\");\n+        } else if (pretend_no_progress) {\n+            BOOST_TEST_MESSAGE(\"[Interact] pretend !progress\");\n+        }\n+    }\n+\n+    /** Send/receive scheduled/available bytes and messages.\n+     *\n+     * This is the only function that interacts with the transport being tested; everything else is\n+     * scheduling things done by Interact(), or processing things learned by it.\n+     */\n+    InteractResult Interact()\n+    {\n+        std::vector<std::optional<Sv2NetMsg>> ret;\n+        while (true) {\n+            bool progress{false};\n+            // Send bytes from m_to_send to the transport.\n+            if (!m_to_send.empty()) {\n+                size_t n_bytes_to_send = 1 + InsecureRandRange(m_to_send.size());\n+                BOOST_TEST_MESSAGE(strprintf(\"[Interact] send %d of %d bytes\", n_bytes_to_send, m_to_send.size()));\n+                Span<const uint8_t> to_send = Span{m_to_send}.first(n_bytes_to_send);\n+                size_t old_len = to_send.size();\n+                if (!m_transport->ReceivedBytes(to_send)) {\n+                    BOOST_TEST_MESSAGE(\"[Interact] transport error\");\n+                    return std::nullopt;\n+                }\n+                if (old_len != to_send.size()) {\n+                    progress = true;\n+                    m_to_send.erase(m_to_send.begin(), m_to_send.begin() + (old_len - to_send.size()));\n+                }\n+            }\n+            // Retrieve messages received by the transport.\n+            bool should_progress = m_transport->ReceivedMessageComplete();\n+            bool pretend_no_progress = InsecureRandBool();\n+            LogProgress(should_progress, progress, pretend_no_progress);\n+            if (should_progress && (!progress || pretend_no_progress)) {\n+                bool dummy_reject_message = false;\n+                CNetMessage net_msg = m_transport->GetReceivedMessage(std::chrono::microseconds(0), dummy_reject_message);\n+                Sv2NetMsg msg(std::move(net_msg));\n+                ret.emplace_back(std::move(msg));\n+                progress = true;\n+            }\n+            // Enqueue a message to be sent by the transport to us.\n+            should_progress = !m_msg_to_send.empty();\n+            pretend_no_progress = InsecureRandBool();\n+            LogProgress(should_progress, progress, pretend_no_progress);\n+            if (should_progress && (!progress || pretend_no_progress)) {\n+                BOOST_TEST_MESSAGE(\"Shoehorn into CSerializedNetMsg\");\n+                CSerializedNetMsg msg{m_msg_to_send.front()};\n+                BOOST_TEST_MESSAGE(\"Call SetMessageToSend\");\n+                if (m_transport->SetMessageToSend(msg)) {\n+                    BOOST_TEST_MESSAGE(\"Finished SetMessageToSend\");\n+                    m_msg_to_send.pop_front();\n+                    progress = true;\n+                }\n+            }\n+            // Receive bytes from the transport.\n+            const auto& [recv_bytes, _more, _m_type] = m_transport->GetBytesToSend(!m_msg_to_send.empty());\n+            should_progress = !recv_bytes.empty();\n+            pretend_no_progress = InsecureRandBool();\n+            LogProgress(should_progress, progress, pretend_no_progress);\n+            if (should_progress && (!progress || pretend_no_progress)) {\n+                size_t to_receive = 1 + InsecureRandRange(recv_bytes.size());\n+                BOOST_TEST_MESSAGE(strprintf(\"[Interact] receive %d of %d bytes\", to_receive, recv_bytes.size()));\n+                m_received.insert(m_received.end(), recv_bytes.begin(), recv_bytes.begin() + to_receive);\n+                progress = true;\n+                m_transport->MarkBytesSent(to_receive);\n+            }\n+            if (!progress) break;\n+        }\n+        return ret;\n+    }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const uint8_t> data)\n+    {\n+        LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"Send: %s\\n\", HexStr(data));\n+        m_to_send.insert(m_to_send.end(), data.begin(), data.end());\n+    }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const std::byte> data) { Send(MakeUCharSpan(data)); }\n+\n+    /** Schedule a message to be sent to us by the transport. */\n+    void AddMessage(Sv2NetMsg msg)\n+    {\n+        m_msg_to_send.push_back(std::move(msg));\n+    }\n+\n+    /**\n+     * If we are the initiator, the send buffer should contain our ephemeral public\n+     * key. Pass this to the peer cipher and clear the buffer.\n+     *\n+     * If we are the responder, put the peer ephemeral public key on our receive buffer.\n+     */\n+    void ProcessHandshake1() {\n+        if (m_test_initiator) {\n+            BOOST_REQUIRE(m_received.size() == Sv2HandshakeState::ELLSWIFT_PUB_KEY_SIZE);\n+            m_peer_cipher->GetHandshakeState().ReadMsgEphemeralPK(MakeWritableByteSpan(m_received));\n+            m_received.clear();\n+        } else {\n+            BOOST_REQUIRE(m_to_send.empty());\n+            m_to_send.resize(Sv2HandshakeState::ELLSWIFT_PUB_KEY_SIZE);\n+            m_peer_cipher->GetHandshakeState().WriteMsgEphemeralPK(MakeWritableByteSpan(m_to_send));\n+        }\n+\n+    }\n+\n+    /** Expect key to have been received from transport and process it.\n+     *\n+     * Many other Sv2TransportTester functions cannot be called until after\n+     * ProcessHandshake2() has been called, as no encryption keys are set up before that point.\n+     */\n+    void ProcessHandshake2()\n+    {\n+        if (m_test_initiator) {\n+            BOOST_REQUIRE(m_to_send.empty());\n+\n+            // Have the peer cypher write the second part of the handshake into our receive buffer\n+            m_to_send.resize(Sv2HandshakeState::HANDSHAKE_STEP2_SIZE);\n+            m_peer_cipher->GetHandshakeState().WriteMsgES(MakeWritableByteSpan(m_to_send));\n+\n+            // At this point the peer is done with the handshake:\n+            m_peer_cipher->FinishHandshake();\n+        } else {\n+            BOOST_REQUIRE(m_received.size() == Sv2HandshakeState::HANDSHAKE_STEP2_SIZE);\n+            BOOST_REQUIRE(m_peer_cipher->GetHandshakeState().ReadMsgES(MakeWritableByteSpan(m_received)));\n+            m_received.clear();\n+\n+            m_peer_cipher->FinishHandshake();\n+        }\n+    }\n+\n+    /** Schedule an encrypted packet with specified content to be sent to transport\n+     *  (only after ReceiveKey). */\n+    void SendPacket(Sv2NetMsg msg)\n+    {\n+        // TODO: randomly break stuff\n+\n+        std::vector<std::byte> ciphertext;\n+        const size_t encrypted_payload_size = Sv2Cipher::EncryptedMessageSize(msg.size());\n+        ciphertext.resize(SV2_HEADER_ENCRYPTED_SIZE + encrypted_payload_size);\n+        Span<std::byte> buffer_span{MakeWritableByteSpan(ciphertext)};\n+\n+        // Header\n+        DataStream ss_header_plain{};\n+        ss_header_plain << Sv2NetHeader(msg);\n+        LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"Header: %s\\n\", HexStr(ss_header_plain));\n+        Span<std::byte> header_encrypted{buffer_span.subspan(0, SV2_HEADER_ENCRYPTED_SIZE)};\n+        BOOST_REQUIRE(m_peer_cipher->EncryptMessage(ss_header_plain, header_encrypted));\n+\n+        // Payload\n+        Span<const std::byte> payload_plain = MakeByteSpan(msg.data());\n+        // TODO: truncate very long messages, about 100 bytes at the start and end\n+        //       is probably enough for most debugging.\n+        LogPrintLevel(BCLog::SV2, BCLog::Level::Trace, \"Payload: %s\\n\", HexStr(payload_plain));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30315#discussion_r1649293172",
      "id" : 1649293172,
      "in_reply_to_id" : 1649237537,
      "line" : 247,
      "node_id" : "PRRC_kwDOABII585iTjd0",
      "original_commit_id" : "2f673b5959cee168b808e23c6f5554e2f673db15",
      "original_line" : 247,
      "original_position" : 247,
      "original_start_line" : null,
      "path" : "src/test/sv2_transport_tests.cpp",
      "position" : 247,
      "pull_request_review_id" : 2133197114,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30315",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649293172/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-06-21T18:15:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649293172",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   }
]
