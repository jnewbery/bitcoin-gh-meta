[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage\nFor detailed information about the code coverage, see the [test coverage report](https://corecheck.dev/bitcoin/bitcoin/pulls/29431).\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| Concept ACK | [theStack](https://github.com/bitcoin/bitcoin/pull/29431#issuecomment-1948492950), [kevkevinpal](https://github.com/bitcoin/bitcoin/pull/29431#pullrequestreview-1884162177), [mzumsande](https://github.com/bitcoin/bitcoin/pull/29431#pullrequestreview-1907520121) |\n\nIf your review is incorrectly listed, please react with ð to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#29500](https://github.com/bitcoin/bitcoin/pull/29500) (test: create assert_not_equal util by kevkevinpal)\n* [#29420](https://github.com/bitcoin/bitcoin/pull/29420) (test: extend the SOCKS5 Python proxy to actually connect to a destination by vasild)\n* [#29415](https://github.com/bitcoin/bitcoin/pull/29415) (Broadcast own transactions only via short-lived Tor or I2P connections by vasild)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "created_at" : "2024-02-14T08:59:20Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29431#issuecomment-1943330480",
      "id" : 1943330480,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/29431",
      "node_id" : "IC_kwDOABII585z1N6w",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1943330480/reactions"
      },
      "updated_at" : "2024-05-02T05:14:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1943330480",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@sr-gi, i tried [this manually sending idea](https://github.com/bitcoin/bitcoin/pull/29352#pullrequestreview-1854149947) but i still think intermittent failures are possible there.\r\n- we can't get rid of `can_data_be_received` variable because if we don't use this variable, test would succeed irrespective of whether we send 4 bytes network magic first or 4 bytes from ellswift bytes first and we don't want that.\r\n- so since `data_received()` always happens in `Network thread`  and send of ellswift bytes + setting  `can_data_be_received=True` happens on `MainThread`, in the rare scenario that `data_received()` gets called before setting `can_data_be_received`, an intermittent failure could happen i think.\r\n\r\nhere's a [branch](https://github.com/stratospher/bitcoin/commit/7e7173467fd5459e4b19ebd48186690f174be95f) where i tweaked the code you shared a bit with a sleep statement for making the test crash and reintroducing `can_data_be_received` variable.",
      "created_at" : "2024-02-15T05:27:37Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29431#issuecomment-1945395946",
      "id" : 1945395946,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/29431",
      "node_id" : "IC_kwDOABII585z9GLq",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1945395946/reactions"
      },
      "updated_at" : "2024-02-15T05:27:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1945395946",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29431#discussion_r1491842216"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29431"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1491842216"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "doesn't the `+1` make the `garbage_len` greater than `4095` which is what is being covered in `TestType.EXCESS_GARBAGE`",
      "commit_id" : "ec9005ca4be088dfa2d247bbfe964a9c98e4f29d",
      "created_at" : "2024-02-16T01:03:36Z",
      "diff_hunk" : "@@ -0,0 +1,201 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import random\n+from enum import Enum\n+\n+from test_framework.crypto.ellswift import ellswift_create\n+from test_framework.p2p import P2PInterface\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import random_bitflip\n+from test_framework.v2_p2p import (\n+    logger,\n+    EncryptedP2PState,\n+    MAX_GARBAGE_LEN,\n+    TRANSPORT_VERSION,\n+)\n+\n+\n+class TestType(Enum):\n+    \"\"\" Scenarios to be tested:\n+\n+    1. EARLY_KEY_RESPONSE - The responder needs to wait until one byte is received which does not match the 16 bytes\n+    consisting of network magic followed by \"version\\x00\\x00\\x00\\x00\\x00\" before sending out it's ellswift + garbage bytes\n+    2. EXCESS_GARBAGE - Disconnection happens when > MAX_GARBAGE_LEN bytes garbage is sent\n+    3. WRONG_GARBAGE_TERMINATOR - Disconnection happens when incorrect garbage terminator is sent\n+    4. WRONG_GARBAGE - Disconnection happens when garbage bytes that is sent is different from what the peer receives\n+    5. SEND_NO_AAD - Disconnection happens when AAD of first encrypted packet after the garbage terminator is not filled\n+    6. SEND_NON_EMPTY_VERSION_PACKET - non-empty version packet is simply ignored\n+    \"\"\"\n+    EARLY_KEY_RESPONSE = 0\n+    EXCESS_GARBAGE = 1\n+    WRONG_GARBAGE_TERMINATOR = 2\n+    WRONG_GARBAGE = 3\n+    SEND_NO_AAD = 4\n+    SEND_NON_EMPTY_VERSION_PACKET = 5\n+\n+\n+class TestEncryptedP2PState(EncryptedP2PState):\n+    \"\"\" Modify v2 P2P protocol functions for testing scenarios listed in `TestType`\"\"\"\n+    def __init__(self, test_type):\n+        super().__init__(initiating=True, net='regtest')\n+        self.test_type = test_type\n+        if test_type == TestType.EARLY_KEY_RESPONSE:\n+            self.magic_sent = False  # set to True after first 4 bytes of ellswift which match network magic is sent.\n+            self.can_data_be_received = False  # variable used to assert if data is received on recvbuf.\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generate > MAX_GARBAGE_LEN garbage bytes, MAX_GARBAGE_LEN//2 garbage bytes, tampered garbage bytes\n+        when TestType = (EXCESS_GARBAGE, WRONG_GARBAGE_TERMINATOR, WRONG_GARBAGE)\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+\n+        if self.test_type == TestType.EXCESS_GARBAGE:\n+            # send > 4095 bytes garbage\n+            garbage_len = MAX_GARBAGE_LEN + random.randrange(1, 10)\n+        elif self.test_type == TestType.WRONG_GARBAGE_TERMINATOR:\n+            garbage_len = random.randrange(MAX_GARBAGE_LEN//2)\n+        else:\n+            garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29431#discussion_r1491842216",
      "id" : 1491842216,
      "line" : 60,
      "node_id" : "PRRC_kwDOABII585Y67So",
      "original_commit_id" : "ec9005ca4be088dfa2d247bbfe964a9c98e4f29d",
      "original_line" : 60,
      "original_position" : 60,
      "original_start_line" : null,
      "path" : "test/functional/p2p_v2_misbehaving.py",
      "position" : 60,
      "pull_request_review_id" : 1884147732,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29431",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1491842216/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-02-16T01:03:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1491842216",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/15950706?v=4",
         "events_url" : "https://api.github.com/users/kevkevinpal/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kevkevinpal/followers",
         "following_url" : "https://api.github.com/users/kevkevinpal/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kevkevinpal/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kevkevinpal",
         "id" : 15950706,
         "login" : "kevkevinpal",
         "node_id" : "MDQ6VXNlcjE1OTUwNzA2",
         "organizations_url" : "https://api.github.com/users/kevkevinpal/orgs",
         "received_events_url" : "https://api.github.com/users/kevkevinpal/received_events",
         "repos_url" : "https://api.github.com/users/kevkevinpal/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kevkevinpal/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kevkevinpal/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kevkevinpal"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29431#discussion_r1491843089"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29431"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1491843089"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "never mind randrange doesn't include the value passed",
      "commit_id" : "ec9005ca4be088dfa2d247bbfe964a9c98e4f29d",
      "created_at" : "2024-02-16T01:05:25Z",
      "diff_hunk" : "@@ -0,0 +1,201 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import random\n+from enum import Enum\n+\n+from test_framework.crypto.ellswift import ellswift_create\n+from test_framework.p2p import P2PInterface\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import random_bitflip\n+from test_framework.v2_p2p import (\n+    logger,\n+    EncryptedP2PState,\n+    MAX_GARBAGE_LEN,\n+    TRANSPORT_VERSION,\n+)\n+\n+\n+class TestType(Enum):\n+    \"\"\" Scenarios to be tested:\n+\n+    1. EARLY_KEY_RESPONSE - The responder needs to wait until one byte is received which does not match the 16 bytes\n+    consisting of network magic followed by \"version\\x00\\x00\\x00\\x00\\x00\" before sending out it's ellswift + garbage bytes\n+    2. EXCESS_GARBAGE - Disconnection happens when > MAX_GARBAGE_LEN bytes garbage is sent\n+    3. WRONG_GARBAGE_TERMINATOR - Disconnection happens when incorrect garbage terminator is sent\n+    4. WRONG_GARBAGE - Disconnection happens when garbage bytes that is sent is different from what the peer receives\n+    5. SEND_NO_AAD - Disconnection happens when AAD of first encrypted packet after the garbage terminator is not filled\n+    6. SEND_NON_EMPTY_VERSION_PACKET - non-empty version packet is simply ignored\n+    \"\"\"\n+    EARLY_KEY_RESPONSE = 0\n+    EXCESS_GARBAGE = 1\n+    WRONG_GARBAGE_TERMINATOR = 2\n+    WRONG_GARBAGE = 3\n+    SEND_NO_AAD = 4\n+    SEND_NON_EMPTY_VERSION_PACKET = 5\n+\n+\n+class TestEncryptedP2PState(EncryptedP2PState):\n+    \"\"\" Modify v2 P2P protocol functions for testing scenarios listed in `TestType`\"\"\"\n+    def __init__(self, test_type):\n+        super().__init__(initiating=True, net='regtest')\n+        self.test_type = test_type\n+        if test_type == TestType.EARLY_KEY_RESPONSE:\n+            self.magic_sent = False  # set to True after first 4 bytes of ellswift which match network magic is sent.\n+            self.can_data_be_received = False  # variable used to assert if data is received on recvbuf.\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generate > MAX_GARBAGE_LEN garbage bytes, MAX_GARBAGE_LEN//2 garbage bytes, tampered garbage bytes\n+        when TestType = (EXCESS_GARBAGE, WRONG_GARBAGE_TERMINATOR, WRONG_GARBAGE)\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+\n+        if self.test_type == TestType.EXCESS_GARBAGE:\n+            # send > 4095 bytes garbage\n+            garbage_len = MAX_GARBAGE_LEN + random.randrange(1, 10)\n+        elif self.test_type == TestType.WRONG_GARBAGE_TERMINATOR:\n+            garbage_len = random.randrange(MAX_GARBAGE_LEN//2)\n+        else:\n+            garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29431#discussion_r1491843089",
      "id" : 1491843089,
      "in_reply_to_id" : 1491842216,
      "line" : 60,
      "node_id" : "PRRC_kwDOABII585Y67gR",
      "original_commit_id" : "ec9005ca4be088dfa2d247bbfe964a9c98e4f29d",
      "original_line" : 60,
      "original_position" : 60,
      "original_start_line" : null,
      "path" : "test/functional/p2p_v2_misbehaving.py",
      "position" : 60,
      "pull_request_review_id" : 1884149060,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29431",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1491843089/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-02-16T01:05:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1491843089",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/15950706?v=4",
         "events_url" : "https://api.github.com/users/kevkevinpal/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kevkevinpal/followers",
         "following_url" : "https://api.github.com/users/kevkevinpal/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kevkevinpal/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kevkevinpal",
         "id" : 15950706,
         "login" : "kevkevinpal",
         "node_id" : "MDQ6VXNlcjE1OTUwNzA2",
         "organizations_url" : "https://api.github.com/users/kevkevinpal/orgs",
         "received_events_url" : "https://api.github.com/users/kevkevinpal/received_events",
         "repos_url" : "https://api.github.com/users/kevkevinpal/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kevkevinpal/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kevkevinpal/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kevkevinpal"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29431#discussion_r1491848110"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29431"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1491848110"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "do you think it would make sense to use `test_earlykeyresponse` here and then make `test_v2disconnection` into `run_test`",
      "commit_id" : "ec9005ca4be088dfa2d247bbfe964a9c98e4f29d",
      "created_at" : "2024-02-16T01:15:28Z",
      "diff_hunk" : "@@ -0,0 +1,201 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import random\n+from enum import Enum\n+\n+from test_framework.crypto.ellswift import ellswift_create\n+from test_framework.p2p import P2PInterface\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import random_bitflip\n+from test_framework.v2_p2p import (\n+    logger,\n+    EncryptedP2PState,\n+    MAX_GARBAGE_LEN,\n+    TRANSPORT_VERSION,\n+)\n+\n+\n+class TestType(Enum):\n+    \"\"\" Scenarios to be tested:\n+\n+    1. EARLY_KEY_RESPONSE - The responder needs to wait until one byte is received which does not match the 16 bytes\n+    consisting of network magic followed by \"version\\x00\\x00\\x00\\x00\\x00\" before sending out it's ellswift + garbage bytes\n+    2. EXCESS_GARBAGE - Disconnection happens when > MAX_GARBAGE_LEN bytes garbage is sent\n+    3. WRONG_GARBAGE_TERMINATOR - Disconnection happens when incorrect garbage terminator is sent\n+    4. WRONG_GARBAGE - Disconnection happens when garbage bytes that is sent is different from what the peer receives\n+    5. SEND_NO_AAD - Disconnection happens when AAD of first encrypted packet after the garbage terminator is not filled\n+    6. SEND_NON_EMPTY_VERSION_PACKET - non-empty version packet is simply ignored\n+    \"\"\"\n+    EARLY_KEY_RESPONSE = 0\n+    EXCESS_GARBAGE = 1\n+    WRONG_GARBAGE_TERMINATOR = 2\n+    WRONG_GARBAGE = 3\n+    SEND_NO_AAD = 4\n+    SEND_NON_EMPTY_VERSION_PACKET = 5\n+\n+\n+class TestEncryptedP2PState(EncryptedP2PState):\n+    \"\"\" Modify v2 P2P protocol functions for testing scenarios listed in `TestType`\"\"\"\n+    def __init__(self, test_type):\n+        super().__init__(initiating=True, net='regtest')\n+        self.test_type = test_type\n+        if test_type == TestType.EARLY_KEY_RESPONSE:\n+            self.magic_sent = False  # set to True after first 4 bytes of ellswift which match network magic is sent.\n+            self.can_data_be_received = False  # variable used to assert if data is received on recvbuf.\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generate > MAX_GARBAGE_LEN garbage bytes, MAX_GARBAGE_LEN//2 garbage bytes, tampered garbage bytes\n+        when TestType = (EXCESS_GARBAGE, WRONG_GARBAGE_TERMINATOR, WRONG_GARBAGE)\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+\n+        if self.test_type == TestType.EXCESS_GARBAGE:\n+            # send > 4095 bytes garbage\n+            garbage_len = MAX_GARBAGE_LEN + random.randrange(1, 10)\n+        elif self.test_type == TestType.WRONG_GARBAGE_TERMINATOR:\n+            garbage_len = random.randrange(MAX_GARBAGE_LEN//2)\n+        else:\n+            garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+\n+        if self.test_type == TestType.WRONG_GARBAGE:\n+            # assume that garbage bytes sent to TestNode were tampered with\n+            return self.ellswift_ours + random_bitflip(self.sent_garbage)\n+        else:\n+            return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Send ellswift and garbage bytes in 2 parts when TestType = (EARLY_KEY_RESPONSE)\"\"\"\n+        if self.test_type == TestType.EARLY_KEY_RESPONSE:\n+            # Here, the 64 bytes ellswift is assumed to have it's first 4 bytes match network magic bytes.\n+            # It is sent in 2 phases:\n+            # 1. when `magic_sent` = False, send first 4 bytes of ellswift (matches network magic bytes)\n+            # 2. when `magic_sent` = True, send remaining 60 bytes of ellswift\n+            if not self.magic_sent:\n+                self.generate_keypair_and_garbage()\n+                self.magic_sent = True\n+                return b\"\\xfa\\xbf\\xb5\\xda\"\n+            else:\n+                # `can_data_be_received` is a variable used to assert if data is received on recvbuf.\n+                # 1. v2 TestNode shouldn't respond back if we send V1_PREFIX and data shouldn't be received on recvbuf.\n+                # This state is represented using `can_data_be_received` = False.\n+                # 2. v2 TestNode responds back when mismatch from V1_PREFIX happens and data can be received on recvbuf.\n+                # This state is represented using `can_data_be_received` = True.\n+                self.can_data_be_received = True\n+                return self.ellswift_ours[4:] + self.sent_garbage\n+        else:\n+            return super().initiate_v2_handshake()\n+\n+    def complete_handshake(self, response):\n+        \"\"\"Add option for sending wrong garbage terminator, not filling first encrypted packet after garbage terminator\n+        with AAD, sending non-empty transport version packet.\n+        when TestType = (WRONG_GARBAGE_TERMINATOR, SEND_NO_AAD, SEND_NON_EMPTY_VERSION_PACKET)\"\"\"\n+        ellswift_theirs = self.received_prefix + response.read(64 - len(self.received_prefix))\n+        # return b\"\" if we need to receive more bytes\n+        if len(ellswift_theirs) != 64:\n+            return 0, b\"\"\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        aad = self.sent_garbage\n+\n+        if self.test_type == TestType.WRONG_GARBAGE_TERMINATOR:\n+            msg_to_send = random_bitflip(msg_to_send)\n+        elif self.test_type == TestType.SEND_NO_AAD:\n+            aad = b''\n+\n+        # Optionally send decoy packets after garbage terminator.\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(random.randint(0, 10))]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+\n+        # Send version packet.\n+        if self.test_type == TestType.SEND_NON_EMPTY_VERSION_PACKET:\n+            msg_to_send += self.v2_enc_packet(random.randbytes(5), aad=aad)\n+        else:\n+            msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+\n+        return 64 - len(self.received_prefix), msg_to_send\n+\n+\n+class MisbehavingV2Peer(P2PInterface):\n+    \"\"\"Custom implementation of P2PInterface which uses modified v2 P2P protocol functions for testing purposes.\"\"\"\n+    def __init__(self, test_type):\n+        super().__init__()\n+        self.v2_state = None\n+        self.connection_opened = False\n+        self.test_type = test_type\n+\n+    def connection_made(self, transport):\n+        \"\"\"Only first 4 ellswift bytes which match network magic bytes is sent using `initial_v2_handshake()` in\n+        `connection_made()` when TestType = (EARLY_KEY_RESPONSE)\"\"\"\n+        self.v2_state = TestEncryptedP2PState(self.test_type)\n+        super().connection_made(transport)\n+\n+    def data_received(self, t):\n+        if self.test_type == TestType.EARLY_KEY_RESPONSE:\n+            # check that data can be received on recvbuf only when mismatch from V1_PREFIX happens (magic_sent = True)\n+            assert self.v2_state.can_data_be_received and self.v2_state.magic_sent\n+        else:\n+            super().data_received(t)\n+\n+    def on_open(self):\n+        self.connection_opened = True\n+\n+\n+class EncryptedP2PMisbehaving(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[\"-v2transport=1\", \"-peertimeout=3\"]]\n+\n+    def run_test(self):\n+        self.test_earlykeyresponse()\n+        self.test_v2disconnection()\n+\n+    def test_earlykeyresponse(self):\n+        self.log.info('Sending ellswift bytes in parts to ensure that response from responder is received only when')\n+        self.log.info('ellswift bytes have a mismatch from the 16 bytes(network magic followed by \"version\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\")')\n+        node0 = self.nodes[0]\n+        self.log.info('Sending first 4 bytes of ellswift which match network magic')\n+        self.log.info('If a response is received, assertion failure would happen in our custom data_received() function')\n+        # send happens in `initiate_v2_handshake()` in `connection_made()`\n+        peer1 = node0.add_p2p_connection(MisbehavingV2Peer(TestType.EARLY_KEY_RESPONSE), wait_for_verack=False, send_version=False, supports_v2_p2p=True)\n+        self.wait_until(lambda: peer1.connection_opened)\n+        self.log.info('Sending remaining ellswift and garbage which are different from V1_PREFIX. Since a response is')\n+        self.log.info('expected now, our custom data_received() function wouldn\\'t result in assertion failure')\n+        ellswift_and_garbage_data = peer1.v2_state.initiate_v2_handshake()\n+        peer1.send_raw_message(ellswift_and_garbage_data)\n+        with self.nodes[0].assert_debug_log(['version handshake timeout peer=0']):\n+            peer1.wait_for_disconnect(timeout=5)\n+        self.log.info('successful disconnection since modified ellswift was sent as response')\n+\n+    def test_v2disconnection(self):\n+        # test v2 disconnection scenarios\n+        node0 = self.nodes[0]\n+        expected_debug_message = [\n+            [],  # EARLY_KEY_RESPONSE\n+            [\"V2 transport error: missing garbage terminator, peer=1\"],  # EXCESS_GARBAGE\n+            [\"version handshake timeout peer=2\"],  # WRONG_GARBAGE_TERMINATOR\n+            [\"V2 transport error: packet decryption failure\"],  # WRONG_GARBAGE\n+            [\"V2 transport error: packet decryption failure\"],  # SEND_NO_AAD\n+            [],  # SEND_NON_EMPTY_VERSION_PACKET\n+        ]\n+        for test_type in TestType:\n+            if test_type == TestType.EARLY_KEY_RESPONSE:\n+                continue",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29431#discussion_r1491848110",
      "id" : 1491848110,
      "line" : 190,
      "node_id" : "PRRC_kwDOABII585Y68uu",
      "original_commit_id" : "ec9005ca4be088dfa2d247bbfe964a9c98e4f29d",
      "original_line" : 190,
      "original_position" : 190,
      "original_start_line" : null,
      "path" : "test/functional/p2p_v2_misbehaving.py",
      "position" : 190,
      "pull_request_review_id" : 1884162177,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29431",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1491848110/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-02-16T15:12:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1491848110",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/15950706?v=4",
         "events_url" : "https://api.github.com/users/kevkevinpal/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kevkevinpal/followers",
         "following_url" : "https://api.github.com/users/kevkevinpal/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kevkevinpal/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kevkevinpal",
         "id" : 15950706,
         "login" : "kevkevinpal",
         "node_id" : "MDQ6VXNlcjE1OTUwNzA2",
         "organizations_url" : "https://api.github.com/users/kevkevinpal/orgs",
         "received_events_url" : "https://api.github.com/users/kevkevinpal/received_events",
         "repos_url" : "https://api.github.com/users/kevkevinpal/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kevkevinpal/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kevkevinpal/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kevkevinpal"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29431#discussion_r1491897558"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29431"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1491897558"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Are the `test_type`'s in `test_v2disconnection` dependent on `test_earlykeyresponse` to run first?\r\n\r\nI tried running the tests individually for each `test_type` but I ran into this error, using this diff a74f4ddcc50eeba04977d8eeb96ffee2a94dbbf9 \r\n```\r\n2024-02-16T02:38:17.055000Z TestFramework (INFO): PRNG seed is: 8074818075718275852\r\n2024-02-16T02:38:17.056000Z TestFramework (INFO): Initializing test directory /var/folders/9g/cvx014yx4dq5lwl_x5zvn_j80000gn/T/bitcoin_func_test_dmwxb4ar\r\n2024-02-16T02:38:22.936000Z TestFramework (ERROR): Assertion failed\r\nTraceback (most recent call last):\r\n  File \"/Users/kevkevin/DEVDIR/bitcoin/test/functional/test_framework/test_framework.py\", line 131, in main\r\n    self.run_test()\r\n  File \"/Users/kevkevin/DEVDIR/bitcoin/./test/functional/p2p_v2_misbehaving.py\", line 176, in run_test\r\n    with self.nodes[0].assert_debug_log(expected_debug_message[test_type.value], timeout=5):\r\n  File \"/usr/local/Cellar/python@3.11/3.11.6_1/Frameworks/Python.framework/Versions/3.11/lib/python3.11/contextlib.py\", line 144, in __exit__\r\n    next(self.gen)\r\n  File \"/Users/kevkevin/DEVDIR/bitcoin/test/functional/test_framework/test_node.py\", line 492, in assert_debug_log\r\n    self._raise_assertion_error('Expected messages \"{}\" does not partially match log:\\n\\n{}\\n\\n'.format(str(expected_msgs), print_log))\r\n  File \"/Users/kevkevin/DEVDIR/bitcoin/test/functional/test_framework/test_node.py\", line 190, in _raise_assertion_error\r\n    raise AssertionError(self._node_msg(msg))\r\nAssertionError: [node 0] Expected messages \"['version handshake timeout peer=2']\" does not partially match log:\r\n\r\n - 2024-02-16T02:38:17.908176Z [net] [net.cpp:3712] [CNode] [net] Added connection peer=0\r\n - 2024-02-16T02:38:17.908650Z [net] [net.cpp:1820] [CreateNodeFromAcceptedSocket] [net] connection from 127.0.0.1:63849 accepted\r\n - 2024-02-16T02:38:21.015546Z [net] [net.cpp:1992] [InactivityCheck] [net] version handshake timeout peer=0\r\n - 2024-02-16T02:38:21.015844Z [net] [net.cpp:555] [CloseSocketDisconnect] [net] disconnecting peer=0\r\n - 2024-02-16T02:38:21.016463Z [net] [net_processing.cpp:1672] [FinalizeNode] [net] Cleared nodestate for peer=0\r\n\r\n\r\n2024-02-16T02:38:22.999000Z TestFramework (INFO): Stopping nodes\r\n2024-02-16T02:38:23.270000Z TestFramework (WARNING): Not cleaning up dir /var/folders/9g/cvx014yx4dq5lwl_x5zvn_j80000gn/T/bitcoin_func_test_dmwxb4ar\r\n2024-02-16T02:38:23.270000Z TestFramework (ERROR): Test failed. Test logging available at /var/folders/9g/cvx014yx4dq5lwl_x5zvn_j80000gn/T/bitcoin_func_test_dmwxb4ar/test_framework.log\r\n2024-02-16T02:38:23.271000Z TestFramework (ERROR):\r\n2024-02-16T02:38:23.271000Z TestFramework (ERROR): Hint: Call /Users/kevkevin/DEVDIR/bitcoin/test/functional/combine_logs.py '/var/folders/9g/cvx014yx4dq5lwl_x5zvn_j80000gn/T/bitcoin_func_test_dmwxb4ar' to consolidate all logs\r\n2024-02-16T02:38:23.271000Z TestFramework (ERROR):\r\n2024-02-16T02:38:23.271000Z TestFramework (ERROR): If this failure happened unexpectedly or intermittently, please file a bug and provide a link or upload of the combined log.\r\n2024-02-16T02:38:23.272000Z TestFramework (ERROR): https://github.com/bitcoin/bitcoin/issues\r\n2024-02-16T02:38:23.272000Z TestFramework (ERROR):\r\n```",
      "commit_id" : "ec9005ca4be088dfa2d247bbfe964a9c98e4f29d",
      "created_at" : "2024-02-16T02:43:16Z",
      "diff_hunk" : "@@ -0,0 +1,201 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import random\n+from enum import Enum\n+\n+from test_framework.crypto.ellswift import ellswift_create\n+from test_framework.p2p import P2PInterface\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import random_bitflip\n+from test_framework.v2_p2p import (\n+    logger,\n+    EncryptedP2PState,\n+    MAX_GARBAGE_LEN,\n+    TRANSPORT_VERSION,\n+)\n+\n+\n+class TestType(Enum):\n+    \"\"\" Scenarios to be tested:\n+\n+    1. EARLY_KEY_RESPONSE - The responder needs to wait until one byte is received which does not match the 16 bytes\n+    consisting of network magic followed by \"version\\x00\\x00\\x00\\x00\\x00\" before sending out it's ellswift + garbage bytes\n+    2. EXCESS_GARBAGE - Disconnection happens when > MAX_GARBAGE_LEN bytes garbage is sent\n+    3. WRONG_GARBAGE_TERMINATOR - Disconnection happens when incorrect garbage terminator is sent\n+    4. WRONG_GARBAGE - Disconnection happens when garbage bytes that is sent is different from what the peer receives\n+    5. SEND_NO_AAD - Disconnection happens when AAD of first encrypted packet after the garbage terminator is not filled\n+    6. SEND_NON_EMPTY_VERSION_PACKET - non-empty version packet is simply ignored\n+    \"\"\"\n+    EARLY_KEY_RESPONSE = 0\n+    EXCESS_GARBAGE = 1\n+    WRONG_GARBAGE_TERMINATOR = 2\n+    WRONG_GARBAGE = 3\n+    SEND_NO_AAD = 4\n+    SEND_NON_EMPTY_VERSION_PACKET = 5\n+\n+\n+class TestEncryptedP2PState(EncryptedP2PState):\n+    \"\"\" Modify v2 P2P protocol functions for testing scenarios listed in `TestType`\"\"\"\n+    def __init__(self, test_type):\n+        super().__init__(initiating=True, net='regtest')\n+        self.test_type = test_type\n+        if test_type == TestType.EARLY_KEY_RESPONSE:\n+            self.magic_sent = False  # set to True after first 4 bytes of ellswift which match network magic is sent.\n+            self.can_data_be_received = False  # variable used to assert if data is received on recvbuf.\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generate > MAX_GARBAGE_LEN garbage bytes, MAX_GARBAGE_LEN//2 garbage bytes, tampered garbage bytes\n+        when TestType = (EXCESS_GARBAGE, WRONG_GARBAGE_TERMINATOR, WRONG_GARBAGE)\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+\n+        if self.test_type == TestType.EXCESS_GARBAGE:\n+            # send > 4095 bytes garbage\n+            garbage_len = MAX_GARBAGE_LEN + random.randrange(1, 10)\n+        elif self.test_type == TestType.WRONG_GARBAGE_TERMINATOR:\n+            garbage_len = random.randrange(MAX_GARBAGE_LEN//2)\n+        else:\n+            garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+\n+        if self.test_type == TestType.WRONG_GARBAGE:\n+            # assume that garbage bytes sent to TestNode were tampered with\n+            return self.ellswift_ours + random_bitflip(self.sent_garbage)\n+        else:\n+            return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Send ellswift and garbage bytes in 2 parts when TestType = (EARLY_KEY_RESPONSE)\"\"\"\n+        if self.test_type == TestType.EARLY_KEY_RESPONSE:\n+            # Here, the 64 bytes ellswift is assumed to have it's first 4 bytes match network magic bytes.\n+            # It is sent in 2 phases:\n+            # 1. when `magic_sent` = False, send first 4 bytes of ellswift (matches network magic bytes)\n+            # 2. when `magic_sent` = True, send remaining 60 bytes of ellswift\n+            if not self.magic_sent:\n+                self.generate_keypair_and_garbage()\n+                self.magic_sent = True\n+                return b\"\\xfa\\xbf\\xb5\\xda\"\n+            else:\n+                # `can_data_be_received` is a variable used to assert if data is received on recvbuf.\n+                # 1. v2 TestNode shouldn't respond back if we send V1_PREFIX and data shouldn't be received on recvbuf.\n+                # This state is represented using `can_data_be_received` = False.\n+                # 2. v2 TestNode responds back when mismatch from V1_PREFIX happens and data can be received on recvbuf.\n+                # This state is represented using `can_data_be_received` = True.\n+                self.can_data_be_received = True\n+                return self.ellswift_ours[4:] + self.sent_garbage\n+        else:\n+            return super().initiate_v2_handshake()\n+\n+    def complete_handshake(self, response):\n+        \"\"\"Add option for sending wrong garbage terminator, not filling first encrypted packet after garbage terminator\n+        with AAD, sending non-empty transport version packet.\n+        when TestType = (WRONG_GARBAGE_TERMINATOR, SEND_NO_AAD, SEND_NON_EMPTY_VERSION_PACKET)\"\"\"\n+        ellswift_theirs = self.received_prefix + response.read(64 - len(self.received_prefix))\n+        # return b\"\" if we need to receive more bytes\n+        if len(ellswift_theirs) != 64:\n+            return 0, b\"\"\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        aad = self.sent_garbage\n+\n+        if self.test_type == TestType.WRONG_GARBAGE_TERMINATOR:\n+            msg_to_send = random_bitflip(msg_to_send)\n+        elif self.test_type == TestType.SEND_NO_AAD:\n+            aad = b''\n+\n+        # Optionally send decoy packets after garbage terminator.\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(random.randint(0, 10))]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+\n+        # Send version packet.\n+        if self.test_type == TestType.SEND_NON_EMPTY_VERSION_PACKET:\n+            msg_to_send += self.v2_enc_packet(random.randbytes(5), aad=aad)\n+        else:\n+            msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+\n+        return 64 - len(self.received_prefix), msg_to_send\n+\n+\n+class MisbehavingV2Peer(P2PInterface):\n+    \"\"\"Custom implementation of P2PInterface which uses modified v2 P2P protocol functions for testing purposes.\"\"\"\n+    def __init__(self, test_type):\n+        super().__init__()\n+        self.v2_state = None\n+        self.connection_opened = False\n+        self.test_type = test_type\n+\n+    def connection_made(self, transport):\n+        \"\"\"Only first 4 ellswift bytes which match network magic bytes is sent using `initial_v2_handshake()` in\n+        `connection_made()` when TestType = (EARLY_KEY_RESPONSE)\"\"\"\n+        self.v2_state = TestEncryptedP2PState(self.test_type)\n+        super().connection_made(transport)\n+\n+    def data_received(self, t):\n+        if self.test_type == TestType.EARLY_KEY_RESPONSE:\n+            # check that data can be received on recvbuf only when mismatch from V1_PREFIX happens (magic_sent = True)\n+            assert self.v2_state.can_data_be_received and self.v2_state.magic_sent\n+        else:\n+            super().data_received(t)\n+\n+    def on_open(self):\n+        self.connection_opened = True\n+\n+\n+class EncryptedP2PMisbehaving(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[\"-v2transport=1\", \"-peertimeout=3\"]]\n+\n+    def run_test(self):\n+        self.test_earlykeyresponse()\n+        self.test_v2disconnection()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29431#discussion_r1491897558",
      "id" : 1491897558,
      "line" : 158,
      "node_id" : "PRRC_kwDOABII585Y7IzW",
      "original_commit_id" : "ec9005ca4be088dfa2d247bbfe964a9c98e4f29d",
      "original_line" : 158,
      "original_position" : 158,
      "original_start_line" : 157,
      "path" : "test/functional/p2p_v2_misbehaving.py",
      "position" : 158,
      "pull_request_review_id" : 1884162177,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29431",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1491897558/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 157,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2024-02-16T15:12:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1491897558",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/15950706?v=4",
         "events_url" : "https://api.github.com/users/kevkevinpal/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kevkevinpal/followers",
         "following_url" : "https://api.github.com/users/kevkevinpal/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kevkevinpal/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kevkevinpal",
         "id" : 15950706,
         "login" : "kevkevinpal",
         "node_id" : "MDQ6VXNlcjE1OTUwNzA2",
         "organizations_url" : "https://api.github.com/users/kevkevinpal/orgs",
         "received_events_url" : "https://api.github.com/users/kevkevinpal/received_events",
         "repos_url" : "https://api.github.com/users/kevkevinpal/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kevkevinpal/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kevkevinpal/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kevkevinpal"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29431#discussion_r1491901555"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29431"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1491901555"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "yes!",
      "commit_id" : "ec9005ca4be088dfa2d247bbfe964a9c98e4f29d",
      "created_at" : "2024-02-16T02:51:30Z",
      "diff_hunk" : "@@ -0,0 +1,201 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import random\n+from enum import Enum\n+\n+from test_framework.crypto.ellswift import ellswift_create\n+from test_framework.p2p import P2PInterface\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import random_bitflip\n+from test_framework.v2_p2p import (\n+    logger,\n+    EncryptedP2PState,\n+    MAX_GARBAGE_LEN,\n+    TRANSPORT_VERSION,\n+)\n+\n+\n+class TestType(Enum):\n+    \"\"\" Scenarios to be tested:\n+\n+    1. EARLY_KEY_RESPONSE - The responder needs to wait until one byte is received which does not match the 16 bytes\n+    consisting of network magic followed by \"version\\x00\\x00\\x00\\x00\\x00\" before sending out it's ellswift + garbage bytes\n+    2. EXCESS_GARBAGE - Disconnection happens when > MAX_GARBAGE_LEN bytes garbage is sent\n+    3. WRONG_GARBAGE_TERMINATOR - Disconnection happens when incorrect garbage terminator is sent\n+    4. WRONG_GARBAGE - Disconnection happens when garbage bytes that is sent is different from what the peer receives\n+    5. SEND_NO_AAD - Disconnection happens when AAD of first encrypted packet after the garbage terminator is not filled\n+    6. SEND_NON_EMPTY_VERSION_PACKET - non-empty version packet is simply ignored\n+    \"\"\"\n+    EARLY_KEY_RESPONSE = 0\n+    EXCESS_GARBAGE = 1\n+    WRONG_GARBAGE_TERMINATOR = 2\n+    WRONG_GARBAGE = 3\n+    SEND_NO_AAD = 4\n+    SEND_NON_EMPTY_VERSION_PACKET = 5\n+\n+\n+class TestEncryptedP2PState(EncryptedP2PState):\n+    \"\"\" Modify v2 P2P protocol functions for testing scenarios listed in `TestType`\"\"\"\n+    def __init__(self, test_type):\n+        super().__init__(initiating=True, net='regtest')\n+        self.test_type = test_type\n+        if test_type == TestType.EARLY_KEY_RESPONSE:\n+            self.magic_sent = False  # set to True after first 4 bytes of ellswift which match network magic is sent.\n+            self.can_data_be_received = False  # variable used to assert if data is received on recvbuf.\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generate > MAX_GARBAGE_LEN garbage bytes, MAX_GARBAGE_LEN//2 garbage bytes, tampered garbage bytes\n+        when TestType = (EXCESS_GARBAGE, WRONG_GARBAGE_TERMINATOR, WRONG_GARBAGE)\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+\n+        if self.test_type == TestType.EXCESS_GARBAGE:\n+            # send > 4095 bytes garbage\n+            garbage_len = MAX_GARBAGE_LEN + random.randrange(1, 10)\n+        elif self.test_type == TestType.WRONG_GARBAGE_TERMINATOR:\n+            garbage_len = random.randrange(MAX_GARBAGE_LEN//2)\n+        else:\n+            garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29431#discussion_r1491901555",
      "id" : 1491901555,
      "in_reply_to_id" : 1491842216,
      "line" : 60,
      "node_id" : "PRRC_kwDOABII585Y7Jxz",
      "original_commit_id" : "ec9005ca4be088dfa2d247bbfe964a9c98e4f29d",
      "original_line" : 60,
      "original_position" : 60,
      "original_start_line" : null,
      "path" : "test/functional/p2p_v2_misbehaving.py",
      "position" : 60,
      "pull_request_review_id" : 1884232439,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29431",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1491901555/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-02-16T02:51:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1491901555",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Concept ACK",
      "created_at" : "2024-02-16T14:35:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29431#issuecomment-1948492950",
      "id" : 1948492950,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/29431",
      "node_id" : "IC_kwDOABII5850I6SW",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1948492950/reactions"
      },
      "updated_at" : "2024-02-16T14:35:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1948492950",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29431#discussion_r1494116658"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29431"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1494116658"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`test_earlykeyresponse` sends handshake bytes etc.. in the `MainThread` and I feel it's better to isolate that behaviour in a different test.\r\n\r\nalso, if you grep for `def test_` in `test/functional`, you'll see many [examples](https://github.com/bitcoin/bitcoin/blob/3cbc8cbc71d3d6ecfaf41164ce59c24ac94bae99/test/functional/feature_asmap.py#L128) of different tests listed in `run_test()` using the pattern which is currently used.",
      "commit_id" : "ec9005ca4be088dfa2d247bbfe964a9c98e4f29d",
      "created_at" : "2024-02-19T07:35:13Z",
      "diff_hunk" : "@@ -0,0 +1,201 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import random\n+from enum import Enum\n+\n+from test_framework.crypto.ellswift import ellswift_create\n+from test_framework.p2p import P2PInterface\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import random_bitflip\n+from test_framework.v2_p2p import (\n+    logger,\n+    EncryptedP2PState,\n+    MAX_GARBAGE_LEN,\n+    TRANSPORT_VERSION,\n+)\n+\n+\n+class TestType(Enum):\n+    \"\"\" Scenarios to be tested:\n+\n+    1. EARLY_KEY_RESPONSE - The responder needs to wait until one byte is received which does not match the 16 bytes\n+    consisting of network magic followed by \"version\\x00\\x00\\x00\\x00\\x00\" before sending out it's ellswift + garbage bytes\n+    2. EXCESS_GARBAGE - Disconnection happens when > MAX_GARBAGE_LEN bytes garbage is sent\n+    3. WRONG_GARBAGE_TERMINATOR - Disconnection happens when incorrect garbage terminator is sent\n+    4. WRONG_GARBAGE - Disconnection happens when garbage bytes that is sent is different from what the peer receives\n+    5. SEND_NO_AAD - Disconnection happens when AAD of first encrypted packet after the garbage terminator is not filled\n+    6. SEND_NON_EMPTY_VERSION_PACKET - non-empty version packet is simply ignored\n+    \"\"\"\n+    EARLY_KEY_RESPONSE = 0\n+    EXCESS_GARBAGE = 1\n+    WRONG_GARBAGE_TERMINATOR = 2\n+    WRONG_GARBAGE = 3\n+    SEND_NO_AAD = 4\n+    SEND_NON_EMPTY_VERSION_PACKET = 5\n+\n+\n+class TestEncryptedP2PState(EncryptedP2PState):\n+    \"\"\" Modify v2 P2P protocol functions for testing scenarios listed in `TestType`\"\"\"\n+    def __init__(self, test_type):\n+        super().__init__(initiating=True, net='regtest')\n+        self.test_type = test_type\n+        if test_type == TestType.EARLY_KEY_RESPONSE:\n+            self.magic_sent = False  # set to True after first 4 bytes of ellswift which match network magic is sent.\n+            self.can_data_be_received = False  # variable used to assert if data is received on recvbuf.\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generate > MAX_GARBAGE_LEN garbage bytes, MAX_GARBAGE_LEN//2 garbage bytes, tampered garbage bytes\n+        when TestType = (EXCESS_GARBAGE, WRONG_GARBAGE_TERMINATOR, WRONG_GARBAGE)\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+\n+        if self.test_type == TestType.EXCESS_GARBAGE:\n+            # send > 4095 bytes garbage\n+            garbage_len = MAX_GARBAGE_LEN + random.randrange(1, 10)\n+        elif self.test_type == TestType.WRONG_GARBAGE_TERMINATOR:\n+            garbage_len = random.randrange(MAX_GARBAGE_LEN//2)\n+        else:\n+            garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+\n+        if self.test_type == TestType.WRONG_GARBAGE:\n+            # assume that garbage bytes sent to TestNode were tampered with\n+            return self.ellswift_ours + random_bitflip(self.sent_garbage)\n+        else:\n+            return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Send ellswift and garbage bytes in 2 parts when TestType = (EARLY_KEY_RESPONSE)\"\"\"\n+        if self.test_type == TestType.EARLY_KEY_RESPONSE:\n+            # Here, the 64 bytes ellswift is assumed to have it's first 4 bytes match network magic bytes.\n+            # It is sent in 2 phases:\n+            # 1. when `magic_sent` = False, send first 4 bytes of ellswift (matches network magic bytes)\n+            # 2. when `magic_sent` = True, send remaining 60 bytes of ellswift\n+            if not self.magic_sent:\n+                self.generate_keypair_and_garbage()\n+                self.magic_sent = True\n+                return b\"\\xfa\\xbf\\xb5\\xda\"\n+            else:\n+                # `can_data_be_received` is a variable used to assert if data is received on recvbuf.\n+                # 1. v2 TestNode shouldn't respond back if we send V1_PREFIX and data shouldn't be received on recvbuf.\n+                # This state is represented using `can_data_be_received` = False.\n+                # 2. v2 TestNode responds back when mismatch from V1_PREFIX happens and data can be received on recvbuf.\n+                # This state is represented using `can_data_be_received` = True.\n+                self.can_data_be_received = True\n+                return self.ellswift_ours[4:] + self.sent_garbage\n+        else:\n+            return super().initiate_v2_handshake()\n+\n+    def complete_handshake(self, response):\n+        \"\"\"Add option for sending wrong garbage terminator, not filling first encrypted packet after garbage terminator\n+        with AAD, sending non-empty transport version packet.\n+        when TestType = (WRONG_GARBAGE_TERMINATOR, SEND_NO_AAD, SEND_NON_EMPTY_VERSION_PACKET)\"\"\"\n+        ellswift_theirs = self.received_prefix + response.read(64 - len(self.received_prefix))\n+        # return b\"\" if we need to receive more bytes\n+        if len(ellswift_theirs) != 64:\n+            return 0, b\"\"\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        aad = self.sent_garbage\n+\n+        if self.test_type == TestType.WRONG_GARBAGE_TERMINATOR:\n+            msg_to_send = random_bitflip(msg_to_send)\n+        elif self.test_type == TestType.SEND_NO_AAD:\n+            aad = b''\n+\n+        # Optionally send decoy packets after garbage terminator.\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(random.randint(0, 10))]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+\n+        # Send version packet.\n+        if self.test_type == TestType.SEND_NON_EMPTY_VERSION_PACKET:\n+            msg_to_send += self.v2_enc_packet(random.randbytes(5), aad=aad)\n+        else:\n+            msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+\n+        return 64 - len(self.received_prefix), msg_to_send\n+\n+\n+class MisbehavingV2Peer(P2PInterface):\n+    \"\"\"Custom implementation of P2PInterface which uses modified v2 P2P protocol functions for testing purposes.\"\"\"\n+    def __init__(self, test_type):\n+        super().__init__()\n+        self.v2_state = None\n+        self.connection_opened = False\n+        self.test_type = test_type\n+\n+    def connection_made(self, transport):\n+        \"\"\"Only first 4 ellswift bytes which match network magic bytes is sent using `initial_v2_handshake()` in\n+        `connection_made()` when TestType = (EARLY_KEY_RESPONSE)\"\"\"\n+        self.v2_state = TestEncryptedP2PState(self.test_type)\n+        super().connection_made(transport)\n+\n+    def data_received(self, t):\n+        if self.test_type == TestType.EARLY_KEY_RESPONSE:\n+            # check that data can be received on recvbuf only when mismatch from V1_PREFIX happens (magic_sent = True)\n+            assert self.v2_state.can_data_be_received and self.v2_state.magic_sent\n+        else:\n+            super().data_received(t)\n+\n+    def on_open(self):\n+        self.connection_opened = True\n+\n+\n+class EncryptedP2PMisbehaving(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[\"-v2transport=1\", \"-peertimeout=3\"]]\n+\n+    def run_test(self):\n+        self.test_earlykeyresponse()\n+        self.test_v2disconnection()\n+\n+    def test_earlykeyresponse(self):\n+        self.log.info('Sending ellswift bytes in parts to ensure that response from responder is received only when')\n+        self.log.info('ellswift bytes have a mismatch from the 16 bytes(network magic followed by \"version\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\")')\n+        node0 = self.nodes[0]\n+        self.log.info('Sending first 4 bytes of ellswift which match network magic')\n+        self.log.info('If a response is received, assertion failure would happen in our custom data_received() function')\n+        # send happens in `initiate_v2_handshake()` in `connection_made()`\n+        peer1 = node0.add_p2p_connection(MisbehavingV2Peer(TestType.EARLY_KEY_RESPONSE), wait_for_verack=False, send_version=False, supports_v2_p2p=True)\n+        self.wait_until(lambda: peer1.connection_opened)\n+        self.log.info('Sending remaining ellswift and garbage which are different from V1_PREFIX. Since a response is')\n+        self.log.info('expected now, our custom data_received() function wouldn\\'t result in assertion failure')\n+        ellswift_and_garbage_data = peer1.v2_state.initiate_v2_handshake()\n+        peer1.send_raw_message(ellswift_and_garbage_data)\n+        with self.nodes[0].assert_debug_log(['version handshake timeout peer=0']):\n+            peer1.wait_for_disconnect(timeout=5)\n+        self.log.info('successful disconnection since modified ellswift was sent as response')\n+\n+    def test_v2disconnection(self):\n+        # test v2 disconnection scenarios\n+        node0 = self.nodes[0]\n+        expected_debug_message = [\n+            [],  # EARLY_KEY_RESPONSE\n+            [\"V2 transport error: missing garbage terminator, peer=1\"],  # EXCESS_GARBAGE\n+            [\"version handshake timeout peer=2\"],  # WRONG_GARBAGE_TERMINATOR\n+            [\"V2 transport error: packet decryption failure\"],  # WRONG_GARBAGE\n+            [\"V2 transport error: packet decryption failure\"],  # SEND_NO_AAD\n+            [],  # SEND_NON_EMPTY_VERSION_PACKET\n+        ]\n+        for test_type in TestType:\n+            if test_type == TestType.EARLY_KEY_RESPONSE:\n+                continue",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29431#discussion_r1494116658",
      "id" : 1494116658,
      "in_reply_to_id" : 1491848110,
      "line" : 190,
      "node_id" : "PRRC_kwDOABII585ZDmky",
      "original_commit_id" : "ec9005ca4be088dfa2d247bbfe964a9c98e4f29d",
      "original_line" : 190,
      "original_position" : 190,
      "original_start_line" : null,
      "path" : "test/functional/p2p_v2_misbehaving.py",
      "position" : 190,
      "pull_request_review_id" : 1887729403,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29431",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1494116658/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-02-19T07:51:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1494116658",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29431#discussion_r1494131410"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29431"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1494131410"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "yeah! `expected_debug_message` on [L180](https://github.com/bitcoin/bitcoin/blob/ec9005ca4be088dfa2d247bbfe964a9c98e4f29d/test/functional/p2p_v2_misbehaving.py#L180) was written with the assumption that `test_v2disconnection` is run after `test_earlykeyresponse`. so peer=0 happens in `test_earlykeyresponse` and peer=1,2,3,4,5 happens in  `test_v2disconnection`.",
      "commit_id" : "ec9005ca4be088dfa2d247bbfe964a9c98e4f29d",
      "created_at" : "2024-02-19T07:50:51Z",
      "diff_hunk" : "@@ -0,0 +1,201 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import random\n+from enum import Enum\n+\n+from test_framework.crypto.ellswift import ellswift_create\n+from test_framework.p2p import P2PInterface\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import random_bitflip\n+from test_framework.v2_p2p import (\n+    logger,\n+    EncryptedP2PState,\n+    MAX_GARBAGE_LEN,\n+    TRANSPORT_VERSION,\n+)\n+\n+\n+class TestType(Enum):\n+    \"\"\" Scenarios to be tested:\n+\n+    1. EARLY_KEY_RESPONSE - The responder needs to wait until one byte is received which does not match the 16 bytes\n+    consisting of network magic followed by \"version\\x00\\x00\\x00\\x00\\x00\" before sending out it's ellswift + garbage bytes\n+    2. EXCESS_GARBAGE - Disconnection happens when > MAX_GARBAGE_LEN bytes garbage is sent\n+    3. WRONG_GARBAGE_TERMINATOR - Disconnection happens when incorrect garbage terminator is sent\n+    4. WRONG_GARBAGE - Disconnection happens when garbage bytes that is sent is different from what the peer receives\n+    5. SEND_NO_AAD - Disconnection happens when AAD of first encrypted packet after the garbage terminator is not filled\n+    6. SEND_NON_EMPTY_VERSION_PACKET - non-empty version packet is simply ignored\n+    \"\"\"\n+    EARLY_KEY_RESPONSE = 0\n+    EXCESS_GARBAGE = 1\n+    WRONG_GARBAGE_TERMINATOR = 2\n+    WRONG_GARBAGE = 3\n+    SEND_NO_AAD = 4\n+    SEND_NON_EMPTY_VERSION_PACKET = 5\n+\n+\n+class TestEncryptedP2PState(EncryptedP2PState):\n+    \"\"\" Modify v2 P2P protocol functions for testing scenarios listed in `TestType`\"\"\"\n+    def __init__(self, test_type):\n+        super().__init__(initiating=True, net='regtest')\n+        self.test_type = test_type\n+        if test_type == TestType.EARLY_KEY_RESPONSE:\n+            self.magic_sent = False  # set to True after first 4 bytes of ellswift which match network magic is sent.\n+            self.can_data_be_received = False  # variable used to assert if data is received on recvbuf.\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generate > MAX_GARBAGE_LEN garbage bytes, MAX_GARBAGE_LEN//2 garbage bytes, tampered garbage bytes\n+        when TestType = (EXCESS_GARBAGE, WRONG_GARBAGE_TERMINATOR, WRONG_GARBAGE)\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+\n+        if self.test_type == TestType.EXCESS_GARBAGE:\n+            # send > 4095 bytes garbage\n+            garbage_len = MAX_GARBAGE_LEN + random.randrange(1, 10)\n+        elif self.test_type == TestType.WRONG_GARBAGE_TERMINATOR:\n+            garbage_len = random.randrange(MAX_GARBAGE_LEN//2)\n+        else:\n+            garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+\n+        if self.test_type == TestType.WRONG_GARBAGE:\n+            # assume that garbage bytes sent to TestNode were tampered with\n+            return self.ellswift_ours + random_bitflip(self.sent_garbage)\n+        else:\n+            return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Send ellswift and garbage bytes in 2 parts when TestType = (EARLY_KEY_RESPONSE)\"\"\"\n+        if self.test_type == TestType.EARLY_KEY_RESPONSE:\n+            # Here, the 64 bytes ellswift is assumed to have it's first 4 bytes match network magic bytes.\n+            # It is sent in 2 phases:\n+            # 1. when `magic_sent` = False, send first 4 bytes of ellswift (matches network magic bytes)\n+            # 2. when `magic_sent` = True, send remaining 60 bytes of ellswift\n+            if not self.magic_sent:\n+                self.generate_keypair_and_garbage()\n+                self.magic_sent = True\n+                return b\"\\xfa\\xbf\\xb5\\xda\"\n+            else:\n+                # `can_data_be_received` is a variable used to assert if data is received on recvbuf.\n+                # 1. v2 TestNode shouldn't respond back if we send V1_PREFIX and data shouldn't be received on recvbuf.\n+                # This state is represented using `can_data_be_received` = False.\n+                # 2. v2 TestNode responds back when mismatch from V1_PREFIX happens and data can be received on recvbuf.\n+                # This state is represented using `can_data_be_received` = True.\n+                self.can_data_be_received = True\n+                return self.ellswift_ours[4:] + self.sent_garbage\n+        else:\n+            return super().initiate_v2_handshake()\n+\n+    def complete_handshake(self, response):\n+        \"\"\"Add option for sending wrong garbage terminator, not filling first encrypted packet after garbage terminator\n+        with AAD, sending non-empty transport version packet.\n+        when TestType = (WRONG_GARBAGE_TERMINATOR, SEND_NO_AAD, SEND_NON_EMPTY_VERSION_PACKET)\"\"\"\n+        ellswift_theirs = self.received_prefix + response.read(64 - len(self.received_prefix))\n+        # return b\"\" if we need to receive more bytes\n+        if len(ellswift_theirs) != 64:\n+            return 0, b\"\"\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        aad = self.sent_garbage\n+\n+        if self.test_type == TestType.WRONG_GARBAGE_TERMINATOR:\n+            msg_to_send = random_bitflip(msg_to_send)\n+        elif self.test_type == TestType.SEND_NO_AAD:\n+            aad = b''\n+\n+        # Optionally send decoy packets after garbage terminator.\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(random.randint(0, 10))]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+\n+        # Send version packet.\n+        if self.test_type == TestType.SEND_NON_EMPTY_VERSION_PACKET:\n+            msg_to_send += self.v2_enc_packet(random.randbytes(5), aad=aad)\n+        else:\n+            msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+\n+        return 64 - len(self.received_prefix), msg_to_send\n+\n+\n+class MisbehavingV2Peer(P2PInterface):\n+    \"\"\"Custom implementation of P2PInterface which uses modified v2 P2P protocol functions for testing purposes.\"\"\"\n+    def __init__(self, test_type):\n+        super().__init__()\n+        self.v2_state = None\n+        self.connection_opened = False\n+        self.test_type = test_type\n+\n+    def connection_made(self, transport):\n+        \"\"\"Only first 4 ellswift bytes which match network magic bytes is sent using `initial_v2_handshake()` in\n+        `connection_made()` when TestType = (EARLY_KEY_RESPONSE)\"\"\"\n+        self.v2_state = TestEncryptedP2PState(self.test_type)\n+        super().connection_made(transport)\n+\n+    def data_received(self, t):\n+        if self.test_type == TestType.EARLY_KEY_RESPONSE:\n+            # check that data can be received on recvbuf only when mismatch from V1_PREFIX happens (magic_sent = True)\n+            assert self.v2_state.can_data_be_received and self.v2_state.magic_sent\n+        else:\n+            super().data_received(t)\n+\n+    def on_open(self):\n+        self.connection_opened = True\n+\n+\n+class EncryptedP2PMisbehaving(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[\"-v2transport=1\", \"-peertimeout=3\"]]\n+\n+    def run_test(self):\n+        self.test_earlykeyresponse()\n+        self.test_v2disconnection()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29431#discussion_r1494131410",
      "id" : 1494131410,
      "in_reply_to_id" : 1491897558,
      "line" : 158,
      "node_id" : "PRRC_kwDOABII585ZDqLS",
      "original_commit_id" : "ec9005ca4be088dfa2d247bbfe964a9c98e4f29d",
      "original_line" : 158,
      "original_position" : 158,
      "original_start_line" : 157,
      "path" : "test/functional/p2p_v2_misbehaving.py",
      "position" : 158,
      "pull_request_review_id" : 1887729403,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29431",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1494131410/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 157,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2024-02-19T07:51:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1494131410",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29431#discussion_r1506721918"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29431"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1506721918"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "It seems not ideal to me that this is done before the line `self.p2ps.append(p2p_conn)`.\r\nI think it could lead to errors in which we expect to get disconnected but actually didn't: If we just haven't established the connected yet (i.e. the `connection_made` callback hasn't been called yet), we could abort here, and only afterwards establish the connection that would then not be part of `self.p2ps`.\r\n\r\nA better approach in general might be to have an `expect_success` parameter instead that just skips the waits below and returns, and let the individual test deal with the waiting for disconnection waiting (depending on the test it could ask the TestNode, the test framework, both to wait, or do something else like checking logs for specific disconnect reasons, which the tests you add later already do). ",
      "commit_id" : "67708b64dba454fc625607470d0cbf4341ebb85a",
      "created_at" : "2024-02-28T22:06:19Z",
      "diff_hunk" : "@@ -694,6 +694,9 @@ def add_p2p_connection(self, p2p_conn, *, wait_for_verack=True, send_version=Tru\n         supports_v2_p2p = self.use_v2transport and supports_v2_p2p\n         p2p_conn.peer_connect(**kwargs, send_version=send_version, net=self.chain, timeout_factor=self.timeout_factor, supports_v2_p2p=supports_v2_p2p)()\n \n+        if wait_for_disconnect:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29431#discussion_r1506721918",
      "id" : 1506721918,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585ZzsB-",
      "original_commit_id" : "32f9afb00ad26da3570cc89e5ac8904de0e26fa0",
      "original_line" : 697,
      "original_position" : 13,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/test_node.py",
      "position" : null,
      "pull_request_review_id" : 1907520121,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29431",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 1,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1506721918/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-03-07T22:24:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1506721918",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> * we can't get rid of `can_data_be_received` variable because if we don't use this variable, test would succeed irrespective of whether we send 4 bytes network magic first or 4 bytes from ellswift bytes first and we don't want that.\r\n\r\nI've been playing around sending anything different than the first 4 bytes as the network magic and test fail on my end (which is expected given `data_received` is called with `magic_sent` false on the first-byte mismatch).\r\n\r\nDo you have any working example I can try to reproduce?",
      "created_at" : "2024-02-29T16:28:44Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29431#issuecomment-1971505987",
      "id" : 1971505987,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/29431",
      "node_id" : "IC_kwDOABII5851gstD",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1971505987/reactions"
      },
      "updated_at" : "2024-02-29T16:29:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1971505987",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6665628?v=4",
         "events_url" : "https://api.github.com/users/sr-gi/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sr-gi/followers",
         "following_url" : "https://api.github.com/users/sr-gi/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sr-gi/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sr-gi",
         "id" : 6665628,
         "login" : "sr-gi",
         "node_id" : "MDQ6VXNlcjY2NjU2Mjg=",
         "organizations_url" : "https://api.github.com/users/sr-gi/orgs",
         "received_events_url" : "https://api.github.com/users/sr-gi/received_events",
         "repos_url" : "https://api.github.com/users/sr-gi/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sr-gi/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sr-gi/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sr-gi"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> I've been playing around sending anything different than the first 4 bytes as the network magic and test fail on my end (which is expected given data_received is called with magic_sent false on the first-byte mismatch).\r\n\r\nyes! that's expected behaviour and sending anything other than the first 4 bytes as network magic will make the test fail on master.\r\n\r\nwhat i was trying to say was:\r\n1. on master\r\n- replacing `return b\"\\xfa\\xbf\\xb5\\xda\"` with any other 4 bytes will make the test fail and this is expected behaviour\r\n3. using [this patch](https://github.com/bitcoin/bitcoin/pull/29352#pullrequestreview-1854149947) mentioned in #29352\r\n- replacing `return b\"\\xfa\\xbf\\xb5\\xda\"` with any other 4 bytes will make the test pass and this isn't behaviour we want\r\n- this happens because [`can_data_be_received` variable](https://github.com/bitcoin/bitcoin/blob/ab5dfdbec1143f673f4d83acd4e335bb2c51034e/test/functional/p2p_v2_earlykeyresponse.py#L29) is removed in the patch\r\n\r\nso i was just trying to say that we can't remove [`can_data_be_received` variable](https://github.com/bitcoin/bitcoin/blob/ab5dfdbec1143f673f4d83acd4e335bb2c51034e/test/functional/p2p_v2_earlykeyresponse.py#L29).",
      "created_at" : "2024-03-07T08:15:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29431#issuecomment-1982878975",
      "id" : 1982878975,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/29431",
      "node_id" : "IC_kwDOABII5852MFT_",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1982878975/reactions"
      },
      "updated_at" : "2024-03-07T08:15:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1982878975",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29431#discussion_r1516792089"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29431"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1516792089"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: its",
      "commit_id" : "67708b64dba454fc625607470d0cbf4341ebb85a",
      "created_at" : "2024-03-07T20:39:28Z",
      "diff_hunk" : "@@ -3,87 +3,107 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-import random\n+from enum import Enum\n \n-from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.crypto.ellswift import ellswift_create\n from test_framework.p2p import P2PInterface\n+from test_framework.test_framework import BitcoinTestFramework\n from test_framework.v2_p2p import EncryptedP2PState\n \n \n-class TestEncryptedP2PState(EncryptedP2PState):\n-    \"\"\" Modify v2 P2P protocol functions for testing that \"The responder waits until one byte is received which does\n-    not match the 16 bytes consisting of the network magic followed by \"version\\x00\\x00\\x00\\x00\\x00\".\" (see BIP 324)\n-\n-    - if `send_net_magic` is True, send first 4 bytes of ellswift (match network magic) else send remaining 60 bytes\n-    - `can_data_be_received` is a variable used to assert if data is received on recvbuf.\n-            - v2 TestNode shouldn't respond back if we send V1_PREFIX and data shouldn't be received on recvbuf.\n-              This state is represented using `can_data_be_received` = False.\n-            - v2 TestNode responds back when mismatch from V1_PREFIX happens and data can be received on recvbuf.\n-              This state is represented using `can_data_be_received` = True.\n+class TestType(Enum):\n+    \"\"\" Scenarios to be tested:\n+\n+    1. EARLY_KEY_RESPONSE - The responder needs to wait until one byte is received which does not match the 16 bytes\n+    consisting of network magic followed by \"version\\x00\\x00\\x00\\x00\\x00\" before sending out it's ellswift + garbage bytes",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29431#discussion_r1516792089",
      "id" : 1516792089,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585aaGkZ",
      "original_commit_id" : "af6bd3f664aeb42094a50d31f4f5349c149000b4",
      "original_line" : 17,
      "original_position" : 28,
      "original_start_line" : null,
      "path" : "test/functional/p2p_v2_misbehaving.py",
      "position" : null,
      "pull_request_review_id" : 1907520121,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29431",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1516792089/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-03-07T22:24:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1516792089",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29431#discussion_r1516838229"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29431"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1516838229"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: can use `node0`",
      "commit_id" : "67708b64dba454fc625607470d0cbf4341ebb85a",
      "created_at" : "2024-03-07T21:12:00Z",
      "diff_hunk" : "@@ -3,87 +3,107 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-import random\n+from enum import Enum\n \n-from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.crypto.ellswift import ellswift_create\n from test_framework.p2p import P2PInterface\n+from test_framework.test_framework import BitcoinTestFramework\n from test_framework.v2_p2p import EncryptedP2PState\n \n \n-class TestEncryptedP2PState(EncryptedP2PState):\n-    \"\"\" Modify v2 P2P protocol functions for testing that \"The responder waits until one byte is received which does\n-    not match the 16 bytes consisting of the network magic followed by \"version\\x00\\x00\\x00\\x00\\x00\".\" (see BIP 324)\n-\n-    - if `send_net_magic` is True, send first 4 bytes of ellswift (match network magic) else send remaining 60 bytes\n-    - `can_data_be_received` is a variable used to assert if data is received on recvbuf.\n-            - v2 TestNode shouldn't respond back if we send V1_PREFIX and data shouldn't be received on recvbuf.\n-              This state is represented using `can_data_be_received` = False.\n-            - v2 TestNode responds back when mismatch from V1_PREFIX happens and data can be received on recvbuf.\n-              This state is represented using `can_data_be_received` = True.\n+class TestType(Enum):\n+    \"\"\" Scenarios to be tested:\n+\n+    1. EARLY_KEY_RESPONSE - The responder needs to wait until one byte is received which does not match the 16 bytes\n+    consisting of network magic followed by \"version\\x00\\x00\\x00\\x00\\x00\" before sending out it's ellswift + garbage bytes\n     \"\"\"\n+    EARLY_KEY_RESPONSE = 0\n+\n \n-    def __init__(self):\n+class TestEncryptedP2PState(EncryptedP2PState):\n+    \"\"\" Modify v2 P2P protocol functions for testing scenarios listed in `TestType`\"\"\"\n+    def __init__(self, test_type):\n         super().__init__(initiating=True, net='regtest')\n-        self.send_net_magic = True\n-        self.can_data_be_received = False\n-\n-    def initiate_v2_handshake(self, garbage_len=random.randrange(4096)):\n-        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage.\n-        Here, the 64 bytes ellswift is assumed to have it's 4 bytes match network magic bytes. It is sent in 2 phases:\n-            1. when `send_network_magic` = True, send first 4 bytes of ellswift (matches network magic bytes)\n-            2. when `send_network_magic` = False, send remaining 60 bytes of ellswift\n-        \"\"\"\n-        if self.send_net_magic:\n-            self.privkey_ours, self.ellswift_ours = ellswift_create()\n-            self.sent_garbage = random.randbytes(garbage_len)\n-            self.send_net_magic = False\n-            return b\"\\xfa\\xbf\\xb5\\xda\"\n+        self.test_type = test_type\n+        if test_type == TestType.EARLY_KEY_RESPONSE:\n+            self.magic_sent = False  # set to True after first 4 bytes of ellswift which match network magic is sent.\n+            self.can_data_be_received = False  # variable used to assert if data is received on recvbuf.\n+\n+    def generate_keypair_and_garbage(self):\n+        return super().generate_keypair_and_garbage()\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Send ellswift and garbage bytes in 2 parts when TestType = (EARLY_KEY_RESPONSE)\"\"\"\n+        if self.test_type == TestType.EARLY_KEY_RESPONSE:\n+            # Here, the 64 bytes ellswift is assumed to have it's first 4 bytes match network magic bytes.\n+            # It is sent in 2 phases:\n+            # 1. when `magic_sent` = False, send first 4 bytes of ellswift (matches network magic bytes)\n+            # 2. when `magic_sent` = True, send remaining 60 bytes of ellswift\n+            if not self.magic_sent:\n+                self.generate_keypair_and_garbage()\n+                self.magic_sent = True\n+                return b\"\\xfa\\xbf\\xb5\\xda\"\n+            else:\n+                # `can_data_be_received` is a variable used to assert if data is received on recvbuf.\n+                # 1. v2 TestNode shouldn't respond back if we send V1_PREFIX and data shouldn't be received on recvbuf.\n+                # This state is represented using `can_data_be_received` = False.\n+                # 2. v2 TestNode responds back when mismatch from V1_PREFIX happens and data can be received on recvbuf.\n+                # This state is represented using `can_data_be_received` = True.\n+                self.can_data_be_received = True\n+                return self.ellswift_ours[4:] + self.sent_garbage\n         else:\n-            self.can_data_be_received = True\n-            return self.ellswift_ours[4:] + self.sent_garbage\n+            return super().initiate_v2_handshake()\n \n \n-class PeerEarlyKey(P2PInterface):\n+class MisbehavingV2Peer(P2PInterface):\n     \"\"\"Custom implementation of P2PInterface which uses modified v2 P2P protocol functions for testing purposes.\"\"\"\n-    def __init__(self):\n+    def __init__(self, test_type):\n         super().__init__()\n         self.v2_state = None\n         self.connection_opened = False\n+        self.test_type = test_type\n \n     def connection_made(self, transport):\n-        \"\"\"64 bytes ellswift is sent in 2 parts during `initial_v2_handshake()`\"\"\"\n-        self.v2_state = TestEncryptedP2PState()\n+        \"\"\"Only first 4 ellswift bytes which match network magic bytes is sent using `initial_v2_handshake()` in\n+        `connection_made()` when TestType = (EARLY_KEY_RESPONSE)\"\"\"\n+        self.v2_state = TestEncryptedP2PState(self.test_type)\n         super().connection_made(transport)\n \n     def data_received(self, t):\n-        # check that data can be received on recvbuf only when mismatch from V1_PREFIX happens (send_net_magic = False)\n-        assert self.v2_state.can_data_be_received and not self.v2_state.send_net_magic\n+        if self.test_type == TestType.EARLY_KEY_RESPONSE:\n+            # check that data can be received on recvbuf only when mismatch from V1_PREFIX happens (magic_sent = True)\n+            assert self.v2_state.can_data_be_received and self.v2_state.magic_sent\n+        else:\n+            super().data_received(t)\n \n     def on_open(self):\n         self.connection_opened = True\n \n-class P2PEarlyKey(BitcoinTestFramework):\n+\n+class EncryptedP2PMisbehaving(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 1\n         self.extra_args = [[\"-v2transport=1\", \"-peertimeout=3\"]]\n \n     def run_test(self):\n+        self.test_earlykeyresponse()\n+\n+    def test_earlykeyresponse(self):\n         self.log.info('Sending ellswift bytes in parts to ensure that response from responder is received only when')\n         self.log.info('ellswift bytes have a mismatch from the 16 bytes(network magic followed by \"version\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\")')\n         node0 = self.nodes[0]\n         self.log.info('Sending first 4 bytes of ellswift which match network magic')\n         self.log.info('If a response is received, assertion failure would happen in our custom data_received() function')\n         # send happens in `initiate_v2_handshake()` in `connection_made()`\n-        peer1 = node0.add_p2p_connection(PeerEarlyKey(), wait_for_verack=False, send_version=False, supports_v2_p2p=True, wait_for_v2_handshake=False)\n+        peer1 = node0.add_p2p_connection(MisbehavingV2Peer(TestType.EARLY_KEY_RESPONSE), wait_for_verack=False, send_version=False, supports_v2_p2p=True, wait_for_v2_handshake=False)\n         self.wait_until(lambda: peer1.connection_opened)\n         self.log.info('Sending remaining ellswift and garbage which are different from V1_PREFIX. Since a response is')\n         self.log.info('expected now, our custom data_received() function wouldn\\'t result in assertion failure')\n         ellswift_and_garbage_data = peer1.v2_state.initiate_v2_handshake()\n         peer1.send_raw_message(ellswift_and_garbage_data)\n-        peer1.wait_for_disconnect(timeout=5)\n-        self.log.info('successful disconnection when MITM happens in the key exchange phase')\n+        with self.nodes[0].assert_debug_log(['version handshake timeout peer=0']):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29431#discussion_r1516838229",
      "id" : 1516838229,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585aaR1V",
      "original_commit_id" : "af6bd3f664aeb42094a50d31f4f5349c149000b4",
      "original_line" : 103,
      "original_position" : 141,
      "original_start_line" : null,
      "path" : "test/functional/p2p_v2_misbehaving.py",
      "position" : null,
      "pull_request_review_id" : 1907520121,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29431",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1516838229/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-03-07T22:24:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1516838229",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29431#discussion_r1519263987"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29431"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1519263987"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done.",
      "commit_id" : "67708b64dba454fc625607470d0cbf4341ebb85a",
      "created_at" : "2024-03-11T07:42:50Z",
      "diff_hunk" : "@@ -3,87 +3,107 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-import random\n+from enum import Enum\n \n-from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.crypto.ellswift import ellswift_create\n from test_framework.p2p import P2PInterface\n+from test_framework.test_framework import BitcoinTestFramework\n from test_framework.v2_p2p import EncryptedP2PState\n \n \n-class TestEncryptedP2PState(EncryptedP2PState):\n-    \"\"\" Modify v2 P2P protocol functions for testing that \"The responder waits until one byte is received which does\n-    not match the 16 bytes consisting of the network magic followed by \"version\\x00\\x00\\x00\\x00\\x00\".\" (see BIP 324)\n-\n-    - if `send_net_magic` is True, send first 4 bytes of ellswift (match network magic) else send remaining 60 bytes\n-    - `can_data_be_received` is a variable used to assert if data is received on recvbuf.\n-            - v2 TestNode shouldn't respond back if we send V1_PREFIX and data shouldn't be received on recvbuf.\n-              This state is represented using `can_data_be_received` = False.\n-            - v2 TestNode responds back when mismatch from V1_PREFIX happens and data can be received on recvbuf.\n-              This state is represented using `can_data_be_received` = True.\n+class TestType(Enum):\n+    \"\"\" Scenarios to be tested:\n+\n+    1. EARLY_KEY_RESPONSE - The responder needs to wait until one byte is received which does not match the 16 bytes\n+    consisting of network magic followed by \"version\\x00\\x00\\x00\\x00\\x00\" before sending out it's ellswift + garbage bytes\n     \"\"\"\n+    EARLY_KEY_RESPONSE = 0\n+\n \n-    def __init__(self):\n+class TestEncryptedP2PState(EncryptedP2PState):\n+    \"\"\" Modify v2 P2P protocol functions for testing scenarios listed in `TestType`\"\"\"\n+    def __init__(self, test_type):\n         super().__init__(initiating=True, net='regtest')\n-        self.send_net_magic = True\n-        self.can_data_be_received = False\n-\n-    def initiate_v2_handshake(self, garbage_len=random.randrange(4096)):\n-        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage.\n-        Here, the 64 bytes ellswift is assumed to have it's 4 bytes match network magic bytes. It is sent in 2 phases:\n-            1. when `send_network_magic` = True, send first 4 bytes of ellswift (matches network magic bytes)\n-            2. when `send_network_magic` = False, send remaining 60 bytes of ellswift\n-        \"\"\"\n-        if self.send_net_magic:\n-            self.privkey_ours, self.ellswift_ours = ellswift_create()\n-            self.sent_garbage = random.randbytes(garbage_len)\n-            self.send_net_magic = False\n-            return b\"\\xfa\\xbf\\xb5\\xda\"\n+        self.test_type = test_type\n+        if test_type == TestType.EARLY_KEY_RESPONSE:\n+            self.magic_sent = False  # set to True after first 4 bytes of ellswift which match network magic is sent.\n+            self.can_data_be_received = False  # variable used to assert if data is received on recvbuf.\n+\n+    def generate_keypair_and_garbage(self):\n+        return super().generate_keypair_and_garbage()\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Send ellswift and garbage bytes in 2 parts when TestType = (EARLY_KEY_RESPONSE)\"\"\"\n+        if self.test_type == TestType.EARLY_KEY_RESPONSE:\n+            # Here, the 64 bytes ellswift is assumed to have it's first 4 bytes match network magic bytes.\n+            # It is sent in 2 phases:\n+            # 1. when `magic_sent` = False, send first 4 bytes of ellswift (matches network magic bytes)\n+            # 2. when `magic_sent` = True, send remaining 60 bytes of ellswift\n+            if not self.magic_sent:\n+                self.generate_keypair_and_garbage()\n+                self.magic_sent = True\n+                return b\"\\xfa\\xbf\\xb5\\xda\"\n+            else:\n+                # `can_data_be_received` is a variable used to assert if data is received on recvbuf.\n+                # 1. v2 TestNode shouldn't respond back if we send V1_PREFIX and data shouldn't be received on recvbuf.\n+                # This state is represented using `can_data_be_received` = False.\n+                # 2. v2 TestNode responds back when mismatch from V1_PREFIX happens and data can be received on recvbuf.\n+                # This state is represented using `can_data_be_received` = True.\n+                self.can_data_be_received = True\n+                return self.ellswift_ours[4:] + self.sent_garbage\n         else:\n-            self.can_data_be_received = True\n-            return self.ellswift_ours[4:] + self.sent_garbage\n+            return super().initiate_v2_handshake()\n \n \n-class PeerEarlyKey(P2PInterface):\n+class MisbehavingV2Peer(P2PInterface):\n     \"\"\"Custom implementation of P2PInterface which uses modified v2 P2P protocol functions for testing purposes.\"\"\"\n-    def __init__(self):\n+    def __init__(self, test_type):\n         super().__init__()\n         self.v2_state = None\n         self.connection_opened = False\n+        self.test_type = test_type\n \n     def connection_made(self, transport):\n-        \"\"\"64 bytes ellswift is sent in 2 parts during `initial_v2_handshake()`\"\"\"\n-        self.v2_state = TestEncryptedP2PState()\n+        \"\"\"Only first 4 ellswift bytes which match network magic bytes is sent using `initial_v2_handshake()` in\n+        `connection_made()` when TestType = (EARLY_KEY_RESPONSE)\"\"\"\n+        self.v2_state = TestEncryptedP2PState(self.test_type)\n         super().connection_made(transport)\n \n     def data_received(self, t):\n-        # check that data can be received on recvbuf only when mismatch from V1_PREFIX happens (send_net_magic = False)\n-        assert self.v2_state.can_data_be_received and not self.v2_state.send_net_magic\n+        if self.test_type == TestType.EARLY_KEY_RESPONSE:\n+            # check that data can be received on recvbuf only when mismatch from V1_PREFIX happens (magic_sent = True)\n+            assert self.v2_state.can_data_be_received and self.v2_state.magic_sent\n+        else:\n+            super().data_received(t)\n \n     def on_open(self):\n         self.connection_opened = True\n \n-class P2PEarlyKey(BitcoinTestFramework):\n+\n+class EncryptedP2PMisbehaving(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 1\n         self.extra_args = [[\"-v2transport=1\", \"-peertimeout=3\"]]\n \n     def run_test(self):\n+        self.test_earlykeyresponse()\n+\n+    def test_earlykeyresponse(self):\n         self.log.info('Sending ellswift bytes in parts to ensure that response from responder is received only when')\n         self.log.info('ellswift bytes have a mismatch from the 16 bytes(network magic followed by \"version\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\")')\n         node0 = self.nodes[0]\n         self.log.info('Sending first 4 bytes of ellswift which match network magic')\n         self.log.info('If a response is received, assertion failure would happen in our custom data_received() function')\n         # send happens in `initiate_v2_handshake()` in `connection_made()`\n-        peer1 = node0.add_p2p_connection(PeerEarlyKey(), wait_for_verack=False, send_version=False, supports_v2_p2p=True, wait_for_v2_handshake=False)\n+        peer1 = node0.add_p2p_connection(MisbehavingV2Peer(TestType.EARLY_KEY_RESPONSE), wait_for_verack=False, send_version=False, supports_v2_p2p=True, wait_for_v2_handshake=False)\n         self.wait_until(lambda: peer1.connection_opened)\n         self.log.info('Sending remaining ellswift and garbage which are different from V1_PREFIX. Since a response is')\n         self.log.info('expected now, our custom data_received() function wouldn\\'t result in assertion failure')\n         ellswift_and_garbage_data = peer1.v2_state.initiate_v2_handshake()\n         peer1.send_raw_message(ellswift_and_garbage_data)\n-        peer1.wait_for_disconnect(timeout=5)\n-        self.log.info('successful disconnection when MITM happens in the key exchange phase')\n+        with self.nodes[0].assert_debug_log(['version handshake timeout peer=0']):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29431#discussion_r1519263987",
      "id" : 1519263987,
      "in_reply_to_id" : 1516838229,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585ajiDz",
      "original_commit_id" : "af6bd3f664aeb42094a50d31f4f5349c149000b4",
      "original_line" : 103,
      "original_position" : 141,
      "original_start_line" : null,
      "path" : "test/functional/p2p_v2_misbehaving.py",
      "position" : null,
      "pull_request_review_id" : 1927099239,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29431",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1519263987/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-03-11T07:42:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1519263987",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29431#discussion_r1519264157"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29431"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1519264157"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done.",
      "commit_id" : "67708b64dba454fc625607470d0cbf4341ebb85a",
      "created_at" : "2024-03-11T07:43:00Z",
      "diff_hunk" : "@@ -3,87 +3,107 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-import random\n+from enum import Enum\n \n-from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.crypto.ellswift import ellswift_create\n from test_framework.p2p import P2PInterface\n+from test_framework.test_framework import BitcoinTestFramework\n from test_framework.v2_p2p import EncryptedP2PState\n \n \n-class TestEncryptedP2PState(EncryptedP2PState):\n-    \"\"\" Modify v2 P2P protocol functions for testing that \"The responder waits until one byte is received which does\n-    not match the 16 bytes consisting of the network magic followed by \"version\\x00\\x00\\x00\\x00\\x00\".\" (see BIP 324)\n-\n-    - if `send_net_magic` is True, send first 4 bytes of ellswift (match network magic) else send remaining 60 bytes\n-    - `can_data_be_received` is a variable used to assert if data is received on recvbuf.\n-            - v2 TestNode shouldn't respond back if we send V1_PREFIX and data shouldn't be received on recvbuf.\n-              This state is represented using `can_data_be_received` = False.\n-            - v2 TestNode responds back when mismatch from V1_PREFIX happens and data can be received on recvbuf.\n-              This state is represented using `can_data_be_received` = True.\n+class TestType(Enum):\n+    \"\"\" Scenarios to be tested:\n+\n+    1. EARLY_KEY_RESPONSE - The responder needs to wait until one byte is received which does not match the 16 bytes\n+    consisting of network magic followed by \"version\\x00\\x00\\x00\\x00\\x00\" before sending out it's ellswift + garbage bytes",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29431#discussion_r1519264157",
      "id" : 1519264157,
      "in_reply_to_id" : 1516792089,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585ajiGd",
      "original_commit_id" : "af6bd3f664aeb42094a50d31f4f5349c149000b4",
      "original_line" : 17,
      "original_position" : 28,
      "original_start_line" : null,
      "path" : "test/functional/p2p_v2_misbehaving.py",
      "position" : null,
      "pull_request_review_id" : 1927099456,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29431",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1519264157/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-03-11T07:43:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1519264157",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29431#discussion_r1519266541"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29431"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1519266541"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "woah more racy thread logic. good catch! i've implemented the `expect_success` parameter suggestion.",
      "commit_id" : "67708b64dba454fc625607470d0cbf4341ebb85a",
      "created_at" : "2024-03-11T07:45:57Z",
      "diff_hunk" : "@@ -694,6 +694,9 @@ def add_p2p_connection(self, p2p_conn, *, wait_for_verack=True, send_version=Tru\n         supports_v2_p2p = self.use_v2transport and supports_v2_p2p\n         p2p_conn.peer_connect(**kwargs, send_version=send_version, net=self.chain, timeout_factor=self.timeout_factor, supports_v2_p2p=supports_v2_p2p)()\n \n+        if wait_for_disconnect:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29431#discussion_r1519266541",
      "id" : 1519266541,
      "in_reply_to_id" : 1506721918,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585ajirt",
      "original_commit_id" : "32f9afb00ad26da3570cc89e5ac8904de0e26fa0",
      "original_line" : 697,
      "original_position" : 13,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/test_node.py",
      "position" : null,
      "pull_request_review_id" : 1927104835,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29431",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1519266541/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-03-11T07:45:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1519266541",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> The one thing I'm a bit unsure about is that this duplicates quite a lot of code, especially in complete_handshake - the main implementation in v2_p2p.py and the overwritten version from this test could run out of sync in the future. But I don't have a good idea how to avoid this yet...\r\n\r\nhmm good point. will need to think about it more. simplest solution would be keeping it all in main implementation in `v2_p2p.py` haha but doesn't make sense to have it there just for this test file :(",
      "created_at" : "2024-03-11T07:55:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29431#issuecomment-1987813380",
      "id" : 1987813380,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/29431",
      "node_id" : "IC_kwDOABII5852e6AE",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1987813380/reactions"
      },
      "updated_at" : "2024-03-11T07:55:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1987813380",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29431#discussion_r1537611908"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29431"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1537611908"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "in commit ee562933765e64babe067bfcb56a65c8637df82c, magic-number-nit:\r\n```suggestion\r\n                return MAGIC_BYTES[self.net]\r\n```",
      "commit_id" : "b06255688af46bac47f985be747f76acb51b0104",
      "created_at" : "2024-03-25T13:36:24Z",
      "diff_hunk" : "@@ -3,87 +3,107 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-import random\n+from enum import Enum\n \n-from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.crypto.ellswift import ellswift_create\n from test_framework.p2p import P2PInterface\n+from test_framework.test_framework import BitcoinTestFramework\n from test_framework.v2_p2p import EncryptedP2PState\n \n \n-class TestEncryptedP2PState(EncryptedP2PState):\n-    \"\"\" Modify v2 P2P protocol functions for testing that \"The responder waits until one byte is received which does\n-    not match the 16 bytes consisting of the network magic followed by \"version\\x00\\x00\\x00\\x00\\x00\".\" (see BIP 324)\n-\n-    - if `send_net_magic` is True, send first 4 bytes of ellswift (match network magic) else send remaining 60 bytes\n-    - `can_data_be_received` is a variable used to assert if data is received on recvbuf.\n-            - v2 TestNode shouldn't respond back if we send V1_PREFIX and data shouldn't be received on recvbuf.\n-              This state is represented using `can_data_be_received` = False.\n-            - v2 TestNode responds back when mismatch from V1_PREFIX happens and data can be received on recvbuf.\n-              This state is represented using `can_data_be_received` = True.\n+class TestType(Enum):\n+    \"\"\" Scenarios to be tested:\n+\n+    1. EARLY_KEY_RESPONSE - The responder needs to wait until one byte is received which does not match the 16 bytes\n+    consisting of network magic followed by \"version\\x00\\x00\\x00\\x00\\x00\" before sending out its ellswift + garbage bytes\n     \"\"\"\n+    EARLY_KEY_RESPONSE = 0\n+\n \n-    def __init__(self):\n+class TestEncryptedP2PState(EncryptedP2PState):\n+    \"\"\" Modify v2 P2P protocol functions for testing scenarios listed in `TestType`\"\"\"\n+    def __init__(self, test_type):\n         super().__init__(initiating=True, net='regtest')\n-        self.send_net_magic = True\n-        self.can_data_be_received = False\n-\n-    def initiate_v2_handshake(self, garbage_len=random.randrange(4096)):\n-        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage.\n-        Here, the 64 bytes ellswift is assumed to have it's 4 bytes match network magic bytes. It is sent in 2 phases:\n-            1. when `send_network_magic` = True, send first 4 bytes of ellswift (matches network magic bytes)\n-            2. when `send_network_magic` = False, send remaining 60 bytes of ellswift\n-        \"\"\"\n-        if self.send_net_magic:\n-            self.privkey_ours, self.ellswift_ours = ellswift_create()\n-            self.sent_garbage = random.randbytes(garbage_len)\n-            self.send_net_magic = False\n-            return b\"\\xfa\\xbf\\xb5\\xda\"\n+        self.test_type = test_type\n+        if test_type == TestType.EARLY_KEY_RESPONSE:\n+            self.magic_sent = False  # set to True after first 4 bytes of ellswift which match network magic is sent.\n+            self.can_data_be_received = False  # variable used to assert if data is received on recvbuf.\n+\n+    def generate_keypair_and_garbage(self):\n+        return super().generate_keypair_and_garbage()\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Send ellswift and garbage bytes in 2 parts when TestType = (EARLY_KEY_RESPONSE)\"\"\"\n+        if self.test_type == TestType.EARLY_KEY_RESPONSE:\n+            # Here, the 64 bytes ellswift is assumed to have it's first 4 bytes match network magic bytes.\n+            # It is sent in 2 phases:\n+            # 1. when `magic_sent` = False, send first 4 bytes of ellswift (matches network magic bytes)\n+            # 2. when `magic_sent` = True, send remaining 60 bytes of ellswift\n+            if not self.magic_sent:\n+                self.generate_keypair_and_garbage()\n+                self.magic_sent = True\n+                return b\"\\xfa\\xbf\\xb5\\xda\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29431#discussion_r1537611908",
      "id" : 1537611908,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585bphiE",
      "original_commit_id" : "ee562933765e64babe067bfcb56a65c8637df82c",
      "original_line" : 44,
      "original_position" : 70,
      "original_start_line" : null,
      "path" : "test/functional/p2p_v2_misbehaving.py",
      "position" : null,
      "pull_request_review_id" : 1957780790,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29431",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1537611908/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-03-25T14:17:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1537611908",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> > The one thing I'm a bit unsure about is that this duplicates quite a lot of code, especially in complete_handshake - the main implementation in v2_p2p.py and the overwritten version from this test could run out of sync in the future. But I don't have a good idea how to avoid this yet...\r\n> \r\n> hmm good point. will need to think about it more. simplest solution would be keeping it all in main implementation in `v2_p2p.py` haha but doesn't make sense to have it there just for this test file :(\r\n\r\nOne idea to avoid at least reimplementing `generate_keypair_and_garbage` would be to allow setting a fixed garbage length with a new parameter (that is `None` by default, meaning that a random length will be picked), e.g:\r\n```diff\r\ndiff --git a/test/functional/test_framework/v2_p2p.py b/test/functional/test_framework/v2_p2p.py\r\nindex 8f79623bd8..c27cd5e2fe 100644\r\n--- a/test/functional/test_framework/v2_p2p.py\r\n+++ b/test/functional/test_framework/v2_p2p.py\r\n@@ -111,10 +111,11 @@ class EncryptedP2PState:\r\n             # Responding, place their public key encoding first.\r\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\r\n \r\n-    def generate_keypair_and_garbage(self):\r\n+    def generate_keypair_and_garbage(self, garbage_len=None):\r\n         \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\r\n         self.privkey_ours, self.ellswift_ours = ellswift_create()\r\n-        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\r\n+        if garbage_len is None:\r\n+            garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\r\n         self.sent_garbage = random.randbytes(garbage_len)\r\n         logger.debug(f\"sending {garbage_len} bytes of garbage data\")\r\n         return self.ellswift_ours + self.sent_garbage\r\n```\r\nThe overruled method of `initiate_v2_handshake` in the test could then call this with the parameter set if needed, e.g. for the EXCESS_GARBAGE case:\r\n```\r\n     def initiate_v2_handshake(self):\r\n         if self.test_type == TestType.EARLY_KEY_RESPONSE:\r\n             .....\r\n         elif self.test_type == TestType.EXCESS_GARBAGE:\r\n             # send > 4095 bytes garbage\r\n             return self.generate_keypair_and_garbage(garbage_len=MAX_GARBAGE_LEN + random.randrange(1, 10))\r\n```\r\n(For the `WRONG_GARBAGE` test, bit-flipping `self.sent_garbage` right after calling `generate_keypair_and_garbage` should still be sufficient for causing a mismatch.)",
      "created_at" : "2024-03-25T14:14:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29431#issuecomment-2018102733",
      "id" : 2018102733,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/29431",
      "node_id" : "IC_kwDOABII5854Sc3N",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2018102733/reactions"
      },
      "updated_at" : "2024-03-25T14:14:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2018102733",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I find the approach fairly hard to follow here. Having all the logic in the constructor with if/elses based on the connection type instead of having different constructors/a test for each type of failure feels really error-prone and difficult to make sure if a test is doing what we expect. I think it'd be better to have multiple classes that build from `v2_p2p` and modify what's needed, even if the file gets larger.\r\n\r\nJust an example:\r\n\r\nIn the `WRONG_GARBAGE_TERMINATOR` case, we are modifying the gargabe in two ways. First, we are making it smaller than expected, but also, we are randomly flipping some of its bits. Turns out if you removed both changes, the tests still passes, but I'm not sure why. I would expect this not to be the case, since removing the relevant parts should make the class equal to the expected `v2_p2p`.",
      "created_at" : "2024-05-06T17:07:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29431#issuecomment-2096517368",
      "id" : 2096517368,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/29431",
      "node_id" : "IC_kwDOABII58589lD4",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2096517368/reactions"
      },
      "updated_at" : "2024-05-06T17:15:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2096517368",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6665628?v=4",
         "events_url" : "https://api.github.com/users/sr-gi/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sr-gi/followers",
         "following_url" : "https://api.github.com/users/sr-gi/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sr-gi/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sr-gi",
         "id" : 6665628,
         "login" : "sr-gi",
         "node_id" : "MDQ6VXNlcjY2NjU2Mjg=",
         "organizations_url" : "https://api.github.com/users/sr-gi/orgs",
         "received_events_url" : "https://api.github.com/users/sr-gi/received_events",
         "repos_url" : "https://api.github.com/users/sr-gi/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sr-gi/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sr-gi/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sr-gi"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> I think it'd be better to have multiple classes that build from v2_p2p and modify what's needed, even if the file gets larger.\r\n\r\nthat's a great suggestion @sr-gi! it's possible to design those classes in such a way that it avoids code duplication and the file is almost the same size!\r\n\r\n> Turns out if you removed both changes, the tests still passes, but I'm not sure why. \r\n\r\nbecause we don't send a version message to ensure that the disconnection happens in the v2 handshake phase. in your case (different from what we are testing here), we send the correct garbage terminator but because we don't send a version message - disconnection is still expected.",
      "created_at" : "2024-05-17T05:39:35Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29431#issuecomment-2116717090",
      "id" : 2116717090,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/29431",
      "node_id" : "IC_kwDOABII585-Kooi",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2116717090/reactions"
      },
      "updated_at" : "2024-05-17T05:39:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2116717090",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--85328a0da195eb286784d51f73fa0af9-->\n\nð§ At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/25085973641</sub>",
      "created_at" : "2024-05-17T06:45:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29431#issuecomment-2116864386",
      "id" : 2116864386,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/29431",
      "node_id" : "IC_kwDOABII585-LMmC",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2116864386/reactions"
      },
      "updated_at" : "2024-05-17T06:45:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2116864386",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "I've updated the PR to have different child class implementations for `EncryptedP2PState` based on the disconnection scenario we're testing - `EarlyKeyResponseState`, `ExcessGarbageState` etc...\r\n\r\nAlso introduced 2 more commits for cleaner code:\r\n- c642b08c - logging when the garbage is sent instead of when garbage is generated (suggestion from https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1466826427 which is useful now that we have multiple child classes for `EncryptedP2PState`)\r\n- 38eb429 - transport version as a class variable instead of a global variable",
      "created_at" : "2024-05-17T15:18:37Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29431#issuecomment-2117828829",
      "id" : 2117828829,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/29431",
      "node_id" : "IC_kwDOABII585-O4Dd",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2117828829/reactions"
      },
      "updated_at" : "2024-05-17T15:18:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2117828829",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29431#discussion_r1605174508"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29431"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1605174508"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done.",
      "commit_id" : "b06255688af46bac47f985be747f76acb51b0104",
      "created_at" : "2024-05-17T15:18:44Z",
      "diff_hunk" : "@@ -3,87 +3,107 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-import random\n+from enum import Enum\n \n-from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.crypto.ellswift import ellswift_create\n from test_framework.p2p import P2PInterface\n+from test_framework.test_framework import BitcoinTestFramework\n from test_framework.v2_p2p import EncryptedP2PState\n \n \n-class TestEncryptedP2PState(EncryptedP2PState):\n-    \"\"\" Modify v2 P2P protocol functions for testing that \"The responder waits until one byte is received which does\n-    not match the 16 bytes consisting of the network magic followed by \"version\\x00\\x00\\x00\\x00\\x00\".\" (see BIP 324)\n-\n-    - if `send_net_magic` is True, send first 4 bytes of ellswift (match network magic) else send remaining 60 bytes\n-    - `can_data_be_received` is a variable used to assert if data is received on recvbuf.\n-            - v2 TestNode shouldn't respond back if we send V1_PREFIX and data shouldn't be received on recvbuf.\n-              This state is represented using `can_data_be_received` = False.\n-            - v2 TestNode responds back when mismatch from V1_PREFIX happens and data can be received on recvbuf.\n-              This state is represented using `can_data_be_received` = True.\n+class TestType(Enum):\n+    \"\"\" Scenarios to be tested:\n+\n+    1. EARLY_KEY_RESPONSE - The responder needs to wait until one byte is received which does not match the 16 bytes\n+    consisting of network magic followed by \"version\\x00\\x00\\x00\\x00\\x00\" before sending out its ellswift + garbage bytes\n     \"\"\"\n+    EARLY_KEY_RESPONSE = 0\n+\n \n-    def __init__(self):\n+class TestEncryptedP2PState(EncryptedP2PState):\n+    \"\"\" Modify v2 P2P protocol functions for testing scenarios listed in `TestType`\"\"\"\n+    def __init__(self, test_type):\n         super().__init__(initiating=True, net='regtest')\n-        self.send_net_magic = True\n-        self.can_data_be_received = False\n-\n-    def initiate_v2_handshake(self, garbage_len=random.randrange(4096)):\n-        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage.\n-        Here, the 64 bytes ellswift is assumed to have it's 4 bytes match network magic bytes. It is sent in 2 phases:\n-            1. when `send_network_magic` = True, send first 4 bytes of ellswift (matches network magic bytes)\n-            2. when `send_network_magic` = False, send remaining 60 bytes of ellswift\n-        \"\"\"\n-        if self.send_net_magic:\n-            self.privkey_ours, self.ellswift_ours = ellswift_create()\n-            self.sent_garbage = random.randbytes(garbage_len)\n-            self.send_net_magic = False\n-            return b\"\\xfa\\xbf\\xb5\\xda\"\n+        self.test_type = test_type\n+        if test_type == TestType.EARLY_KEY_RESPONSE:\n+            self.magic_sent = False  # set to True after first 4 bytes of ellswift which match network magic is sent.\n+            self.can_data_be_received = False  # variable used to assert if data is received on recvbuf.\n+\n+    def generate_keypair_and_garbage(self):\n+        return super().generate_keypair_and_garbage()\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Send ellswift and garbage bytes in 2 parts when TestType = (EARLY_KEY_RESPONSE)\"\"\"\n+        if self.test_type == TestType.EARLY_KEY_RESPONSE:\n+            # Here, the 64 bytes ellswift is assumed to have it's first 4 bytes match network magic bytes.\n+            # It is sent in 2 phases:\n+            # 1. when `magic_sent` = False, send first 4 bytes of ellswift (matches network magic bytes)\n+            # 2. when `magic_sent` = True, send remaining 60 bytes of ellswift\n+            if not self.magic_sent:\n+                self.generate_keypair_and_garbage()\n+                self.magic_sent = True\n+                return b\"\\xfa\\xbf\\xb5\\xda\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29431#discussion_r1605174508",
      "id" : 1605174508,
      "in_reply_to_id" : 1537611908,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585frQTs",
      "original_commit_id" : "ee562933765e64babe067bfcb56a65c8637df82c",
      "original_line" : 44,
      "original_position" : 70,
      "original_start_line" : null,
      "path" : "test/functional/p2p_v2_misbehaving.py",
      "position" : null,
      "pull_request_review_id" : 2063714050,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29431",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1605174508/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-17T15:18:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1605174508",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   }
]
