[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Making CPFP work better, and making small mempools work better while avoiding DoS risks and complications from updating the P2P protocol is an important thing to work on even if no one immediately benefits from changes right now.\r\n\r\nBut the design space is so huge that it would probably help to propose a concrete change or set of changes if you want feedback, so there is something to start thinking concretely about and respond to. Even very rough or strawman proposals could be good starting points.",
      "created_at" : "2019-04-10T18:37:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/14895#issuecomment-481812073",
      "id" : 481812073,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14895",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ4MTgxMjA3Mw==",
      "updated_at" : "2019-04-10T18:37:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/481812073",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "The final goal seems far out to achieve and I believe suhas has started working on some intermediate milestones that would already come with advantages (such as getting rid of the shared mapRelay, IIRC).",
      "created_at" : "2019-04-10T18:43:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/14895#issuecomment-481814139",
      "id" : 481814139,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14895",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ4MTgxNDEzOQ==",
      "updated_at" : "2019-04-10T18:43:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/481814139",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Think receiver-initiator is probably better, but you could possibly do sender-initiated package relay by saying \"is this tx's feerate > parent's fee rate, and is parent's fee rate < peer's announced minfee cutoff\". Don't see how you could make sender-initiator work without p2p changes though.\r\n\r\nIt sounds like we could get the simplest case (one tx doing CPFP for one or more others, but no grandparents, and immediately getting them all into the top 2 or 3 MB of mempool) without p2p changes, just by noticing you don't have the parents, requesting them, and handling the new tx and any requested parents as a package. Might be a good phase 1.\r\n\r\n(EDIT: had written receiver-initiator where I meant sender-initiator)",
      "created_at" : "2019-05-16T20:57:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/14895#issuecomment-493229524",
      "id" : 493229524,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14895",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ5MzIyOTUyNA==",
      "updated_at" : "2019-06-07T11:07:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/493229524",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "For context, I am responding to this in the spirit of \"PR shepherd\" as discussed the previous day. Given this \"PR\" (Issue) is on the high priority list, I have prioritized taking a look.\r\n\r\nMy read of the status of this Issue is as follows:\r\n- the author has stated a motivation, a set of design questions, and a discussion of how to think about the design.\r\n- commenters have requested a specific design to review and (N)ACK\r\n- it has now been added to the high priority list chasing a Concept ACK\r\n\r\nIf we were to adopt the new language separating Concept ACK and Design ACK (#16149), then it seems this Issue is ready for Concept (N)ACKs, but not Design (N)ACKs. Given the current process which combines Concept and Design, then it seems like this Issue needs the author to propose a concrete design.\r\n\r\n@sdaftuar can you clarify whether you're seeking a Concept ACK in order to proceed to defining a specific design?\r\n\r\n@ryanofsky, @MarcoFalke, @ajtowns assuming we are just seeking Concept (not Design) ACK, do you have the information needed to weigh in?",
      "created_at" : "2019-06-06T12:57:44Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/14895#issuecomment-499482277",
      "id" : 499482277,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14895",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ5OTQ4MjI3Nw==",
      "updated_at" : "2019-06-06T20:25:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/499482277",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/326147?v=4",
         "events_url" : "https://api.github.com/users/moneyball/events{/privacy}",
         "followers_url" : "https://api.github.com/users/moneyball/followers",
         "following_url" : "https://api.github.com/users/moneyball/following{/other_user}",
         "gists_url" : "https://api.github.com/users/moneyball/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/moneyball",
         "id" : 326147,
         "login" : "moneyball",
         "node_id" : "MDQ6VXNlcjMyNjE0Nw==",
         "organizations_url" : "https://api.github.com/users/moneyball/orgs",
         "received_events_url" : "https://api.github.com/users/moneyball/received_events",
         "repos_url" : "https://api.github.com/users/moneyball/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/moneyball/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/moneyball/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/moneyball"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@moneyball Thanks for the nudge and taking a look here.\r\n\r\nI do have a strawman proposal for a p2p protocol change in support of package relay that I wrote up a while ago: https://gist.github.com/sdaftuar/8756699bfcad4d3806ba9f3396d4e66a\r\n\r\nMy intuition right now is that we can make package acceptance much easier to reason about if the recipient of an orphan transaction can ask a peer for the unconfirmed parents of a given transaction, which should be sent back in topological order.\r\n\r\nTo make progress on this project, I'm breaking up this work into several steps:\r\n\r\n1) Refactor the mempool acceptance logic to support a concept of \"package acceptance\", which would be motivated by better orphan handling (for instance, maybe we can take some simple case, like a transaction missing exactly 1 parent, and process the two transactions together as a package).  I expect that refactoring the mempool in this way to be major work and require careful review.\r\n\r\n2) Once that mempool refactor has been done, then I think we could propose a p2p protocol change (such as my above proposal, or some other more efficient or more clever proposal if anyone has a better idea).\r\n\r\nI'd love feedback on whether this path seems reasonable, or also if someone has a better idea of how to achieve the end result.",
      "created_at" : "2019-06-06T15:18:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/14895#issuecomment-499540137",
      "id" : 499540137,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14895",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ5OTU0MDEzNw==",
      "updated_at" : "2019-06-06T15:18:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/499540137",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Concept ACK I think -- splitting mempool acceptance and being able to submit a package as a single unit seems plausible; and doing that before p2p changes also seems plausible. I think we ought to be able to break out smaller useful pieces as we go along though.",
      "created_at" : "2019-06-07T11:08:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/14895#issuecomment-499846099",
      "id" : 499846099,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14895",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ5OTg0NjA5OQ==",
      "updated_at" : "2019-06-07T11:08:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/499846099",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Looking forward to more progress on this one. I'm skeptical that the ATMP refactor is as bad as you think, but it does have cost in terms of additional complexity there. Definitely worth it, though, and I'd appreciate even a first step with only 1 parent as that would have real benefits for some users.",
      "created_at" : "2019-06-20T17:06:32Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/14895#issuecomment-504106403",
      "id" : 504106403,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14895",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUwNDEwNjQwMw==",
      "updated_at" : "2019-06-20T17:06:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/504106403",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Concept ACK.\r\nI think this is a must-have feature in the p2p layer, and I have a feeling that code won't become much less intuitive.\r\n\r\nI think it's a good timing for introducing new p2p messages: the problem is not severe at the moment and it's not that bad if old nodes don't get the benefit. \r\nHowever, there might be an issue if we start to *rely* on this assumption real soon (e.g., imagine a lot of people start closing lightning channels with low fees). I don't know how to justify this part.\r\n\r\nBtw, I believe a scenario similar to what Matt send to the mailing list: multi-sig transactions or coinjoins which take a while to prepare. While collecting signatures, fee market might change a lot, and cpfp might happen quite often (if not overpaying a lot by default).",
      "created_at" : "2019-06-20T20:13:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/14895#issuecomment-504166091",
      "id" : 504166091,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14895",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUwNDE2NjA5MQ==",
      "updated_at" : "2019-06-20T20:13:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/504166091",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "I had a thought about looking at the problem from a slightly different angle. What if instead of **Child Pays For Parent** we think of it as **Parent Discounts Child**? \r\n\r\nThen we can keep a limited set of non-relayable \"waiting-state\" parents and include their feerate (represented by a pair of `(fee, weight)`). Every time another candidate tx arrives, its effective fee rate is computed as âfee/âweight over all its \"waiting-state\" ancestors. In other words, all ancestors discount the feerate of the new candidate. If such effective feerate is over the threshold, then such tx and all its waiting ancestors are marked as \"accepted\" and now can be relayed.\r\n\r\nIf there is an overlapping subgraph (because some waiting ancestor has 2+ outputs) and the common ancestor transitions from _waiting_ to _accepted_, we need to recursively follow the known descendants and re-calculate their feerates so they are not discounted anymore. Since some of them can become acceptable themselves, the process should probably consist of two phases: update the feerates downstream, then try to accept the updated waiting txs.\r\n\r\nDoes this make sense?\r\n\r\n",
      "created_at" : "2020-01-23T17:19:10Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/14895#issuecomment-577781457",
      "id" : 577781457,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14895",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU3Nzc4MTQ1Nw==",
      "updated_at" : "2020-01-23T17:19:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/577781457",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/698?v=4",
         "events_url" : "https://api.github.com/users/oleganza/events{/privacy}",
         "followers_url" : "https://api.github.com/users/oleganza/followers",
         "following_url" : "https://api.github.com/users/oleganza/following{/other_user}",
         "gists_url" : "https://api.github.com/users/oleganza/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/oleganza",
         "id" : 698,
         "login" : "oleganza",
         "node_id" : "MDQ6VXNlcjY5OA==",
         "organizations_url" : "https://api.github.com/users/oleganza/orgs",
         "received_events_url" : "https://api.github.com/users/oleganza/received_events",
         "repos_url" : "https://api.github.com/users/oleganza/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/oleganza/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/oleganza/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/oleganza"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I would like to re-open the discussion relative to package relay design, especially in light of my learnings from the past few months of the LN security requirements. \r\n\r\nTo sum-up, we have an array of use-cases for which package relay would provide value. (ofc Iâm looking at this issue with a strong LN bias and getting an LN-fix in the first version might be too much to ask.)\r\n\r\n###  Best-feerate discovery\r\nA node on the network may have a small mempool configuration, such that its minimum feerate required\r\nfor acceptance is far higher than the rest of the network. Receipt of a low-feerate transaction will be rejected even though a high-feerate child may be received just after. This scenario downgrades the feerate discovery of nodeâs with small mempools and limits their ability to accurately estimate fees.\r\n\r\n### Multi-party transactions\r\nA Coinjoin user among a set of participants may have a different liquidity preference than others\r\nand would like to unilaterally bump the feerate of the pending coinjoin to spend the funds sooner.\r\nRequiring interactivity breaks privacy assumptions by triggering another round of communications or violates spending policy by accessing the cold wallet.\r\n\r\n### Pre-signed delegated transactions\r\nA LN user may delegate enforcement of its channel to a watchtower, while only providing pre-signed\r\ntransactions to avoid fund hijacks by the distrusted watchtower. To do its job correctly, the delegated watchtower needs to bump the feerate of pre-signed transactions.\r\n\r\n### Bitcoin Contracts with Competing Interests\r\nContract applications (vaults or LN) rely on the timely confirmation of transactions for fund security. Assuming a pre-negotiated fees model, a counterparty has an interest in preventing the inclusion of a transaction to benefit from a timelock expiration. An honest party should be able to unilaterally bump feerates of its counter-signed transactions, without any assumed knowledge of network mempools. See https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html\r\n\r\n### Security Requirements\r\nHere are a few attacks to consider when designing package-relay:\r\na) a counterparty shouldn't be able to block propagation of a higher-feerate chain of transactions\r\nby an earlier, lower-feerate broadcast competing for the same utxo\r\nb) a counterparty shouldn't be able to pin an invalid or low-feerate parent in reject filters to\r\nblock later acceptance of a higher-feerate child\r\nc) a counterparty shouldn't be able to flood the p2p network with cheap, invalid chains of\r\ntransactions or orphans to obstruct the propagation of higher-feerate packages.\r\nAttacks b) and c) are especially concerning from an LN perspective, as you can map a LN-node to its full-node. Assuming we can't mask tx-relay topology, an attacker can directly connect to victimsâ peers to\r\ninterfere with propagation.\r\n\r\n### Approaches Trade-offs\r\nTalking with @sdaftuar on package relay design, he underscored the need for a uniform relay/mempool\r\npolicy across the deployed network to ensure package relay efficiency. Policy stability \r\nhas already been talked in other issues (e.g #13283 (comment))\r\nMy mailing list post covers this in more detail, but if we opt for a uniform policy\r\nit means our package design must be backward compatible to avoid breaking applications relying on\r\nprevious package versions.\r\n\r\nWe have a few choices to make on the initial design:\r\n* receiver-initiated: a) without p2p changes https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html or b) with p2p extensions https://gist.github.com/sdaftuar/8756699bfcad4d3806ba9f3396d4e66a\r\n* relay-initiated: at inv/tx sending, the relay node ties a low-feerate parent to a high-feerate child based on its local mempool. You can leverage the feefilter as a trigger or an opt-in from parent\r\n* sender-initiated: original broadcast sender marks a chain of transactions as broadcastable and is evaluated as a whole, see #19621 (there are flavors in between, see Rusty's deferred broadcast ideas here : https://gist.github.com/sdaftuar/8756699bfcad4d3806ba9f3396d4e66a)\r\n\r\nI think itâs possible that any one of the following choices would guard against attacks by: \r\na) solving conflict replacement,\r\nwhich is a mempool mechanism\r\nb) introducing a package_id or evicting low-feerate parents from our rejection filters\r\nc) allocating per-peer resources, to avoid DoS due to new data structures/algorithms, as weâre already doing for INVs \r\n\r\nIMO, where the approaches diverge, is regarding the use of bandwidth. A receiver-initiated scheme would have the following round-trips:\r\n* INV announcement of parent and child\r\n* GETDATA replies of both parent and child\r\n* TX sending of both parent and child, if the parent is rejected, the child kept as an orphan\r\n* GETPACKAGE reply of child ancestors\r\n* PACKAGE sending of ancestors ids\r\n* GETDATA replies of ancestors\r\n* TX sending of ancestors\r\nParent announcement/sending would have to be duplicated.\r\n\r\nWhereas a sender/relay initiated, based on introducing a package_id (sha256 of all package elements) might look like the following:\r\n* INV announcement of package_id\r\n* GETDATA of package_id, if it's not already known\r\n* PACKAGE sending of all package members\r\n\r\nA sender/relay initiated scheme, due to already knowing the feerate dependency between transactions,\r\ncan only announce a common identifier for the whole. Of course, among package elements, a parent can\r\nalready be known by the receiver, but you should always allow a mempool retry as it's a \"different\"\r\nrelay.\r\n\r\nNow, is this worth the effort to optimize package-relay ? That's a question hard to answer without knowing\r\nits future usage. Dependent second-layers may use it more often based on their fee models requirements which may make up a significant share of the overall tx-relay bandwidth. Starting with a high-bandwidth scheme now\r\n(receiver-initiated) but needing to switch to a lower-bandwidth scheme (sender-initiated) if later needed, will be a break a backward-compatible uniform policy.\r\n\r\nBetween original-sender-initiated and relay-initiated schemes, I think we want to avoid encumbering\r\nevery relaying hop with recomputing packages when it can be done O(1) by the sender. This also helps\r\navoid doing work that your mempool has already done with regards to package limits.\r\n\r\nIt might even be worth exploring fancier p2p extensions, like new INVs where the utxo/feerate of either a transaction or a whole package could be sent or queried by peers.\r\n\r\n### Conclusion\r\nIMHO, going forward, \r\n* we should have a clear understanding of second-layer application requirements to evaluate proposals, including the edge cases of LN security issues\r\n* we should decide if it's worth leaving room for future bandwidth optimizations so that either sender or receiver can initiate with the caveat that fancier optimizations come with greater DoS vulnerabilities\r\n* we should deploy an backward-compatible package policy, namely only 2-tx package for now solving pinning (at least until mempool refactors are merged) to avoid package replacement DoS vectors package support should be built on top of overhaul transaction request to reduce DoS and transaction origin inference attack surfaces \r\n* we should decide on a consistency guarantee, the package API should be clear enough to avoid footgunish misuse by higher-level applications\r\n\r\nMaybe to start, we can work on an unoptimized, upgradeable LN-fixing package relay\r\nand defer the hard questions to later.\r\n\r\nThoughts ?\r\n\r\ncc @TheBlueMatt @t-bast @rustyrussell ",
      "created_at" : "2020-07-29T19:55:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/14895#issuecomment-665874764",
      "id" : 665874764,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14895",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NTg3NDc2NA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-08-11T15:13:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/665874764",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I'm still digesting all this, but I wanted to respond to this very clearly:\r\n\r\n> Talking with @sdaftuar on package relay design, he underscored the need for an uniform relay/mempool\r\npolicy across the deployed network to ensure package relay efficiency. \r\n\r\nI think you misunderstand my points on this issue.  My view is exactly the opposite: philosophically, trying to enforce a uniform relay/mempool policy across the network in order to protect the security model of an application is something that I think is a mistake and a huge divergence from how we've approached relay policy and p2p design in the past.\r\n\r\nWhat I was also trying to say is that recent conversations around the insufficiency of our transaction relay system for lightning's security model make it sound like lightning needs a uniform relay policy -- which I think would be troubling if true.  So I think it's worth hashing out here exactly what the security requirements are in some more detail, and whether we can reasonably accommodate that at the base layer.  Perhaps the best way to do that is to throw up some proposals and discuss whether they are actually sufficient?",
      "created_at" : "2020-07-29T20:12:30Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/14895#issuecomment-665901650",
      "id" : 665901650,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14895",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NTkwMTY1MA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-29T20:12:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/665901650",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> a) a counterparty shouldn't be able to block propagation of a higher-feerate chain of transactions\r\nby an earlier, lower-feerate broadcast competing for the same utxo\r\nb) a counterparty shouldn't be able to pin an invalid or low-feerate parent in reject filters to\r\nblock latter evaluation with a higher-feerate child\r\nc) a counterparty shouldn't be able to overflow the p2p network with cheap, invalid chains of\r\ntransactions or orphans to obstrucate propagation of higher-feerate packages\r\n\r\nThis is a helpful start.  Points a) and c) make me wonder what are the RBF requirements of lightning?  It sounds like we need to be able to do package-level-RBF in order to achieve some of these goals, possibly with new RBF semantics that might allow total mempool fee to drop.  Is that correct?  Also, does it need to apply even if not all directly conflicting transactions signal for opt-in, to prevent an attacker from creating a transaction that can't be package-RBF-evicted because it's not signaling?",
      "created_at" : "2020-07-29T20:25:41Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/14895#issuecomment-665907792",
      "id" : 665907792,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14895",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NTkwNzc5Mg==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-29T20:25:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/665907792",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@thebluematt and I previously discussed some policy changes that might help here. I'm not sure I entirely understand all the issues but we had two ideas that I think may mitigate some of the transaction chain pinning concerns:\r\n\r\na) Transaction pinning.  To solve the problem of low-feerate transactions being stuck in the mempool interfering with protocols like lightning which just need resolution, we can borrow from suggestions to solve RBF-pinning.  I believe @gmaxwell once suggested that one way we could mitigate RBF-pinning issues would be by letting transaction creators add a flag (perhaps an unused bit in a sequence field or the like) that would indicate that nodes should not add children to the transaction, unless doing so would likely cause the transaction to be confirmed very soon.  The motivation is that the author of the transaction may seek to use RBF in the future to bump the feerate, so relay or mining nodes would be better off not accepting low-feerate children, which would interfere with that.  \r\n\r\nThis seems like it should be incentive-compatible in principle, although the details around determining exactly what is \"near confirmation\" could have implementation difficulties in practice, I dunno.  I don't really know how lightning works, but presumably if we had such a policy that was broadly in use, then applications like lightning could attach this flag to all pre-signed transactions that involve more than one-party?\r\n\r\nAlso, I guess we'd need to have this flag work at the package level (so that we only let a transaction in if the package it's part of has a high enough feerate to be mined soon).\r\n\r\nb) Package RBF.  I guess if some undesirable transaction does end up stuck in the mempool somehow, that you'd need package-level RBF in order to evict a package with another.  If we think our implementation of (a) is good enough, then I don't know how much we need to worry about this, but perhaps there are ways that (a) would be gamed which make package rbf of some sort important.  I think figuring out exactly what the semantics here would be will take some design effort.  This also reintroduces the RBF pinning problem but this time for packages rather than single transactions (ie what do you do when you want to evict a large package with a small one?).\r\n\r\nAre there any other tools we need at our disposal to achieve the security requirements listed?",
      "created_at" : "2020-07-29T22:49:30Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/14895#issuecomment-665969902",
      "id" : 665969902,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14895",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NTk2OTkwMg==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-29T22:49:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/665969902",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Just want to mention this here.\r\n\r\n@rustyrussell floated the idea once of having sort of a \"pre-mempool\", of transactions that are queued for inclusion into the mempool, but otherwise unvalidated. These transactions aren't relayed until they're actually accepted into the mempool (gated by it shrinking through its normal expiration/confirmation/conflict mechanism), so there are fewer concerns about creating a freely abusable network wide broadcast channel. In addition, these could be relayed along with the outputs they're spending (and identified using a hash that commits to these), so that the receiver can correctly reason about their feerate and whatever other policies they want to apply, without needing to care about orphaning or doing costly UTXO lookups and other full validation. This could reduce the actual mempool to a smaller area, of sufficient size to efficiently decide what goes into the next block, but and delay relay of what can't be confirmed soon.\r\n\r\nI haven't thought through the implications too much, but perhaps it is useful in this discussion.\r\n\r\n@rustyrussell let me know if I'm missing something or misrepresented anything.\r\n\r\n",
      "created_at" : "2020-07-29T23:07:43Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/14895#issuecomment-665975441",
      "id" : 665975441,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14895",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NTk3NTQ0MQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-29T23:08:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/665975441",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> I think you misunderstand my points on this issue. My view is exactly the opposite: philosophically, trying to enforce a uniform relay/mempool policy across the network in order to protect the security model of an application is something that I think is a mistake and a huge divergence from how we've approached relay policy and p2p design in the past.\r\n\r\n> What I was also trying to say is that recent conversations around the insufficiency of our transaction relay system for lightning's security model make it sound like lightning needs a uniform relay policy -- which I think would be troubling if true. \r\n\r\nI'm sorry for the misunderstanding there, but I think there is still a valuable discussion to have on some policy subset stability across versions, on which higher applications (not only LN) can confidently build their fee model and propagation model. And it could be a) base layer agreeing on the policy subset b) in consequence applications designing their fee model c) as a feedback, if there is use-cases demand, reasonably extending the subset. Actually that's not the order followed, because we have deployed protocols with funds at risk due to these issues not being understood enough (and I don't blame anyone each layer has a complexity of its own, and the interactivity of both is daunting).\r\n\r\nWhen I'm thinking about a uniform policy, here the class of  scenario I'm concerned about, we tight some rules in the future in release Y (like increasing minRelayTxFee), a higher application may have pre-signed parent transactions with hardcoded older minRelayTxFee and relying on a high-feerate children for timely confirmation of the whole (as you can't predict the future why bother with an inaccurate parent feerate ?). The application full-node is safe as long as you have a propagation path Y (the older release) to miner mempools. If your full-node is a private one and has only few tx-relay peers as soon as they're all X ones your application becomes insecure. Of course, it's unlikely we touch inconsiderately to an obvious rule like minRelayTxFee, but as the whole policy set is loosely documented and hard to test, it's hard to know on which higher-layer devs have made assumptions for the security of their software stack. \r\n\r\nNaturally a way to avoid that would be to give some ecosystem warning when we identify such upgrade risk and ensure there is sufficient time elapsed for higher-software to compel and re-deploy. And maybe that's the word \"uniformity\" where we hanging on, I think it's more backward-compatibility which is aimed ?\r\n\r\nIt's as much troubling to think the security of your LN node is function of the whom your linked full-node might be connected to. And this good-propagation of your time-sensitive transactions is really a fundamental assumption of all payment channels design, even before LN. Ecosystem-wise, it's quite concerning that this assumption is, in fact, laying on a false premise.",
      "created_at" : "2020-07-30T01:26:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/14895#issuecomment-666021701",
      "id" : 666021701,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14895",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NjAyMTcwMQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-30T01:31:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/666021701",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> This is a helpful start. Points a) and c) make me wonder what are the RBF requirements of lightning? It sounds like we need to be able to do package-level-RBF in order to achieve some of these goals, possibly with new RBF semantics that might allow total mempool fee to drop. Is that correct? Also, does it need to apply even if not all directly conflicting transactions signal for opt-in, to prevent an attacker from creating a transaction that can't be package-RBF-evicted because it's not signaling?\r\n\r\nI think the total mempool fee needs to drop because otherwise a malicious counterparty can broadcast first a low-feerate, high-fee package for the utxo in competition, such preventing replacement by a honest party capping its fee-bump to the contested value. Honest bump must happen through CPFP as the honest parent is also pre-signed and won't replace the malicious pin on its own. As you might not learned pinned parent (and you may have a different one in each network mempool), you can't do blind-CPFP and must assume that your honest parent+high-feerate CPFP replace every malicious instance as a whole. For the second concern, that's something we can handle on our own, as transactions are pre-signed or spends must use a CSV you can force opt-in, even of malicious transactions.\r\n\r\nOverall, for Lightning security model with regards to known pinning attack scenarios I sum up them there : https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html.  \r\n\r\n> I believe @gmaxwell once suggested that one way we could mitigate RBF-pinning issues would be by letting transaction creators add a flag (perhaps an unused bit in a sequence field or the like) that would indicate that nodes should not add children to the transaction, unless doing so would likely cause the transaction to be confirmed very soon. \r\n\r\nI guess there is the weakness of someone connecting to your node, the original sender, and freely inflating the feerate of your mempool to make you reject your own CPFP. An attacker can do this without effectively paying the price by partition-conflicting your mempool from the rest of the network. There is also an attacker anticipating mempool-congestion (like exchange payouts) and racing to make the low-feerate make it in the mempool before being obsolete but staying there. Also not broadcasting low-feerate children restrain the network to learn about them, they're valid blockspace demand at some price point and may express a honest user confirmation preference (now does low-feerate CPFP on RBFable transactions make sense ?)\r\n\r\nGenerally I'm skeptical turning mempools as fee-estimators (even if latter are built on top of former) and instead favor applications expressing their confirmation preferences, mempools just reflecting them (just policing out resources abuse). \"near confirmation\" sounds like a moving target due to block variance and mempool-congestion. That said it might be good enough, I need to think more on it.\r\n\r\n> This also reintroduces the RBF pinning problem but this time for packages rather than single transactions (ie what do you do when you want to evict a large package with a small one?).\r\n\r\nIs this an issue if smaller one has a better feerate than large package or you're thinking about ancestor/descendants limits here ?\r\n\r\n> Are there any other tools we need at our disposal to achieve the security requirements listed?\r\n\r\nIIRC we mentioned with Matt about fast rotation of some of your tx-relay peers to make topology less static and thus less prone to exploitation through conflicting mempools or interfering with propagation. But that was only for the more sophisticated scenarios (\"The Ugly\" in my June post), not the one I'm immediately concerned with.",
      "created_at" : "2020-07-30T02:20:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/14895#issuecomment-666043085",
      "id" : 666043085,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14895",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NjA0MzA4NQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-30T02:37:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/666043085",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "If that helps, I tried summing up recent discussions around these issues and LN assumptions here:\r\n\r\n- https://github.com/t-bast/lightning-docs/blob/master/lightning-txs.md\r\n- https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md\r\n\r\nThese documents may be incomplete, and there may be mistakes (my own!), but I think they can be a good starting point to understand where LN may be making wishful assumptions that can fall apart at tx-relay time (and the tx format constraints LN has).\r\n\r\n> What I was also trying to say is that recent conversations around the insufficiency of our transaction relay system for lightning's security model make it sound like lightning needs a uniform relay policy -- which I think would be troubling if true.\r\n\r\nI don't think LN requires a uniform p2p network (in the sense that all nodes apply the exact same relay policies and mempools always converge). And I agree that it would not be desirable; I think there's simply a misunderstanding on what \"uniform\" means here. IIUC @ariard means that higher layers need to be able to rely on a few core assumptions that need to remain \"loosely true\" for a big enough portion of the network (e.g. `minRelayTxFee` will not be raised arbitrarily).\r\n\r\nI think the core tx-relay assumption for LN is that there must be a (somewhat stable) mechanism to allow an honest node to bump the fees of a tx that has been signed in the past with a low feerate (and that can't be updated because it requires signatures from multiple participants, who may be malicious and won't cooperate). If we raise the fee to `X sats`, it's ok if some nodes relay it and others won't, as long as raising the fees even more can guarantee that most nodes will eventually relay it (once the fee has been raised enough).\r\n\r\nI don't have enough knowledge to suggest how this high-level goal should be met (even though sender-initiated package relay feels like a good starting design point), but I can share what I think is the root cause of the issue nowadays (my point of view may be biased and incomplete, please don't hesitate to hurt my feelings and tell me I'm completely wrong). IMHO BIP 125 rule 5 is the culprit because it introduces *irreplaceable packages*. Those packages are also quite costly for mempools (because walking the graph is costly). I don't understand why allowing such long chains of unconfirmed transactions in the mempool is useful. It feels to me that bitcoin should only allow much smaller unconfirmed packages (with a hard-coded, maybe configurable limit `N`), allow replacing those packages, and shift the complexity of managing long chains to clients; if someone wants to chain 100 txs, they should be buffering them and broadcasting them `N` by `N`, waiting for the previous batch to be confirmed before broadcasting more (i.e. they're the only ones bearing the complexity cost of their usecase, instead of putting the burden on the whole network).\r\n\r\nAgain, I want to emphasize that I may be completely wrong on this; it's very likely that I'm unaware of use-cases that require this feature.",
      "created_at" : "2020-07-30T08:13:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/14895#issuecomment-666215119",
      "id" : 666215119,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14895",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NjIxNTExOQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-30T08:13:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/666215119",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/31281497?v=4",
         "events_url" : "https://api.github.com/users/t-bast/events{/privacy}",
         "followers_url" : "https://api.github.com/users/t-bast/followers",
         "following_url" : "https://api.github.com/users/t-bast/following{/other_user}",
         "gists_url" : "https://api.github.com/users/t-bast/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/t-bast",
         "id" : 31281497,
         "login" : "t-bast",
         "node_id" : "MDQ6VXNlcjMxMjgxNDk3",
         "organizations_url" : "https://api.github.com/users/t-bast/orgs",
         "received_events_url" : "https://api.github.com/users/t-bast/received_events",
         "repos_url" : "https://api.github.com/users/t-bast/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/t-bast/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/t-bast/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/t-bast"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> \"pre-mempool\"\r\n\r\nI've had a similar thought, that I call the \"memswamp\" -- basically, keep an indexed collections of transactions but allow it to include conflicting transactions as well (could potentially include orphan or non-final transactions as well, suitably tagged). You filter out conflicting and low-fee txs from the memswamp to generate the mempool, which is what you use to build blocks.\r\n\r\nThe main idea being that if someone relays you a tx that you can successfully validate (you know its parents, its signatures are valid, and it complies with standardness rules), then if it doesn't pass RBF rules, you still keep it around, you just don't immediately forward it. Ideally, you maintain a \"minfeebump\" value that you use to ratelimit what tx's you forward, so if there's a lull in tx traffic, you'll forward even a tx that RBF's by a small amount, but if there's a lot it may rise above \"minfee\" even. Expire txs when they're low fee, have been replaced by a higher fee tx and you've relayed that tx, when they've been orphaned for too long, etc. I think that might be a good enough way of preventing tx spam on its own, so that you could drop the \"must pay a higher fee than the package it's replacing, not just a higher fee rate\" rule, which seems like the biggest road block in ensuring you can get your contract resolution committed on chain.\r\n\r\nI think the memswamp approach potentially has nicer properties for handling reorgs, since you can \"just\" free up space for the txs from the reorged blocks, and dump them directly into the mempool, without having to resolve conflicts. If it's a >100 block reorg you'd need to be careful about disappearing coinbases making some tx's orphans, and would have to take care of final txs becoming non-final as well.",
      "created_at" : "2020-07-30T09:50:32Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/14895#issuecomment-666267749",
      "id" : 666267749,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14895",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NjI2Nzc0OQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-30T09:50:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/666267749",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Should package limits be expressed in weight units or virtual bytes ?\r\n\r\nSee discussion : https://github.com/bitcoin/bitcoin/pull/20833/#discussion_r618629408\r\n\r\ncc @glozow ",
      "created_at" : "2021-04-24T23:55:41Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/14895#issuecomment-826168715",
      "id" : 826168715,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14895",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDgyNjE2ODcxNQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-04-24T23:55:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/826168715",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> Should package limits be expressed in weight units or virtual bytes ?\r\n\r\nIsn't one a multiple of the other? I used vbytes in 20833 since that's what descendant limits are expressed in. I don't think I fully understand why there would be a significant difference in using one over the other. ",
      "created_at" : "2021-04-25T03:16:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/14895#issuecomment-826237280",
      "id" : 826237280,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14895",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDgyNjIzNzI4MA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-04-26T23:15:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/826237280",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Isn't one a multiple of the other? I used vbytes in 20833 since that's what descendant limits are expressed in. I don't think I fully understand why there would be a significant difference in using one over the other.\r\n\r\nSee #22097 for rational and proposed changes.",
      "created_at" : "2021-05-28T22:07:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/14895#issuecomment-850698441",
      "id" : 850698441,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14895",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDg1MDY5ODQ0MQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-05-28T22:08:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/850698441",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Design discussion has made progress in various places. Since we now have code and a bip and can discuss the design decisions more concretely, I'm going to close this issue.\r\n\r\nSee #27463 for project tracking.",
      "created_at" : "2023-09-21T16:51:41Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/14895#issuecomment-1729954358",
      "id" : 1729954358,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14895",
      "node_id" : "IC_kwDOABII585nHQI2",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1729954358/reactions"
      },
      "updated_at" : "2023-09-21T16:51:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1729954358",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   }
]
