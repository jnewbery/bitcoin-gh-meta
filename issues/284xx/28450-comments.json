[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| Concept ACK | [darosior](https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1713984415), [glozow](https://github.com/bitcoin/bitcoin/pull/28450#pullrequestreview-1620122880), [dergoegge](https://github.com/bitcoin/bitcoin/pull/28450#pullrequestreview-1620240896), [brunoerg](https://github.com/bitcoin/bitcoin/pull/28450#pullrequestreview-1622579860), [MarcoFalke](https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1719137408) |\n\nIf your review is incorrectly listed, please react with ð to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nNo conflicts as of last run.\n",
      "created_at" : "2023-09-11T14:10:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1713970394",
      "id" : 1713970394,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28450",
      "node_id" : "IC_kwDOABII585mKRza",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 1,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1713970394/reactions"
      },
      "updated_at" : "2023-09-14T09:52:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1713970394",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "cc @glozow @MarcoFalke ",
      "created_at" : "2023-09-11T14:11:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1713971539",
      "id" : 1713971539,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28450",
      "node_id" : "IC_kwDOABII585mKSFT",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1713971539/reactions"
      },
      "updated_at" : "2023-09-11T14:11:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1713971539",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1321625656"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1321625656"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Maybe worth adding `-bytespersigop` too?",
      "commit_id" : "3654ad4152f139e6583f819d7d039fd7cdd5dc7f",
      "created_at" : "2023-09-11T14:15:13Z",
      "diff_hunk" : "@@ -0,0 +1,349 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void SetMempoolConstraints(ArgsManager& args, FuzzedDataProvider& fuzzed_data_provider)\n+{\n+    args.ForceSetArg(\"-limitancestorcount\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50)));\n+    args.ForceSetArg(\"-limitancestorsize\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202)));\n+    args.ForceSetArg(\"-limitdescendantcount\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50)));\n+    args.ForceSetArg(\"-limitdescendantsize\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202)));\n+    args.ForceSetArg(\"-maxmempool\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200)));\n+    args.ForceSetArg(\"-mempoolexpiry\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1321625656",
      "id" : 1321625656,
      "line" : 88,
      "node_id" : "PRRC_kwDOABII585Oxmg4",
      "original_commit_id" : "f06cf5b0549b741f6825e8dfea8ee97bcf7ed572",
      "original_line" : 88,
      "original_position" : 88,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 88,
      "pull_request_review_id" : 1620122880,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1321625656/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-11T14:22:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1321625656",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Awesome, Concept ACK.",
      "created_at" : "2023-09-11T14:18:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1713984415",
      "id" : 1713984415,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28450",
      "node_id" : "IC_kwDOABII585mKVOf",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1713984415/reactions"
      },
      "updated_at" : "2023-09-11T14:18:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1713984415",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22457751?v=4",
         "events_url" : "https://api.github.com/users/darosior/events{/privacy}",
         "followers_url" : "https://api.github.com/users/darosior/followers",
         "following_url" : "https://api.github.com/users/darosior/following{/other_user}",
         "gists_url" : "https://api.github.com/users/darosior/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/darosior",
         "id" : 22457751,
         "login" : "darosior",
         "node_id" : "MDQ6VXNlcjIyNDU3NzUx",
         "organizations_url" : "https://api.github.com/users/darosior/orgs",
         "received_events_url" : "https://api.github.com/users/darosior/received_events",
         "repos_url" : "https://api.github.com/users/darosior/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/darosior/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/darosior/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/darosior"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1321690708"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1321690708"
         }
      },
      "author_association" : "MEMBER",
      "body" : "to take advantage of this, probably would need to do some bare mulitisigs? wouldn't hurt to add I suppose",
      "commit_id" : "3654ad4152f139e6583f819d7d039fd7cdd5dc7f",
      "created_at" : "2023-09-11T15:02:07Z",
      "diff_hunk" : "@@ -0,0 +1,349 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void SetMempoolConstraints(ArgsManager& args, FuzzedDataProvider& fuzzed_data_provider)\n+{\n+    args.ForceSetArg(\"-limitancestorcount\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50)));\n+    args.ForceSetArg(\"-limitancestorsize\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202)));\n+    args.ForceSetArg(\"-limitdescendantcount\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50)));\n+    args.ForceSetArg(\"-limitdescendantsize\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202)));\n+    args.ForceSetArg(\"-maxmempool\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200)));\n+    args.ForceSetArg(\"-mempoolexpiry\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1321690708",
      "id" : 1321690708,
      "in_reply_to_id" : 1321625656,
      "line" : 88,
      "node_id" : "PRRC_kwDOABII585Ox2ZU",
      "original_commit_id" : "f06cf5b0549b741f6825e8dfea8ee97bcf7ed572",
      "original_line" : 88,
      "original_position" : 88,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 88,
      "pull_request_review_id" : 1620226361,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1321690708/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-11T15:02:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1321690708",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1321699963"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1321699963"
         }
      },
      "author_association" : "MEMBER",
      "body" : "could set all the options here instead of round tripping through the args man?",
      "commit_id" : "3654ad4152f139e6583f819d7d039fd7cdd5dc7f",
      "created_at" : "2023-09-11T15:08:06Z",
      "diff_hunk" : "@@ -0,0 +1,351 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void SetMempoolConstraints(ArgsManager& args, FuzzedDataProvider& fuzzed_data_provider)\n+{\n+    args.ForceSetArg(\"-limitancestorcount\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50)));\n+    args.ForceSetArg(\"-limitancestorsize\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202)));\n+    args.ForceSetArg(\"-limitdescendantcount\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50)));\n+    args.ForceSetArg(\"-limitdescendantsize\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202)));\n+    args.ForceSetArg(\"-maxmempool\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200)));\n+    args.ForceSetArg(\"-mempoolexpiry\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)));\n+    args.ForceSetArg(\"-bytespersigop\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999)));\n+}\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1321699963",
      "id" : 1321699963,
      "line" : 132,
      "node_id" : "PRRC_kwDOABII585Ox4p7",
      "original_commit_id" : "3654ad4152f139e6583f819d7d039fd7cdd5dc7f",
      "original_line" : 132,
      "original_position" : 132,
      "original_start_line" : 130,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 132,
      "pull_request_review_id" : 1620240896,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1321699963/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 130,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-09-11T15:16:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1321699963",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2023-09-13T17:49:41Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1718062922",
      "id" : 1718062922,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28450",
      "node_id" : "IC_kwDOABII585mZ49K",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1718062922/reactions"
      },
      "updated_at" : "2023-09-13T17:49:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1718062922",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1324888195"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1324888195"
         }
      },
      "author_association" : "MEMBER",
      "body" : "done",
      "commit_id" : "28f45d6883d06c56dfd7444eeb82b30cff6b8c1b",
      "created_at" : "2023-09-13T18:06:41Z",
      "diff_hunk" : "@@ -0,0 +1,351 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void SetMempoolConstraints(ArgsManager& args, FuzzedDataProvider& fuzzed_data_provider)\n+{\n+    args.ForceSetArg(\"-limitancestorcount\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50)));\n+    args.ForceSetArg(\"-limitancestorsize\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202)));\n+    args.ForceSetArg(\"-limitdescendantcount\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50)));\n+    args.ForceSetArg(\"-limitdescendantsize\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202)));\n+    args.ForceSetArg(\"-maxmempool\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200)));\n+    args.ForceSetArg(\"-mempoolexpiry\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)));\n+    args.ForceSetArg(\"-bytespersigop\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999)));\n+}\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1324888195",
      "id" : 1324888195,
      "in_reply_to_id" : 1321699963,
      "line" : 123,
      "node_id" : "PRRC_kwDOABII585O-DCD",
      "original_commit_id" : "3654ad4152f139e6583f819d7d039fd7cdd5dc7f",
      "original_line" : 123,
      "original_position" : 132,
      "original_start_line" : 130,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 123,
      "pull_request_review_id" : 1625146817,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1324888195/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 121,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-09-13T18:06:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1324888195",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "rebased on master, removed arg round-trip, un-marked WIP",
      "created_at" : "2023-09-13T18:09:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1718092570",
      "id" : 1718092570,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28450",
      "node_id" : "IC_kwDOABII585maAMa",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1718092570/reactions"
      },
      "updated_at" : "2023-09-13T18:09:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1718092570",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK, I guess this also picks up https://github.com/bitcoin/bitcoin/pull/25778 ?",
      "created_at" : "2023-09-14T09:52:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1719137408",
      "id" : 1719137408,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28450",
      "node_id" : "IC_kwDOABII585md_SA",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1719137408/reactions"
      },
      "updated_at" : "2023-09-14T09:52:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1719137408",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Any interest in using `CheckPackageMempoolAcceptResult` from https://github.com/bitcoin/bitcoin/pull/26711/commits/baf475de599c82e7718ffefd7f0481fc88217853? It checks that a result contains the fields we expect based on whether it's supposed to be valid.",
      "created_at" : "2023-09-14T10:47:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1719217351",
      "id" : 1719217351,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28450",
      "node_id" : "IC_kwDOABII585meSzH",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1719217351/reactions"
      },
      "updated_at" : "2023-09-14T10:47:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1719217351",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@MarcoFalke oh, had no idea it existed. Yes I think this should subsume it. I kept it a separate fuzz target to allow more specialization for what we're covering.\r\n\r\n> Any interest in using CheckPackageMempoolAcceptResult from https://github.com/bitcoin/bitcoin/commit/baf475de599c82e7718ffefd7f0481fc88217853? It checks that a result contains the fields we expect based on whether it's supposed to be valid.\r\n\r\nI might take a subset of that, but a few parts wouldn't be useful since I'm firing off random packages that may or may not be valid, and the mempool may trim things even if they're valid?\r\n\r\nedit: In other words, please consider this PR review-ready :+1: ",
      "created_at" : "2023-09-14T14:00:21Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1719512750",
      "id" : 1719512750,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28450",
      "node_id" : "IC_kwDOABII585mfa6u",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1719512750/reactions"
      },
      "updated_at" : "2023-09-14T14:30:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1719512750",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1326380398"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1326380398"
         }
      },
      "author_association" : "MEMBER",
      "body" : "future work: making the tx >40kWu sometimes, along with other invariant checks, would have likely allowed the fuzzer to catch https://github.com/bitcoin/bitcoin/pull/28472",
      "commit_id" : "93d7c5c09c86f9543433d87a2ca074f35cac0fe6",
      "created_at" : "2023-09-14T18:42:01Z",
      "diff_hunk" : "@@ -0,0 +1,341 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &chainstate.CoinsTip()), tx_pool};\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1326380398",
      "id" : 1326380398,
      "line" : 211,
      "node_id" : "PRRC_kwDOABII585PDvVu",
      "original_commit_id" : "28f45d6883d06c56dfd7444eeb82b30cff6b8c1b",
      "original_line" : 211,
      "original_position" : 211,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 211,
      "pull_request_review_id" : 1627544107,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 1,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1326380398/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-14T18:42:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1326380398",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "removed the second commit to not impede review of the various bugfix PRs individually\r\n\r\nrebasing on this should result in no known crashes: https://github.com/bitcoin/bitcoin/pull/28471\r\nhttps://github.com/bitcoin/bitcoin/pull/28472",
      "created_at" : "2023-09-15T13:46:43Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1721311984",
      "id" : 1721311984,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28450",
      "node_id" : "IC_kwDOABII585mmSLw",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1721311984/reactions"
      },
      "updated_at" : "2023-09-15T18:52:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1721311984",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1331487664"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331487664"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't think this set is ever actually used.",
      "commit_id" : "93d7c5c09c86f9543433d87a2ca074f35cac0fe6",
      "created_at" : "2023-09-20T11:26:35Z",
      "diff_hunk" : "@@ -0,0 +1,341 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1331487664",
      "id" : 1331487664,
      "line" : 140,
      "node_id" : "PRRC_kwDOABII585PXOOw",
      "original_commit_id" : "93d7c5c09c86f9543433d87a2ca074f35cac0fe6",
      "original_line" : 140,
      "original_position" : 140,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 140,
      "pull_request_review_id" : 1635411567,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331487664/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-20T11:27:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331487664",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1331487971"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331487971"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`Assert(true)` seems to not be useful.",
      "commit_id" : "93d7c5c09c86f9543433d87a2ca074f35cac0fe6",
      "created_at" : "2023-09-20T11:26:51Z",
      "diff_hunk" : "@@ -0,0 +1,341 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &chainstate.CoinsTip()), tx_pool};\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;\n+        std::set<CTransactionRef> added;\n+        auto txr = std::make_shared<TransactionsDelta>(removed, added);\n+        RegisterSharedValidationInterface(txr);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+\n+        // Single-tx packages should be rejected, so do that sometimes, and sometimes send it via single submission\n+        // to allow it into the mempool by itself to make more interesting mempool packages\n+        auto single_submit = txs.size() == 1 && fuzzed_data_provider.ConsumeBool();\n+        auto package_submit = !single_submit;\n+\n+        const auto result_package = WITH_LOCK(::cs_main,\n+                                    return ProcessNewPackage(chainstate, tx_pool, txs, /*test_accept=*/!package_submit));\n+        // If something went wrong due to a package-specific policy, it might not return a\n+        // validation result for the transaction.\n+        if (result_package.m_state.GetResult() != PackageValidationResult::PCKG_POLICY) {\n+            auto it = result_package.m_tx_results.find(txs.back()->GetWitnessHash());\n+            Assert(it != result_package.m_tx_results.end());\n+            Assert(it->second.m_result_type == MempoolAcceptResult::ResultType::VALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::INVALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::MEMPOOL_ENTRY);\n+        }\n+\n+        const auto res = WITH_LOCK(::cs_main, return AcceptToMemoryPool(chainstate, txs.back(), GetTime(), bypass_limits, /*test_accept=*/!single_submit));\n+        const bool accepted = res.m_result_type == MempoolAcceptResult::ResultType::VALID;\n+\n+        SyncWithValidationInterfaceQueue();\n+        UnregisterSharedValidationInterface(txr);\n+\n+        if (single_submit) {\n+            Assert(accepted != added.empty());\n+            Assert(accepted == res.m_state.IsValid());\n+            Assert(accepted != res.m_state.IsInvalid());\n+            if (accepted) {\n+                Assert(added.size() == 1);\n+                Assert(txs.back() == *added.begin());\n+            } else {\n+                // Do not consider rejected transaction removed\n+                removed.erase(txs.back());\n+            }\n+        } else {\n+            // This is empty if it fails early checks, or \"full\" if transactions are looked at deeper\n+            Assert(result_package.m_tx_results.size() == txs.size() || result_package.m_tx_results.empty());\n+            if (result_package.m_state.GetResult() == PackageValidationResult::PCKG_POLICY) {\n+                for (const auto& tx : txs) {\n+                    removed.erase(tx);\n+                }\n+            } else {\n+                for (const auto& [k, v] : result_package.m_tx_results) {\n+                    if (v.m_result_type != MempoolAcceptResult::ResultType::INVALID) {\n+                        Assert(true);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1331487971",
      "id" : 1331487971,
      "line" : 295,
      "node_id" : "PRRC_kwDOABII585PXOTj",
      "original_commit_id" : "93d7c5c09c86f9543433d87a2ca074f35cac0fe6",
      "original_line" : 295,
      "original_position" : 295,
      "original_start_line" : 294,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 295,
      "pull_request_review_id" : 1635411567,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331487971/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 294,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-09-20T11:27:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331487971",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1331488544"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331488544"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Seems a bit odd to me that the chain limits could go up to 50 but we only create packages of up to 26.",
      "commit_id" : "93d7c5c09c86f9543433d87a2ca074f35cac0fe6",
      "created_at" : "2023-09-20T11:27:28Z",
      "diff_hunk" : "@@ -0,0 +1,341 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1331488544",
      "id" : 1331488544,
      "line" : 115,
      "node_id" : "PRRC_kwDOABII585PXOcg",
      "original_commit_id" : "93d7c5c09c86f9543433d87a2ca074f35cac0fe6",
      "original_line" : 115,
      "original_position" : 115,
      "original_start_line" : 113,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 115,
      "pull_request_review_id" : 1635411567,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331488544/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 113,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-09-20T11:27:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331488544",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1331652861"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331652861"
         }
      },
      "author_association" : "MEMBER",
      "body" : "That's chain limits vs package limit checks, I think it's useful\r\n\r\ne.g., we could have 26 txns in the mempool, and submit another 25",
      "commit_id" : "bf7436cde8ba7eac0912817f6f8a41828cb60bc2",
      "created_at" : "2023-09-20T13:40:30Z",
      "diff_hunk" : "@@ -0,0 +1,341 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1331652861",
      "id" : 1331652861,
      "in_reply_to_id" : 1331488544,
      "line" : 115,
      "node_id" : "PRRC_kwDOABII585PX2j9",
      "original_commit_id" : "93d7c5c09c86f9543433d87a2ca074f35cac0fe6",
      "original_line" : 115,
      "original_position" : 115,
      "original_start_line" : 113,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 115,
      "pull_request_review_id" : 1635676679,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331652861/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 113,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-09-20T14:14:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331652861",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1331684820"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331684820"
         }
      },
      "author_association" : "MEMBER",
      "body" : "it is added to in `insert_tx` when used in `created_by_tx` arg. Lets each new package consider newly-entered outpoints in the mempool",
      "commit_id" : "bf7436cde8ba7eac0912817f6f8a41828cb60bc2",
      "created_at" : "2023-09-20T14:01:30Z",
      "diff_hunk" : "@@ -0,0 +1,341 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1331684820",
      "id" : 1331684820,
      "in_reply_to_id" : 1331487664,
      "line" : 140,
      "node_id" : "PRRC_kwDOABII585PX-XU",
      "original_commit_id" : "93d7c5c09c86f9543433d87a2ca074f35cac0fe6",
      "original_line" : 140,
      "original_position" : 140,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 140,
      "pull_request_review_id" : 1635727786,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331684820/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-20T14:01:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331684820",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1331685986"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331685986"
         }
      },
      "author_association" : "MEMBER",
      "body" : "removed debugging code",
      "commit_id" : "bf7436cde8ba7eac0912817f6f8a41828cb60bc2",
      "created_at" : "2023-09-20T14:02:19Z",
      "diff_hunk" : "@@ -0,0 +1,341 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &chainstate.CoinsTip()), tx_pool};\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;\n+        std::set<CTransactionRef> added;\n+        auto txr = std::make_shared<TransactionsDelta>(removed, added);\n+        RegisterSharedValidationInterface(txr);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+\n+        // Single-tx packages should be rejected, so do that sometimes, and sometimes send it via single submission\n+        // to allow it into the mempool by itself to make more interesting mempool packages\n+        auto single_submit = txs.size() == 1 && fuzzed_data_provider.ConsumeBool();\n+        auto package_submit = !single_submit;\n+\n+        const auto result_package = WITH_LOCK(::cs_main,\n+                                    return ProcessNewPackage(chainstate, tx_pool, txs, /*test_accept=*/!package_submit));\n+        // If something went wrong due to a package-specific policy, it might not return a\n+        // validation result for the transaction.\n+        if (result_package.m_state.GetResult() != PackageValidationResult::PCKG_POLICY) {\n+            auto it = result_package.m_tx_results.find(txs.back()->GetWitnessHash());\n+            Assert(it != result_package.m_tx_results.end());\n+            Assert(it->second.m_result_type == MempoolAcceptResult::ResultType::VALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::INVALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::MEMPOOL_ENTRY);\n+        }\n+\n+        const auto res = WITH_LOCK(::cs_main, return AcceptToMemoryPool(chainstate, txs.back(), GetTime(), bypass_limits, /*test_accept=*/!single_submit));\n+        const bool accepted = res.m_result_type == MempoolAcceptResult::ResultType::VALID;\n+\n+        SyncWithValidationInterfaceQueue();\n+        UnregisterSharedValidationInterface(txr);\n+\n+        if (single_submit) {\n+            Assert(accepted != added.empty());\n+            Assert(accepted == res.m_state.IsValid());\n+            Assert(accepted != res.m_state.IsInvalid());\n+            if (accepted) {\n+                Assert(added.size() == 1);\n+                Assert(txs.back() == *added.begin());\n+            } else {\n+                // Do not consider rejected transaction removed\n+                removed.erase(txs.back());\n+            }\n+        } else {\n+            // This is empty if it fails early checks, or \"full\" if transactions are looked at deeper\n+            Assert(result_package.m_tx_results.size() == txs.size() || result_package.m_tx_results.empty());\n+            if (result_package.m_state.GetResult() == PackageValidationResult::PCKG_POLICY) {\n+                for (const auto& tx : txs) {\n+                    removed.erase(tx);\n+                }\n+            } else {\n+                for (const auto& [k, v] : result_package.m_tx_results) {\n+                    if (v.m_result_type != MempoolAcceptResult::ResultType::INVALID) {\n+                        Assert(true);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1331685986",
      "id" : 1331685986,
      "in_reply_to_id" : 1331487971,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585PX-pi",
      "original_commit_id" : "93d7c5c09c86f9543433d87a2ca074f35cac0fe6",
      "original_line" : 295,
      "original_position" : 295,
      "original_start_line" : 294,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : null,
      "pull_request_review_id" : 1635729649,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331685986/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-09-20T14:02:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331685986",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "updated with cleanups",
      "created_at" : "2023-09-20T15:45:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1727984710",
      "id" : 1727984710,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28450",
      "node_id" : "IC_kwDOABII585m_vRG",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1727984710/reactions"
      },
      "updated_at" : "2023-09-20T15:45:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1727984710",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "from discussions with others:\r\n\r\n1) I have a PR built on https://github.com/bitcoin/bitcoin/pull/26711 which generalized from this fairly basic topology to general ancestor packages, including the last tx spending any subset of outpoints, and any package transactions potentially spending other package outpoints. I'd like to make sure it's getting relatively targeted coverage before switching to that, so deferring to after this PR.\r\n2) We can add coverage where we mutate the wtxid of txns\r\n3) Also should allow duplication of inputs\r\n\r\nI plan on doing these in the follow-up on top of #26711 ",
      "created_at" : "2023-09-21T10:27:42Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1729293183",
      "id" : 1729293183,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28450",
      "node_id" : "IC_kwDOABII585nEut_",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1729293183/reactions"
      },
      "updated_at" : "2023-09-21T10:27:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1729293183",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1332851868"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1332851868"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In bf7436cde8ba7eac0912817f6f8a41828cb60bc2: In `ProcessNewPackage`, couldn't we just use `single_submit` for `/*test_accept=*/` directly, instead of creating `package_submit`? ",
      "commit_id" : "aaffa22634be2b07dd50092f44caf6f4b0f8ee4e",
      "created_at" : "2023-09-21T10:37:56Z",
      "diff_hunk" : "@@ -0,0 +1,339 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &chainstate.CoinsTip()), tx_pool};\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;\n+        std::set<CTransactionRef> added;\n+        auto txr = std::make_shared<TransactionsDelta>(removed, added);\n+        RegisterSharedValidationInterface(txr);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+\n+        // Single-tx packages should be rejected, so do that sometimes, and sometimes send it via single submission\n+        // to allow it into the mempool by itself to make more interesting mempool packages\n+        auto single_submit = txs.size() == 1 && fuzzed_data_provider.ConsumeBool();\n+        auto package_submit = !single_submit;\n+\n+        const auto result_package = WITH_LOCK(::cs_main,\n+                                    return ProcessNewPackage(chainstate, tx_pool, txs, /*test_accept=*/!package_submit));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1332851868",
      "id" : 1332851868,
      "line" : 256,
      "node_id" : "PRRC_kwDOABII585PcbSc",
      "original_commit_id" : "bf7436cde8ba7eac0912817f6f8a41828cb60bc2",
      "original_line" : 256,
      "original_position" : 257,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 256,
      "pull_request_review_id" : 1637502233,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1332851868/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-21T10:37:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1332851868",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19480819?v=4",
         "events_url" : "https://api.github.com/users/brunoerg/events{/privacy}",
         "followers_url" : "https://api.github.com/users/brunoerg/followers",
         "following_url" : "https://api.github.com/users/brunoerg/following{/other_user}",
         "gists_url" : "https://api.github.com/users/brunoerg/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/brunoerg",
         "id" : 19480819,
         "login" : "brunoerg",
         "node_id" : "MDQ6VXNlcjE5NDgwODE5",
         "organizations_url" : "https://api.github.com/users/brunoerg/orgs",
         "received_events_url" : "https://api.github.com/users/brunoerg/received_events",
         "repos_url" : "https://api.github.com/users/brunoerg/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/brunoerg/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/brunoerg/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/brunoerg"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1332860797"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1332860797"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In bf7436cde8ba7eac0912817f6f8a41828cb60bc2: I think `amount_view` hasn't been used.",
      "commit_id" : "aaffa22634be2b07dd50092f44caf6f4b0f8ee4e",
      "created_at" : "2023-09-21T10:45:36Z",
      "diff_hunk" : "@@ -0,0 +1,339 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &chainstate.CoinsTip()), tx_pool};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1332860797",
      "id" : 1332860797,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Pcdd9",
      "original_commit_id" : "bf7436cde8ba7eac0912817f6f8a41828cb60bc2",
      "original_line" : 155,
      "original_position" : 155,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : null,
      "pull_request_review_id" : 1637516869,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1332860797/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-21T10:45:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1332860797",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19480819?v=4",
         "events_url" : "https://api.github.com/users/brunoerg/events{/privacy}",
         "followers_url" : "https://api.github.com/users/brunoerg/followers",
         "following_url" : "https://api.github.com/users/brunoerg/following{/other_user}",
         "gists_url" : "https://api.github.com/users/brunoerg/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/brunoerg",
         "id" : 19480819,
         "login" : "brunoerg",
         "node_id" : "MDQ6VXNlcjE5NDgwODE5",
         "organizations_url" : "https://api.github.com/users/brunoerg/orgs",
         "received_events_url" : "https://api.github.com/users/brunoerg/received_events",
         "repos_url" : "https://api.github.com/users/brunoerg/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/brunoerg/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/brunoerg/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/brunoerg"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1332902420"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1332902420"
         }
      },
      "author_association" : "MEMBER",
      "body" : "deleted",
      "commit_id" : "aaffa22634be2b07dd50092f44caf6f4b0f8ee4e",
      "created_at" : "2023-09-21T11:24:08Z",
      "diff_hunk" : "@@ -0,0 +1,339 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &chainstate.CoinsTip()), tx_pool};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1332902420",
      "id" : 1332902420,
      "in_reply_to_id" : 1332860797,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585PcnoU",
      "original_commit_id" : "bf7436cde8ba7eac0912817f6f8a41828cb60bc2",
      "original_line" : 155,
      "original_position" : 155,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : null,
      "pull_request_review_id" : 1637583711,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1332902420/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-21T11:24:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1332902420",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1332902922"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1332902922"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I find this ever so slightly more readable myself, opinions may vary ",
      "commit_id" : "aaffa22634be2b07dd50092f44caf6f4b0f8ee4e",
      "created_at" : "2023-09-21T11:24:37Z",
      "diff_hunk" : "@@ -0,0 +1,339 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &chainstate.CoinsTip()), tx_pool};\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;\n+        std::set<CTransactionRef> added;\n+        auto txr = std::make_shared<TransactionsDelta>(removed, added);\n+        RegisterSharedValidationInterface(txr);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+\n+        // Single-tx packages should be rejected, so do that sometimes, and sometimes send it via single submission\n+        // to allow it into the mempool by itself to make more interesting mempool packages\n+        auto single_submit = txs.size() == 1 && fuzzed_data_provider.ConsumeBool();\n+        auto package_submit = !single_submit;\n+\n+        const auto result_package = WITH_LOCK(::cs_main,\n+                                    return ProcessNewPackage(chainstate, tx_pool, txs, /*test_accept=*/!package_submit));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1332902922",
      "id" : 1332902922,
      "in_reply_to_id" : 1332851868,
      "line" : 256,
      "node_id" : "PRRC_kwDOABII585PcnwK",
      "original_commit_id" : "bf7436cde8ba7eac0912817f6f8a41828cb60bc2",
      "original_line" : 256,
      "original_position" : 257,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 256,
      "pull_request_review_id" : 1637584469,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1332902922/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-21T11:24:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1332902922",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "rebased on latest master on top of #28471 \r\n\r\nShould not be crashing anymore :crossed_fingers: cc @dergoegge ",
      "created_at" : "2023-09-21T16:17:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1729897131",
      "id" : 1729897131,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28450",
      "node_id" : "IC_kwDOABII585nHCKr",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 1,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1729897131/reactions"
      },
      "updated_at" : "2023-09-21T16:17:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1729897131",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335215049"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335215049"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Why is it calling `MockTime` again? I guess to trigger the `nLockTime`? ",
      "commit_id" : "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "created_at" : "2023-09-24T16:39:21Z",
      "diff_hunk" : "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335215049",
      "id" : 1335215049,
      "line" : 230,
      "node_id" : "PRRC_kwDOABII585PlcPJ",
      "original_commit_id" : "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "original_line" : 230,
      "original_position" : 230,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 230,
      "pull_request_review_id" : 1641093035,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335215049/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-24T17:44:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335215049",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19480819?v=4",
         "events_url" : "https://api.github.com/users/brunoerg/events{/privacy}",
         "followers_url" : "https://api.github.com/users/brunoerg/followers",
         "following_url" : "https://api.github.com/users/brunoerg/following{/other_user}",
         "gists_url" : "https://api.github.com/users/brunoerg/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/brunoerg",
         "id" : 19480819,
         "login" : "brunoerg",
         "node_id" : "MDQ6VXNlcjE5NDgwODE5",
         "organizations_url" : "https://api.github.com/users/brunoerg/orgs",
         "received_events_url" : "https://api.github.com/users/brunoerg/received_events",
         "repos_url" : "https://api.github.com/users/brunoerg/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/brunoerg/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/brunoerg/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/brunoerg"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335220434"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335220434"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In 2ecdc2183f0a1291730ae8728fa3d847b9cf80b5: Couldn't we prioritise more than 1 transaction?",
      "commit_id" : "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "created_at" : "2023-09-24T17:27:43Z",
      "diff_hunk" : "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335220434",
      "id" : 1335220434,
      "line" : 240,
      "node_id" : "PRRC_kwDOABII585PldjS",
      "original_commit_id" : "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "original_line" : 240,
      "original_position" : 240,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 240,
      "pull_request_review_id" : 1641097915,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335220434/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-24T17:27:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335220434",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19480819?v=4",
         "events_url" : "https://api.github.com/users/brunoerg/events{/privacy}",
         "followers_url" : "https://api.github.com/users/brunoerg/followers",
         "following_url" : "https://api.github.com/users/brunoerg/following{/other_user}",
         "gists_url" : "https://api.github.com/users/brunoerg/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/brunoerg",
         "id" : 19480819,
         "login" : "brunoerg",
         "node_id" : "MDQ6VXNlcjE5NDgwODE5",
         "organizations_url" : "https://api.github.com/users/brunoerg/orgs",
         "received_events_url" : "https://api.github.com/users/brunoerg/received_events",
         "repos_url" : "https://api.github.com/users/brunoerg/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/brunoerg/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/brunoerg/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/brunoerg"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335221272"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335221272"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In 2ecdc2183f0a1291730ae8728fa3d847b9cf80b5: Does it make sense to check whether the state is invalid if we previously assert that is valid?",
      "commit_id" : "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "created_at" : "2023-09-24T17:35:32Z",
      "diff_hunk" : "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;\n+        std::set<CTransactionRef> added;\n+        auto txr = std::make_shared<TransactionsDelta>(removed, added);\n+        RegisterSharedValidationInterface(txr);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+\n+        // Single-tx packages should be rejected, so do that sometimes, and sometimes send it via single submission\n+        // to allow it into the mempool by itself to make more interesting mempool packages\n+        auto single_submit = txs.size() == 1 && fuzzed_data_provider.ConsumeBool();\n+        auto package_submit = !single_submit;\n+\n+        const auto result_package = WITH_LOCK(::cs_main,\n+                                    return ProcessNewPackage(chainstate, tx_pool, txs, /*test_accept=*/!package_submit));\n+        // If something went wrong due to a package-specific policy, it might not return a\n+        // validation result for the transaction.\n+        if (result_package.m_state.GetResult() != PackageValidationResult::PCKG_POLICY) {\n+            auto it = result_package.m_tx_results.find(txs.back()->GetWitnessHash());\n+            Assert(it != result_package.m_tx_results.end());\n+            Assert(it->second.m_result_type == MempoolAcceptResult::ResultType::VALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::INVALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::MEMPOOL_ENTRY);\n+        }\n+\n+        const auto res = WITH_LOCK(::cs_main, return AcceptToMemoryPool(chainstate, txs.back(), GetTime(), bypass_limits, /*test_accept=*/!single_submit));\n+        const bool accepted = res.m_result_type == MempoolAcceptResult::ResultType::VALID;\n+\n+        SyncWithValidationInterfaceQueue();\n+        UnregisterSharedValidationInterface(txr);\n+\n+        if (single_submit) {\n+            Assert(accepted != added.empty());\n+            Assert(accepted == res.m_state.IsValid());\n+            Assert(accepted != res.m_state.IsInvalid());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335221272",
      "id" : 1335221272,
      "line" : 276,
      "node_id" : "PRRC_kwDOABII585PldwY",
      "original_commit_id" : "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "original_line" : 276,
      "original_position" : 276,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 276,
      "pull_request_review_id" : 1641098600,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335221272/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-24T19:22:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335221272",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19480819?v=4",
         "events_url" : "https://api.github.com/users/brunoerg/events{/privacy}",
         "followers_url" : "https://api.github.com/users/brunoerg/followers",
         "following_url" : "https://api.github.com/users/brunoerg/following{/other_user}",
         "gists_url" : "https://api.github.com/users/brunoerg/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/brunoerg",
         "id" : 19480819,
         "login" : "brunoerg",
         "node_id" : "MDQ6VXNlcjE5NDgwODE5",
         "organizations_url" : "https://api.github.com/users/brunoerg/orgs",
         "received_events_url" : "https://api.github.com/users/brunoerg/received_events",
         "repos_url" : "https://api.github.com/users/brunoerg/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/brunoerg/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/brunoerg/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/brunoerg"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335232415"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335232415"
         }
      },
      "author_association" : "MEMBER",
      "body" : "it's called for each package separately, sometimes, yes",
      "commit_id" : "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "created_at" : "2023-09-24T19:12:19Z",
      "diff_hunk" : "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335232415",
      "id" : 1335232415,
      "in_reply_to_id" : 1335215049,
      "line" : 230,
      "node_id" : "PRRC_kwDOABII585Plgef",
      "original_commit_id" : "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "original_line" : 230,
      "original_position" : 230,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 230,
      "pull_request_review_id" : 1641109462,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 1,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335232415/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-24T19:12:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335232415",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335232777"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335232777"
         }
      },
      "author_association" : "MEMBER",
      "body" : "yes, I'm not sure if it will end up covering more interesting cases though",
      "commit_id" : "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "created_at" : "2023-09-24T19:16:17Z",
      "diff_hunk" : "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335232777",
      "id" : 1335232777,
      "in_reply_to_id" : 1335220434,
      "line" : 240,
      "node_id" : "PRRC_kwDOABII585PlgkJ",
      "original_commit_id" : "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "original_line" : 240,
      "original_position" : 240,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 240,
      "pull_request_review_id" : 1641109814,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335232777/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-24T19:16:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335232777",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335232955"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335232955"
         }
      },
      "author_association" : "MEMBER",
      "body" : "sorry can you be a bit more explicit in what you're asking to do? ",
      "commit_id" : "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "created_at" : "2023-09-24T19:17:43Z",
      "diff_hunk" : "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;\n+        std::set<CTransactionRef> added;\n+        auto txr = std::make_shared<TransactionsDelta>(removed, added);\n+        RegisterSharedValidationInterface(txr);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+\n+        // Single-tx packages should be rejected, so do that sometimes, and sometimes send it via single submission\n+        // to allow it into the mempool by itself to make more interesting mempool packages\n+        auto single_submit = txs.size() == 1 && fuzzed_data_provider.ConsumeBool();\n+        auto package_submit = !single_submit;\n+\n+        const auto result_package = WITH_LOCK(::cs_main,\n+                                    return ProcessNewPackage(chainstate, tx_pool, txs, /*test_accept=*/!package_submit));\n+        // If something went wrong due to a package-specific policy, it might not return a\n+        // validation result for the transaction.\n+        if (result_package.m_state.GetResult() != PackageValidationResult::PCKG_POLICY) {\n+            auto it = result_package.m_tx_results.find(txs.back()->GetWitnessHash());\n+            Assert(it != result_package.m_tx_results.end());\n+            Assert(it->second.m_result_type == MempoolAcceptResult::ResultType::VALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::INVALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::MEMPOOL_ENTRY);\n+        }\n+\n+        const auto res = WITH_LOCK(::cs_main, return AcceptToMemoryPool(chainstate, txs.back(), GetTime(), bypass_limits, /*test_accept=*/!single_submit));\n+        const bool accepted = res.m_result_type == MempoolAcceptResult::ResultType::VALID;\n+\n+        SyncWithValidationInterfaceQueue();\n+        UnregisterSharedValidationInterface(txr);\n+\n+        if (single_submit) {\n+            Assert(accepted != added.empty());\n+            Assert(accepted == res.m_state.IsValid());\n+            Assert(accepted != res.m_state.IsInvalid());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335232955",
      "id" : 1335232955,
      "in_reply_to_id" : 1335221272,
      "line" : 276,
      "node_id" : "PRRC_kwDOABII585Plgm7",
      "original_commit_id" : "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "original_line" : 276,
      "original_position" : 276,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 276,
      "pull_request_review_id" : 1641109948,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335232955/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-24T19:17:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335232955",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335776752"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335776752"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Question: this effectively tests that `CreateNewBlock` creates a coinbase, is that intended?",
      "commit_id" : "3707ed7c0d02d86ff86c159bbd746acfa52db145",
      "created_at" : "2023-09-25T11:51:27Z",
      "diff_hunk" : "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335776752",
      "id" : 1335776752,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585PnlXw",
      "original_commit_id" : "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "original_line" : 84,
      "original_position" : 84,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : null,
      "pull_request_review_id" : 1641957355,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 1,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335776752/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-25T16:43:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335776752",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335782946"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335782946"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Could be slightly stronger by getting the descendant count of `tx_to_remove` and checking here that `all_txids.size() == info_all.size() - descendant_count`",
      "commit_id" : "3707ed7c0d02d86ff86c159bbd746acfa52db145",
      "created_at" : "2023-09-25T11:58:03Z",
      "diff_hunk" : "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335782946",
      "id" : 1335782946,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Pnm4i",
      "original_commit_id" : "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "original_line" : 92,
      "original_position" : 92,
      "original_start_line" : 89,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : null,
      "pull_request_review_id" : 1641957355,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 1,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335782946/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-09-25T16:43:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335782946",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335798543"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335798543"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think he's suggesting that the checks are redundant and to remove one",
      "commit_id" : "3707ed7c0d02d86ff86c159bbd746acfa52db145",
      "created_at" : "2023-09-25T12:11:47Z",
      "diff_hunk" : "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;\n+        std::set<CTransactionRef> added;\n+        auto txr = std::make_shared<TransactionsDelta>(removed, added);\n+        RegisterSharedValidationInterface(txr);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+\n+        // Single-tx packages should be rejected, so do that sometimes, and sometimes send it via single submission\n+        // to allow it into the mempool by itself to make more interesting mempool packages\n+        auto single_submit = txs.size() == 1 && fuzzed_data_provider.ConsumeBool();\n+        auto package_submit = !single_submit;\n+\n+        const auto result_package = WITH_LOCK(::cs_main,\n+                                    return ProcessNewPackage(chainstate, tx_pool, txs, /*test_accept=*/!package_submit));\n+        // If something went wrong due to a package-specific policy, it might not return a\n+        // validation result for the transaction.\n+        if (result_package.m_state.GetResult() != PackageValidationResult::PCKG_POLICY) {\n+            auto it = result_package.m_tx_results.find(txs.back()->GetWitnessHash());\n+            Assert(it != result_package.m_tx_results.end());\n+            Assert(it->second.m_result_type == MempoolAcceptResult::ResultType::VALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::INVALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::MEMPOOL_ENTRY);\n+        }\n+\n+        const auto res = WITH_LOCK(::cs_main, return AcceptToMemoryPool(chainstate, txs.back(), GetTime(), bypass_limits, /*test_accept=*/!single_submit));\n+        const bool accepted = res.m_result_type == MempoolAcceptResult::ResultType::VALID;\n+\n+        SyncWithValidationInterfaceQueue();\n+        UnregisterSharedValidationInterface(txr);\n+\n+        if (single_submit) {\n+            Assert(accepted != added.empty());\n+            Assert(accepted == res.m_state.IsValid());\n+            Assert(accepted != res.m_state.IsInvalid());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335798543",
      "id" : 1335798543,
      "in_reply_to_id" : 1335221272,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585PnqsP",
      "original_commit_id" : "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "original_line" : 276,
      "original_position" : 276,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : null,
      "pull_request_review_id" : 1641957355,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 1,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335798543/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-25T16:43:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335798543",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335807638"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335807638"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This was a bit confusing. Perhaps adding this comment beforehand would help clarify things\r\n\r\n\"When there are multiple transactions in the package, we call ProcessNewPackage(txs, test_accept=false) and AcceptToMemoryPool(txs.back(), test_accept=true). When there is only 1 transaction, we might flip it (the package is a test accept and ATMP is a submission).\"",
      "commit_id" : "3707ed7c0d02d86ff86c159bbd746acfa52db145",
      "created_at" : "2023-09-25T12:20:38Z",
      "diff_hunk" : "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;\n+        std::set<CTransactionRef> added;\n+        auto txr = std::make_shared<TransactionsDelta>(removed, added);\n+        RegisterSharedValidationInterface(txr);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+\n+        // Single-tx packages should be rejected, so do that sometimes, and sometimes send it via single submission\n+        // to allow it into the mempool by itself to make more interesting mempool packages\n+        auto single_submit = txs.size() == 1 && fuzzed_data_provider.ConsumeBool();\n+        auto package_submit = !single_submit;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335807638",
      "id" : 1335807638,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Pns6W",
      "original_commit_id" : "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "original_line" : 289,
      "original_position" : 253,
      "original_start_line" : 250,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : null,
      "pull_request_review_id" : 1641957355,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335807638/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-09-25T16:43:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335807638",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335839442"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335839442"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think achow is wondering if this is redundant with `outpoints_rbf`? Since new transactions are always created using `outpoints_rbf` inputs.",
      "commit_id" : "3707ed7c0d02d86ff86c159bbd746acfa52db145",
      "created_at" : "2023-09-25T12:46:05Z",
      "diff_hunk" : "@@ -0,0 +1,341 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335839442",
      "id" : 1335839442,
      "in_reply_to_id" : 1331487664,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Pn0rS",
      "original_commit_id" : "93d7c5c09c86f9543433d87a2ca074f35cac0fe6",
      "original_line" : 140,
      "original_position" : 140,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : null,
      "pull_request_review_id" : 1641957355,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 1,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335839442/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-25T16:43:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335839442",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335849114"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335849114"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This can also go under `if (!last_tx)`, right? There's no need to add the last tx's outputs since we won't need them",
      "commit_id" : "3707ed7c0d02d86ff86c159bbd746acfa52db145",
      "created_at" : "2023-09-25T12:53:46Z",
      "diff_hunk" : "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335849114",
      "id" : 1335849114,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Pn3Ca",
      "original_commit_id" : "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "original_line" : 257,
      "original_position" : 222,
      "original_start_line" : 218,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : null,
      "pull_request_review_id" : 1641957355,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 1,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335849114/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-09-25T16:43:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335849114",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335851668"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335851668"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Would be nice to remind ourselves what this means, e.g. \"There is only 1 transaction in the package. We did a test-package-accept and a ATMP\"",
      "commit_id" : "3707ed7c0d02d86ff86c159bbd746acfa52db145",
      "created_at" : "2023-09-25T12:55:51Z",
      "diff_hunk" : "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;\n+        std::set<CTransactionRef> added;\n+        auto txr = std::make_shared<TransactionsDelta>(removed, added);\n+        RegisterSharedValidationInterface(txr);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+\n+        // Single-tx packages should be rejected, so do that sometimes, and sometimes send it via single submission\n+        // to allow it into the mempool by itself to make more interesting mempool packages\n+        auto single_submit = txs.size() == 1 && fuzzed_data_provider.ConsumeBool();\n+        auto package_submit = !single_submit;\n+\n+        const auto result_package = WITH_LOCK(::cs_main,\n+                                    return ProcessNewPackage(chainstate, tx_pool, txs, /*test_accept=*/!package_submit));\n+        // If something went wrong due to a package-specific policy, it might not return a\n+        // validation result for the transaction.\n+        if (result_package.m_state.GetResult() != PackageValidationResult::PCKG_POLICY) {\n+            auto it = result_package.m_tx_results.find(txs.back()->GetWitnessHash());\n+            Assert(it != result_package.m_tx_results.end());\n+            Assert(it->second.m_result_type == MempoolAcceptResult::ResultType::VALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::INVALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::MEMPOOL_ENTRY);\n+        }\n+\n+        const auto res = WITH_LOCK(::cs_main, return AcceptToMemoryPool(chainstate, txs.back(), GetTime(), bypass_limits, /*test_accept=*/!single_submit));\n+        const bool accepted = res.m_result_type == MempoolAcceptResult::ResultType::VALID;\n+\n+        SyncWithValidationInterfaceQueue();\n+        UnregisterSharedValidationInterface(txr);\n+\n+        if (single_submit) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335851668",
      "id" : 1335851668,
      "line" : 310,
      "node_id" : "PRRC_kwDOABII585Pn3qU",
      "original_commit_id" : "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "original_line" : 310,
      "original_position" : 273,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 310,
      "pull_request_review_id" : 1641957355,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 1,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335851668/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-25T16:43:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335851668",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335863257"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335863257"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Question: this means transactions in the package can conflict with each other, right? It's possible to select the same outpoint from `outpoints_rbf` for 2 parents in the same package?",
      "commit_id" : "3707ed7c0d02d86ff86c159bbd746acfa52db145",
      "created_at" : "2023-09-25T13:05:51Z",
      "diff_hunk" : "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335863257",
      "id" : 1335863257,
      "line" : 244,
      "node_id" : "PRRC_kwDOABII585Pn6fZ",
      "original_commit_id" : "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "original_line" : 244,
      "original_position" : 212,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 244,
      "pull_request_review_id" : 1641957355,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 1,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335863257/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-25T16:43:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335863257",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335867121"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335867121"
         }
      },
      "author_association" : "MEMBER",
      "body" : "maybe add `Assert(!outpoints_rbf.empty())` at the top",
      "commit_id" : "3707ed7c0d02d86ff86c159bbd746acfa52db145",
      "created_at" : "2023-09-25T13:09:17Z",
      "diff_hunk" : "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335867121",
      "id" : 1335867121,
      "line" : 203,
      "node_id" : "PRRC_kwDOABII585Pn7bx",
      "original_commit_id" : "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "original_line" : 203,
      "original_position" : 174,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 203,
      "pull_request_review_id" : 1641957355,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 1,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335867121/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-25T16:43:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335867121",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335872892"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335872892"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This is kinda convoluted... could we just update `outpoints_supply` and `outpoints_rbf` directly on the `TransactionAddedToMempool` and `TransactionRemovedFromMempool` callbacks instead of the added/removed sets? took a stab in https://github.com/glozow/bitcoin/commit/df433f82364502b443d433918af0a0cf4196d210",
      "commit_id" : "3707ed7c0d02d86ff86c159bbd746acfa52db145",
      "created_at" : "2023-09-25T13:14:07Z",
      "diff_hunk" : "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;\n+        std::set<CTransactionRef> added;\n+        auto txr = std::make_shared<TransactionsDelta>(removed, added);\n+        RegisterSharedValidationInterface(txr);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+\n+        // Single-tx packages should be rejected, so do that sometimes, and sometimes send it via single submission\n+        // to allow it into the mempool by itself to make more interesting mempool packages\n+        auto single_submit = txs.size() == 1 && fuzzed_data_provider.ConsumeBool();\n+        auto package_submit = !single_submit;\n+\n+        const auto result_package = WITH_LOCK(::cs_main,\n+                                    return ProcessNewPackage(chainstate, tx_pool, txs, /*test_accept=*/!package_submit));\n+        // If something went wrong due to a package-specific policy, it might not return a\n+        // validation result for the transaction.\n+        if (result_package.m_state.GetResult() != PackageValidationResult::PCKG_POLICY) {\n+            auto it = result_package.m_tx_results.find(txs.back()->GetWitnessHash());\n+            Assert(it != result_package.m_tx_results.end());\n+            Assert(it->second.m_result_type == MempoolAcceptResult::ResultType::VALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::INVALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::MEMPOOL_ENTRY);\n+        }\n+\n+        const auto res = WITH_LOCK(::cs_main, return AcceptToMemoryPool(chainstate, txs.back(), GetTime(), bypass_limits, /*test_accept=*/!single_submit));\n+        const bool accepted = res.m_result_type == MempoolAcceptResult::ResultType::VALID;\n+\n+        SyncWithValidationInterfaceQueue();\n+        UnregisterSharedValidationInterface(txr);\n+\n+        if (single_submit) {\n+            Assert(accepted != added.empty());\n+            Assert(accepted == res.m_state.IsValid());\n+            Assert(accepted != res.m_state.IsInvalid());\n+            if (accepted) {\n+                Assert(added.size() == 1);\n+                Assert(txs.back() == *added.begin());\n+            } else {\n+                // Do not consider rejected transaction removed\n+                removed.erase(txs.back());\n+            }\n+        } else {\n+            // This is empty if it fails early checks, or \"full\" if transactions are looked at deeper\n+            Assert(result_package.m_tx_results.size() == txs.size() || result_package.m_tx_results.empty());\n+            if (result_package.m_state.GetResult() == PackageValidationResult::PCKG_POLICY) {\n+                for (const auto& tx : txs) {\n+                    removed.erase(tx);\n+                }\n+            } else {\n+                for (const auto& [k, v] : result_package.m_tx_results) {\n+                    if (v.m_result_type == MempoolAcceptResult::ResultType::INVALID) {\n+                        removed.erase(wtxid_to_tx[k]);\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Helper to insert spent and created outpoints of a tx into collections\n+        using Sets = std::vector<std::reference_wrapper<std::set<COutPoint>>>;\n+        const auto insert_tx = [](Sets created_by_tx, Sets consumed_by_tx, const auto& tx) {\n+            for (size_t i{0}; i < tx.vout.size(); ++i) {\n+                for (auto& set : created_by_tx) {\n+                    set.get().emplace(tx.GetHash(), i);\n+                }\n+            }\n+            for (const auto& in : tx.vin) {\n+                for (auto& set : consumed_by_tx) {\n+                    set.get().insert(in.prevout);\n+                }\n+            }\n+        };\n+\n+        // Add created outpoints, remove spent outpoints\n+        {\n+            // Outpoints that no longer exist at all\n+            std::set<COutPoint> consumed_erased;\n+            // Outpoints that no longer count toward the total supply\n+            std::set<COutPoint> consumed_supply;\n+            for (const auto& removed_tx : removed) {\n+                insert_tx(/*created_by_tx=*/{consumed_erased}, /*consumed_by_tx=*/{outpoints_supply}, /*tx=*/*removed_tx);\n+            }\n+            for (const auto& added_tx : added) {\n+                insert_tx(/*created_by_tx=*/{outpoints_supply, outpoints_rbf}, /*consumed_by_tx=*/{consumed_supply}, /*tx=*/*added_tx);\n+            }\n+            for (const auto& p : consumed_erased) {\n+                outpoints_supply.erase(p);\n+                outpoints_rbf.erase(p);\n+            }\n+            for (const auto& p : consumed_supply) {\n+                outpoints_supply.erase(p);\n+            }\n+        }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335872892",
      "id" : 1335872892,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Pn818",
      "original_commit_id" : "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "original_line" : 334,
      "original_position" : 334,
      "original_start_line" : 315,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : null,
      "pull_request_review_id" : 1641957355,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 1,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335872892/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-09-25T16:43:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335872892",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1336145901"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1336145901"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Also... wondering why allow `num_txs` to be less than 2 anyway? Isn't this test kind of the same as what's in the tx_pool fuzzer?",
      "commit_id" : "3707ed7c0d02d86ff86c159bbd746acfa52db145",
      "created_at" : "2023-09-25T16:41:58Z",
      "diff_hunk" : "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;\n+        std::set<CTransactionRef> added;\n+        auto txr = std::make_shared<TransactionsDelta>(removed, added);\n+        RegisterSharedValidationInterface(txr);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+\n+        // Single-tx packages should be rejected, so do that sometimes, and sometimes send it via single submission\n+        // to allow it into the mempool by itself to make more interesting mempool packages\n+        auto single_submit = txs.size() == 1 && fuzzed_data_provider.ConsumeBool();\n+        auto package_submit = !single_submit;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1336145901",
      "id" : 1336145901,
      "in_reply_to_id" : 1335807638,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Po_ft",
      "original_commit_id" : "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "original_line" : 289,
      "original_position" : 253,
      "original_start_line" : 250,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : null,
      "pull_request_review_id" : 1641957355,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 1,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1336145901/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-09-25T16:43:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1336145901",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "CI failure is a functional test so I'd assume unrelated",
      "created_at" : "2023-09-25T16:45:14Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1734117140",
      "id" : 1734117140,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28450",
      "node_id" : "IC_kwDOABII585nXIcU",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 1,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1734117140/reactions"
      },
      "updated_at" : "2023-09-25T16:45:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1734117140",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Made a coverage report: https://dergoegge.github.io/bitcoin-coverage/pr28450/fuzz.coverage/index.html",
      "created_at" : "2023-09-26T10:24:53Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1735258305",
      "id" : 1735258305,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28450",
      "node_id" : "IC_kwDOABII585nbfDB",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1735258305/reactions"
      },
      "updated_at" : "2023-09-26T10:24:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1735258305",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Made a coverage report: https://dergoegge.github.io/bitcoin-coverage/pr28450/fuzz.coverage/index.html\r\n\r\nLooks pretty good to me, noting the main missing bits:\r\n- same-txid-different-witness\r\n- policy script checks failing\r\n- bad-txns-too-many-sigops\r\n- being granted CPFP carve out and then failing\r\n\r\n^which have already been marked as followups.\r\n\r\nThere's no package-not-child-with-unconfirmed-parents which is by design. Also looks like RBF rules are red, perhaps it'll take a while to hit them?",
      "created_at" : "2023-09-26T11:12:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1735324430",
      "id" : 1735324430,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28450",
      "node_id" : "IC_kwDOABII585nbvMO",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1735324430/reactions"
      },
      "updated_at" : "2023-09-26T11:12:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1735324430",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Also looks like RBF rules are red, perhaps it'll take a while to hit them?\r\n\r\nThe seed corpus from the report was the result of 5000+ cpu hours, so I'd say it's likely just not able to hit the rbf paths.",
      "created_at" : "2023-09-26T12:04:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1735410372",
      "id" : 1735410372,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28450",
      "node_id" : "IC_kwDOABII585ncELE",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1735410372/reactions"
      },
      "updated_at" : "2023-09-26T12:04:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1735410372",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1337226446"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337226446"
         }
      },
      "author_association" : "MEMBER",
      "body" : "was used prior but no longer, removed until it's needed again",
      "commit_id" : "3707ed7c0d02d86ff86c159bbd746acfa52db145",
      "created_at" : "2023-09-26T13:38:49Z",
      "diff_hunk" : "@@ -0,0 +1,341 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1337226446",
      "id" : 1337226446,
      "in_reply_to_id" : 1331487664,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585PtHTO",
      "original_commit_id" : "93d7c5c09c86f9543433d87a2ca074f35cac0fe6",
      "original_line" : 140,
      "original_position" : 140,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : null,
      "pull_request_review_id" : 1644297068,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337226446/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-26T13:38:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337226446",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1337227133"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337227133"
         }
      },
      "author_association" : "MEMBER",
      "body" : "removed as it's not very interesting a check",
      "commit_id" : "3707ed7c0d02d86ff86c159bbd746acfa52db145",
      "created_at" : "2023-09-26T13:39:15Z",
      "diff_hunk" : "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1337227133",
      "id" : 1337227133,
      "in_reply_to_id" : 1335776752,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585PtHd9",
      "original_commit_id" : "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "original_line" : 84,
      "original_position" : 84,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : null,
      "pull_request_review_id" : 1644298098,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337227133/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-26T13:39:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337227133",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1337227312"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337227312"
         }
      },
      "author_association" : "MEMBER",
      "body" : "done",
      "commit_id" : "3707ed7c0d02d86ff86c159bbd746acfa52db145",
      "created_at" : "2023-09-26T13:39:23Z",
      "diff_hunk" : "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1337227312",
      "id" : 1337227312,
      "in_reply_to_id" : 1335782946,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585PtHgw",
      "original_commit_id" : "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "original_line" : 92,
      "original_position" : 92,
      "original_start_line" : 89,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : null,
      "pull_request_review_id" : 1644298410,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337227312/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-09-26T13:39:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337227312",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1337227564"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337227564"
         }
      },
      "author_association" : "MEMBER",
      "body" : "taken, thanks",
      "commit_id" : "3707ed7c0d02d86ff86c159bbd746acfa52db145",
      "created_at" : "2023-09-26T13:39:35Z",
      "diff_hunk" : "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;\n+        std::set<CTransactionRef> added;\n+        auto txr = std::make_shared<TransactionsDelta>(removed, added);\n+        RegisterSharedValidationInterface(txr);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+\n+        // Single-tx packages should be rejected, so do that sometimes, and sometimes send it via single submission\n+        // to allow it into the mempool by itself to make more interesting mempool packages\n+        auto single_submit = txs.size() == 1 && fuzzed_data_provider.ConsumeBool();\n+        auto package_submit = !single_submit;\n+\n+        const auto result_package = WITH_LOCK(::cs_main,\n+                                    return ProcessNewPackage(chainstate, tx_pool, txs, /*test_accept=*/!package_submit));\n+        // If something went wrong due to a package-specific policy, it might not return a\n+        // validation result for the transaction.\n+        if (result_package.m_state.GetResult() != PackageValidationResult::PCKG_POLICY) {\n+            auto it = result_package.m_tx_results.find(txs.back()->GetWitnessHash());\n+            Assert(it != result_package.m_tx_results.end());\n+            Assert(it->second.m_result_type == MempoolAcceptResult::ResultType::VALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::INVALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::MEMPOOL_ENTRY);\n+        }\n+\n+        const auto res = WITH_LOCK(::cs_main, return AcceptToMemoryPool(chainstate, txs.back(), GetTime(), bypass_limits, /*test_accept=*/!single_submit));\n+        const bool accepted = res.m_result_type == MempoolAcceptResult::ResultType::VALID;\n+\n+        SyncWithValidationInterfaceQueue();\n+        UnregisterSharedValidationInterface(txr);\n+\n+        if (single_submit) {\n+            Assert(accepted != added.empty());\n+            Assert(accepted == res.m_state.IsValid());\n+            Assert(accepted != res.m_state.IsInvalid());\n+            if (accepted) {\n+                Assert(added.size() == 1);\n+                Assert(txs.back() == *added.begin());\n+            } else {\n+                // Do not consider rejected transaction removed\n+                removed.erase(txs.back());\n+            }\n+        } else {\n+            // This is empty if it fails early checks, or \"full\" if transactions are looked at deeper\n+            Assert(result_package.m_tx_results.size() == txs.size() || result_package.m_tx_results.empty());\n+            if (result_package.m_state.GetResult() == PackageValidationResult::PCKG_POLICY) {\n+                for (const auto& tx : txs) {\n+                    removed.erase(tx);\n+                }\n+            } else {\n+                for (const auto& [k, v] : result_package.m_tx_results) {\n+                    if (v.m_result_type == MempoolAcceptResult::ResultType::INVALID) {\n+                        removed.erase(wtxid_to_tx[k]);\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Helper to insert spent and created outpoints of a tx into collections\n+        using Sets = std::vector<std::reference_wrapper<std::set<COutPoint>>>;\n+        const auto insert_tx = [](Sets created_by_tx, Sets consumed_by_tx, const auto& tx) {\n+            for (size_t i{0}; i < tx.vout.size(); ++i) {\n+                for (auto& set : created_by_tx) {\n+                    set.get().emplace(tx.GetHash(), i);\n+                }\n+            }\n+            for (const auto& in : tx.vin) {\n+                for (auto& set : consumed_by_tx) {\n+                    set.get().insert(in.prevout);\n+                }\n+            }\n+        };\n+\n+        // Add created outpoints, remove spent outpoints\n+        {\n+            // Outpoints that no longer exist at all\n+            std::set<COutPoint> consumed_erased;\n+            // Outpoints that no longer count toward the total supply\n+            std::set<COutPoint> consumed_supply;\n+            for (const auto& removed_tx : removed) {\n+                insert_tx(/*created_by_tx=*/{consumed_erased}, /*consumed_by_tx=*/{outpoints_supply}, /*tx=*/*removed_tx);\n+            }\n+            for (const auto& added_tx : added) {\n+                insert_tx(/*created_by_tx=*/{outpoints_supply, outpoints_rbf}, /*consumed_by_tx=*/{consumed_supply}, /*tx=*/*added_tx);\n+            }\n+            for (const auto& p : consumed_erased) {\n+                outpoints_supply.erase(p);\n+                outpoints_rbf.erase(p);\n+            }\n+            for (const auto& p : consumed_supply) {\n+                outpoints_supply.erase(p);\n+            }\n+        }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1337227564",
      "id" : 1337227564,
      "in_reply_to_id" : 1335872892,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585PtHks",
      "original_commit_id" : "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "original_line" : 334,
      "original_position" : 334,
      "original_start_line" : 315,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : null,
      "pull_request_review_id" : 1644298870,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337227564/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-09-26T13:39:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337227564",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1337227691"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337227691"
         }
      },
      "author_association" : "MEMBER",
      "body" : "done",
      "commit_id" : "3707ed7c0d02d86ff86c159bbd746acfa52db145",
      "created_at" : "2023-09-26T13:39:39Z",
      "diff_hunk" : "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1337227691",
      "id" : 1337227691,
      "in_reply_to_id" : 1335867121,
      "line" : 203,
      "node_id" : "PRRC_kwDOABII585PtHmr",
      "original_commit_id" : "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "original_line" : 203,
      "original_position" : 174,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 203,
      "pull_request_review_id" : 1644299068,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337227691/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-26T13:39:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337227691",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1337227987"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337227987"
         }
      },
      "author_association" : "MEMBER",
      "body" : "yes",
      "commit_id" : "3707ed7c0d02d86ff86c159bbd746acfa52db145",
      "created_at" : "2023-09-26T13:39:46Z",
      "diff_hunk" : "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1337227987",
      "id" : 1337227987,
      "in_reply_to_id" : 1335863257,
      "line" : 244,
      "node_id" : "PRRC_kwDOABII585PtHrT",
      "original_commit_id" : "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "original_line" : 244,
      "original_position" : 212,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 244,
      "pull_request_review_id" : 1644299448,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337227987/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-26T13:39:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337227987",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1337228126"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337228126"
         }
      },
      "author_association" : "MEMBER",
      "body" : "done",
      "commit_id" : "3707ed7c0d02d86ff86c159bbd746acfa52db145",
      "created_at" : "2023-09-26T13:39:50Z",
      "diff_hunk" : "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;\n+        std::set<CTransactionRef> added;\n+        auto txr = std::make_shared<TransactionsDelta>(removed, added);\n+        RegisterSharedValidationInterface(txr);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+\n+        // Single-tx packages should be rejected, so do that sometimes, and sometimes send it via single submission\n+        // to allow it into the mempool by itself to make more interesting mempool packages\n+        auto single_submit = txs.size() == 1 && fuzzed_data_provider.ConsumeBool();\n+        auto package_submit = !single_submit;\n+\n+        const auto result_package = WITH_LOCK(::cs_main,\n+                                    return ProcessNewPackage(chainstate, tx_pool, txs, /*test_accept=*/!package_submit));\n+        // If something went wrong due to a package-specific policy, it might not return a\n+        // validation result for the transaction.\n+        if (result_package.m_state.GetResult() != PackageValidationResult::PCKG_POLICY) {\n+            auto it = result_package.m_tx_results.find(txs.back()->GetWitnessHash());\n+            Assert(it != result_package.m_tx_results.end());\n+            Assert(it->second.m_result_type == MempoolAcceptResult::ResultType::VALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::INVALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::MEMPOOL_ENTRY);\n+        }\n+\n+        const auto res = WITH_LOCK(::cs_main, return AcceptToMemoryPool(chainstate, txs.back(), GetTime(), bypass_limits, /*test_accept=*/!single_submit));\n+        const bool accepted = res.m_result_type == MempoolAcceptResult::ResultType::VALID;\n+\n+        SyncWithValidationInterfaceQueue();\n+        UnregisterSharedValidationInterface(txr);\n+\n+        if (single_submit) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1337228126",
      "id" : 1337228126,
      "in_reply_to_id" : 1335851668,
      "line" : 310,
      "node_id" : "PRRC_kwDOABII585PtHte",
      "original_commit_id" : "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "original_line" : 310,
      "original_position" : 273,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 310,
      "pull_request_review_id" : 1644299658,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337228126/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-26T13:39:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337228126",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1337228741"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337228741"
         }
      },
      "author_association" : "MEMBER",
      "body" : "done, had to keep the outpoints_value check outside though since it needs all generated outpoints",
      "commit_id" : "3707ed7c0d02d86ff86c159bbd746acfa52db145",
      "created_at" : "2023-09-26T13:40:06Z",
      "diff_hunk" : "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1337228741",
      "id" : 1337228741,
      "in_reply_to_id" : 1335849114,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585PtH3F",
      "original_commit_id" : "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "original_line" : 257,
      "original_position" : 222,
      "original_start_line" : 218,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : null,
      "pull_request_review_id" : 1644300692,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337228741/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-09-26T13:40:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337228741",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1337231154"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337231154"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> Also... wondering why allow num_txs to be less than 2 anyway?\r\n\r\n1) it can get rejected by ProcessNewPackage\r\n2) it can cause the existing mempool to be somewhat more interesting maybe",
      "commit_id" : "3707ed7c0d02d86ff86c159bbd746acfa52db145",
      "created_at" : "2023-09-26T13:40:47Z",
      "diff_hunk" : "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;\n+        std::set<CTransactionRef> added;\n+        auto txr = std::make_shared<TransactionsDelta>(removed, added);\n+        RegisterSharedValidationInterface(txr);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+\n+        // Single-tx packages should be rejected, so do that sometimes, and sometimes send it via single submission\n+        // to allow it into the mempool by itself to make more interesting mempool packages\n+        auto single_submit = txs.size() == 1 && fuzzed_data_provider.ConsumeBool();\n+        auto package_submit = !single_submit;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1337231154",
      "id" : 1337231154,
      "in_reply_to_id" : 1335807638,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585PtIcy",
      "original_commit_id" : "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "original_line" : 289,
      "original_position" : 253,
      "original_start_line" : 250,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : null,
      "pull_request_review_id" : 1644304537,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337231154/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-09-26T13:40:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337231154",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Also looks like RBF rules are red, perhaps it'll take a while to hit them?\r\n\r\nA couple of those cases would look difficult to hit without intention/design to do so. One I'm unsure how it hasn't been hit, something to look at later especially as we approach package rbf.\r\n\r\n> I think achow is wondering if this is redundant with outpoints_rbf? Since new transactions are always created using outpoints_rbf inputs.\r\n\r\nCan't find the actual place to reply(thanks github), removed outpoints_supply entirely as it's vestigial\r\n\r\n----\r\n\r\nTook all suggestions, pushed\r\n\r\n",
      "created_at" : "2023-09-26T13:42:04Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1735569725",
      "id" : 1735569725,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28450",
      "node_id" : "IC_kwDOABII585ncrE9",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1735569725/reactions"
      },
      "updated_at" : "2023-09-26T13:44:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1735569725",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1337364357"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337364357"
         }
      },
      "author_association" : "MEMBER",
      "body" : "note: `g_outpoints_coinbase_init_immature` seems unused rn, I assume the plan is to maybe spend immature coinbases later?",
      "commit_id" : "3707ed7c0d02d86ff86c159bbd746acfa52db145",
      "created_at" : "2023-09-26T15:03:51Z",
      "diff_hunk" : "@@ -0,0 +1,341 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1337364357",
      "id" : 1337364357,
      "line" : 28,
      "node_id" : "PRRC_kwDOABII585Pto-F",
      "original_commit_id" : "3707ed7c0d02d86ff86c159bbd746acfa52db145",
      "original_line" : 28,
      "original_position" : 28,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 28,
      "pull_request_review_id" : 1644525101,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337364357/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-26T15:20:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337364357",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1337366755"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337366755"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: `outpoints_rbf` contains unconfirmed, no?\r\n```suggestion\r\n            // Note that this test currently only spends package outputs in last transaction.\r\n```",
      "commit_id" : "3707ed7c0d02d86ff86c159bbd746acfa52db145",
      "created_at" : "2023-09-26T15:05:30Z",
      "diff_hunk" : "@@ -0,0 +1,341 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct OutpointsUpdater final : public CValidationInterface {\n+    std::set<COutPoint>& m_outpoints_rbf;\n+\n+    explicit OutpointsUpdater(std::set<COutPoint>& r)\n+        : m_outpoints_rbf{r} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // for coins spent we always want to be able to rbf so they're not removed\n+\n+        // outputs from this tx can now be spent\n+        for (uint32_t index{0}; index < tx->vout.size(); ++index) {\n+            m_outpoints_rbf.insert(COutPoint{tx->GetHash(), index});\n+        }\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // outpoints spent by this tx are now available\n+        for (const auto& input : tx->vin) {\n+            // Could already exist if this was a replacement\n+            m_outpoints_rbf.insert(input.prevout);\n+        }\n+        // outpoints created by this tx no longer exist\n+        for (uint32_t index{0}; index < tx->vout.size(); ++index) {\n+            m_outpoints_rbf.erase(COutPoint{tx->GetHash(), index});\n+        }\n+    }\n+};\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        const auto tx_it = WITH_LOCK(tx_pool.cs, return tx_pool.mapTx.find(tx_to_remove.GetHash()));\n+        size_t num_descendants = tx_it->GetCountWithDescendants();\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() == info_all.size() - num_descendants);\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the unsubmitted package\n+    std::set<COutPoint> outpoints_rbf;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_rbf.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    auto outpoints_updater = std::make_shared<OutpointsUpdater>(outpoints_rbf);\n+    RegisterSharedValidationInterface(outpoints_updater);\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_rbf.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1337366755",
      "id" : 1337366755,
      "line" : 199,
      "node_id" : "PRRC_kwDOABII585Ptpjj",
      "original_commit_id" : "3707ed7c0d02d86ff86c159bbd746acfa52db145",
      "original_line" : 199,
      "original_position" : 199,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 199,
      "pull_request_review_id" : 1644525101,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337366755/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-26T15:20:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337366755",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1337375763"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337375763"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: I think these `removed.erase()` calls might be unnecessary now that you don't use it to update `outpoints_rbf`.",
      "commit_id" : "3707ed7c0d02d86ff86c159bbd746acfa52db145",
      "created_at" : "2023-09-26T15:11:51Z",
      "diff_hunk" : "@@ -0,0 +1,341 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct OutpointsUpdater final : public CValidationInterface {\n+    std::set<COutPoint>& m_outpoints_rbf;\n+\n+    explicit OutpointsUpdater(std::set<COutPoint>& r)\n+        : m_outpoints_rbf{r} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // for coins spent we always want to be able to rbf so they're not removed\n+\n+        // outputs from this tx can now be spent\n+        for (uint32_t index{0}; index < tx->vout.size(); ++index) {\n+            m_outpoints_rbf.insert(COutPoint{tx->GetHash(), index});\n+        }\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // outpoints spent by this tx are now available\n+        for (const auto& input : tx->vin) {\n+            // Could already exist if this was a replacement\n+            m_outpoints_rbf.insert(input.prevout);\n+        }\n+        // outpoints created by this tx no longer exist\n+        for (uint32_t index{0}; index < tx->vout.size(); ++index) {\n+            m_outpoints_rbf.erase(COutPoint{tx->GetHash(), index});\n+        }\n+    }\n+};\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        const auto tx_it = WITH_LOCK(tx_pool.cs, return tx_pool.mapTx.find(tx_to_remove.GetHash()));\n+        size_t num_descendants = tx_it->GetCountWithDescendants();\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() == info_all.size() - num_descendants);\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the unsubmitted package\n+    std::set<COutPoint> outpoints_rbf;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_rbf.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    auto outpoints_updater = std::make_shared<OutpointsUpdater>(outpoints_rbf);\n+    RegisterSharedValidationInterface(outpoints_updater);\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_rbf.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                Assert(!outpoints.empty());\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    // no need to update or erase from outpoints_value\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                    // Cache the in-package outpoints being made\n+                    for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                        package_outpoints.emplace(tx->GetHash(), i);\n+                    }\n+                }\n+                // We need newly-created values for the duration of this run\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;\n+        std::set<CTransactionRef> added;\n+        auto txr = std::make_shared<TransactionsDelta>(removed, added);\n+        RegisterSharedValidationInterface(txr);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+\n+        // When there are multiple transactions in the package, we call ProcessNewPackage(txs, test_accept=false)\n+        // and AcceptToMemoryPool(txs.back(), test_accept=true). When there is only 1 transaction, we might flip it\n+        // (the package is a test accept and ATMP is a submission).\n+        auto single_submit = txs.size() == 1 && fuzzed_data_provider.ConsumeBool();\n+        auto package_submit = !single_submit;\n+\n+        const auto result_package = WITH_LOCK(::cs_main,\n+                                    return ProcessNewPackage(chainstate, tx_pool, txs, /*test_accept=*/!package_submit));\n+        // If something went wrong due to a package-specific policy, it might not return a\n+        // validation result for the transaction.\n+        if (result_package.m_state.GetResult() != PackageValidationResult::PCKG_POLICY) {\n+            auto it = result_package.m_tx_results.find(txs.back()->GetWitnessHash());\n+            Assert(it != result_package.m_tx_results.end());\n+            Assert(it->second.m_result_type == MempoolAcceptResult::ResultType::VALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::INVALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::MEMPOOL_ENTRY);\n+        }\n+\n+        const auto res = WITH_LOCK(::cs_main, return AcceptToMemoryPool(chainstate, txs.back(), GetTime(), bypass_limits, /*test_accept=*/!single_submit));\n+        const bool accepted = res.m_result_type == MempoolAcceptResult::ResultType::VALID;\n+\n+        SyncWithValidationInterfaceQueue();\n+        UnregisterSharedValidationInterface(txr);\n+\n+        // There is only 1 transaction in the package. We did a test-package-accept and a ATMP\n+        if (single_submit) {\n+            Assert(accepted != added.empty());\n+            Assert(accepted == res.m_state.IsValid());\n+            if (accepted) {\n+                Assert(added.size() == 1);\n+                Assert(txs.back() == *added.begin());\n+            } else {\n+                // Do not consider rejected transaction removed\n+                removed.erase(txs.back());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1337375763",
      "id" : 1337375763,
      "line" : 318,
      "node_id" : "PRRC_kwDOABII585PtrwT",
      "original_commit_id" : "3707ed7c0d02d86ff86c159bbd746acfa52db145",
      "original_line" : 318,
      "original_position" : 318,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 318,
      "pull_request_review_id" : 1644525101,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337375763/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-26T15:20:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337375763",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   }
]
