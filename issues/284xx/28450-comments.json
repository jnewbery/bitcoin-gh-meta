[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| Concept ACK | [darosior](https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1713984415), [glozow](https://github.com/bitcoin/bitcoin/pull/28450#pullrequestreview-1620122880), [dergoegge](https://github.com/bitcoin/bitcoin/pull/28450#pullrequestreview-1620240896), [brunoerg](https://github.com/bitcoin/bitcoin/pull/28450#pullrequestreview-1622579860), [MarcoFalke](https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1719137408) |\n\nIf your review is incorrectly listed, please react with ð to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nNo conflicts as of last run.\n",
      "created_at" : "2023-09-11T14:10:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1713970394",
      "id" : 1713970394,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28450",
      "node_id" : "IC_kwDOABII585mKRza",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 1,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1713970394/reactions"
      },
      "updated_at" : "2023-09-14T09:52:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1713970394",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "cc @glozow @MarcoFalke ",
      "created_at" : "2023-09-11T14:11:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1713971539",
      "id" : 1713971539,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28450",
      "node_id" : "IC_kwDOABII585mKSFT",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1713971539/reactions"
      },
      "updated_at" : "2023-09-11T14:11:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1713971539",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1321625656"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1321625656"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Maybe worth adding `-bytespersigop` too?",
      "commit_id" : "3654ad4152f139e6583f819d7d039fd7cdd5dc7f",
      "created_at" : "2023-09-11T14:15:13Z",
      "diff_hunk" : "@@ -0,0 +1,349 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void SetMempoolConstraints(ArgsManager& args, FuzzedDataProvider& fuzzed_data_provider)\n+{\n+    args.ForceSetArg(\"-limitancestorcount\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50)));\n+    args.ForceSetArg(\"-limitancestorsize\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202)));\n+    args.ForceSetArg(\"-limitdescendantcount\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50)));\n+    args.ForceSetArg(\"-limitdescendantsize\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202)));\n+    args.ForceSetArg(\"-maxmempool\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200)));\n+    args.ForceSetArg(\"-mempoolexpiry\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1321625656",
      "id" : 1321625656,
      "line" : 88,
      "node_id" : "PRRC_kwDOABII585Oxmg4",
      "original_commit_id" : "f06cf5b0549b741f6825e8dfea8ee97bcf7ed572",
      "original_line" : 88,
      "original_position" : 88,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 88,
      "pull_request_review_id" : 1620122880,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1321625656/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-11T14:22:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1321625656",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Awesome, Concept ACK.",
      "created_at" : "2023-09-11T14:18:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1713984415",
      "id" : 1713984415,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28450",
      "node_id" : "IC_kwDOABII585mKVOf",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1713984415/reactions"
      },
      "updated_at" : "2023-09-11T14:18:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1713984415",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22457751?v=4",
         "events_url" : "https://api.github.com/users/darosior/events{/privacy}",
         "followers_url" : "https://api.github.com/users/darosior/followers",
         "following_url" : "https://api.github.com/users/darosior/following{/other_user}",
         "gists_url" : "https://api.github.com/users/darosior/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/darosior",
         "id" : 22457751,
         "login" : "darosior",
         "node_id" : "MDQ6VXNlcjIyNDU3NzUx",
         "organizations_url" : "https://api.github.com/users/darosior/orgs",
         "received_events_url" : "https://api.github.com/users/darosior/received_events",
         "repos_url" : "https://api.github.com/users/darosior/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/darosior/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/darosior/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/darosior"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1321690708"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1321690708"
         }
      },
      "author_association" : "MEMBER",
      "body" : "to take advantage of this, probably would need to do some bare mulitisigs? wouldn't hurt to add I suppose",
      "commit_id" : "3654ad4152f139e6583f819d7d039fd7cdd5dc7f",
      "created_at" : "2023-09-11T15:02:07Z",
      "diff_hunk" : "@@ -0,0 +1,349 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void SetMempoolConstraints(ArgsManager& args, FuzzedDataProvider& fuzzed_data_provider)\n+{\n+    args.ForceSetArg(\"-limitancestorcount\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50)));\n+    args.ForceSetArg(\"-limitancestorsize\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202)));\n+    args.ForceSetArg(\"-limitdescendantcount\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50)));\n+    args.ForceSetArg(\"-limitdescendantsize\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202)));\n+    args.ForceSetArg(\"-maxmempool\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200)));\n+    args.ForceSetArg(\"-mempoolexpiry\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1321690708",
      "id" : 1321690708,
      "in_reply_to_id" : 1321625656,
      "line" : 88,
      "node_id" : "PRRC_kwDOABII585Ox2ZU",
      "original_commit_id" : "f06cf5b0549b741f6825e8dfea8ee97bcf7ed572",
      "original_line" : 88,
      "original_position" : 88,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 88,
      "pull_request_review_id" : 1620226361,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1321690708/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-11T15:02:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1321690708",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1321699963"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1321699963"
         }
      },
      "author_association" : "MEMBER",
      "body" : "could set all the options here instead of round tripping through the args man?",
      "commit_id" : "3654ad4152f139e6583f819d7d039fd7cdd5dc7f",
      "created_at" : "2023-09-11T15:08:06Z",
      "diff_hunk" : "@@ -0,0 +1,351 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void SetMempoolConstraints(ArgsManager& args, FuzzedDataProvider& fuzzed_data_provider)\n+{\n+    args.ForceSetArg(\"-limitancestorcount\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50)));\n+    args.ForceSetArg(\"-limitancestorsize\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202)));\n+    args.ForceSetArg(\"-limitdescendantcount\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50)));\n+    args.ForceSetArg(\"-limitdescendantsize\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202)));\n+    args.ForceSetArg(\"-maxmempool\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200)));\n+    args.ForceSetArg(\"-mempoolexpiry\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)));\n+    args.ForceSetArg(\"-bytespersigop\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999)));\n+}\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1321699963",
      "id" : 1321699963,
      "line" : 132,
      "node_id" : "PRRC_kwDOABII585Ox4p7",
      "original_commit_id" : "3654ad4152f139e6583f819d7d039fd7cdd5dc7f",
      "original_line" : 132,
      "original_position" : 132,
      "original_start_line" : 130,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 132,
      "pull_request_review_id" : 1620240896,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1321699963/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 130,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-09-11T15:16:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1321699963",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2023-09-13T17:49:41Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1718062922",
      "id" : 1718062922,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28450",
      "node_id" : "IC_kwDOABII585mZ49K",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1718062922/reactions"
      },
      "updated_at" : "2023-09-13T17:49:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1718062922",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1324888195"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1324888195"
         }
      },
      "author_association" : "MEMBER",
      "body" : "done",
      "commit_id" : "28f45d6883d06c56dfd7444eeb82b30cff6b8c1b",
      "created_at" : "2023-09-13T18:06:41Z",
      "diff_hunk" : "@@ -0,0 +1,351 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void SetMempoolConstraints(ArgsManager& args, FuzzedDataProvider& fuzzed_data_provider)\n+{\n+    args.ForceSetArg(\"-limitancestorcount\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50)));\n+    args.ForceSetArg(\"-limitancestorsize\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202)));\n+    args.ForceSetArg(\"-limitdescendantcount\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50)));\n+    args.ForceSetArg(\"-limitdescendantsize\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202)));\n+    args.ForceSetArg(\"-maxmempool\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200)));\n+    args.ForceSetArg(\"-mempoolexpiry\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)));\n+    args.ForceSetArg(\"-bytespersigop\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999)));\n+}\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1324888195",
      "id" : 1324888195,
      "in_reply_to_id" : 1321699963,
      "line" : 123,
      "node_id" : "PRRC_kwDOABII585O-DCD",
      "original_commit_id" : "3654ad4152f139e6583f819d7d039fd7cdd5dc7f",
      "original_line" : 123,
      "original_position" : 132,
      "original_start_line" : 130,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 123,
      "pull_request_review_id" : 1625146817,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1324888195/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 121,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-09-13T18:06:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1324888195",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "rebased on master, removed arg round-trip, un-marked WIP",
      "created_at" : "2023-09-13T18:09:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1718092570",
      "id" : 1718092570,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28450",
      "node_id" : "IC_kwDOABII585maAMa",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1718092570/reactions"
      },
      "updated_at" : "2023-09-13T18:09:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1718092570",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK, I guess this also picks up https://github.com/bitcoin/bitcoin/pull/25778 ?",
      "created_at" : "2023-09-14T09:52:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1719137408",
      "id" : 1719137408,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28450",
      "node_id" : "IC_kwDOABII585md_SA",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1719137408/reactions"
      },
      "updated_at" : "2023-09-14T09:52:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1719137408",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Any interest in using `CheckPackageMempoolAcceptResult` from https://github.com/bitcoin/bitcoin/pull/26711/commits/baf475de599c82e7718ffefd7f0481fc88217853? It checks that a result contains the fields we expect based on whether it's supposed to be valid.",
      "created_at" : "2023-09-14T10:47:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1719217351",
      "id" : 1719217351,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28450",
      "node_id" : "IC_kwDOABII585meSzH",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1719217351/reactions"
      },
      "updated_at" : "2023-09-14T10:47:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1719217351",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@MarcoFalke oh, had no idea it existed. Yes I think this should subsume it. I kept it a separate fuzz target to allow more specialization for what we're covering.\r\n\r\n> Any interest in using CheckPackageMempoolAcceptResult from https://github.com/bitcoin/bitcoin/commit/baf475de599c82e7718ffefd7f0481fc88217853? It checks that a result contains the fields we expect based on whether it's supposed to be valid.\r\n\r\nI might take a subset of that, but a few parts wouldn't be useful since I'm firing off random packages that may or may not be valid, and the mempool may trim things even if they're valid?\r\n\r\nedit: In other words, please consider this PR review-ready :+1: ",
      "created_at" : "2023-09-14T14:00:21Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1719512750",
      "id" : 1719512750,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28450",
      "node_id" : "IC_kwDOABII585mfa6u",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1719512750/reactions"
      },
      "updated_at" : "2023-09-14T14:30:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1719512750",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1326380398"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1326380398"
         }
      },
      "author_association" : "MEMBER",
      "body" : "future work: making the tx >40kWu sometimes, along with other invariant checks, would have likely allowed the fuzzer to catch https://github.com/bitcoin/bitcoin/pull/28472",
      "commit_id" : "93d7c5c09c86f9543433d87a2ca074f35cac0fe6",
      "created_at" : "2023-09-14T18:42:01Z",
      "diff_hunk" : "@@ -0,0 +1,341 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &chainstate.CoinsTip()), tx_pool};\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1326380398",
      "id" : 1326380398,
      "line" : 211,
      "node_id" : "PRRC_kwDOABII585PDvVu",
      "original_commit_id" : "28f45d6883d06c56dfd7444eeb82b30cff6b8c1b",
      "original_line" : 211,
      "original_position" : 211,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 211,
      "pull_request_review_id" : 1627544107,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 1,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1326380398/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-14T18:42:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1326380398",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "removed the second commit to not impede review of the various bugfix PRs individually\r\n\r\nrebasing on this should result in no known crashes: https://github.com/bitcoin/bitcoin/pull/28471\r\nhttps://github.com/bitcoin/bitcoin/pull/28472",
      "created_at" : "2023-09-15T13:46:43Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1721311984",
      "id" : 1721311984,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28450",
      "node_id" : "IC_kwDOABII585mmSLw",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1721311984/reactions"
      },
      "updated_at" : "2023-09-15T18:52:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1721311984",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1331487664"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331487664"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't think this set is ever actually used.",
      "commit_id" : "93d7c5c09c86f9543433d87a2ca074f35cac0fe6",
      "created_at" : "2023-09-20T11:26:35Z",
      "diff_hunk" : "@@ -0,0 +1,341 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1331487664",
      "id" : 1331487664,
      "line" : 140,
      "node_id" : "PRRC_kwDOABII585PXOOw",
      "original_commit_id" : "93d7c5c09c86f9543433d87a2ca074f35cac0fe6",
      "original_line" : 140,
      "original_position" : 140,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 140,
      "pull_request_review_id" : 1635411567,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331487664/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-20T11:27:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331487664",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1331487971"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331487971"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`Assert(true)` seems to not be useful.",
      "commit_id" : "93d7c5c09c86f9543433d87a2ca074f35cac0fe6",
      "created_at" : "2023-09-20T11:26:51Z",
      "diff_hunk" : "@@ -0,0 +1,341 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &chainstate.CoinsTip()), tx_pool};\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;\n+        std::set<CTransactionRef> added;\n+        auto txr = std::make_shared<TransactionsDelta>(removed, added);\n+        RegisterSharedValidationInterface(txr);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+\n+        // Single-tx packages should be rejected, so do that sometimes, and sometimes send it via single submission\n+        // to allow it into the mempool by itself to make more interesting mempool packages\n+        auto single_submit = txs.size() == 1 && fuzzed_data_provider.ConsumeBool();\n+        auto package_submit = !single_submit;\n+\n+        const auto result_package = WITH_LOCK(::cs_main,\n+                                    return ProcessNewPackage(chainstate, tx_pool, txs, /*test_accept=*/!package_submit));\n+        // If something went wrong due to a package-specific policy, it might not return a\n+        // validation result for the transaction.\n+        if (result_package.m_state.GetResult() != PackageValidationResult::PCKG_POLICY) {\n+            auto it = result_package.m_tx_results.find(txs.back()->GetWitnessHash());\n+            Assert(it != result_package.m_tx_results.end());\n+            Assert(it->second.m_result_type == MempoolAcceptResult::ResultType::VALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::INVALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::MEMPOOL_ENTRY);\n+        }\n+\n+        const auto res = WITH_LOCK(::cs_main, return AcceptToMemoryPool(chainstate, txs.back(), GetTime(), bypass_limits, /*test_accept=*/!single_submit));\n+        const bool accepted = res.m_result_type == MempoolAcceptResult::ResultType::VALID;\n+\n+        SyncWithValidationInterfaceQueue();\n+        UnregisterSharedValidationInterface(txr);\n+\n+        if (single_submit) {\n+            Assert(accepted != added.empty());\n+            Assert(accepted == res.m_state.IsValid());\n+            Assert(accepted != res.m_state.IsInvalid());\n+            if (accepted) {\n+                Assert(added.size() == 1);\n+                Assert(txs.back() == *added.begin());\n+            } else {\n+                // Do not consider rejected transaction removed\n+                removed.erase(txs.back());\n+            }\n+        } else {\n+            // This is empty if it fails early checks, or \"full\" if transactions are looked at deeper\n+            Assert(result_package.m_tx_results.size() == txs.size() || result_package.m_tx_results.empty());\n+            if (result_package.m_state.GetResult() == PackageValidationResult::PCKG_POLICY) {\n+                for (const auto& tx : txs) {\n+                    removed.erase(tx);\n+                }\n+            } else {\n+                for (const auto& [k, v] : result_package.m_tx_results) {\n+                    if (v.m_result_type != MempoolAcceptResult::ResultType::INVALID) {\n+                        Assert(true);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1331487971",
      "id" : 1331487971,
      "line" : 295,
      "node_id" : "PRRC_kwDOABII585PXOTj",
      "original_commit_id" : "93d7c5c09c86f9543433d87a2ca074f35cac0fe6",
      "original_line" : 295,
      "original_position" : 295,
      "original_start_line" : 294,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 295,
      "pull_request_review_id" : 1635411567,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331487971/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 294,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-09-20T11:27:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331487971",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1331488544"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331488544"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Seems a bit odd to me that the chain limits could go up to 50 but we only create packages of up to 26.",
      "commit_id" : "93d7c5c09c86f9543433d87a2ca074f35cac0fe6",
      "created_at" : "2023-09-20T11:27:28Z",
      "diff_hunk" : "@@ -0,0 +1,341 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1331488544",
      "id" : 1331488544,
      "line" : 115,
      "node_id" : "PRRC_kwDOABII585PXOcg",
      "original_commit_id" : "93d7c5c09c86f9543433d87a2ca074f35cac0fe6",
      "original_line" : 115,
      "original_position" : 115,
      "original_start_line" : 113,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 115,
      "pull_request_review_id" : 1635411567,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331488544/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 113,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-09-20T11:27:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331488544",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1331652861"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331652861"
         }
      },
      "author_association" : "MEMBER",
      "body" : "That's chain limits vs package limit checks, I think it's useful\r\n\r\ne.g., we could have 26 txns in the mempool, and submit another 25",
      "commit_id" : "bf7436cde8ba7eac0912817f6f8a41828cb60bc2",
      "created_at" : "2023-09-20T13:40:30Z",
      "diff_hunk" : "@@ -0,0 +1,341 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1331652861",
      "id" : 1331652861,
      "in_reply_to_id" : 1331488544,
      "line" : 115,
      "node_id" : "PRRC_kwDOABII585PX2j9",
      "original_commit_id" : "93d7c5c09c86f9543433d87a2ca074f35cac0fe6",
      "original_line" : 115,
      "original_position" : 115,
      "original_start_line" : 113,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 115,
      "pull_request_review_id" : 1635676679,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331652861/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 113,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-09-20T14:14:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331652861",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1331684820"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331684820"
         }
      },
      "author_association" : "MEMBER",
      "body" : "it is added to in `insert_tx` when used in `created_by_tx` arg. Lets each new package consider newly-entered outpoints in the mempool",
      "commit_id" : "bf7436cde8ba7eac0912817f6f8a41828cb60bc2",
      "created_at" : "2023-09-20T14:01:30Z",
      "diff_hunk" : "@@ -0,0 +1,341 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1331684820",
      "id" : 1331684820,
      "in_reply_to_id" : 1331487664,
      "line" : 140,
      "node_id" : "PRRC_kwDOABII585PX-XU",
      "original_commit_id" : "93d7c5c09c86f9543433d87a2ca074f35cac0fe6",
      "original_line" : 140,
      "original_position" : 140,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 140,
      "pull_request_review_id" : 1635727786,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331684820/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-20T14:01:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331684820",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1331685986"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331685986"
         }
      },
      "author_association" : "MEMBER",
      "body" : "removed debugging code",
      "commit_id" : "bf7436cde8ba7eac0912817f6f8a41828cb60bc2",
      "created_at" : "2023-09-20T14:02:19Z",
      "diff_hunk" : "@@ -0,0 +1,341 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &chainstate.CoinsTip()), tx_pool};\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;\n+        std::set<CTransactionRef> added;\n+        auto txr = std::make_shared<TransactionsDelta>(removed, added);\n+        RegisterSharedValidationInterface(txr);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+\n+        // Single-tx packages should be rejected, so do that sometimes, and sometimes send it via single submission\n+        // to allow it into the mempool by itself to make more interesting mempool packages\n+        auto single_submit = txs.size() == 1 && fuzzed_data_provider.ConsumeBool();\n+        auto package_submit = !single_submit;\n+\n+        const auto result_package = WITH_LOCK(::cs_main,\n+                                    return ProcessNewPackage(chainstate, tx_pool, txs, /*test_accept=*/!package_submit));\n+        // If something went wrong due to a package-specific policy, it might not return a\n+        // validation result for the transaction.\n+        if (result_package.m_state.GetResult() != PackageValidationResult::PCKG_POLICY) {\n+            auto it = result_package.m_tx_results.find(txs.back()->GetWitnessHash());\n+            Assert(it != result_package.m_tx_results.end());\n+            Assert(it->second.m_result_type == MempoolAcceptResult::ResultType::VALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::INVALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::MEMPOOL_ENTRY);\n+        }\n+\n+        const auto res = WITH_LOCK(::cs_main, return AcceptToMemoryPool(chainstate, txs.back(), GetTime(), bypass_limits, /*test_accept=*/!single_submit));\n+        const bool accepted = res.m_result_type == MempoolAcceptResult::ResultType::VALID;\n+\n+        SyncWithValidationInterfaceQueue();\n+        UnregisterSharedValidationInterface(txr);\n+\n+        if (single_submit) {\n+            Assert(accepted != added.empty());\n+            Assert(accepted == res.m_state.IsValid());\n+            Assert(accepted != res.m_state.IsInvalid());\n+            if (accepted) {\n+                Assert(added.size() == 1);\n+                Assert(txs.back() == *added.begin());\n+            } else {\n+                // Do not consider rejected transaction removed\n+                removed.erase(txs.back());\n+            }\n+        } else {\n+            // This is empty if it fails early checks, or \"full\" if transactions are looked at deeper\n+            Assert(result_package.m_tx_results.size() == txs.size() || result_package.m_tx_results.empty());\n+            if (result_package.m_state.GetResult() == PackageValidationResult::PCKG_POLICY) {\n+                for (const auto& tx : txs) {\n+                    removed.erase(tx);\n+                }\n+            } else {\n+                for (const auto& [k, v] : result_package.m_tx_results) {\n+                    if (v.m_result_type != MempoolAcceptResult::ResultType::INVALID) {\n+                        Assert(true);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1331685986",
      "id" : 1331685986,
      "in_reply_to_id" : 1331487971,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585PX-pi",
      "original_commit_id" : "93d7c5c09c86f9543433d87a2ca074f35cac0fe6",
      "original_line" : 295,
      "original_position" : 295,
      "original_start_line" : 294,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : null,
      "pull_request_review_id" : 1635729649,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331685986/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-09-20T14:02:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331685986",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "updated with cleanups",
      "created_at" : "2023-09-20T15:45:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1727984710",
      "id" : 1727984710,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28450",
      "node_id" : "IC_kwDOABII585m_vRG",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1727984710/reactions"
      },
      "updated_at" : "2023-09-20T15:45:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1727984710",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "from discussions with others:\r\n\r\n1) I have a PR built on https://github.com/bitcoin/bitcoin/pull/26711 which generalized from this fairly basic topology to general ancestor packages, including the last tx spending any subset of outpoints, and any package transactions potentially spending other package outpoints. I'd like to make sure it's getting relatively targeted coverage before switching to that, so deferring to after this PR.\r\n2) We can add coverage where we mutate the wtxid of txns\r\n3) Also should allow duplication of inputs\r\n\r\nI plan on doing these in the follow-up on top of #26711 ",
      "created_at" : "2023-09-21T10:27:42Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1729293183",
      "id" : 1729293183,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28450",
      "node_id" : "IC_kwDOABII585nEut_",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1729293183/reactions"
      },
      "updated_at" : "2023-09-21T10:27:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1729293183",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1332851868"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1332851868"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In bf7436cde8ba7eac0912817f6f8a41828cb60bc2: In `ProcessNewPackage`, couldn't we just use `single_submit` for `/*test_accept=*/` directly, instead of creating `package_submit`? ",
      "commit_id" : "aaffa22634be2b07dd50092f44caf6f4b0f8ee4e",
      "created_at" : "2023-09-21T10:37:56Z",
      "diff_hunk" : "@@ -0,0 +1,339 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &chainstate.CoinsTip()), tx_pool};\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;\n+        std::set<CTransactionRef> added;\n+        auto txr = std::make_shared<TransactionsDelta>(removed, added);\n+        RegisterSharedValidationInterface(txr);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+\n+        // Single-tx packages should be rejected, so do that sometimes, and sometimes send it via single submission\n+        // to allow it into the mempool by itself to make more interesting mempool packages\n+        auto single_submit = txs.size() == 1 && fuzzed_data_provider.ConsumeBool();\n+        auto package_submit = !single_submit;\n+\n+        const auto result_package = WITH_LOCK(::cs_main,\n+                                    return ProcessNewPackage(chainstate, tx_pool, txs, /*test_accept=*/!package_submit));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1332851868",
      "id" : 1332851868,
      "line" : 256,
      "node_id" : "PRRC_kwDOABII585PcbSc",
      "original_commit_id" : "bf7436cde8ba7eac0912817f6f8a41828cb60bc2",
      "original_line" : 256,
      "original_position" : 257,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 256,
      "pull_request_review_id" : 1637502233,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1332851868/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-21T10:37:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1332851868",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19480819?v=4",
         "events_url" : "https://api.github.com/users/brunoerg/events{/privacy}",
         "followers_url" : "https://api.github.com/users/brunoerg/followers",
         "following_url" : "https://api.github.com/users/brunoerg/following{/other_user}",
         "gists_url" : "https://api.github.com/users/brunoerg/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/brunoerg",
         "id" : 19480819,
         "login" : "brunoerg",
         "node_id" : "MDQ6VXNlcjE5NDgwODE5",
         "organizations_url" : "https://api.github.com/users/brunoerg/orgs",
         "received_events_url" : "https://api.github.com/users/brunoerg/received_events",
         "repos_url" : "https://api.github.com/users/brunoerg/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/brunoerg/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/brunoerg/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/brunoerg"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1332860797"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1332860797"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In bf7436cde8ba7eac0912817f6f8a41828cb60bc2: I think `amount_view` hasn't been used.",
      "commit_id" : "aaffa22634be2b07dd50092f44caf6f4b0f8ee4e",
      "created_at" : "2023-09-21T10:45:36Z",
      "diff_hunk" : "@@ -0,0 +1,339 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &chainstate.CoinsTip()), tx_pool};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1332860797",
      "id" : 1332860797,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Pcdd9",
      "original_commit_id" : "bf7436cde8ba7eac0912817f6f8a41828cb60bc2",
      "original_line" : 155,
      "original_position" : 155,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : null,
      "pull_request_review_id" : 1637516869,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1332860797/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-21T10:45:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1332860797",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19480819?v=4",
         "events_url" : "https://api.github.com/users/brunoerg/events{/privacy}",
         "followers_url" : "https://api.github.com/users/brunoerg/followers",
         "following_url" : "https://api.github.com/users/brunoerg/following{/other_user}",
         "gists_url" : "https://api.github.com/users/brunoerg/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/brunoerg",
         "id" : 19480819,
         "login" : "brunoerg",
         "node_id" : "MDQ6VXNlcjE5NDgwODE5",
         "organizations_url" : "https://api.github.com/users/brunoerg/orgs",
         "received_events_url" : "https://api.github.com/users/brunoerg/received_events",
         "repos_url" : "https://api.github.com/users/brunoerg/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/brunoerg/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/brunoerg/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/brunoerg"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1332902420"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1332902420"
         }
      },
      "author_association" : "MEMBER",
      "body" : "deleted",
      "commit_id" : "aaffa22634be2b07dd50092f44caf6f4b0f8ee4e",
      "created_at" : "2023-09-21T11:24:08Z",
      "diff_hunk" : "@@ -0,0 +1,339 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &chainstate.CoinsTip()), tx_pool};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1332902420",
      "id" : 1332902420,
      "in_reply_to_id" : 1332860797,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585PcnoU",
      "original_commit_id" : "bf7436cde8ba7eac0912817f6f8a41828cb60bc2",
      "original_line" : 155,
      "original_position" : 155,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : null,
      "pull_request_review_id" : 1637583711,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1332902420/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-21T11:24:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1332902420",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1332902922"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1332902922"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I find this ever so slightly more readable myself, opinions may vary ",
      "commit_id" : "aaffa22634be2b07dd50092f44caf6f4b0f8ee4e",
      "created_at" : "2023-09-21T11:24:37Z",
      "diff_hunk" : "@@ -0,0 +1,339 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &chainstate.CoinsTip()), tx_pool};\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;\n+        std::set<CTransactionRef> added;\n+        auto txr = std::make_shared<TransactionsDelta>(removed, added);\n+        RegisterSharedValidationInterface(txr);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+\n+        // Single-tx packages should be rejected, so do that sometimes, and sometimes send it via single submission\n+        // to allow it into the mempool by itself to make more interesting mempool packages\n+        auto single_submit = txs.size() == 1 && fuzzed_data_provider.ConsumeBool();\n+        auto package_submit = !single_submit;\n+\n+        const auto result_package = WITH_LOCK(::cs_main,\n+                                    return ProcessNewPackage(chainstate, tx_pool, txs, /*test_accept=*/!package_submit));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1332902922",
      "id" : 1332902922,
      "in_reply_to_id" : 1332851868,
      "line" : 256,
      "node_id" : "PRRC_kwDOABII585PcnwK",
      "original_commit_id" : "bf7436cde8ba7eac0912817f6f8a41828cb60bc2",
      "original_line" : 256,
      "original_position" : 257,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 256,
      "pull_request_review_id" : 1637584469,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1332902922/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-21T11:24:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1332902922",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "rebased on latest master on top of #28471 \r\n\r\nShould not be crashing anymore :crossed_fingers: cc @dergoegge ",
      "created_at" : "2023-09-21T16:17:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1729897131",
      "id" : 1729897131,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28450",
      "node_id" : "IC_kwDOABII585nHCKr",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 1,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1729897131/reactions"
      },
      "updated_at" : "2023-09-21T16:17:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1729897131",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335215049"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335215049"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Why is it calling `MockTime` again? I guess to trigger the `nLockTime`? ",
      "commit_id" : "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "created_at" : "2023-09-24T16:39:21Z",
      "diff_hunk" : "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335215049",
      "id" : 1335215049,
      "line" : 230,
      "node_id" : "PRRC_kwDOABII585PlcPJ",
      "original_commit_id" : "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "original_line" : 230,
      "original_position" : 230,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 230,
      "pull_request_review_id" : 1641093035,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335215049/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-24T17:44:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335215049",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19480819?v=4",
         "events_url" : "https://api.github.com/users/brunoerg/events{/privacy}",
         "followers_url" : "https://api.github.com/users/brunoerg/followers",
         "following_url" : "https://api.github.com/users/brunoerg/following{/other_user}",
         "gists_url" : "https://api.github.com/users/brunoerg/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/brunoerg",
         "id" : 19480819,
         "login" : "brunoerg",
         "node_id" : "MDQ6VXNlcjE5NDgwODE5",
         "organizations_url" : "https://api.github.com/users/brunoerg/orgs",
         "received_events_url" : "https://api.github.com/users/brunoerg/received_events",
         "repos_url" : "https://api.github.com/users/brunoerg/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/brunoerg/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/brunoerg/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/brunoerg"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335220434"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335220434"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In 2ecdc2183f0a1291730ae8728fa3d847b9cf80b5: Couldn't we prioritise more than 1 transaction?",
      "commit_id" : "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "created_at" : "2023-09-24T17:27:43Z",
      "diff_hunk" : "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335220434",
      "id" : 1335220434,
      "line" : 240,
      "node_id" : "PRRC_kwDOABII585PldjS",
      "original_commit_id" : "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "original_line" : 240,
      "original_position" : 240,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 240,
      "pull_request_review_id" : 1641097915,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335220434/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-24T17:27:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335220434",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19480819?v=4",
         "events_url" : "https://api.github.com/users/brunoerg/events{/privacy}",
         "followers_url" : "https://api.github.com/users/brunoerg/followers",
         "following_url" : "https://api.github.com/users/brunoerg/following{/other_user}",
         "gists_url" : "https://api.github.com/users/brunoerg/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/brunoerg",
         "id" : 19480819,
         "login" : "brunoerg",
         "node_id" : "MDQ6VXNlcjE5NDgwODE5",
         "organizations_url" : "https://api.github.com/users/brunoerg/orgs",
         "received_events_url" : "https://api.github.com/users/brunoerg/received_events",
         "repos_url" : "https://api.github.com/users/brunoerg/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/brunoerg/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/brunoerg/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/brunoerg"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335221272"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335221272"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In `2ecdc2183f0a1291730ae8728fa3d847b9cf80b5`: Does it make sense to check whether the state is invalid if we previously assert that is valid?",
      "commit_id" : "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "created_at" : "2023-09-24T17:35:32Z",
      "diff_hunk" : "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;\n+        std::set<CTransactionRef> added;\n+        auto txr = std::make_shared<TransactionsDelta>(removed, added);\n+        RegisterSharedValidationInterface(txr);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+\n+        // Single-tx packages should be rejected, so do that sometimes, and sometimes send it via single submission\n+        // to allow it into the mempool by itself to make more interesting mempool packages\n+        auto single_submit = txs.size() == 1 && fuzzed_data_provider.ConsumeBool();\n+        auto package_submit = !single_submit;\n+\n+        const auto result_package = WITH_LOCK(::cs_main,\n+                                    return ProcessNewPackage(chainstate, tx_pool, txs, /*test_accept=*/!package_submit));\n+        // If something went wrong due to a package-specific policy, it might not return a\n+        // validation result for the transaction.\n+        if (result_package.m_state.GetResult() != PackageValidationResult::PCKG_POLICY) {\n+            auto it = result_package.m_tx_results.find(txs.back()->GetWitnessHash());\n+            Assert(it != result_package.m_tx_results.end());\n+            Assert(it->second.m_result_type == MempoolAcceptResult::ResultType::VALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::INVALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::MEMPOOL_ENTRY);\n+        }\n+\n+        const auto res = WITH_LOCK(::cs_main, return AcceptToMemoryPool(chainstate, txs.back(), GetTime(), bypass_limits, /*test_accept=*/!single_submit));\n+        const bool accepted = res.m_result_type == MempoolAcceptResult::ResultType::VALID;\n+\n+        SyncWithValidationInterfaceQueue();\n+        UnregisterSharedValidationInterface(txr);\n+\n+        if (single_submit) {\n+            Assert(accepted != added.empty());\n+            Assert(accepted == res.m_state.IsValid());\n+            Assert(accepted != res.m_state.IsInvalid());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335221272",
      "id" : 1335221272,
      "line" : 276,
      "node_id" : "PRRC_kwDOABII585PldwY",
      "original_commit_id" : "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "original_line" : 276,
      "original_position" : 276,
      "original_start_line" : null,
      "path" : "src/test/fuzz/package_eval.cpp",
      "position" : 276,
      "pull_request_review_id" : 1641098600,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335221272/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-24T17:35:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335221272",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19480819?v=4",
         "events_url" : "https://api.github.com/users/brunoerg/events{/privacy}",
         "followers_url" : "https://api.github.com/users/brunoerg/followers",
         "following_url" : "https://api.github.com/users/brunoerg/following{/other_user}",
         "gists_url" : "https://api.github.com/users/brunoerg/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/brunoerg",
         "id" : 19480819,
         "login" : "brunoerg",
         "node_id" : "MDQ6VXNlcjE5NDgwODE5",
         "organizations_url" : "https://api.github.com/users/brunoerg/orgs",
         "received_events_url" : "https://api.github.com/users/brunoerg/received_events",
         "repos_url" : "https://api.github.com/users/brunoerg/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/brunoerg/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/brunoerg/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/brunoerg"
      }
   }
]
