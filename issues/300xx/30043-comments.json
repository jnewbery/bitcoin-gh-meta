[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage\nFor detailed information about the code coverage, see the [test coverage report](https://corecheck.dev/bitcoin/bitcoin/pulls/30043).\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| Concept ACK | [Sjors](https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2095761769), [theuni](https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2096485412), [vasild](https://github.com/bitcoin/bitcoin/pull/30043#pullrequestreview-2061123015) |\n\nIf your review is incorrectly listed, please react with ð to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#29852](https://github.com/bitcoin/bitcoin/pull/29852) ([WIP] build: remove need to test for endianness by fanquake)\n* [#29790](https://github.com/bitcoin/bitcoin/pull/29790) ([DO NOT MERGE] cmake: Migrate CI scripts to CMake-based build system -- WIP by hebasto)\n* [#29015](https://github.com/bitcoin/bitcoin/pull/29015) (kernel: Streamline util library by ryanofsky)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "created_at" : "2024-05-05T18:35:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2094906184",
      "id" : 2094906184,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII58583btI",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2094906184/reactions"
      },
      "updated_at" : "2024-05-23T21:53:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2094906184",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--85328a0da195eb286784d51f73fa0af9-->\n\nð§ At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/24606743714</sub>",
      "created_at" : "2024-05-05T18:49:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2094910598",
      "id" : 2094910598,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII58583cyG",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2094910598/reactions"
      },
      "updated_at" : "2024-05-05T18:49:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2094910598",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK",
      "created_at" : "2024-05-06T11:08:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2095761769",
      "id" : 2095761769,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII58586slp",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2095761769/reactions"
      },
      "updated_at" : "2024-05-06T11:08:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2095761769",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1590975165"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1590975165"
         }
      },
      "author_association" : "MEMBER",
      "body" : "a2d67c320f8a28da98e6c8352bd67648a9b831a8: I think you need to keep this (and above) until `-natpmp` is removed.",
      "commit_id" : "b06edec229d5cfc8d0d1a19bd723852e6bcfd9d9",
      "created_at" : "2024-05-06T12:53:51Z",
      "diff_hunk" : "@@ -760,8 +757,8 @@ void InitParameterInteraction(ArgsManager& args)\n         // do not map ports or try to retrieve public IP when not listening (pointless)\n         if (args.SoftSetBoolArg(\"-upnp\", false))\n             LogPrintf(\"%s: parameter interaction: -listen=0 -> setting -upnp=0\\n\", __func__);\n-        if (args.SoftSetBoolArg(\"-natpmp\", false)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1590975165",
      "id" : 1590975165,
      "line" : 763,
      "node_id" : "PRRC_kwDOABII585e1Fq9",
      "original_commit_id" : "a2d67c320f8a28da98e6c8352bd67648a9b831a8",
      "original_line" : 763,
      "original_position" : 29,
      "original_start_line" : null,
      "path" : "src/init.cpp",
      "position" : 29,
      "pull_request_review_id" : 2040718091,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1590975165/reactions"
      },
      "side" : "LEFT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-06T16:51:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1590975165",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Whoa :)\r\n\r\n(Concept ACK)",
      "created_at" : "2024-05-06T16:49:54Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2096485412",
      "id" : 2096485412,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII58589dQk",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2096485412/reactions"
      },
      "updated_at" : "2024-05-06T17:25:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2096485412",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=4",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "node_id" : "MDQ6VXNlcjQxNzA0Mw==",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Regarding the custom lib/self-impl discussion in #30005: \r\nTaking a quick look at the implementation here, I think it's simple enough for us to maintain ourselves. If a nice canonical lib ever emerges we could always jump to it, as there are only a few basic functions and presumably we could probably switch them out close to 1:1.\r\n\r\nThat said, it is a little rough to review as\r\n- It needs to be compared to the letter of the spec, with the assumption that @laanwj is evil or has mis-implemented (I doubt that :)\r\n- It needs to be very defensive, though the attack surface seems quite minimal\r\n- It needs to be aware of real-world violators/benders/extenders of the spec (if any? I have no idea.)\r\n\r\nBut it seems worth the effort to me.",
      "created_at" : "2024-05-06T18:37:14Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2096670310",
      "id" : 2096670310,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII5858-KZm",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2096670310/reactions"
      },
      "updated_at" : "2024-05-06T18:37:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2096670310",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=4",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "node_id" : "MDQ6VXNlcjQxNzA0Mw==",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2024-05-07T04:16:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2097414181",
      "id" : 2097414181,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII5859BAAl",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2097414181/reactions"
      },
      "updated_at" : "2024-05-07T04:16:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2097414181",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased for #29984",
      "created_at" : "2024-05-07T08:59:20Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2097797401",
      "id" : 2097797401,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII5859CdkZ",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2097797401/reactions"
      },
      "updated_at" : "2024-05-07T08:59:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2097797401",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1592075348"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1592075348"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yes, good point.",
      "commit_id" : "b06edec229d5cfc8d0d1a19bd723852e6bcfd9d9",
      "created_at" : "2024-05-07T08:59:41Z",
      "diff_hunk" : "@@ -760,8 +757,8 @@ void InitParameterInteraction(ArgsManager& args)\n         // do not map ports or try to retrieve public IP when not listening (pointless)\n         if (args.SoftSetBoolArg(\"-upnp\", false))\n             LogPrintf(\"%s: parameter interaction: -listen=0 -> setting -upnp=0\\n\", __func__);\n-        if (args.SoftSetBoolArg(\"-natpmp\", false)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1592075348",
      "id" : 1592075348,
      "in_reply_to_id" : 1590975165,
      "line" : 763,
      "node_id" : "PRRC_kwDOABII585e5SRU",
      "original_commit_id" : "a2d67c320f8a28da98e6c8352bd67648a9b831a8",
      "original_line" : 763,
      "original_position" : 29,
      "original_start_line" : null,
      "path" : "src/init.cpp",
      "position" : 29,
      "pull_request_review_id" : 2042519681,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1592075348/reactions"
      },
      "side" : "LEFT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-07T08:59:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1592075348",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> That said, it is a little rough to review as\r\n>  It needs to be compared to the letter of the spec, with the assumption that @laanwj is evil or has mis-implemented (I doubt that :)\r\n\r\nIf you're more comfortable comparing it against another implementation there's:\r\n- A kinda haphazard windows implementation here: https://github.com/moonlight-stream/GS-IPv6-Forwarder/blob/master/GSv6Fwd/pcp.cpp\r\n- Miniupnpd's pcp server implementation https://github.com/miniupnp/miniupnp/blob/master/miniupnpd/pcpserver.c\r\n\r\n> It needs to be aware of real-world violators/benders/extenders of the spec (if any? I have no idea.)\r\n\r\nMiniupnpd's is, likely, the most common server implementation in the wild. It's been tested against that. i'm hoping people will test this on various routers and conditions, there will be inevitable edge cases to iron out.\r\n\r\n> If a nice canonical lib ever emerges we could always jump to it\r\n\r\nMaybe, but at some point there's not much difference between implementing a simple request/reply protocol and using a library. At least the RFC is unambigiously documented, which can't be said of many FOSS ABI's. Also, @fanquake (and @gmaxwell in the past) has been hoping for a solution that doesn't introduce a library dependency.",
      "created_at" : "2024-05-07T10:18:35Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2097968387",
      "id" : 2097968387,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII5859DHUD",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2097968387/reactions"
      },
      "updated_at" : "2024-05-07T10:28:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2097968387",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1592765102"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1592765102"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit:\r\n```suggestion\r\n    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Requesting port mapping for addr %s port %d from gateway %s\\n\", bind.ToStringAddr(), port, gateway.ToStringAddr());\r\n```",
      "commit_id" : "b06edec229d5cfc8d0d1a19bd723852e6bcfd9d9",
      "created_at" : "2024-05-07T16:25:32Z",
      "diff_hunk" : "@@ -0,0 +1,236 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+// RFC 6887 Port Control Protocol (PCP) implementation.\n+// PCP uses network byte order (big-endian).\n+// References to sections and figures in the code below refer to https://datatracker.ietf.org/doc/html/rfc6887.\n+\n+//! Mapping of PCP result code to string (7.4).\n+static const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RFC. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] static bool PCPWrapAddress(uint8_t *wrapped_addr, const CNetAddr &addr)\n+{\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        memcpy(wrapped_addr, IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        memcpy(wrapped_addr + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        memcpy(wrapped_addr, &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address.\n+static CNetAddr PCPUnwrapAddress(const uint8_t *wrapped_addr)\n+{\n+    if (memcmp(wrapped_addr, IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size()) == 0) {\n+        struct in_addr addr4;\n+        memcpy(&addr4, wrapped_addr + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        memcpy(&addr6, wrapped_addr, ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+std::optional<MappingResult> PCPRequestPortMap(const PCPMappingNonce &nonce, const CNetAddr &gateway, const CNetAddr &bind, uint16_t port, uint32_t lifetime, int num_tries, bool option_prefer_failure)\n+{\n+    struct sockaddr_storage dest_addr, bind_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage), bind_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Requesting port mapping for addr %s port %d from gateway %s\\n\", bind.ToStringAddr(), port, gateway.ToStringAddr());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1592765102",
      "id" : 1592765102,
      "line" : 83,
      "node_id" : "PRRC_kwDOABII585e76qu",
      "original_commit_id" : "fe53862fd4dca2ce7d3208847ed9e917c30ccb27",
      "original_line" : 83,
      "original_position" : 83,
      "original_start_line" : null,
      "path" : "src/util/pcp.cpp",
      "position" : 83,
      "pull_request_review_id" : 2043665469,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1592765102/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-07T16:25:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1592765102",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2257631?v=4",
         "events_url" : "https://api.github.com/users/davidgumberg/events{/privacy}",
         "followers_url" : "https://api.github.com/users/davidgumberg/followers",
         "following_url" : "https://api.github.com/users/davidgumberg/following{/other_user}",
         "gists_url" : "https://api.github.com/users/davidgumberg/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/davidgumberg",
         "id" : 2257631,
         "login" : "davidgumberg",
         "node_id" : "MDQ6VXNlcjIyNTc2MzE=",
         "organizations_url" : "https://api.github.com/users/davidgumberg/orgs",
         "received_events_url" : "https://api.github.com/users/davidgumberg/received_events",
         "repos_url" : "https://api.github.com/users/davidgumberg/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/davidgumberg/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/davidgumberg/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/davidgumberg"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Would prefer this in two steps (add PCP, then remove NAT-PMP)",
      "created_at" : "2024-05-08T15:26:35Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2100841942",
      "id" : 2100841942,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII5859OE3W",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2100841942/reactions"
      },
      "updated_at" : "2024-05-08T15:26:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2100841942",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Would prefer this in two steps (add PCP, then remove NAT-PMP)\r\n\r\ni'm not planning to do this, the build system commits are already set up this way, but doing it throughout would involve adding another setting in Qt just to remove it later. Same for adding a third mechanism in `portmap.cpp`. Agree with @sjors that having a forest of different port mapping settings is confusing to the user.",
      "created_at" : "2024-05-09T07:25:43Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2102107669",
      "id" : 2102107669,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII5859S54V",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2102107669/reactions"
      },
      "updated_at" : "2024-05-09T07:25:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2102107669",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1595141704"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1595141704"
         }
      },
      "author_association" : "MEMBER",
      "body" : "73037f27fc21765414c298b171dfdeee130c549b: needs to be `true`, but you can actually drop this line.",
      "commit_id" : "b06edec229d5cfc8d0d1a19bd723852e6bcfd9d9",
      "created_at" : "2024-05-09T08:29:52Z",
      "diff_hunk" : "@@ -108,9 +108,7 @@ OptionsDialog::OptionsDialog(QWidget* parent, bool enableWallet)\n #ifndef USE_UPNP\n     ui->mapPortUpnp->setEnabled(false);\n #endif\n-#ifndef USE_NATPMP\n-    ui->mapPortNatpmp->setEnabled(false);\n-#endif\n+    ui->mapPortPCP->setEnabled(false);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1595141704",
      "id" : 1595141704,
      "line" : 111,
      "node_id" : "PRRC_kwDOABII585fE-5I",
      "original_commit_id" : "73037f27fc21765414c298b171dfdeee130c549b",
      "original_line" : 111,
      "original_position" : 7,
      "original_start_line" : null,
      "path" : "src/qt/optionsdialog.cpp",
      "position" : 7,
      "pull_request_review_id" : 2047432934,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1595141704/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-09T09:56:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1595141704",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1595145827"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1595145827"
         }
      },
      "author_association" : "MEMBER",
      "body" : "73037f27fc21765414c298b171dfdeee130c549b: maybe add: \"PCP is the successor to NAT-PMP.\", in case someone who didn't read the release notes is confused why that option disappeared.",
      "commit_id" : "b06edec229d5cfc8d0d1a19bd723852e6bcfd9d9",
      "created_at" : "2024-05-09T08:34:02Z",
      "diff_hunk" : "@@ -326,12 +326,12 @@\n         </widget>\n        </item>\n        <item>\n-        <widget class=\"QCheckBox\" name=\"mapPortNatpmp\">\n+        <widget class=\"QCheckBox\" name=\"mapPortPCP\">\n          <property name=\"toolTip\">\n-          <string>Automatically open the Bitcoin client port on the router. This only works when your router supports NAT-PMP and it is enabled. The external port could be random.</string>\n+          <string>Automatically open the Bitcoin client port on the router. This only works when your router supports PCP and it is enabled. The external port could be random.</string>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1595145827",
      "id" : 1595145827,
      "line" : 331,
      "node_id" : "PRRC_kwDOABII585fE_5j",
      "original_commit_id" : "73037f27fc21765414c298b171dfdeee130c549b",
      "original_line" : 331,
      "original_position" : 8,
      "original_start_line" : null,
      "path" : "src/qt/forms/optionsdialog.ui",
      "position" : 8,
      "pull_request_review_id" : 2047432934,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1595145827/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-09T09:56:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1595145827",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "In terms of which IPv6 address to use, my understanding is this:\r\n\r\n1. In the olden days the IPv6 address contained part of the MAC address. This ensured uniqueness, but was bad for mobile device privacy; no matter where you went, part of your IP address was constant. Such addresses always (?) contain `0xfffe`. See https://datatracker.ietf.org/doc/html/rfc7707\r\n2. A new standard was introduced that uses a hash of both the MAC address and the prefix, ensuring it's stable if you stay on the same network, but changes when you move. See https://datatracker.ietf.org/doc/html/rfc7217#page-19\r\n3. There's also temporary addresses, which are rotated every couple of hours. See https://datatracker.ietf.org/doc/html/rfc8981\r\n\r\nIf we were able to tell which one one is which, then I think we should pick only one, in order of preference: (2), (3), (1). This reflects our desire to actually get inbound connections, even after a shutdown, while at the same time not doxxing ourselves when on the move (mainly for laptops, perhaps mobile in the future).\r\n\r\nWe can easily detect type (1) by looking for `0xfffe` at the right position (and then least prefer it).\r\n\r\nI believe you can detect (2) by looking for `IFA_F_STABLE_PRIVACY` in `flags` of the `inet6_ifaddr` struct. It seems `getifaddrs` doesn't have access to that. Neither does `/proc/net/if_inet6` since https://patchwork.ozlabs.org/project/netdev/patch/1386680189-7852-1-git-send-email-jiri@resnulli.us/\r\n\r\nAfaik there's also no guarantee about the order of results.\r\n\r\nSo maybe we should just pick one at random rather than announce all three. This also seems orthogonal to PCP.",
      "created_at" : "2024-05-09T13:53:04Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2102707649",
      "id" : 2102707649,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII5859VMXB",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2102707649/reactions"
      },
      "updated_at" : "2024-05-09T13:53:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2102707649",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1595583401"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1595583401"
         }
      },
      "author_association" : "MEMBER",
      "body" : "6cf4809c6b93e1720dfdfe4e3320cfd8939686b6: This is `::Warning` worthy.",
      "commit_id" : "b06edec229d5cfc8d0d1a19bd723852e6bcfd9d9",
      "created_at" : "2024-05-09T15:10:12Z",
      "diff_hunk" : "@@ -47,105 +44,73 @@ static std::atomic<MapPortProtoFlag> g_mapport_current_proto{MapPortProtoFlag::N\n using namespace std::chrono_literals;\n static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD{20min};\n static constexpr auto PORT_MAPPING_RETRY_PERIOD{5min};\n+static constexpr auto PORT_MAPPING_REANNOUNCE_MARGIN{60s};\n \n-#ifdef USE_NATPMP\n-static uint16_t g_mapport_external_port = 0;\n-static bool NatpmpInit(natpmp_t* natpmp)\n+static bool ProcessPCP()\n {\n-    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n-    if (r_init == 0) return true;\n-    LogPrintf(\"natpmp: initnatpmp() failed with %d error.\\n\", r_init);\n-    return false;\n-}\n+    // The same nonce is used for all mappings, this is allowed by the spec, and simplifies keeping track of them.\n+    PCPMappingNonce pcp_nonce;\n+    GetRandBytes(pcp_nonce);\n \n-static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n-{\n-    const int r_send = sendpublicaddressrequest(natpmp);\n-    if (r_send == 2 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            external_ipv4_addr = response.pnu.publicaddress.addr;\n-            return true;\n-        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n-            LogPrintf(\"natpmp: The gateway does not support NAT-PMP.\\n\");\n+    bool ret = false;\n+    const uint16_t private_port = GetListenPort();\n+    // Request reannounce period plus safety margin.\n+    const uint32_t requested_lifetime = std::chrono::seconds(PORT_MAPPING_REANNOUNCE_PERIOD + PORT_MAPPING_REANNOUNCE_MARGIN).count();\n+    std::chrono::seconds sleep_time;\n+\n+    do {\n+        uint32_t actual_lifetime = requested_lifetime;\n+        ret = false; // Set to true if any mapping succeeds.\n+\n+        // IPv4\n+        std::optional<CNetAddr> gateway4 = QueryDefaultGateway(NET_IPV4);\n+        if (!gateway4) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Could not determine IPv4 default gateway\\n\");\n         } else {\n-            LogPrintf(\"natpmp: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: gateway [IPv4]: %s\\n\", gateway4->ToStringAddr());\n+\n+            // Open a port mapping on whatever local address we have toward the gateway.\n+            struct in_addr inaddr_any;\n+            inaddr_any.s_addr = htonl(INADDR_ANY);\n+            std::optional<MappingResult> res = PCPRequestPortMap(pcp_nonce, *gateway4, CNetAddr(inaddr_any), private_port, requested_lifetime);\n+            if (res) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Info, \"pcp: ExternalIPv4Address:port = %s\\n\", res->external.ToStringAddrPort());\n+                AddLocal(res->external, LOCAL_MAPPED);\n+                ret = true;\n+                actual_lifetime = std::min(actual_lifetime, res->lifetime);\n+            }\n         }\n-    } else {\n-        LogPrintf(\"natpmp: sendpublicaddressrequest() failed with %d error.\\n\", r_send);\n-    }\n \n-    return false;\n-}\n-\n-static bool NatpmpMapping(natpmp_t* natpmp, const struct in_addr& external_ipv4_addr, uint16_t private_port, bool& external_ip_discovered)\n-{\n-    const uint16_t suggested_external_port = g_mapport_external_port ? g_mapport_external_port : private_port;\n-    const int r_send = sendnewportmappingrequest(natpmp, NATPMP_PROTOCOL_TCP, private_port, suggested_external_port, 3600 /*seconds*/);\n-    if (r_send == 12 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            auto pm = response.pnu.newportmapping;\n-            if (private_port == pm.privateport && pm.lifetime > 0) {\n-                g_mapport_external_port = pm.mappedpublicport;\n-                const CService external{external_ipv4_addr, pm.mappedpublicport};\n-                if (!external_ip_discovered && fDiscover) {\n-                    AddLocal(external, LOCAL_MAPPED);\n-                    external_ip_discovered = true;\n+        // IPv6\n+        std::optional<CNetAddr> gateway6 = QueryDefaultGateway(NET_IPV6);\n+        if (!gateway6) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Could not determine IPv6 default gateway\\n\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1595583401",
      "id" : 1595583401,
      "line" : 87,
      "node_id" : "PRRC_kwDOABII585fGqup",
      "original_commit_id" : "6cf4809c6b93e1720dfdfe4e3320cfd8939686b6",
      "original_line" : 87,
      "original_position" : 119,
      "original_start_line" : null,
      "path" : "src/mapport.cpp",
      "position" : 119,
      "pull_request_review_id" : 2048184349,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1595583401/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-09T15:45:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1595583401",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2024-05-15T10:05:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2112095584",
      "id" : 2112095584,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII58595AVg",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2112095584/reactions"
      },
      "updated_at" : "2024-05-15T10:05:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2112095584",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Thanks!\r\n\r\nOn Windows (Vista and higher, which is all we care about) getting the default gateway is straightforward, there's `GetBestRoute2` that does all the work. It's part of netioapi which we already need for interface enumeration. MacOS's sysctl is a bit uglier.\r\n\r\n> If PCP servers announced themselves via DNS-Based Service Discovery [rfc6763](https://www.rfc-editor.org/rfc/rfc6763.html) that would also make things easier.\r\n\r\ni don't think it really would, we'd need some special library for DNS access, getting TXT records isn't built into libc.\r\n\r\n> One creative cross-platform way to find the default gateway is, like traceroute, to send an ICMP(v6) message towards a random IPv4/6 address (via TCP), with Hop Limit set to 1, wait for the Destination Unreachable Message response and get the origin IP. \r\n\r\nIt's a clever idea, but sending/receiving ICMP needs raw socket privileges on many operating systems.",
      "created_at" : "2024-05-15T12:00:38Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2112341321",
      "id" : 2112341321,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585958VJ",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2112341321/reactions"
      },
      "updated_at" : "2024-05-15T12:02:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2112341321",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Maybe you can split src/util/netif.h off into a separate PR, along with https://github.com/bitcoin/bitcoin/commit/b06edec229d5cfc8d0d1a19bd723852e6bcfd9d9.\r\n\r\nSure, could do that.\r\n\r\n> So maybe we should just pick one at random rather than announce all three. This also seems orthogonal to PCP.\r\n\r\nThanks, that's interesting.\r\n\r\nOne problem is that routers might fail to pinhole some of the addresses. For example, Fritz!Box refuses to open ports on temporary privacy ones, which aren't a distinguishable range or type (on purpose). Might end up having no open port at all, or only for a temporary address lifetime. So for this PR, i prefer to keep the \"announce all publicly routable\" that is the current `Discover()` behavior for now.\r\n\r\nFine with discussing changes to IPv6 address choosing behavior later, as you say, it's orthogonal to adding PCP. ",
      "created_at" : "2024-05-16T06:56:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2114203144",
      "id" : 2114203144,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585-BC4I",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2114203144/reactions"
      },
      "updated_at" : "2024-05-16T06:56:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2114203144",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1602742155"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1602742155"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It's hidden as debug because at the moment this is shown when the user doesn't have IPv6. Could boost this to warning if we do the address check first, then don't bother looking for a default gateway if there's none. Will do that.",
      "commit_id" : "9e329fccca3ccaa21432a97e0d7eb9d119fcee06",
      "created_at" : "2024-05-16T07:13:39Z",
      "diff_hunk" : "@@ -47,105 +44,73 @@ static std::atomic<MapPortProtoFlag> g_mapport_current_proto{MapPortProtoFlag::N\n using namespace std::chrono_literals;\n static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD{20min};\n static constexpr auto PORT_MAPPING_RETRY_PERIOD{5min};\n+static constexpr auto PORT_MAPPING_REANNOUNCE_MARGIN{60s};\n \n-#ifdef USE_NATPMP\n-static uint16_t g_mapport_external_port = 0;\n-static bool NatpmpInit(natpmp_t* natpmp)\n+static bool ProcessPCP()\n {\n-    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n-    if (r_init == 0) return true;\n-    LogPrintf(\"natpmp: initnatpmp() failed with %d error.\\n\", r_init);\n-    return false;\n-}\n+    // The same nonce is used for all mappings, this is allowed by the spec, and simplifies keeping track of them.\n+    PCPMappingNonce pcp_nonce;\n+    GetRandBytes(pcp_nonce);\n \n-static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n-{\n-    const int r_send = sendpublicaddressrequest(natpmp);\n-    if (r_send == 2 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            external_ipv4_addr = response.pnu.publicaddress.addr;\n-            return true;\n-        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n-            LogPrintf(\"natpmp: The gateway does not support NAT-PMP.\\n\");\n+    bool ret = false;\n+    const uint16_t private_port = GetListenPort();\n+    // Request reannounce period plus safety margin.\n+    const uint32_t requested_lifetime = std::chrono::seconds(PORT_MAPPING_REANNOUNCE_PERIOD + PORT_MAPPING_REANNOUNCE_MARGIN).count();\n+    std::chrono::seconds sleep_time;\n+\n+    do {\n+        uint32_t actual_lifetime = requested_lifetime;\n+        ret = false; // Set to true if any mapping succeeds.\n+\n+        // IPv4\n+        std::optional<CNetAddr> gateway4 = QueryDefaultGateway(NET_IPV4);\n+        if (!gateway4) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Could not determine IPv4 default gateway\\n\");\n         } else {\n-            LogPrintf(\"natpmp: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: gateway [IPv4]: %s\\n\", gateway4->ToStringAddr());\n+\n+            // Open a port mapping on whatever local address we have toward the gateway.\n+            struct in_addr inaddr_any;\n+            inaddr_any.s_addr = htonl(INADDR_ANY);\n+            std::optional<MappingResult> res = PCPRequestPortMap(pcp_nonce, *gateway4, CNetAddr(inaddr_any), private_port, requested_lifetime);\n+            if (res) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Info, \"pcp: ExternalIPv4Address:port = %s\\n\", res->external.ToStringAddrPort());\n+                AddLocal(res->external, LOCAL_MAPPED);\n+                ret = true;\n+                actual_lifetime = std::min(actual_lifetime, res->lifetime);\n+            }\n         }\n-    } else {\n-        LogPrintf(\"natpmp: sendpublicaddressrequest() failed with %d error.\\n\", r_send);\n-    }\n \n-    return false;\n-}\n-\n-static bool NatpmpMapping(natpmp_t* natpmp, const struct in_addr& external_ipv4_addr, uint16_t private_port, bool& external_ip_discovered)\n-{\n-    const uint16_t suggested_external_port = g_mapport_external_port ? g_mapport_external_port : private_port;\n-    const int r_send = sendnewportmappingrequest(natpmp, NATPMP_PROTOCOL_TCP, private_port, suggested_external_port, 3600 /*seconds*/);\n-    if (r_send == 12 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            auto pm = response.pnu.newportmapping;\n-            if (private_port == pm.privateport && pm.lifetime > 0) {\n-                g_mapport_external_port = pm.mappedpublicport;\n-                const CService external{external_ipv4_addr, pm.mappedpublicport};\n-                if (!external_ip_discovered && fDiscover) {\n-                    AddLocal(external, LOCAL_MAPPED);\n-                    external_ip_discovered = true;\n+        // IPv6\n+        std::optional<CNetAddr> gateway6 = QueryDefaultGateway(NET_IPV6);\n+        if (!gateway6) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Could not determine IPv6 default gateway\\n\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1602742155",
      "id" : 1602742155,
      "in_reply_to_id" : 1595583401,
      "line" : 85,
      "node_id" : "PRRC_kwDOABII585fh-eL",
      "original_commit_id" : "6cf4809c6b93e1720dfdfe4e3320cfd8939686b6",
      "original_line" : 85,
      "original_position" : 119,
      "original_start_line" : null,
      "path" : "src/mapport.cpp",
      "position" : 119,
      "pull_request_review_id" : 2059790357,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1602742155/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-16T07:13:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1602742155",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1602763394"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1602763394"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Whoops, yes, it's `setEnabled`, not setting the default value ð .",
      "commit_id" : "9e329fccca3ccaa21432a97e0d7eb9d119fcee06",
      "created_at" : "2024-05-16T07:28:29Z",
      "diff_hunk" : "@@ -108,9 +108,7 @@ OptionsDialog::OptionsDialog(QWidget* parent, bool enableWallet)\n #ifndef USE_UPNP\n     ui->mapPortUpnp->setEnabled(false);\n #endif\n-#ifndef USE_NATPMP\n-    ui->mapPortNatpmp->setEnabled(false);\n-#endif\n+    ui->mapPortPCP->setEnabled(false);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1602763394",
      "id" : 1602763394,
      "in_reply_to_id" : 1595141704,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585fiDqC",
      "original_commit_id" : "73037f27fc21765414c298b171dfdeee130c549b",
      "original_line" : 111,
      "original_position" : 7,
      "original_start_line" : null,
      "path" : "src/qt/optionsdialog.cpp",
      "position" : null,
      "pull_request_review_id" : 2059823939,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1602763394/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-16T07:28:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1602763394",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1602770267"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1602770267"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Will keep this open but leave it as-is for now. For IPv4 i'm not currently sure how to check if we have (Internet) networking besides checking for a default gateway, and i'd like to keep the two paths reasonably symmetric. Just checking for publicly routable addresses isn't going to cut it for IPv4.",
      "commit_id" : "9e329fccca3ccaa21432a97e0d7eb9d119fcee06",
      "created_at" : "2024-05-16T07:33:03Z",
      "diff_hunk" : "@@ -47,105 +44,73 @@ static std::atomic<MapPortProtoFlag> g_mapport_current_proto{MapPortProtoFlag::N\n using namespace std::chrono_literals;\n static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD{20min};\n static constexpr auto PORT_MAPPING_RETRY_PERIOD{5min};\n+static constexpr auto PORT_MAPPING_REANNOUNCE_MARGIN{60s};\n \n-#ifdef USE_NATPMP\n-static uint16_t g_mapport_external_port = 0;\n-static bool NatpmpInit(natpmp_t* natpmp)\n+static bool ProcessPCP()\n {\n-    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n-    if (r_init == 0) return true;\n-    LogPrintf(\"natpmp: initnatpmp() failed with %d error.\\n\", r_init);\n-    return false;\n-}\n+    // The same nonce is used for all mappings, this is allowed by the spec, and simplifies keeping track of them.\n+    PCPMappingNonce pcp_nonce;\n+    GetRandBytes(pcp_nonce);\n \n-static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n-{\n-    const int r_send = sendpublicaddressrequest(natpmp);\n-    if (r_send == 2 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            external_ipv4_addr = response.pnu.publicaddress.addr;\n-            return true;\n-        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n-            LogPrintf(\"natpmp: The gateway does not support NAT-PMP.\\n\");\n+    bool ret = false;\n+    const uint16_t private_port = GetListenPort();\n+    // Request reannounce period plus safety margin.\n+    const uint32_t requested_lifetime = std::chrono::seconds(PORT_MAPPING_REANNOUNCE_PERIOD + PORT_MAPPING_REANNOUNCE_MARGIN).count();\n+    std::chrono::seconds sleep_time;\n+\n+    do {\n+        uint32_t actual_lifetime = requested_lifetime;\n+        ret = false; // Set to true if any mapping succeeds.\n+\n+        // IPv4\n+        std::optional<CNetAddr> gateway4 = QueryDefaultGateway(NET_IPV4);\n+        if (!gateway4) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Could not determine IPv4 default gateway\\n\");\n         } else {\n-            LogPrintf(\"natpmp: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: gateway [IPv4]: %s\\n\", gateway4->ToStringAddr());\n+\n+            // Open a port mapping on whatever local address we have toward the gateway.\n+            struct in_addr inaddr_any;\n+            inaddr_any.s_addr = htonl(INADDR_ANY);\n+            std::optional<MappingResult> res = PCPRequestPortMap(pcp_nonce, *gateway4, CNetAddr(inaddr_any), private_port, requested_lifetime);\n+            if (res) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Info, \"pcp: ExternalIPv4Address:port = %s\\n\", res->external.ToStringAddrPort());\n+                AddLocal(res->external, LOCAL_MAPPED);\n+                ret = true;\n+                actual_lifetime = std::min(actual_lifetime, res->lifetime);\n+            }\n         }\n-    } else {\n-        LogPrintf(\"natpmp: sendpublicaddressrequest() failed with %d error.\\n\", r_send);\n-    }\n \n-    return false;\n-}\n-\n-static bool NatpmpMapping(natpmp_t* natpmp, const struct in_addr& external_ipv4_addr, uint16_t private_port, bool& external_ip_discovered)\n-{\n-    const uint16_t suggested_external_port = g_mapport_external_port ? g_mapport_external_port : private_port;\n-    const int r_send = sendnewportmappingrequest(natpmp, NATPMP_PROTOCOL_TCP, private_port, suggested_external_port, 3600 /*seconds*/);\n-    if (r_send == 12 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            auto pm = response.pnu.newportmapping;\n-            if (private_port == pm.privateport && pm.lifetime > 0) {\n-                g_mapport_external_port = pm.mappedpublicport;\n-                const CService external{external_ipv4_addr, pm.mappedpublicport};\n-                if (!external_ip_discovered && fDiscover) {\n-                    AddLocal(external, LOCAL_MAPPED);\n-                    external_ip_discovered = true;\n+        // IPv6\n+        std::optional<CNetAddr> gateway6 = QueryDefaultGateway(NET_IPV6);\n+        if (!gateway6) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Could not determine IPv6 default gateway\\n\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1602770267",
      "id" : 1602770267,
      "in_reply_to_id" : 1595583401,
      "line" : 85,
      "node_id" : "PRRC_kwDOABII585fiFVb",
      "original_commit_id" : "6cf4809c6b93e1720dfdfe4e3320cfd8939686b6",
      "original_line" : 85,
      "original_position" : 119,
      "original_start_line" : null,
      "path" : "src/mapport.cpp",
      "position" : 119,
      "pull_request_review_id" : 2059835406,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1602770267/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-16T07:33:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1602770267",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "- Rebased for a trivial merge conflict related to clang installation in `.github/workflows/ci.yml`.\r\n- Needed to change the use of `bitcoin_config.h` to make the lint pass.\r\n- Split `netif.h` and `netif.cpp` creation into a seperate commit (could be a seperate PR later).\r\n- Addressed a few comments.",
      "created_at" : "2024-05-16T07:43:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2114295253",
      "id" : 2114295253,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585-BZXV",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2114295253/reactions"
      },
      "updated_at" : "2024-05-16T08:22:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2114295253",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1603565742"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1603565742"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "The following patch uses a netlink socket to get the information from the kernel, that is supported on (at least) Linux and FreeBSD>=13.2:\r\n\r\n<details>\r\n<summary>[patch] get default gateway using a netlink socket</summary>\r\n\r\n```diff\r\n--- a/src/test/netbase_tests.cpp\r\n+++ b/src/test/netbase_tests.cpp\r\n@@ -1,25 +1,34 @@\r\n // Copyright (c) 2012-2022 The Bitcoin Core developers\r\n // Distributed under the MIT software license, see the accompanying\r\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n \r\n+#include <compat/compat.h>\r\n #include <net_permissions.h>\r\n #include <netaddress.h>\r\n #include <netbase.h>\r\n #include <netgroup.h>\r\n #include <protocol.h>\r\n #include <serialize.h>\r\n #include <streams.h>\r\n #include <test/util/setup_common.h>\r\n #include <util/strencodings.h>\r\n+#include <util/syserror.h>\r\n #include <util/translation.h>\r\n \r\n #include <string>\r\n \r\n #include <boost/test/unit_test.hpp>\r\n \r\n+#ifdef __linux__\r\n+#include <linux/rtnetlink.h>\r\n+#elif defined(__FreeBSD__)\r\n+#include <netlink/netlink.h>\r\n+#include <netlink/netlink_route.h>\r\n+#endif\r\n+\r\n using namespace std::literals;\r\n \r\n BOOST_FIXTURE_TEST_SUITE(netbase_tests, BasicTestingSetup)\r\n \r\n static CNetAddr ResolveIP(const std::string& ip)\r\n {\r\n@@ -610,7 +619,100 @@ BOOST_AUTO_TEST_CASE(isbadport)\r\n             ++total_bad_ports;\r\n         }\r\n     }\r\n     BOOST_CHECK_EQUAL(total_bad_ports, 80);\r\n }\r\n \r\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\r\n+{\r\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\r\n+\r\n+    // Create a netlink socket.\r\n+\r\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\r\n+    if (s < 0) {\r\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\r\n+        return std::nullopt;\r\n+    }\r\n+    Sock sock{static_cast<SOCKET>(s)};\r\n+\r\n+    // Send request.\r\n+\r\n+    struct {\r\n+        nlmsghdr hdr; ///< Request header.\r\n+        rtmsg data; ///< Request data, a \"route message\".\r\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\r\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\r\n+    } request;\r\n+\r\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\r\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\r\n+\r\n+    memset(&request, 0x0, sizeof(request));\r\n+\r\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\r\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\r\n+#ifdef __linux__\r\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\r\n+#endif\r\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\r\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\r\n+    request.data.rtm_family = network == NET_IPV4 ? AF_INET : AF_INET6;\r\n+    request.data.rtm_dst_len = 0; // Prefix length.\r\n+#ifdef __FreeBSD__\r\n+    request.data.rtm_flags = RTM_F_PREFIX;\r\n+#endif\r\n+    request.dst_hdr.nla_type = RTA_DST;\r\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\r\n+\r\n+    if (sock.Send(&request, sizeof(request), 0) != sizeof(request)) {\r\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", SysErrorString(errno));\r\n+        return std::nullopt;\r\n+    }\r\n+\r\n+    // Receive response.\r\n+\r\n+    char response[4096];\r\n+    ssize_t response_len;\r\n+    do {\r\n+        response_len = sock.Recv(response, sizeof(response), 0);\r\n+    } while (response_len < 0 && (errno == EINTR || errno == EAGAIN));\r\n+    if (response_len < 0) {\r\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", SysErrorString(errno));\r\n+        return std::nullopt;\r\n+    }\r\n+\r\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\r\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\r\n+        int remaining_len = RTM_PAYLOAD(hdr);\r\n+        // Iterate over the attributes.\r\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\r\n+            if (attr->rta_type == RTA_GATEWAY) {\r\n+                if (network == NET_IPV4) {\r\n+                    Assume(sizeof(in_addr) == RTA_PAYLOAD(attr));\r\n+                    return CNetAddr{in_addr{.s_addr = *static_cast<decltype(in_addr::s_addr)*>(RTA_DATA(attr))}};\r\n+                } else {\r\n+                    Assume(sizeof(in6_addr) == RTA_PAYLOAD(attr));\r\n+                    in6_addr gw;\r\n+                    std::memcpy(&gw, RTA_DATA(attr), sizeof(gw));\r\n+                    return CNetAddr{gw};\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    return std::nullopt;\r\n+}\r\n+\r\n+BOOST_AUTO_TEST_CASE(netlink)\r\n+{\r\n+    for (const auto net : {NET_IPV4, NET_IPV6}) {\r\n+        const auto gw{QueryDefaultGateway(net)};\r\n+        if (gw.has_value()) {\r\n+            printf(\"Default %s gateway: %s\\n\", GetNetworkName(net).c_str(), gw->ToStringAddr().c_str());\r\n+        } else {\r\n+            printf(\"No %s default gateway.\\n\", GetNetworkName(net).c_str());\r\n+        }\r\n+    }\r\n+}\r\n+\r\n BOOST_AUTO_TEST_SUITE_END()\r\n```\r\n</details>\r\n\r\nI find the netlink interface a somewhat difficult to grasp.\r\n\r\nhttps://man7.org/linux/man-pages/man7/netlink.7.html\r\nhttps://man7.org/linux/man-pages/man7/rtnetlink.7.html\r\nhttps://man7.org/linux/man-pages/man3/rtnetlink.3.html\r\nhttps://stackoverflow.com/questions/11788326/extract-current-route-from-netlink-message-code-attached\r\nhttps://www.rfc-editor.org/rfc/rfc3549",
      "commit_id" : "39933a53f3a3d29cfebd8252a9b4ddcb48d3965c",
      "created_at" : "2024-05-16T15:10:54Z",
      "diff_hunk" : "@@ -0,0 +1,116 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+#ifdef HAVE_LINUX_ROUTE_H\n+\n+#include <linux/route.h>\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1603565742",
      "id" : 1603565742,
      "line" : 19,
      "node_id" : "PRRC_kwDOABII585flHiu",
      "original_commit_id" : "39933a53f3a3d29cfebd8252a9b4ddcb48d3965c",
      "original_line" : 19,
      "original_position" : 19,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 19,
      "pull_request_review_id" : 2061123015,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1603565742/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-16T15:48:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1603565742",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1603770501"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1603770501"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Huh interesting. i didn't know netlink worked for multiple operating systems, that's much better.",
      "commit_id" : "39933a53f3a3d29cfebd8252a9b4ddcb48d3965c",
      "created_at" : "2024-05-16T17:31:16Z",
      "diff_hunk" : "@@ -0,0 +1,116 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+#ifdef HAVE_LINUX_ROUTE_H\n+\n+#include <linux/route.h>\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1603770501",
      "id" : 1603770501,
      "in_reply_to_id" : 1603565742,
      "line" : 19,
      "node_id" : "PRRC_kwDOABII585fl5iF",
      "original_commit_id" : "39933a53f3a3d29cfebd8252a9b4ddcb48d3965c",
      "original_line" : 19,
      "original_position" : 19,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 19,
      "pull_request_review_id" : 2061450460,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1603770501/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-16T17:31:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1603770501",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1603876259"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1603876259"
         }
      },
      "author_association" : "MEMBER",
      "body" : "~~Is it possible to get the `scope_id` for IPv6 addresses? At least my router gives me an link-scope address.~~\r\n\r\nEdit: on linux this is `RTA_OIF`, it appears",
      "commit_id" : "bb4eeed169b150b19036756dc0c4f412ae31c1d3",
      "created_at" : "2024-05-16T18:37:25Z",
      "diff_hunk" : "@@ -0,0 +1,116 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+#ifdef HAVE_LINUX_ROUTE_H\n+\n+#include <linux/route.h>\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1603876259",
      "id" : 1603876259,
      "in_reply_to_id" : 1603565742,
      "line" : 24,
      "node_id" : "PRRC_kwDOABII585fmTWj",
      "original_commit_id" : "39933a53f3a3d29cfebd8252a9b4ddcb48d3965c",
      "original_line" : 19,
      "original_position" : 19,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 24,
      "pull_request_review_id" : 2061615847,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1603876259/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-16T19:00:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1603876259",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Replaced Linux-specific `QueryDefaultGateway` with @vasild's netlink implementation for Linux and FreeBSD. This may even generalize to more UNIX variants. \r\n\r\nWill tackle Windows next.",
      "created_at" : "2024-05-16T19:04:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2115990626",
      "id" : 2115990626,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585-H3Ri",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2115990626/reactions"
      },
      "updated_at" : "2024-05-16T19:04:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2115990626",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--85328a0da195eb286784d51f73fa0af9-->\n\nð§ At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/25069227736</sub>",
      "created_at" : "2024-05-16T20:53:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2116158791",
      "id" : 2116158791,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585-IgVH",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2116158791/reactions"
      },
      "updated_at" : "2024-05-16T20:53:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2116158791",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Added a ~~(mostly untested for now)~~ Windows implementation of `QueryDefaultGateway`, if someone could test this it'd be very helpful. i will try in WINE later.\r\n\r\nEdit: Wine has only a stub for `GetBestRoute2`, so tested on Amazon EC2 actual windows, can't check PCP due to lack of a suitable router there, but IP address and default gateway finding works:\r\n```\r\n2024-05-17T14:17:48Z [net] pcp: gateway [IPv4]: 172.31.16.1\r\n2024-05-17T14:17:48Z [net] pcp: Requesting port mapping for addr 0.0.0.0 port 18444 from gateway 172.31.16.1                                                                                                                                   \r\n2024-05-17T14:17:48Z [net] pcp: Internal address after connect: 172.31.28.xxx                                                                             \r\n2024-05-17T14:17:51Z [net] pcp: gateway [IPv6]: fe80::58:f4ff:feca:xxxx%7\r\n2024-05-17T14:17:51Z [net] pcp: Requesting port mapping for addr 2600:1f1c:b80:8af0:e073:32d6:80b3:xxxx port 18444 from gateway fe80::58:f4ff:feca:xxxx%7\r\n2024-05-17T14:17:51Z [net] pcp: Internal address after connect: 2600:1f1c:b80:8af0:e073:32d6:80b3:xxxx\r\n```",
      "created_at" : "2024-05-17T08:18:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2117004469",
      "id" : 2117004469,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585-Luy1",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2117004469/reactions"
      },
      "updated_at" : "2024-05-23T08:30:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2117004469",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1604635967"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1604635967"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Here is a standalone program to get the default gateway using a netlink socket:\r\n\r\n<details>\r\n<summary>netlink_get_default_route.cc</summary>\r\n\r\n```cc\r\n#include <arpa/inet.h>\r\n#include <assert.h>\r\n#include <errno.h>\r\n#include <net/if.h>\r\n#include <netinet/in.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <sys/socket.h>\r\n#include <sys/types.h>\r\n#include <unistd.h>\r\n\r\n#ifdef __linux__\r\n#include <linux/rtnetlink.h>\r\n#elif defined(__FreeBSD__)\r\n#include <netlink/netlink.h>\r\n#include <netlink/netlink_route.h>\r\n#endif\r\n\r\nvoid QueryDefaultGateway(sa_family_t family)\r\n{\r\n    // Create a netlink socket.\r\n\r\n    int sock = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE);\r\n    if (sock < 0) {\r\n        perror(\"socket(AF_NETLINK)\");\r\n        return;\r\n    }\r\n\r\n    // Send request.\r\n\r\n    struct {\r\n        nlmsghdr hdr; ///< Request header.\r\n        rtmsg data; ///< Request data, a \"route message\".\r\n        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\r\n        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\r\n    } request{};\r\n\r\n    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\r\n    const size_t dst_data_len = family == AF_INET ? 4 : 16;\r\n\r\n    request.hdr.nlmsg_type = RTM_GETROUTE;\r\n    request.hdr.nlmsg_flags = NLM_F_REQUEST;\r\n#ifdef __linux__\r\n    // XXX some strange behavior:\r\n    // Linux IPv4 - this must be present, otherwise no gateway is found\r\n    // Linux IPv6 - this must be present, otherwise no gateway is found\r\n    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\r\n    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\r\n    request.hdr.nlmsg_flags |= NLM_F_DUMP;\r\n#endif\r\n    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\r\n    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\r\n    request.data.rtm_family = family;\r\n    request.data.rtm_dst_len = 0; // Prefix length.\r\n    //request.data.rtm_table = RT_TABLE_MAIN;\r\n    //request.data.rtm_protocol = RTPROT_STATIC;\r\n    //request.data.rtm_scope = RT_SCOPE_UNIVERSE;\r\n    //request.data.rtm_type = RTN_UNICAST;\r\n#ifdef __FreeBSD__\r\n    // XXX some strange behavior:\r\n    // Linux IPv4 - this must be absent, otherwise no gateway is found\r\n    // Linux IPv6 - this must be absent, otherwise no gateway is found\r\n    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\r\n    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\r\n    request.data.rtm_flags = RTM_F_PREFIX;\r\n#endif\r\n    request.dst_hdr.nla_type = RTA_DST;\r\n    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\r\n\r\n    if (send(sock, &request, request.hdr.nlmsg_len, 0) != request.hdr.nlmsg_len) {\r\n        fprintf(stderr, \"send() failed to send %u bytes\\n\", request.hdr.nlmsg_len);\r\n        close(sock);\r\n        return;\r\n    }\r\n\r\n    // Receive response.\r\n\r\n    char response[4096];\r\n    ssize_t response_len;\r\n    do {\r\n        response_len = recv(sock, response, sizeof(response), 0);\r\n    } while (response_len < 0 && (errno == EINTR || errno == EAGAIN));\r\n    if (response_len < 0) {\r\n        fprintf(stderr, \"recv(): %s\\n\", strerror(errno));\r\n        close(sock);\r\n        return;\r\n    }\r\n\r\n    for (nlmsghdr *hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\r\n        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\r\n        int remaining_len = RTM_PAYLOAD(hdr);\r\n\r\n        // Iterate over the attributes.\r\n        rtattr* rta_gateway = nullptr;\r\n        int scope_id = 0;\r\n        for (rtattr *attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\r\n            if (attr->rta_type == RTA_GATEWAY) {\r\n                rta_gateway = attr;\r\n            } else if (attr->rta_type == RTA_OIF) {\r\n                assert(sizeof(int) == RTA_PAYLOAD(attr));\r\n                memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\r\n            }\r\n        }\r\n\r\n        // Found gateway?\r\n        if (rta_gateway != nullptr) {\r\n            char buf[256];\r\n            printf(\"%s gateway: %s\",\r\n                   family == AF_INET ? \"IPv4\" : \"IPv6\",\r\n                   inet_ntop(r->rtm_family, RTA_DATA(rta_gateway), buf, sizeof(buf)));\r\n            if (family == AF_INET6) {\r\n                printf(\", scope id: %d\\n\", scope_id);\r\n            } else {\r\n                printf(\"\\n\");\r\n            }\r\n        }\r\n    }\r\n\r\n    close(sock);\r\n}\r\n\r\nint main(int argc, char** argv)\r\n{\r\n    QueryDefaultGateway(AF_INET);\r\n    QueryDefaultGateway(AF_INET6);\r\n    return 0;\r\n}\r\n```\r\n</details>\r\n\r\nIdeally the `#ifdef __linux__` / `#ifdef __FreeBSD__` parts should not be needed. I am not sure if this is due to the above program doing something wrong or is due to a difference in Linux vs FreeBSD implementations. @AlexanderChernikov, @markjdb, any ideas?",
      "commit_id" : "841deffd44d7a78452deab39adadbf991249128a",
      "created_at" : "2024-05-17T09:30:22Z",
      "diff_hunk" : "@@ -0,0 +1,116 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+#ifdef HAVE_LINUX_ROUTE_H\n+\n+#include <linux/route.h>\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1604635967",
      "id" : 1604635967,
      "in_reply_to_id" : 1603565742,
      "line" : 24,
      "node_id" : "PRRC_kwDOABII585fpM0_",
      "original_commit_id" : "39933a53f3a3d29cfebd8252a9b4ddcb48d3965c",
      "original_line" : 19,
      "original_position" : 19,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 24,
      "pull_request_review_id" : 2062804021,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 1,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1604635967/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-17T09:30:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1604635967",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1604672913"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1604672913"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I realized that in the IPv4 case this would send the trailing 16-4=12 bytes from `request.dst_data[]`. This seems harmless, but better send exactly what's needed:\r\n\r\n```suggestion\r\n    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != request.hdr.nlmsg_len) {\r\n        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", SysErrorString(errno));\r\n```\r\n\r\nAlso, I am not sure if we should worry about partial writes with netlink sockets, maybe the send can be interrupted? There is a convenience method `Sock::SendComplete()`:\r\n\r\n```cc\r\n    try {\r\n        CThreadInterrupt intr;\r\n        sock.SendComplete(Span{reinterpret_cast<const unsigned char*>(&request), request.hdr.nlmsg_len}, 5s, intr);\r\n    } catch (const std::runtime_error& e) {\r\n        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"writing to netlink socket: %s\\n\", e.what());\r\n        return std::nullopt;\r\n    }\r\n```",
      "commit_id" : "841deffd44d7a78452deab39adadbf991249128a",
      "created_at" : "2024-05-17T09:56:08Z",
      "diff_hunk" : "@@ -0,0 +1,206 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = network == NET_IPV4 ? AF_INET : AF_INET6;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, sizeof(request), 0) != sizeof(request)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", SysErrorString(errno));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1604672913",
      "id" : 1604672913,
      "line" : 63,
      "node_id" : "PRRC_kwDOABII585fpV2R",
      "original_commit_id" : "841deffd44d7a78452deab39adadbf991249128a",
      "original_line" : 63,
      "original_position" : 63,
      "original_start_line" : 62,
      "path" : "src/util/netif.cpp",
      "position" : 63,
      "pull_request_review_id" : 2062857416,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1604672913/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 62,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2024-05-17T09:56:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1604672913",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1604736981"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1604736981"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It's a datagram (packet socket), so *partial* writes and reads cannot happen. Every send is interpreted as a new packet. Using `SendComplete` would be a bug.\r\n\r\nTruncated and corrupted packets could happen in the case of UDP, but as NETLINK is a communication interface with the kernel, that would be rare. No retries are needed. Would still want to detect it and error out gracefully, though, for robustness.\r\n\r\n> I realized that in the IPv4 case this would send the trailing 16-4=12 bytes from request.dst_data[]. This seems harmless, but better send exactly what's needed\r\n\r\nAgreed, will change that.",
      "commit_id" : "841deffd44d7a78452deab39adadbf991249128a",
      "created_at" : "2024-05-17T10:32:41Z",
      "diff_hunk" : "@@ -0,0 +1,206 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = network == NET_IPV4 ? AF_INET : AF_INET6;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, sizeof(request), 0) != sizeof(request)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", SysErrorString(errno));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1604736981",
      "id" : 1604736981,
      "in_reply_to_id" : 1604672913,
      "line" : 63,
      "node_id" : "PRRC_kwDOABII585fplfV",
      "original_commit_id" : "841deffd44d7a78452deab39adadbf991249128a",
      "original_line" : 63,
      "original_position" : 63,
      "original_start_line" : 62,
      "path" : "src/util/netif.cpp",
      "position" : 63,
      "pull_request_review_id" : 2062948610,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1604736981/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 62,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2024-05-17T10:35:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1604736981",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Do we have any information about real-world deployment of PCP vs NAT-PMP? I see PCP dates from 2013, but do we know if it was adopted immediately (and/or, how many older routing devices are in common use)?\r\n\r\nRFC 6887 Appendix A explains how one can be compatible with both, though I don't know how much work it would be to implement.",
      "created_at" : "2024-05-17T14:11:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2117698802",
      "id" : 2117698802,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585-OYTy",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2117698802/reactions"
      },
      "updated_at" : "2024-05-17T14:11:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2117698802",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "i have no idea, also no idea how to get that information; to be honest if we can remotely avoid it, i'd prefer not to implement unnecessary compatibility stuff, with the added complexity that entails, this is already a lot to ask people to review as-is.\r\n\r\nEdit: but this is what we did.",
      "created_at" : "2024-05-17T14:22:21Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2117723501",
      "id" : 2117723501,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585-OeVt",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2117723501/reactions"
      },
      "updated_at" : "2024-05-23T08:30:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2117723501",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@laanwj Yeah, fair enough. Absent any reports of \"doesn't work on my router while nat-pmp worked\" (which we're quite unlikely to get) there is really no way to assess that.",
      "created_at" : "2024-05-17T14:28:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2117736423",
      "id" : 2117736423,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585-Ohfn",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2117736423/reactions"
      },
      "updated_at" : "2024-05-17T14:28:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2117736423",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Yeah, fair enough. Absent any reports of \"doesn't work on my router while nat-pmp worked\" (which we're quite unlikely to get) there is really no way to assess that.\r\n\r\nFor what it's worth, initial support for PCP was added in miniupnpd in [2013](https://github.com/miniupnp/miniupnp/commit/9e1ffd5cd9836053cfd83d95014c729ad0e36872). So the implementation wasn't lagging much behind the standard. Of course, not all routers use miniupnpd but it's extremely common.\r\n\r\nIf we get reports like that, we can decide to re-add NAT-PMP in a similar way as the current code., without reintroducing the dependency. It's not that different, it can share the gateway finding code, for one.",
      "created_at" : "2024-05-17T14:35:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2117749832",
      "id" : 2117749832,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585-OkxI",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2117749832/reactions"
      },
      "updated_at" : "2024-05-17T14:43:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2117749832",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "MacOS implementation of default gateway finding was added as well (i've tested it on MacOS Monterey, but could always use more, especially ARM macs would be interesting). This concludes the coverage of default gateway-finding on the major platforms.",
      "created_at" : "2024-05-18T12:15:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2118804764",
      "id" : 2118804764,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585-SmUc",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2118804764/reactions"
      },
      "updated_at" : "2024-05-18T12:24:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2118804764",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Squashed all fixups into their logical commit. This should be in a good state for review now. The only TODO that is left to do is the Qt settings migration (so that if the user had enabled `natpmp`, `pcp` will now be enabled), i could use some help with that because i don't really know the new mechanism.",
      "created_at" : "2024-05-19T08:09:16Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2119145090",
      "id" : 2119145090,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585-T5aC",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2119145090/reactions"
      },
      "updated_at" : "2024-05-19T08:10:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2119145090",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Trying this with `-pcp=1` on my home internet connection:\r\n```\r\n2024-05-20T23:28:41.625432Z [net] pcp: gateway [IPv4]: 192.168.1.1\r\n2024-05-20T23:28:41.625469Z [net] pcp: Requesting port mapping for addr 0.0.0.0 port 8333 from gateway 192.168.1.1\r\n2024-05-20T23:28:41.625529Z [net] pcp: Internal address after connect: 192.168.1.254\r\n2024-05-20T23:28:41.626388Z [net] pcp: Received response of 8 bytes: 008100010046cfb7\r\n2024-05-20T23:28:41.626404Z [net:warning] pcp: Response too small\r\n2024-05-20T23:28:42.627214Z [net] pcp: Timeout\r\n2024-05-20T23:28:42.627258Z [net] pcp: Retrying (1)\r\n2024-05-20T23:28:42.627870Z [net] pcp: Received response of 8 bytes: 008100010046cfb8\r\n2024-05-20T23:28:42.627901Z [net:warning] pcp: Response too small\r\n2024-05-20T23:28:43.628167Z [net] pcp: Timeout\r\n2024-05-20T23:28:43.628228Z [net] pcp: Retrying (2)\r\n2024-05-20T23:28:43.628976Z [net] pcp: Received response of 8 bytes: 008100010046cfb9\r\n2024-05-20T23:28:43.628999Z [net:warning] pcp: Response too small\r\n2024-05-20T23:28:44.629173Z [net] pcp: Timeout\r\n2024-05-20T23:28:44.629225Z [net] pcp: Giving up after 3 tries\r\n2024-05-20T23:28:44.632097Z [net] pcp: Could not determine IPv6 default gateway\r\n```\r\n",
      "created_at" : "2024-05-20T23:32:08Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2121393948",
      "id" : 2121393948,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585-cecc",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2121393948/reactions"
      },
      "updated_at" : "2024-05-20T23:32:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2121393948",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Trying this with -pcp=1 on my home internet connection:\r\n\r\nThanks for testing!\r\nThe received packet is not a valid PCP response (too short). But interpreting it as one anyway, the version byte is 0x00, result code is 0x01 (UNSUPP_VERSION). So you might have one of those routers that supports NAT-PMP only.",
      "created_at" : "2024-05-21T07:47:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2121977231",
      "id" : 2121977231,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585-es2P",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2121977231/reactions"
      },
      "updated_at" : "2024-05-21T07:47:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2121977231",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@laanwj This is a router provided by Verizon (a large US ISP) in 2021.",
      "created_at" : "2024-05-21T11:44:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2122446973",
      "id" : 2122446973,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585-gfh9",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2122446973/reactions"
      },
      "updated_at" : "2024-05-21T11:44:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2122446973",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> @laanwj This is a router provided by Verizon (a large US ISP) in 2021.\r\n\r\nThat's curious, especially as NAT-PMP doesn't have any IPv6 support. i'm assuming you don't have any output for IPv6?",
      "created_at" : "2024-05-21T12:39:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2122543090",
      "id" : 2122543090,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585-g2_y",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2122543090/reactions"
      },
      "updated_at" : "2024-05-21T12:39:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2122543090",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--9cd9c72976c961c55c7acef8f6ba82cd-->\n### Guix builds (on x86_64) [untrusted test-only build, possibly unsafe, not for production use]\n\n| File | commit a786fd2041913d82ca90b561de309421bd24e41b<br>(master) | commit 7718a5c42f086b7c78000770a68170ff83c79038<br>(master and this pull) |\n|--|--|--|\n| SHA256SUMS.part | [`14f282b5bf7ebcd4...`](https://drahtbot.space/guix/bitcoin/bitcoin/a786fd2041913d82ca90b561de309421bd24e41b/SHA256SUMS.part) | [`bde34ea3844bc5a1...`](https://drahtbot.space/guix/bitcoin/bitcoin/7718a5c42f086b7c78000770a68170ff83c79038/SHA256SUMS.part) |\n| *-aarch64-linux-gnu-debug.tar.gz | [`b2364625629230d1...`](https://drahtbot.space/guix/bitcoin/bitcoin/a786fd2041913d82ca90b561de309421bd24e41b/bitcoin-a786fd204191-aarch64-linux-gnu-debug.tar.gz) | [`0ddcad066c06e5b5...`](https://drahtbot.space/guix/bitcoin/bitcoin/7718a5c42f086b7c78000770a68170ff83c79038/bitcoin-7718a5c42f08-aarch64-linux-gnu-debug.tar.gz) |\n| *-aarch64-linux-gnu.tar.gz | [`b05fc0561baa0966...`](https://drahtbot.space/guix/bitcoin/bitcoin/a786fd2041913d82ca90b561de309421bd24e41b/bitcoin-a786fd204191-aarch64-linux-gnu.tar.gz) | [`cefac02d8a5e9782...`](https://drahtbot.space/guix/bitcoin/bitcoin/7718a5c42f086b7c78000770a68170ff83c79038/bitcoin-7718a5c42f08-aarch64-linux-gnu.tar.gz) |\n| *-arm-linux-gnueabihf-debug.tar.gz | [`4545637daf89882c...`](https://drahtbot.space/guix/bitcoin/bitcoin/a786fd2041913d82ca90b561de309421bd24e41b/bitcoin-a786fd204191-arm-linux-gnueabihf-debug.tar.gz) | [`391b99ffa321ccd8...`](https://drahtbot.space/guix/bitcoin/bitcoin/7718a5c42f086b7c78000770a68170ff83c79038/bitcoin-7718a5c42f08-arm-linux-gnueabihf-debug.tar.gz) |\n| *-arm-linux-gnueabihf.tar.gz | [`27115f4c7e251175...`](https://drahtbot.space/guix/bitcoin/bitcoin/a786fd2041913d82ca90b561de309421bd24e41b/bitcoin-a786fd204191-arm-linux-gnueabihf.tar.gz) | [`46f4d4ec47bc6a05...`](https://drahtbot.space/guix/bitcoin/bitcoin/7718a5c42f086b7c78000770a68170ff83c79038/bitcoin-7718a5c42f08-arm-linux-gnueabihf.tar.gz) |\n| *-arm64-apple-darwin-unsigned.tar.gz | [`cf3950f9d05fb1c0...`](https://drahtbot.space/guix/bitcoin/bitcoin/a786fd2041913d82ca90b561de309421bd24e41b/bitcoin-a786fd204191-arm64-apple-darwin-unsigned.tar.gz) | [`436221ec28ee31a4...`](https://drahtbot.space/guix/bitcoin/bitcoin/7718a5c42f086b7c78000770a68170ff83c79038/bitcoin-7718a5c42f08-arm64-apple-darwin-unsigned.tar.gz) |\n| *-arm64-apple-darwin-unsigned.zip | [`b1c32e004722a3b4...`](https://drahtbot.space/guix/bitcoin/bitcoin/a786fd2041913d82ca90b561de309421bd24e41b/bitcoin-a786fd204191-arm64-apple-darwin-unsigned.zip) | [`8c509e13ed24a312...`](https://drahtbot.space/guix/bitcoin/bitcoin/7718a5c42f086b7c78000770a68170ff83c79038/bitcoin-7718a5c42f08-arm64-apple-darwin-unsigned.zip) |\n| *-arm64-apple-darwin.tar.gz | [`f09a38acef4b141b...`](https://drahtbot.space/guix/bitcoin/bitcoin/a786fd2041913d82ca90b561de309421bd24e41b/bitcoin-a786fd204191-arm64-apple-darwin.tar.gz) | [`b769aecd340fd798...`](https://drahtbot.space/guix/bitcoin/bitcoin/7718a5c42f086b7c78000770a68170ff83c79038/bitcoin-7718a5c42f08-arm64-apple-darwin.tar.gz) |\n| *-powerpc64-linux-gnu-debug.tar.gz | [`75cfe8d73120b00d...`](https://drahtbot.space/guix/bitcoin/bitcoin/a786fd2041913d82ca90b561de309421bd24e41b/bitcoin-a786fd204191-powerpc64-linux-gnu-debug.tar.gz) | [`feb0c0e88628b733...`](https://drahtbot.space/guix/bitcoin/bitcoin/7718a5c42f086b7c78000770a68170ff83c79038/bitcoin-7718a5c42f08-powerpc64-linux-gnu-debug.tar.gz) |\n| *-powerpc64-linux-gnu.tar.gz | [`d4f8c1296886fac4...`](https://drahtbot.space/guix/bitcoin/bitcoin/a786fd2041913d82ca90b561de309421bd24e41b/bitcoin-a786fd204191-powerpc64-linux-gnu.tar.gz) | [`2588795e780f8e6c...`](https://drahtbot.space/guix/bitcoin/bitcoin/7718a5c42f086b7c78000770a68170ff83c79038/bitcoin-7718a5c42f08-powerpc64-linux-gnu.tar.gz) |\n| *-riscv64-linux-gnu-debug.tar.gz | [`a8f56aee14e85f29...`](https://drahtbot.space/guix/bitcoin/bitcoin/a786fd2041913d82ca90b561de309421bd24e41b/bitcoin-a786fd204191-riscv64-linux-gnu-debug.tar.gz) | [`2d8829895961918e...`](https://drahtbot.space/guix/bitcoin/bitcoin/7718a5c42f086b7c78000770a68170ff83c79038/bitcoin-7718a5c42f08-riscv64-linux-gnu-debug.tar.gz) |\n| *-riscv64-linux-gnu.tar.gz | [`d8a4ae4295e6aa9f...`](https://drahtbot.space/guix/bitcoin/bitcoin/a786fd2041913d82ca90b561de309421bd24e41b/bitcoin-a786fd204191-riscv64-linux-gnu.tar.gz) | [`94779be512d355c9...`](https://drahtbot.space/guix/bitcoin/bitcoin/7718a5c42f086b7c78000770a68170ff83c79038/bitcoin-7718a5c42f08-riscv64-linux-gnu.tar.gz) |\n| *-x86_64-apple-darwin-unsigned.tar.gz | [`ff9ae232120c85f9...`](https://drahtbot.space/guix/bitcoin/bitcoin/a786fd2041913d82ca90b561de309421bd24e41b/bitcoin-a786fd204191-x86_64-apple-darwin-unsigned.tar.gz) | [`295c1ee6c4dc4526...`](https://drahtbot.space/guix/bitcoin/bitcoin/7718a5c42f086b7c78000770a68170ff83c79038/bitcoin-7718a5c42f08-x86_64-apple-darwin-unsigned.tar.gz) |\n| *-x86_64-apple-darwin-unsigned.zip | [`9917159a6fd59954...`](https://drahtbot.space/guix/bitcoin/bitcoin/a786fd2041913d82ca90b561de309421bd24e41b/bitcoin-a786fd204191-x86_64-apple-darwin-unsigned.zip) | [`9c28f7151880f1f4...`](https://drahtbot.space/guix/bitcoin/bitcoin/7718a5c42f086b7c78000770a68170ff83c79038/bitcoin-7718a5c42f08-x86_64-apple-darwin-unsigned.zip) |\n| *-x86_64-apple-darwin.tar.gz | [`61112274cace86c4...`](https://drahtbot.space/guix/bitcoin/bitcoin/a786fd2041913d82ca90b561de309421bd24e41b/bitcoin-a786fd204191-x86_64-apple-darwin.tar.gz) | [`27bf6a03f1abce44...`](https://drahtbot.space/guix/bitcoin/bitcoin/7718a5c42f086b7c78000770a68170ff83c79038/bitcoin-7718a5c42f08-x86_64-apple-darwin.tar.gz) |\n| *-x86_64-linux-gnu-debug.tar.gz | [`557d05bc585a2910...`](https://drahtbot.space/guix/bitcoin/bitcoin/a786fd2041913d82ca90b561de309421bd24e41b/bitcoin-a786fd204191-x86_64-linux-gnu-debug.tar.gz) | [`36db8ad04f331f36...`](https://drahtbot.space/guix/bitcoin/bitcoin/7718a5c42f086b7c78000770a68170ff83c79038/bitcoin-7718a5c42f08-x86_64-linux-gnu-debug.tar.gz) |\n| *-x86_64-linux-gnu.tar.gz | [`4928355769a494d7...`](https://drahtbot.space/guix/bitcoin/bitcoin/a786fd2041913d82ca90b561de309421bd24e41b/bitcoin-a786fd204191-x86_64-linux-gnu.tar.gz) | [`5365b31596e65699...`](https://drahtbot.space/guix/bitcoin/bitcoin/7718a5c42f086b7c78000770a68170ff83c79038/bitcoin-7718a5c42f08-x86_64-linux-gnu.tar.gz) |\n| *.tar.gz | [`49c2acd89613cf65...`](https://drahtbot.space/guix/bitcoin/bitcoin/a786fd2041913d82ca90b561de309421bd24e41b/bitcoin-a786fd204191.tar.gz) | [`51524f7ae096c36f...`](https://drahtbot.space/guix/bitcoin/bitcoin/7718a5c42f086b7c78000770a68170ff83c79038/bitcoin-7718a5c42f08.tar.gz) |\n| guix_build.log | [`88d5371b29f8bb75...`](https://drahtbot.space/guix/bitcoin/bitcoin/a786fd2041913d82ca90b561de309421bd24e41b/guix_build.log) | [`d18448a1f3d9cc20...`](https://drahtbot.space/guix/bitcoin/bitcoin/7718a5c42f086b7c78000770a68170ff83c79038/guix_build.log) |\n| guix_build.log.diff |  | [`3207cbd48d885913...`](https://drahtbot.space/guix/bitcoin/bitcoin/7718a5c42f086b7c78000770a68170ff83c79038/guix_build.log.diff) |\n\n",
      "created_at" : "2024-05-22T05:55:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2123920625",
      "id" : 2123920625,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585-mHTx",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2123920625/reactions"
      },
      "updated_at" : "2024-05-22T05:55:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2123920625",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> The only TODO that is left to do is the Qt settings migration \r\n\r\nAvoiding this complexity is another reason to add a NAT-PMP fallback, then we'd be right to keep the option named the same and only change the descriptions.\r\n\r\nEdit: done",
      "created_at" : "2024-05-22T09:04:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2124254747",
      "id" : 2124254747,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585-nY4b",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2124254747/reactions"
      },
      "updated_at" : "2024-05-23T08:29:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2124254747",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Avoiding this complexity is another reason to add a NAT-PMP fallback, then we'd be right to keep the option named the same and only change the descriptions.\r\n\r\nIf you think such a fallback is easier than dealing with QT settings migration :-)\r\n\r\nWe can just sort them PCP, NAT-PMP, UPNP in the GUI. If we also add the word \"recommended\" to PCP, it should mitigate choice-paralysis. Then in the future we can add a little green dot to indicate that it actually works.\r\n\r\nI tested e6656f981019331db869e5bed1fcb5247bafbc3f  on Windows , (Intel) macOS and Linux.\r\n\r\nOn macOS 14.5 it opens IPv4 and IPv6 ports, which eventually leads to inbound connections (I used a non-8333 port so it takes a while).\r\n\r\nThe OPNsense status page only shows IPv4 mappings, not IPv6 hole punch, but the latter clearly works too.\r\n\r\nOn Windows IPv4 mapping works:\r\n\r\n```\r\n2024-05-22T11:54:07Z [net:info] pcp: Mapping successful: we got x.x.x.x:x for 1260 seconds.\r\n2024-05-22T11:54:07Z [net:info] pcp: ExternalIPv4Address:port = x.x.x.x:x\r\n2024-05-22T11:54:07Z AddLocal(x.x.x.x:x,3)\r\n```\r\n\r\nAnd it gets plenty of inbound IPv4 connections.\r\n\r\nIPv6 mapping failed - I think; the message itself isn't specific that this was IPv6:\r\n\r\n```\r\n2024-05-22T11:54:07Z [net:warning] pcp: Mapping failed with result NO_RESOURCES (code 8)\r\n2024-05-22T11:54:07Z [net:warning] pcp: Mapping failed with result NO_RESOURCES (code 8)\r\n2024-05-22T11:54:08Z [net:warning] pcp: Mapping failed with result NO_RESOURCES (code 8)\r\n```\r\n\r\nWhen I restarted the node I noticed that it didn't even try for IPv6 and that the AddLocal / Discover messages for IPv6 addresses happened _after_ the IPv4 mapping was successful. So maybe it needs to wait a bit? But then upon a third restart I got the same sequence of events, but this time it gave a `NO_RESOURCES` error again (with IPv4 working fine).\r\n\r\nOh and now I'm getting `NO_RESOURCES` on my Mac as well, so I guess I just upset the router.",
      "created_at" : "2024-05-22T10:47:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2124488325",
      "id" : 2124488325,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585-oR6F",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2124488325/reactions"
      },
      "updated_at" : "2024-05-22T12:09:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2124488325",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> If you think such a fallback is easier than dealing with QT settings migration :-)\r\n\r\nYes. It also avoids having to rename the command-line option. It would make the new code a drop-in replacement that also supports IPv6, no change for users.\r\n\r\nIt's a matter of handling UNSUPP_VERSION packets (the one @sipa gets), then re-trying through NAT-PMP, for IPv4. i'm already halfway implementing it.\r\n\r\n(see https://datatracker.ietf.org/doc/html/rfc6886#section-3.5 and https://datatracker.ietf.org/doc/html/rfc6887#appendix-A)",
      "created_at" : "2024-05-22T11:34:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2124574440",
      "id" : 2124574440,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585-om7o",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2124574440/reactions"
      },
      "updated_at" : "2024-05-22T11:46:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2124574440",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Restarting the node with the same port seems to trigger the `NO_RESOURCES` error with IPv6. I guess that's because the previous \"lease\" is still valid. It worked fine on Windows once I picked a fresh port.\r\n\r\nDuring a clean shutdown, we should probably ask the gateway to delete the mapping :\r\n\r\n```\r\nRequested lifetime (in common header):  Requested lifetime of this\r\n      mapping, in seconds.  The value 0 indicates \"delete\".\r\n```\r\n\r\nUpdate: despite the `NO_RESOURCES` I still get inbound IPv6 connections, so we can also just ignore it, but then we don't know when to renew.",
      "created_at" : "2024-05-22T12:11:37Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2124640155",
      "id" : 2124640155,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585-o2-b",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2124640155/reactions"
      },
      "updated_at" : "2024-05-22T12:22:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2124640155",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> During a clean shutdown, we should probably ask the gateway to delete the mapping :\r\n\r\ni wasn't sure about this! Yes, it would be cleaner, but also complicates the code (it would have to keep track of current mappings state). In normal use it's unlikely for a user to restart a node in such a small timespan, and having a node unconnectable for a few minutes isn't a big deal. The mappings aren't too long (20 min) and expire automatically, and it will re-try periodically until it gets one. So it's a problem that solves itself.",
      "created_at" : "2024-05-22T12:23:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2124663276",
      "id" : 2124663276,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585-o8ns",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2124663276/reactions"
      },
      "updated_at" : "2024-05-22T12:28:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2124663276",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "If we auto-renew every 20 minutes then I guess that's fine. Maybe just add a comment somewhere that we _could_ explicitly delete the mapping upon shutdown.\r\n\r\nAs well as clarifying the log message for `NO_RESOURCES` with something like \"This is expected after a restart and should clear after N minutes.\".",
      "created_at" : "2024-05-22T12:30:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2124675374",
      "id" : 2124675374,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585-o_ku",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2124675374/reactions"
      },
      "updated_at" : "2024-05-22T12:32:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2124675374",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1609954791"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1609954791"
         }
      },
      "author_association" : "MEMBER",
      "body" : "bebfafcf98d8ed1432407b7603991d54f7cc26c2: it would be useful to have a quick recap here of which strategy is used by `QueryDefaultGateway` for which OS.\r\n\r\nI think it will be (slightly) more readable to have a single `QueryDefaultGateway` implementation which then calls `QueryDefaultGatewayWindows`, `QueryDefaultGatewayMac` and `QueryDefaultGatewayLinuxBSD`.\r\n\r\nIt can start with:\r\n\r\n```cpp\r\nAssume(network == NET_IPV4 || network == NET_IPV6)\r\n```\r\n\r\nand end with\r\n\r\n```cpp\r\n#else return std::nullopt;\r\n```",
      "commit_id" : "e6656f981019331db869e5bed1fcb5247bafbc3f",
      "created_at" : "2024-05-22T13:26:33Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1609954791",
      "id" : 1609954791,
      "line" : 14,
      "node_id" : "PRRC_kwDOABII585f9fXn",
      "original_commit_id" : "bebfafcf98d8ed1432407b7603991d54f7cc26c2",
      "original_line" : 14,
      "original_position" : 14,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 14,
      "pull_request_review_id" : 2071201793,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1609954791/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-22T13:33:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1609954791",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610151853"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610151853"
         }
      },
      "author_association" : "MEMBER",
      "body" : "bebfafcf98d8ed1432407b7603991d54f7cc26c2 presumably netlink only exists in (the rather recent) FreeBSD >= 13.2? For older versions we need to use the same method as macOS? If so, then we probably need to check this stuff in configure.",
      "commit_id" : "e6656f981019331db869e5bed1fcb5247bafbc3f",
      "created_at" : "2024-05-22T14:56:04Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610151853",
      "id" : 1610151853,
      "line" : 19,
      "node_id" : "PRRC_kwDOABII585f-Pet",
      "original_commit_id" : "bebfafcf98d8ed1432407b7603991d54f7cc26c2",
      "original_line" : 19,
      "original_position" : 19,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 19,
      "pull_request_review_id" : 2071531696,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610151853/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-22T14:56:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610151853",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610209650"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610209650"
         }
      },
      "author_association" : "MEMBER",
      "body" : "That said, it looks like FreeBSD 13.2 is the oldest [supported release](https://www.freebsd.org/security/#sup) and 12 is pretty much unusable: https://forums.freebsd.org/threads/freebsd-12-2-stable-pkg-update-failed.92034/#post-640223\r\n\r\nI was not able to build `bitcoind` on a FreeBSD 13.2 VM:\r\n\r\n<img width=\"723\" alt=\"bsd 13\" src=\"https://github.com/bitcoin/bitcoin/assets/10217/8b4d0ee5-e8e7-4318-8c22-67791a77974c\">\r\n\r\n(I don't have Virtual Box guest editions installed, so having a hard time copying the output)",
      "commit_id" : "70a32f654dd74c4e2fedb0b79e27648d633acbd6",
      "created_at" : "2024-05-22T15:28:13Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610209650",
      "id" : 1610209650,
      "in_reply_to_id" : 1610151853,
      "line" : 20,
      "node_id" : "PRRC_kwDOABII585f-dly",
      "original_commit_id" : "bebfafcf98d8ed1432407b7603991d54f7cc26c2",
      "original_line" : 19,
      "original_position" : 19,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 20,
      "pull_request_review_id" : 2071626946,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610209650/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-22T16:23:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610209650",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610286827"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610286827"
         }
      },
      "author_association" : "MEMBER",
      "body" : "If so i would prefer not supporting it at all for older FreeBSD. It's so rare compared to the other operating systems already, and most of the userbase will be setting their own firewall. But we indeed need to check that it doesn't cause a compilation error.",
      "commit_id" : "70a32f654dd74c4e2fedb0b79e27648d633acbd6",
      "created_at" : "2024-05-22T16:19:20Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610286827",
      "id" : 1610286827,
      "in_reply_to_id" : 1610151853,
      "line" : 20,
      "node_id" : "PRRC_kwDOABII585f-wbr",
      "original_commit_id" : "bebfafcf98d8ed1432407b7603991d54f7cc26c2",
      "original_line" : 19,
      "original_position" : 19,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 20,
      "pull_request_review_id" : 2071757177,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610286827/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-22T16:19:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610286827",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Okay - added a NAT-PMP fallback and removed all user visible run-time option changes, except for mentioning PCP in documentation.",
      "created_at" : "2024-05-22T16:21:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2125210478",
      "id" : 2125210478,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585-rCNu",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 1,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2125210478/reactions"
      },
      "updated_at" : "2024-05-22T16:49:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2125210478",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610299087"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610299087"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> If so i would prefer not supporting it at all for older FreeBSD.\r\n\r\nSeems fine to me.",
      "commit_id" : "70a32f654dd74c4e2fedb0b79e27648d633acbd6",
      "created_at" : "2024-05-22T16:27:36Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610299087",
      "id" : 1610299087,
      "in_reply_to_id" : 1610151853,
      "line" : 20,
      "node_id" : "PRRC_kwDOABII585f-zbP",
      "original_commit_id" : "bebfafcf98d8ed1432407b7603991d54f7cc26c2",
      "original_line" : 19,
      "original_position" : 19,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 20,
      "pull_request_review_id" : 2071776788,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610299087/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-22T16:27:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610299087",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610302369"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610302369"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Concept ACK on keep just using `-natpmp` for both PCP and NAT-PMP.\r\n\r\n(you lost the `-`)",
      "commit_id" : "70a32f654dd74c4e2fedb0b79e27648d633acbd6",
      "created_at" : "2024-05-22T16:30:11Z",
      "diff_hunk" : "@@ -556,11 +556,7 @@ void SetupServerArgs(ArgsManager& argsman)\n #else\n     hidden_args.emplace_back(\"-upnp\");\n #endif\n-#ifdef USE_NATPMP\n-    argsman.AddArg(\"-natpmp\", strprintf(\"Use NAT-PMP to map the listening port (default: %u)\", DEFAULT_NATPMP), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n-#else\n-    hidden_args.emplace_back(\"-natpmp\");\n-#endif // USE_NATPMP\n+    argsman.AddArg(\"-natpmp\", strprintf(\"Use PCP or NATPMP to map the listening port (default: %u)\", DEFAULT_NATPMP), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610302369",
      "id" : 1610302369,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585f-0Oh",
      "original_commit_id" : "bd2cc38d8afb1c09dfc4a77f5195bf2a9e58ad90",
      "original_line" : 559,
      "original_position" : 9,
      "original_start_line" : null,
      "path" : "src/init.cpp",
      "position" : null,
      "pull_request_review_id" : 2071782134,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610302369/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-22T16:30:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610302369",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--85328a0da195eb286784d51f73fa0af9-->\n\nð§ At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/25289226001</sub>",
      "created_at" : "2024-05-22T16:31:21Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2125242381",
      "id" : 2125242381,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585-rKAN",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2125242381/reactions"
      },
      "updated_at" : "2024-05-22T16:31:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2125242381",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610306635"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610306635"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Whoops, fixed",
      "commit_id" : "70a32f654dd74c4e2fedb0b79e27648d633acbd6",
      "created_at" : "2024-05-22T16:33:30Z",
      "diff_hunk" : "@@ -556,11 +556,7 @@ void SetupServerArgs(ArgsManager& argsman)\n #else\n     hidden_args.emplace_back(\"-upnp\");\n #endif\n-#ifdef USE_NATPMP\n-    argsman.AddArg(\"-natpmp\", strprintf(\"Use NAT-PMP to map the listening port (default: %u)\", DEFAULT_NATPMP), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n-#else\n-    hidden_args.emplace_back(\"-natpmp\");\n-#endif // USE_NATPMP\n+    argsman.AddArg(\"-natpmp\", strprintf(\"Use PCP or NATPMP to map the listening port (default: %u)\", DEFAULT_NATPMP), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610306635",
      "id" : 1610306635,
      "in_reply_to_id" : 1610302369,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585f-1RL",
      "original_commit_id" : "bd2cc38d8afb1c09dfc4a77f5195bf2a9e58ad90",
      "original_line" : 559,
      "original_position" : 9,
      "original_start_line" : null,
      "path" : "src/init.cpp",
      "position" : null,
      "pull_request_review_id" : 2071788733,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610306635/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-22T16:33:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610306635",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610320133"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610320133"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Added a version check for at least 13.2.",
      "commit_id" : "70a32f654dd74c4e2fedb0b79e27648d633acbd6",
      "created_at" : "2024-05-22T16:42:33Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610320133",
      "id" : 1610320133,
      "in_reply_to_id" : 1610151853,
      "line" : 20,
      "node_id" : "PRRC_kwDOABII585f-4kF",
      "original_commit_id" : "bebfafcf98d8ed1432407b7603991d54f7cc26c2",
      "original_line" : 19,
      "original_position" : 19,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 20,
      "pull_request_review_id" : 2071809446,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610320133/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-22T16:42:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610320133",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610438227"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610438227"
         }
      },
      "author_association" : "MEMBER",
      "body" : "82b0bff51fedff2ce5e47cae1c75b9172766d8ef: the `SysErrorString` documentation says you should call `NetworkErrorString`, though that will in turn just call `SysErrorString`, since this is never called under `WIN32`.",
      "commit_id" : "70a32f654dd74c4e2fedb0b79e27648d633acbd6",
      "created_at" : "2024-05-22T18:11:22Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610438227",
      "id" : 1610438227,
      "line" : 32,
      "node_id" : "PRRC_kwDOABII585f_VZT",
      "original_commit_id" : "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "original_line" : 31,
      "original_position" : 31,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 32,
      "pull_request_review_id" : 2071999619,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610438227/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-22T18:56:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610438227",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610461378"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610461378"
         }
      },
      "author_association" : "MEMBER",
      "body" : "82b0bff51fedff2ce5e47cae1c75b9172766d8ef Why only on linux? It seems to exist on FreeBSD too: https://man.freebsd.org/cgi/man.cgi?netlink(4)",
      "commit_id" : "70a32f654dd74c4e2fedb0b79e27648d633acbd6",
      "created_at" : "2024-05-22T18:28:41Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610461378",
      "id" : 1610461378,
      "line" : 51,
      "node_id" : "PRRC_kwDOABII585f_bDC",
      "original_commit_id" : "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "original_line" : 50,
      "original_position" : 50,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 51,
      "pull_request_review_id" : 2071999619,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610461378/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-22T18:56:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610461378",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610491684"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610491684"
         }
      },
      "author_association" : "MEMBER",
      "body" : "82b0bff51fedff2ce5e47cae1c75b9172766d8ef: IIUC this gets the scope id (https://datatracker.ietf.org/doc/html/rfc4007), but we don't do anything with that except in `IPv6ToString`. So maybe we should just ignore this value (`CNetAddr` initialiser defaults it to 0).\r\n\r\nIf we can't drop it, can we be sure that we encounter `RTA_OIF` _before_ `RTA_GATEWAY`? Otherwise `if (rta_gateway != nullptr)` could trigger prematurely.",
      "commit_id" : "70a32f654dd74c4e2fedb0b79e27648d633acbd6",
      "created_at" : "2024-05-22T18:51:34Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = network == NET_IPV4 ? AF_INET : AF_INET6;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610491684",
      "id" : 1610491684,
      "line" : 90,
      "node_id" : "PRRC_kwDOABII585f_ick",
      "original_commit_id" : "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "original_line" : 89,
      "original_position" : 89,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 90,
      "pull_request_review_id" : 2071999619,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610491684/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-22T18:56:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610491684",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610511267"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610511267"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I see this was added here: https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1603876259, and I see it's not actually ignored, e.g. `GetSockAddr` uses it. ~But when we connect to the default gateway, only `m_addr` is copied by `GetSockAddr` (which is called by `PCPRequestPortMap`).~ (see below)",
      "commit_id" : "70a32f654dd74c4e2fedb0b79e27648d633acbd6",
      "created_at" : "2024-05-22T19:03:07Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = network == NET_IPV4 ? AF_INET : AF_INET6;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610511267",
      "id" : 1610511267,
      "in_reply_to_id" : 1610491684,
      "line" : 90,
      "node_id" : "PRRC_kwDOABII585f_nOj",
      "original_commit_id" : "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "original_line" : 89,
      "original_position" : 89,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 90,
      "pull_request_review_id" : 2072137357,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610511267/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-22T19:50:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610511267",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610537095"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610537095"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The scope ID is extremely important for the default gateway, as it tends to be a scope-local address (it wouldn't work at all here without that).",
      "commit_id" : "70a32f654dd74c4e2fedb0b79e27648d633acbd6",
      "created_at" : "2024-05-22T19:26:09Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = network == NET_IPV4 ? AF_INET : AF_INET6;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610537095",
      "id" : 1610537095,
      "in_reply_to_id" : 1610491684,
      "line" : 90,
      "node_id" : "PRRC_kwDOABII585f_tiH",
      "original_commit_id" : "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "original_line" : 89,
      "original_position" : 89,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 90,
      "pull_request_review_id" : 2072177943,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610537095/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-22T19:43:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610537095",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610540459"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610540459"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> If we can't drop it, can we be sure that we encounter RTA_OIF before RTA_GATEWAY? Otherwise if (rta_gateway != nullptr) could trigger prematurely.\r\n\r\nAFAIK the order of the attributes within a record can be arbitrary. But how can this go wrong? The `rta_gateway` check is only after going over all the attributes, right?\r\n\r\nGetSockAddr does copy the `scope_id` too, see https://github.com/bitcoin/bitcoin/blob/master/src/netaddress.cpp#L883",
      "commit_id" : "70a32f654dd74c4e2fedb0b79e27648d633acbd6",
      "created_at" : "2024-05-22T19:29:06Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = network == NET_IPV4 ? AF_INET : AF_INET6;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610540459",
      "id" : 1610540459,
      "in_reply_to_id" : 1610491684,
      "line" : 90,
      "node_id" : "PRRC_kwDOABII585f_uWr",
      "original_commit_id" : "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "original_line" : 89,
      "original_position" : 89,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 90,
      "pull_request_review_id" : 2072184582,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610540459/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-22T19:31:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610540459",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610543822"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610543822"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Right, will update this (though yeah for POSIX operating systems there's no difference).",
      "commit_id" : "70a32f654dd74c4e2fedb0b79e27648d633acbd6",
      "created_at" : "2024-05-22T19:32:31Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610543822",
      "id" : 1610543822,
      "in_reply_to_id" : 1610438227,
      "line" : 32,
      "node_id" : "PRRC_kwDOABII585f_vLO",
      "original_commit_id" : "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "original_line" : 31,
      "original_position" : 31,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 32,
      "pull_request_review_id" : 2072190170,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610543822/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-22T19:32:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610543822",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610547164"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610547164"
         }
      },
      "author_association" : "MEMBER",
      "body" : "For the FreeBSD versus Linux differences see the comments in the standalone tool here: https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1604635967\r\nThe netlink calls behave differently on Linux and FreeBSD, we don't know why this is.",
      "commit_id" : "70a32f654dd74c4e2fedb0b79e27648d633acbd6",
      "created_at" : "2024-05-22T19:35:31Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610547164",
      "id" : 1610547164,
      "in_reply_to_id" : 1610461378,
      "line" : 51,
      "node_id" : "PRRC_kwDOABII585f_v_c",
      "original_commit_id" : "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "original_line" : 50,
      "original_position" : 50,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 51,
      "pull_request_review_id" : 2072196100,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610547164/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-22T19:35:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610547164",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610559719"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610559719"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> The rta_gateway check is only after going over all the attributes, right?\r\n\r\nOh wait, I misread the indentation, yes.\r\n\r\n> GetSockAddr does copy the scope_id too,\r\n\r\nIndeed it does",
      "commit_id" : "70a32f654dd74c4e2fedb0b79e27648d633acbd6",
      "created_at" : "2024-05-22T19:46:35Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = network == NET_IPV4 ? AF_INET : AF_INET6;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610559719",
      "id" : 1610559719,
      "in_reply_to_id" : 1610491684,
      "line" : 90,
      "node_id" : "PRRC_kwDOABII585f_zDn",
      "original_commit_id" : "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "original_line" : 89,
      "original_position" : 89,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 90,
      "pull_request_review_id" : 2072216776,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610559719/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-22T19:50:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610559719",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610568498"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610568498"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> The scope ID is extremely important for the default gateway, as it tends to be a scope-local address.\r\n\r\nAha: https://blogs.infoblox.com/ipv6-coe/fe80-1-is-a-perfectly-valid-ipv6-default-gateway-address/",
      "commit_id" : "70a32f654dd74c4e2fedb0b79e27648d633acbd6",
      "created_at" : "2024-05-22T19:54:40Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = network == NET_IPV4 ? AF_INET : AF_INET6;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610568498",
      "id" : 1610568498,
      "in_reply_to_id" : 1610491684,
      "line" : 90,
      "node_id" : "PRRC_kwDOABII585f_1My",
      "original_commit_id" : "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "original_line" : 89,
      "original_position" : 89,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 90,
      "pull_request_review_id" : 2072230562,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610568498/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-22T19:54:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610568498",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610572586"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610572586"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Ah, some of these comments are worth preserving until we know more or can point to clear documentation elsewhere. I compressed them a bit:\r\n\r\n```cpp\r\n    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\r\n    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\r\n    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\r\n    request.hdr.nlmsg_flags |= NLM_F_DUMP;\r\n\r\n#ifdef __FreeBSD__\r\n    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\r\n    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\r\n    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\r\n    request.data.rtm_flags = RTM_F_PREFIX;\r\n\r\n```",
      "commit_id" : "70a32f654dd74c4e2fedb0b79e27648d633acbd6",
      "created_at" : "2024-05-22T19:58:38Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610572586",
      "id" : 1610572586,
      "in_reply_to_id" : 1610461378,
      "line" : 51,
      "node_id" : "PRRC_kwDOABII585f_2Mq",
      "original_commit_id" : "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "original_line" : 50,
      "original_position" : 50,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 51,
      "pull_request_review_id" : 2072237518,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610572586/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-22T19:58:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610572586",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610594332"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610594332"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Sure, will add that.\r\nFWIW, this is why i initially went with parsing the route tables from `/proc/net/...`, for Linux that's the most straightforward implementation. Netlink is a bit finnicky, though it should be stable (for the same OS) because it's what the tools like `ip` use.",
      "commit_id" : "f5d8ffd467bba644b1fb855ef020197345953cf3",
      "created_at" : "2024-05-22T20:18:28Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610594332",
      "id" : 1610594332,
      "in_reply_to_id" : 1610461378,
      "line" : 51,
      "node_id" : "PRRC_kwDOABII585f_7gc",
      "original_commit_id" : "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "original_line" : 50,
      "original_position" : 50,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 51,
      "pull_request_review_id" : 2072275774,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610594332/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-22T20:18:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610594332",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Success! My node is reachable publicly, without configuration.\r\n\r\n```\r\n2024-05-23T02:06:39.536932Z [net] pcp: gateway [IPv4]: 192.168.1.1\r\n2024-05-23T02:06:39.536973Z [net] pcp: Requesting port mapping for addr 0.0.0.0 port 8333 from gateway 192.168.1.1\r\n2024-05-23T02:06:39.537027Z [net] pcp: Internal address after connect: 192.168.1.254\r\n...\r\n2024-05-23T02:06:39.538066Z [net] pcp: Received response of 8 bytes: [...]\r\n2024-05-23T02:06:39.538101Z [net] pcp: Got unsupported version response, falling back to NAT-PMP\r\n2024-05-23T02:06:39.538118Z [net] natpmp: Requesting port mapping port 8333 from gateway 192.168.1.1\r\n2024-05-23T02:06:39.539006Z [net] natpmp: Received response of 12 bytes: [...]\r\n...\r\n2024-05-23T02:06:39.551712Z [net] natpmp: Received response of 16 bytes: [...]\r\n2024-05-23T02:06:39.551736Z [net:info] natpmp: Mapping successful: we got [...] for 1200 seconds.\r\n2024-05-23T02:06:39.551774Z [net:info] natpmp: ExternalIPv4Address:port = [...]\r\n2024-05-23T02:06:39.551787Z AddLocal([...],3)\r\n2024-05-23T02:06:39.551826Z [net] pcp: Could not determine IPv6 default gateway\r\n```\r\n(IP address scrubbed)",
      "created_at" : "2024-05-23T02:11:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2126064090",
      "id" : 2126064090,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585-uSna",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 1,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2126064090/reactions"
      },
      "updated_at" : "2024-05-23T02:12:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2126064090",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Success! My node is reachable publicly, without configuration.\r\n\r\nNice!!! Thanks for testing again.",
      "created_at" : "2024-05-23T06:49:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2126357008",
      "id" : 2126357008,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585-vaIQ",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2126357008/reactions"
      },
      "updated_at" : "2024-05-23T06:49:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2126357008",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611240354"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611240354"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Agree, i think i would prefer\r\n`QueryDefaultGatewayNetlink`\r\n`QueryDefaultGatewaySysctl`\r\n`QueryDefaultGatewayWin32` -- only the WIN32 one is truly OS specific, the other ones are POSIX-ish\r\n",
      "commit_id" : "f900db8fc0e083f4a2955048b5574b681046bf2c",
      "created_at" : "2024-05-23T08:26:58Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611240354",
      "id" : 1611240354,
      "in_reply_to_id" : 1609954791,
      "line" : 14,
      "node_id" : "PRRC_kwDOABII585gCZOi",
      "original_commit_id" : "bebfafcf98d8ed1432407b7603991d54f7cc26c2",
      "original_line" : 14,
      "original_position" : 14,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 14,
      "pull_request_review_id" : 2073236638,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611240354/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T08:26:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611240354",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611259233"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611259233"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Unlike the linux code, here it does matter to call `NetworkErrorString`, because it calls `Win32ErrorString`, which calls `FormatMessage(W)` as the docs recommend: https://learn.microsoft.com/en-us/windows/win32/api/iphlpapi/nf-iphlpapi-getbestinterfaceex  \r\n\r\nMy understanding is that using `strerror_s` (called by SysErrorString) here would be wrong:  https://stackoverflow.com/a/20057368\r\n\r\nI wonder if we can prevent doing that by accident.",
      "commit_id" : "f900db8fc0e083f4a2955048b5574b681046bf2c",
      "created_at" : "2024-05-23T08:36:01Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = network == NET_IPV4 ? AF_INET : AF_INET6;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (network == NET_IPV4) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (network == NET_IPV6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+    if (network == NET_IPV4) {\n+        destination_address.si_family = AF_INET;\n+    } else if(network == NET_IPV6) {\n+        destination_address.si_family = AF_INET6;\n+    } else {\n+        return std::nullopt;\n+    }\n+\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", SysErrorString(status));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611259233",
      "id" : 1611259233,
      "line" : 146,
      "node_id" : "PRRC_kwDOABII585gCd1h",
      "original_commit_id" : "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "original_line" : 139,
      "original_position" : 139,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 146,
      "pull_request_review_id" : 2073273200,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611259233/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T08:36:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611259233",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611261160"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611261160"
         }
      },
      "author_association" : "MEMBER",
      "body" : "That said, this Windows code is a lot simpler than the Linux stuff above (_ducks..._).",
      "commit_id" : "f900db8fc0e083f4a2955048b5574b681046bf2c",
      "created_at" : "2024-05-23T08:37:16Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = network == NET_IPV4 ? AF_INET : AF_INET6;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (network == NET_IPV4) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (network == NET_IPV6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+    if (network == NET_IPV4) {\n+        destination_address.si_family = AF_INET;\n+    } else if(network == NET_IPV6) {\n+        destination_address.si_family = AF_INET6;\n+    } else {\n+        return std::nullopt;\n+    }\n+\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", SysErrorString(status));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611261160",
      "id" : 1611261160,
      "in_reply_to_id" : 1611259233,
      "line" : 146,
      "node_id" : "PRRC_kwDOABII585gCeTo",
      "original_commit_id" : "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "original_line" : 139,
      "original_position" : 139,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 146,
      "pull_request_review_id" : 2073276171,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611261160/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T08:37:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611261160",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611265859"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611265859"
         }
      },
      "author_association" : "MEMBER",
      "body" : "OHH, my thinking was that it's a WIN32 API function, not a network function. So i thought `SysErrorString` would be correct. But i think you're right. \"SysError\" is more like \"posix errno emulation error\". Which is not what is needed here.",
      "commit_id" : "f900db8fc0e083f4a2955048b5574b681046bf2c",
      "created_at" : "2024-05-23T08:40:35Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = network == NET_IPV4 ? AF_INET : AF_INET6;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (network == NET_IPV4) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (network == NET_IPV6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+    if (network == NET_IPV4) {\n+        destination_address.si_family = AF_INET;\n+    } else if(network == NET_IPV6) {\n+        destination_address.si_family = AF_INET6;\n+    } else {\n+        return std::nullopt;\n+    }\n+\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", SysErrorString(status));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611265859",
      "id" : 1611265859,
      "in_reply_to_id" : 1611259233,
      "line" : 146,
      "node_id" : "PRRC_kwDOABII585gCfdD",
      "original_commit_id" : "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "original_line" : 139,
      "original_position" : 139,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 146,
      "pull_request_review_id" : 2073283651,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611265859/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T08:40:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611265859",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611280293"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611280293"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> That said, this Windows code is a lot simpler than the Linux stuff above (ducks...).\r\n\r\nYou mean that centrally-controlled proprietary OSes sometimes have well-documented API's that consider use-cases, while FOSS often uses haphazard grabbag API's that were grown in accordance with one tool (where everyone is expected to parse text output of-)... or some custom library, with equally confusing interface. you can just say that out loud here you know... ð \r\nStandards like RFCs, and POSIX (ignoring everyone's custom extensions) are rare exceptions.",
      "commit_id" : "f900db8fc0e083f4a2955048b5574b681046bf2c",
      "created_at" : "2024-05-23T08:49:30Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = network == NET_IPV4 ? AF_INET : AF_INET6;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (network == NET_IPV4) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (network == NET_IPV6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+    if (network == NET_IPV4) {\n+        destination_address.si_family = AF_INET;\n+    } else if(network == NET_IPV6) {\n+        destination_address.si_family = AF_INET6;\n+    } else {\n+        return std::nullopt;\n+    }\n+\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", SysErrorString(status));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611280293",
      "id" : 1611280293,
      "in_reply_to_id" : 1611259233,
      "line" : 146,
      "node_id" : "PRRC_kwDOABII585gCi-l",
      "original_commit_id" : "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "original_line" : 139,
      "original_position" : 139,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 146,
      "pull_request_review_id" : 2073308003,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611280293/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T08:49:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611280293",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611345455"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611345455"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Maybe also check that `NextHop` is not 0.0.0.0 (::/0 for IPv6 below). It's not entirely clear to me from the documentation if that can realistically happen, but doesn't hurt to check either.",
      "commit_id" : "f900db8fc0e083f4a2955048b5574b681046bf2c",
      "created_at" : "2024-05-23T09:29:51Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = network == NET_IPV4 ? AF_INET : AF_INET6;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (network == NET_IPV4) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (network == NET_IPV6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+    if (network == NET_IPV4) {\n+        destination_address.si_family = AF_INET;\n+    } else if(network == NET_IPV6) {\n+        destination_address.si_family = AF_INET6;\n+    } else {\n+        return std::nullopt;\n+    }\n+\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", SysErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, SysErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    if (network == NET_IPV4) {\n+        Assume(best_route.NextHop.si_family == AF_INET);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611345455",
      "id" : 1611345455,
      "line" : 160,
      "node_id" : "PRRC_kwDOABII585gCy4v",
      "original_commit_id" : "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "original_line" : 153,
      "original_position" : 153,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 160,
      "pull_request_review_id" : 2073411892,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611345455/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T09:30:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611345455",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611410019"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611410019"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Alternatively you could store `net.route.0.inet[4].flags.gateway` here and use `sysctlbyname` below, avoiding the need to construct `mib[]`. Not sure if that's better though, because it's nice to be able to lookup constants like `NET_RT_FLAGS` in headers.",
      "commit_id" : "48441655b7acd3def66a93a706cb2b64678aff99",
      "created_at" : "2024-05-23T10:17:18Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = network == NET_IPV4 ? AF_INET : AF_INET6;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (network == NET_IPV4) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (network == NET_IPV6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+    if (network == NET_IPV4) {\n+        destination_address.si_family = AF_INET;\n+    } else if(network == NET_IPV6) {\n+        destination_address.si_family = AF_INET6;\n+    } else {\n+        return std::nullopt;\n+    }\n+\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", SysErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, SysErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    if (network == NET_IPV4) {\n+        Assume(best_route.NextHop.si_family == AF_INET);\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(network == NET_IPV6) {\n+        Assume(best_route.NextHop.si_family == AF_INET6);\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+    int family;\n+    if (network == NET_IPV4) {\n+        family = AF_INET;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611410019",
      "id" : 1611410019,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gDCpj",
      "original_commit_id" : "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "original_line" : 188,
      "original_position" : 188,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : null,
      "pull_request_review_id" : 2073514261,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611410019/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T10:17:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611410019",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611411388"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611411388"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Maybe a general \"is the default gateway address sane\" check might sense? though, up to some point if the OS returns a weird address who are we to question it. Can't get too paranoid about that. The worst that could happen is sending to 0.0.0.0, which wouldn't result in any bad things beyond an error.\r\n\r\nOr do you mean this from a \"what happens if there is no default gateway configured\" angle? yes, we'll have to check what it does in that case. Though i'd expect the call to `GetBestRoute` to fail.",
      "commit_id" : "48441655b7acd3def66a93a706cb2b64678aff99",
      "created_at" : "2024-05-23T10:18:30Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = network == NET_IPV4 ? AF_INET : AF_INET6;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (network == NET_IPV4) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (network == NET_IPV6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+    if (network == NET_IPV4) {\n+        destination_address.si_family = AF_INET;\n+    } else if(network == NET_IPV6) {\n+        destination_address.si_family = AF_INET6;\n+    } else {\n+        return std::nullopt;\n+    }\n+\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", SysErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, SysErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    if (network == NET_IPV4) {\n+        Assume(best_route.NextHop.si_family == AF_INET);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611411388",
      "id" : 1611411388,
      "in_reply_to_id" : 1611345455,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gDC-8",
      "original_commit_id" : "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "original_line" : 153,
      "original_position" : 153,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : null,
      "pull_request_review_id" : 2073516447,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611411388/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T10:28:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611411388",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611416943"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611416943"
         }
      },
      "author_association" : "MEMBER",
      "body" : "i prefer using constants to string based APIs, if given the choice. This avoids say, typos.",
      "commit_id" : "48441655b7acd3def66a93a706cb2b64678aff99",
      "created_at" : "2024-05-23T10:23:11Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = network == NET_IPV4 ? AF_INET : AF_INET6;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (network == NET_IPV4) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (network == NET_IPV6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+    if (network == NET_IPV4) {\n+        destination_address.si_family = AF_INET;\n+    } else if(network == NET_IPV6) {\n+        destination_address.si_family = AF_INET6;\n+    } else {\n+        return std::nullopt;\n+    }\n+\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", SysErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, SysErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    if (network == NET_IPV4) {\n+        Assume(best_route.NextHop.si_family == AF_INET);\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(network == NET_IPV6) {\n+        Assume(best_route.NextHop.si_family == AF_INET6);\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+    int family;\n+    if (network == NET_IPV4) {\n+        family = AF_INET;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611416943",
      "id" : 1611416943,
      "in_reply_to_id" : 1611410019,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gDEVv",
      "original_commit_id" : "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "original_line" : 188,
      "original_position" : 188,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : null,
      "pull_request_review_id" : 2073525398,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611416943/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T10:23:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611416943",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611430621"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611430621"
         }
      },
      "author_association" : "MEMBER",
      "body" : "OK, you're right, this could happen: https://learn.microsoft.com/en-us/windows/win32/api/netioapi/ns-netioapi-mib_ipforward_row2\r\n\r\n> NextHop\r\n>\r\n> Type: [SOCKADDR_INET](https://learn.microsoft.com/en-us/windows/desktop/api/ws2ipdef/ns-ws2ipdef-sockaddr_inet)\r\n>\r\n> For a remote route, the IP address of the next system or gateway en route. If the route is to a local loopback address or an IP address on the local link, the next hop is unspecified (all zeros). For a local loopback route, this member should be an IPv4 address of 0.0.0.0 for an IPv4 route entry or an IPv6 address of 0::0 for an IPv6 route entry.\r\n\r\nMaybe this is true for the other operating systems as well, if the gateway address is `.IsBindAny()` it should be considered as absent.\r\n\r\nEdit: done",
      "commit_id" : "48441655b7acd3def66a93a706cb2b64678aff99",
      "created_at" : "2024-05-23T10:30:46Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = network == NET_IPV4 ? AF_INET : AF_INET6;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (network == NET_IPV4) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (network == NET_IPV6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+    if (network == NET_IPV4) {\n+        destination_address.si_family = AF_INET;\n+    } else if(network == NET_IPV6) {\n+        destination_address.si_family = AF_INET6;\n+    } else {\n+        return std::nullopt;\n+    }\n+\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", SysErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, SysErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    if (network == NET_IPV4) {\n+        Assume(best_route.NextHop.si_family == AF_INET);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611430621",
      "id" : 1611430621,
      "in_reply_to_id" : 1611345455,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gDHrd",
      "original_commit_id" : "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "original_line" : 153,
      "original_position" : 153,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : null,
      "pull_request_review_id" : 2073546134,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611430621/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T11:36:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611430621",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611456690"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611456690"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Seems we could factor out `AddressFamilyFromNetwork` at least, this is repeated in literally every implementation ð \r\n\r\nEdit: in `netaddress.h` there is `CService::GetSAFamily()` -- so close but not... sigh.\r\nEdit: done",
      "commit_id" : "48441655b7acd3def66a93a706cb2b64678aff99",
      "created_at" : "2024-05-23T10:47:25Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = network == NET_IPV4 ? AF_INET : AF_INET6;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (network == NET_IPV4) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (network == NET_IPV6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+    if (network == NET_IPV4) {\n+        destination_address.si_family = AF_INET;\n+    } else if(network == NET_IPV6) {\n+        destination_address.si_family = AF_INET6;\n+    } else {\n+        return std::nullopt;\n+    }\n+\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", SysErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, SysErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    if (network == NET_IPV4) {\n+        Assume(best_route.NextHop.si_family == AF_INET);\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(network == NET_IPV6) {\n+        Assume(best_route.NextHop.si_family == AF_INET6);\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+    int family;\n+    if (network == NET_IPV4) {\n+        family = AF_INET;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611456690",
      "id" : 1611456690,
      "in_reply_to_id" : 1611410019,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gDOCy",
      "original_commit_id" : "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "original_line" : 188,
      "original_position" : 188,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : null,
      "pull_request_review_id" : 2073590059,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611456690/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T11:36:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611456690",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611522537"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611522537"
         }
      },
      "author_association" : "MEMBER",
      "body" : "OK, i went for `QueryDefaultGatewayImpl` for now, with an outer function. Naming it different things on different platforms means having to repeat the `#ifdef` forest, which isn't really worth the slight increase in clarity imo.",
      "commit_id" : "48441655b7acd3def66a93a706cb2b64678aff99",
      "created_at" : "2024-05-23T11:40:08Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611522537",
      "id" : 1611522537,
      "in_reply_to_id" : 1609954791,
      "line" : 14,
      "node_id" : "PRRC_kwDOABII585gDeHp",
      "original_commit_id" : "bebfafcf98d8ed1432407b7603991d54f7cc26c2",
      "original_line" : 14,
      "original_position" : 14,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 14,
      "pull_request_review_id" : 2073699412,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611522537/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T11:40:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611522537",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611597515"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611597515"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Could make this slightly more readable with comments and two nullptr:\r\n\r\n```cpp\r\nif (sysctl(/*name=*/mib, /*namelen=*/sizeof(mib) / sizeof(int), /*oldp=*/nullptr, /*oldlenp=*/&l, /*newp=*/nullptr, /*newlen=*/0) < 0) {\r\n```",
      "commit_id" : "82b1c25b9ca61f5b0382a5196e0ff7016b4d1429",
      "created_at" : "2024-05-23T12:22:06Z",
      "diff_hunk" : "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611597515",
      "id" : 1611597515,
      "line" : 181,
      "node_id" : "PRRC_kwDOABII585gDwbL",
      "original_commit_id" : "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "original_line" : 185,
      "original_position" : 185,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 181,
      "pull_request_review_id" : 2073809550,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611597515/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T13:50:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611597515",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611597943"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611597943"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```cpp\r\nif (sysctl(/*name=*/mib, /*namelen=*/sizeof(mib) / sizeof(int), /*oldp=*/buf.data(), /*oldlenp=*/&l, /*newp=*/nullptr, /*newlen=*/0) < 0) {\r\n```",
      "commit_id" : "82b1c25b9ca61f5b0382a5196e0ff7016b4d1429",
      "created_at" : "2024-05-23T12:22:26Z",
      "diff_hunk" : "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), buf.data(), &l, 0, 0) < 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611597943",
      "id" : 1611597943,
      "line" : 186,
      "node_id" : "PRRC_kwDOABII585gDwh3",
      "original_commit_id" : "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "original_line" : 190,
      "original_position" : 190,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 186,
      "pull_request_review_id" : 2073809550,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611597943/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T13:50:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611597943",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611600021"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611600021"
         }
      },
      "author_association" : "MEMBER",
      "body" : "A useful hint to the reader what's going on here, and where it's documented:\r\n\r\n```cpp\r\n    // The size of the available data can be determined by calling sysctl() with\r\n    // the NULL argument for oldp. See sysctl(3).\r\n```",
      "commit_id" : "82b1c25b9ca61f5b0382a5196e0ff7016b4d1429",
      "created_at" : "2024-05-23T12:24:04Z",
      "diff_hunk" : "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611600021",
      "id" : 1611600021,
      "line" : 180,
      "node_id" : "PRRC_kwDOABII585gDxCV",
      "original_commit_id" : "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "original_line" : 184,
      "original_position" : 184,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 180,
      "pull_request_review_id" : 2073809550,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611600021/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T13:50:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611600021",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611637097"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611637097"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I guess you can't do something closer to `for (const struct rt_msghdr* rt : buf)` (somehow passing in `rt->rtm_msglen`).",
      "commit_id" : "82b1c25b9ca61f5b0382a5196e0ff7016b4d1429",
      "created_at" : "2024-05-23T12:49:56Z",
      "diff_hunk" : "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), buf.data(), &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    const struct rt_msghdr* rt = nullptr;\n+    for (const std::byte* p = buf.data(); p < buf.data() + buf.size(); p += rt->rtm_msglen) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611637097",
      "id" : 1611637097,
      "line" : 191,
      "node_id" : "PRRC_kwDOABII585gD6Fp",
      "original_commit_id" : "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "original_line" : 195,
      "original_position" : 195,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 191,
      "pull_request_review_id" : 2073809550,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611637097/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T13:53:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611637097",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611661588"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611661588"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Do we want to check `rt->rtm_errno` first?\r\n\r\n(if there's an error then probably no bit flags are set, but who knows)",
      "commit_id" : "82b1c25b9ca61f5b0382a5196e0ff7016b4d1429",
      "created_at" : "2024-05-23T13:07:04Z",
      "diff_hunk" : "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), buf.data(), &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    const struct rt_msghdr* rt = nullptr;\n+    for (const std::byte* p = buf.data(); p < buf.data() + buf.size(); p += rt->rtm_msglen) {\n+        // Iterate over routing entry addresses, get destination and gateway (if present).\n+        rt = (const struct rt_msghdr*)p;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611661588",
      "id" : 1611661588,
      "line" : 193,
      "node_id" : "PRRC_kwDOABII585gEAEU",
      "original_commit_id" : "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "original_line" : 197,
      "original_position" : 197,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 193,
      "pull_request_review_id" : 2073809550,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611661588/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T13:54:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611661588",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611691990"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611691990"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```cpp\r\n// We only read from this address if a rtm_addrs bit flag is set.\r\n```\r\n",
      "commit_id" : "82b1c25b9ca61f5b0382a5196e0ff7016b4d1429",
      "created_at" : "2024-05-23T13:22:23Z",
      "diff_hunk" : "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), buf.data(), &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    const struct rt_msghdr* rt = nullptr;\n+    for (const std::byte* p = buf.data(); p < buf.data() + buf.size(); p += rt->rtm_msglen) {\n+        // Iterate over routing entry addresses, get destination and gateway (if present).\n+        rt = (const struct rt_msghdr*)p;\n+        const struct sockaddr* sa = (const struct sockaddr*)(rt + 1);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611691990",
      "id" : 1611691990,
      "line" : 194,
      "node_id" : "PRRC_kwDOABII585gEHfW",
      "original_commit_id" : "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "original_line" : 198,
      "original_position" : 198,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 194,
      "pull_request_review_id" : 2073809550,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611691990/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T13:50:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611691990",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611729605"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611729605"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```cpp\r\n// Skip sockaddr entries for bit flags we're not interested in,\r\n// move cursor.\r\n```",
      "commit_id" : "82b1c25b9ca61f5b0382a5196e0ff7016b4d1429",
      "created_at" : "2024-05-23T13:45:51Z",
      "diff_hunk" : "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), buf.data(), &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    const struct rt_msghdr* rt = nullptr;\n+    for (const std::byte* p = buf.data(); p < buf.data() + buf.size(); p += rt->rtm_msglen) {\n+        // Iterate over routing entry addresses, get destination and gateway (if present).\n+        rt = (const struct rt_msghdr*)p;\n+        const struct sockaddr* sa = (const struct sockaddr*)(rt + 1);\n+        std::optional<CNetAddr> dst;\n+        std::optional<CNetAddr> gateway;\n+        for (int i = 0; i < RTAX_MAX; i++) {\n+            if (rt->rtm_addrs & (1 << i)) {\n+                if (i == RTAX_DST) {\n+                    dst = FromSockAddr(sa);\n+                } else if (i == RTAX_GATEWAY) {\n+                    gateway = FromSockAddr(sa);\n+                }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611729605",
      "id" : 1611729605,
      "line" : 203,
      "node_id" : "PRRC_kwDOABII585gEQrF",
      "original_commit_id" : "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "original_line" : 207,
      "original_position" : 207,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 203,
      "pull_request_review_id" : 2073809550,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611729605/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T13:50:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611729605",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611731634"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611731634"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This seems quite brittle and I don't fully understand it. I did test that it seems necessary, e.g. doing `sa++;` causes it to not map IPv6 ports. If I look at `struct sockaddr_storage` I'm seeing `_SS_ALIGNSIZE   (sizeof(__int64_t)`, but using `uint64_t` instead of `uint32_t` in your `ROUNDUP` also doesn't work.",
      "commit_id" : "82b1c25b9ca61f5b0382a5196e0ff7016b4d1429",
      "created_at" : "2024-05-23T13:47:02Z",
      "diff_hunk" : "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), buf.data(), &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    const struct rt_msghdr* rt = nullptr;\n+    for (const std::byte* p = buf.data(); p < buf.data() + buf.size(); p += rt->rtm_msglen) {\n+        // Iterate over routing entry addresses, get destination and gateway (if present).\n+        rt = (const struct rt_msghdr*)p;\n+        const struct sockaddr* sa = (const struct sockaddr*)(rt + 1);\n+        std::optional<CNetAddr> dst;\n+        std::optional<CNetAddr> gateway;\n+        for (int i = 0; i < RTAX_MAX; i++) {\n+            if (rt->rtm_addrs & (1 << i)) {\n+                if (i == RTAX_DST) {\n+                    dst = FromSockAddr(sa);\n+                } else if (i == RTAX_GATEWAY) {\n+                    gateway = FromSockAddr(sa);\n+                }\n+                sa = (const struct sockaddr*)((std::byte*)sa + ROUNDUP(sa->sa_len));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611731634",
      "id" : 1611731634,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gERKy",
      "original_commit_id" : "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "original_line" : 208,
      "original_position" : 208,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : null,
      "pull_request_review_id" : 2073809550,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611731634/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T13:50:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611731634",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611755766"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611755766"
         }
      },
      "author_association" : "MEMBER",
      "body" : "i'm not sure either, i see it in some other libraries, but no alignment is mentioned in the manual page for `route` at all (which implies they're just back-to-back, no matter what). Leaving out `ROUNDUP` works fine btw. Might just delete it.\r\n\r\nEdit: yes, using `long` or `uint64_t` breaks IPv6. Also they're variable-length so doing just `sa++` won't work.",
      "commit_id" : "82b1c25b9ca61f5b0382a5196e0ff7016b4d1429",
      "created_at" : "2024-05-23T14:00:27Z",
      "diff_hunk" : "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), buf.data(), &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    const struct rt_msghdr* rt = nullptr;\n+    for (const std::byte* p = buf.data(); p < buf.data() + buf.size(); p += rt->rtm_msglen) {\n+        // Iterate over routing entry addresses, get destination and gateway (if present).\n+        rt = (const struct rt_msghdr*)p;\n+        const struct sockaddr* sa = (const struct sockaddr*)(rt + 1);\n+        std::optional<CNetAddr> dst;\n+        std::optional<CNetAddr> gateway;\n+        for (int i = 0; i < RTAX_MAX; i++) {\n+            if (rt->rtm_addrs & (1 << i)) {\n+                if (i == RTAX_DST) {\n+                    dst = FromSockAddr(sa);\n+                } else if (i == RTAX_GATEWAY) {\n+                    gateway = FromSockAddr(sa);\n+                }\n+                sa = (const struct sockaddr*)((std::byte*)sa + ROUNDUP(sa->sa_len));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611755766",
      "id" : 1611755766,
      "in_reply_to_id" : 1611731634,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gEXD2",
      "original_commit_id" : "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "original_line" : 208,
      "original_position" : 208,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : null,
      "pull_request_review_id" : 2074073556,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611755766/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T14:12:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611755766",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611829012"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611829012"
         }
      },
      "author_association" : "MEMBER",
      "body" : "i don't think so, the pointer needs to advance by the size of the specific message, which is part of that message.",
      "commit_id" : "82b1c25b9ca61f5b0382a5196e0ff7016b4d1429",
      "created_at" : "2024-05-23T14:42:06Z",
      "diff_hunk" : "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), buf.data(), &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    const struct rt_msghdr* rt = nullptr;\n+    for (const std::byte* p = buf.data(); p < buf.data() + buf.size(); p += rt->rtm_msglen) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611829012",
      "id" : 1611829012,
      "in_reply_to_id" : 1611637097,
      "line" : 191,
      "node_id" : "PRRC_kwDOABII585gEo8U",
      "original_commit_id" : "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "original_line" : 195,
      "original_position" : 195,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 191,
      "pull_request_review_id" : 2074194160,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611829012/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T14:42:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611829012",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611831862"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611831862"
         }
      },
      "author_association" : "MEMBER",
      "body" : "i'm not sure it makes sense to duplicate documentation that's already in the manual pages. Like if we're doing this here, why not for every system call we make. Do parameter names like `*newp=` `oldp=` even elucidate much?\r\n\r\nAgree re using `nullptr` where possible.",
      "commit_id" : "82b1c25b9ca61f5b0382a5196e0ff7016b4d1429",
      "created_at" : "2024-05-23T14:43:53Z",
      "diff_hunk" : "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611831862",
      "id" : 1611831862,
      "in_reply_to_id" : 1611597515,
      "line" : 181,
      "node_id" : "PRRC_kwDOABII585gEpo2",
      "original_commit_id" : "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "original_line" : 185,
      "original_position" : 185,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 181,
      "pull_request_review_id" : 2074198807,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611831862/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T14:43:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611831862",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611834614"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611834614"
         }
      },
      "author_association" : "MEMBER",
      "body" : "~~Yes, it's a minor optimization, we could always construct a CNetAddr if we wanted, but if we know we're not going to use it anyway might as well skip it.~~\r\n\r\nEdit: oh, i get what you mean. Might be better to just keep a byte pointer and only cast to an `struct sockaddr *` when we need it? all this back and forth casting doesn't make things clearer.",
      "commit_id" : "82b1c25b9ca61f5b0382a5196e0ff7016b4d1429",
      "created_at" : "2024-05-23T14:45:38Z",
      "diff_hunk" : "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), buf.data(), &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    const struct rt_msghdr* rt = nullptr;\n+    for (const std::byte* p = buf.data(); p < buf.data() + buf.size(); p += rt->rtm_msglen) {\n+        // Iterate over routing entry addresses, get destination and gateway (if present).\n+        rt = (const struct rt_msghdr*)p;\n+        const struct sockaddr* sa = (const struct sockaddr*)(rt + 1);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611834614",
      "id" : 1611834614,
      "in_reply_to_id" : 1611691990,
      "line" : 194,
      "node_id" : "PRRC_kwDOABII585gEqT2",
      "original_commit_id" : "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "original_line" : 198,
      "original_position" : 198,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 194,
      "pull_request_review_id" : 2074204212,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611834614/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T14:55:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611834614",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611838998"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611838998"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Well, i guess it wouldn't hurt checking (or adding an `Assume`), but i don't think the routing table is supposed to contain error entries (also these would generally have `rtm_addrs==0`).",
      "commit_id" : "82b1c25b9ca61f5b0382a5196e0ff7016b4d1429",
      "created_at" : "2024-05-23T14:48:23Z",
      "diff_hunk" : "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), buf.data(), &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    const struct rt_msghdr* rt = nullptr;\n+    for (const std::byte* p = buf.data(); p < buf.data() + buf.size(); p += rt->rtm_msglen) {\n+        // Iterate over routing entry addresses, get destination and gateway (if present).\n+        rt = (const struct rt_msghdr*)p;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611838998",
      "id" : 1611838998,
      "in_reply_to_id" : 1611661588,
      "line" : 193,
      "node_id" : "PRRC_kwDOABII585gErYW",
      "original_commit_id" : "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "original_line" : 197,
      "original_position" : 197,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 193,
      "pull_request_review_id" : 2074212289,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611838998/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T14:52:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611838998",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--85328a0da195eb286784d51f73fa0af9-->\n\nð§ At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/25337033465</sub>",
      "created_at" : "2024-05-23T15:08:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2127381964",
      "id" : 2127381964,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585-zUXM",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2127381964/reactions"
      },
      "updated_at" : "2024-05-23T15:08:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2127381964",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611882820"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611882820"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> Also they're variable-length\r\n\r\nThat makes sense. Whereas `rt_msghdr` is fixed length I guess, so you're able to use `rt + 1` above (I'm still a bit terified that compilers don't care).\r\n\r\n",
      "commit_id" : "82b1c25b9ca61f5b0382a5196e0ff7016b4d1429",
      "created_at" : "2024-05-23T15:14:17Z",
      "diff_hunk" : "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), buf.data(), &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    const struct rt_msghdr* rt = nullptr;\n+    for (const std::byte* p = buf.data(); p < buf.data() + buf.size(); p += rt->rtm_msglen) {\n+        // Iterate over routing entry addresses, get destination and gateway (if present).\n+        rt = (const struct rt_msghdr*)p;\n+        const struct sockaddr* sa = (const struct sockaddr*)(rt + 1);\n+        std::optional<CNetAddr> dst;\n+        std::optional<CNetAddr> gateway;\n+        for (int i = 0; i < RTAX_MAX; i++) {\n+            if (rt->rtm_addrs & (1 << i)) {\n+                if (i == RTAX_DST) {\n+                    dst = FromSockAddr(sa);\n+                } else if (i == RTAX_GATEWAY) {\n+                    gateway = FromSockAddr(sa);\n+                }\n+                sa = (const struct sockaddr*)((std::byte*)sa + ROUNDUP(sa->sa_len));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611882820",
      "id" : 1611882820,
      "in_reply_to_id" : 1611731634,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gE2FE",
      "original_commit_id" : "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "original_line" : 208,
      "original_position" : 208,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : null,
      "pull_request_review_id" : 2074286585,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611882820/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T15:14:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611882820",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611884887"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611884887"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'm not sure, but the reason I wrote this comment is because initially I thought: yikes, what if this is out of bound?",
      "commit_id" : "82b1c25b9ca61f5b0382a5196e0ff7016b4d1429",
      "created_at" : "2024-05-23T15:15:50Z",
      "diff_hunk" : "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), buf.data(), &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    const struct rt_msghdr* rt = nullptr;\n+    for (const std::byte* p = buf.data(); p < buf.data() + buf.size(); p += rt->rtm_msglen) {\n+        // Iterate over routing entry addresses, get destination and gateway (if present).\n+        rt = (const struct rt_msghdr*)p;\n+        const struct sockaddr* sa = (const struct sockaddr*)(rt + 1);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611884887",
      "id" : 1611884887,
      "in_reply_to_id" : 1611691990,
      "line" : 194,
      "node_id" : "PRRC_kwDOABII585gE2lX",
      "original_commit_id" : "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "original_line" : 198,
      "original_position" : 198,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 194,
      "pull_request_review_id" : 2074290240,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611884887/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T15:16:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611884887",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611888217"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611888217"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Mmm, I thought perhaps it would return a single error entry to indicate failure.",
      "commit_id" : "82b1c25b9ca61f5b0382a5196e0ff7016b4d1429",
      "created_at" : "2024-05-23T15:16:53Z",
      "diff_hunk" : "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), buf.data(), &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    const struct rt_msghdr* rt = nullptr;\n+    for (const std::byte* p = buf.data(); p < buf.data() + buf.size(); p += rt->rtm_msglen) {\n+        // Iterate over routing entry addresses, get destination and gateway (if present).\n+        rt = (const struct rt_msghdr*)p;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611888217",
      "id" : 1611888217,
      "in_reply_to_id" : 1611661588,
      "line" : 193,
      "node_id" : "PRRC_kwDOABII585gE3ZZ",
      "original_commit_id" : "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "original_line" : 197,
      "original_position" : 197,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 193,
      "pull_request_review_id" : 2074295443,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611888217/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T15:16:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611888217",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611896435"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611896435"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`oldlenp=` does because it's key to the trick of how we get the length first. I find these variable name hints useful to e.g. search for them.",
      "commit_id" : "82b1c25b9ca61f5b0382a5196e0ff7016b4d1429",
      "created_at" : "2024-05-23T15:19:29Z",
      "diff_hunk" : "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611896435",
      "id" : 1611896435,
      "in_reply_to_id" : 1611597515,
      "line" : 181,
      "node_id" : "PRRC_kwDOABII585gE5Zz",
      "original_commit_id" : "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "original_line" : 185,
      "original_position" : 185,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 181,
      "pull_request_review_id" : 2074310132,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611896435/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T15:19:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611896435",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611906833"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611906833"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Can you add \"to gateway x.x.x.x\" here? I'm getting this error on your latest commit, three times, but I can't tell if it's IPv4, IPv6 or both.\r\n\r\nStrangely I do get four successful \"Added mapping pcp\" messages (1 on IPv4, 3 on IPv6).",
      "commit_id" : "82b1c25b9ca61f5b0382a5196e0ff7016b4d1429",
      "created_at" : "2024-05-23T15:25:54Z",
      "diff_hunk" : "@@ -0,0 +1,517 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RPC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RPC6886 3.5). Result codes <=2 match PCP.\n+static const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RPC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RPC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RPC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RPC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RPC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RPC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RPC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RPC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RPC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RPC6887 7.4). Result codes <=2 match NAT-PMP.\n+static const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+static std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+static std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RPC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] static bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RPC6887.\n+static CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+static std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::function<bool(const Span<const uint8_t>)> check_packet)\n+{\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611906833",
      "id" : 1611906833,
      "line" : 228,
      "node_id" : "PRRC_kwDOABII585gE78R",
      "original_commit_id" : "82b1c25b9ca61f5b0382a5196e0ff7016b4d1429",
      "original_line" : 228,
      "original_position" : 228,
      "original_start_line" : null,
      "path" : "src/util/pcp.cpp",
      "position" : 228,
      "pull_request_review_id" : 2074328030,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611906833/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T15:27:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611906833",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611917789"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611917789"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Update: this happens when I'm connected with a physical LAN cable _and_ wifi. So the warning was safe to ignore, but I'm still curious about it.",
      "commit_id" : "82b1c25b9ca61f5b0382a5196e0ff7016b4d1429",
      "created_at" : "2024-05-23T15:33:27Z",
      "diff_hunk" : "@@ -0,0 +1,517 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RPC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RPC6886 3.5). Result codes <=2 match PCP.\n+static const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RPC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RPC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RPC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RPC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RPC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RPC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RPC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RPC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RPC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RPC6887 7.4). Result codes <=2 match NAT-PMP.\n+static const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+static std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+static std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RPC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] static bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RPC6887.\n+static CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+static std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::function<bool(const Span<const uint8_t>)> check_packet)\n+{\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611917789",
      "id" : 1611917789,
      "in_reply_to_id" : 1611906833,
      "line" : 228,
      "node_id" : "PRRC_kwDOABII585gE-nd",
      "original_commit_id" : "82b1c25b9ca61f5b0382a5196e0ff7016b4d1429",
      "original_line" : 228,
      "original_position" : 228,
      "original_start_line" : null,
      "path" : "src/util/pcp.cpp",
      "position" : 228,
      "pull_request_review_id" : 2074346509,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611917789/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T15:33:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611917789",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611953200"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611953200"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Possible alternative, makes it a bit more clear that we rely on `rt->rtm_msglen` to be correct. A `for` loop gives a false sense of safety. No strong feelings though.\r\n\r\n```cpp\r\n    std::byte* p = buf.data();\r\n    while (true) {\r\n        rt = (const struct rt_msghdr*)p;\r\n        // ...\r\n\r\n        p += rt->rtm_msglen;\r\n        if (p == buf.data() + buf.size()) break;\r\n        assert(p < buf.data() + buf.size());\r\n    }\r\n```",
      "commit_id" : "82b1c25b9ca61f5b0382a5196e0ff7016b4d1429",
      "created_at" : "2024-05-23T15:58:15Z",
      "diff_hunk" : "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), buf.data(), &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    const struct rt_msghdr* rt = nullptr;\n+    for (const std::byte* p = buf.data(); p < buf.data() + buf.size(); p += rt->rtm_msglen) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611953200",
      "id" : 1611953200,
      "in_reply_to_id" : 1611637097,
      "line" : 191,
      "node_id" : "PRRC_kwDOABII585gFHQw",
      "original_commit_id" : "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "original_line" : 195,
      "original_position" : 195,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 191,
      "pull_request_review_id" : 2074405871,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611953200/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T15:58:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611953200",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611968560"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611968560"
         }
      },
      "author_association" : "MEMBER",
      "body" : "How about:\r\n\r\n```cpp\r\n// rt_msghdr is followed by zero or more sockaddrs, as indicated by rtm_addrs\r\nauto sa = (const struct sockaddr*)(p + sizeof(rt_msghdr));\r\n```",
      "commit_id" : "82b1c25b9ca61f5b0382a5196e0ff7016b4d1429",
      "created_at" : "2024-05-23T16:10:25Z",
      "diff_hunk" : "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), buf.data(), &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    const struct rt_msghdr* rt = nullptr;\n+    for (const std::byte* p = buf.data(); p < buf.data() + buf.size(); p += rt->rtm_msglen) {\n+        // Iterate over routing entry addresses, get destination and gateway (if present).\n+        rt = (const struct rt_msghdr*)p;\n+        const struct sockaddr* sa = (const struct sockaddr*)(rt + 1);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611968560",
      "id" : 1611968560,
      "in_reply_to_id" : 1611691990,
      "line" : 194,
      "node_id" : "PRRC_kwDOABII585gFLAw",
      "original_commit_id" : "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "original_line" : 198,
      "original_position" : 198,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 194,
      "pull_request_review_id" : 2074432764,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611968560/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T16:10:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611968560",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1612003469"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612003469"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Right, let's add `sizeof(rt_msghdr)` manually instead of doing the +1 trick.\r\n\r\n> That makes sense. Whereas rt_msghdr is fixed length I guess, so you're able to use rt + 1 above (I'm still a bit terified that compilers don't care). \r\n\r\nIf we can hardcode the assumption that `sa_len` is the first byte (which it is) then we can avoid casting and dereferencing sockaddr, anywhere. E.g. when we know the length we can memcpy it into a `sockaddr_storage` first.\r\n",
      "commit_id" : "82b1c25b9ca61f5b0382a5196e0ff7016b4d1429",
      "created_at" : "2024-05-23T16:29:53Z",
      "diff_hunk" : "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), buf.data(), &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    const struct rt_msghdr* rt = nullptr;\n+    for (const std::byte* p = buf.data(); p < buf.data() + buf.size(); p += rt->rtm_msglen) {\n+        // Iterate over routing entry addresses, get destination and gateway (if present).\n+        rt = (const struct rt_msghdr*)p;\n+        const struct sockaddr* sa = (const struct sockaddr*)(rt + 1);\n+        std::optional<CNetAddr> dst;\n+        std::optional<CNetAddr> gateway;\n+        for (int i = 0; i < RTAX_MAX; i++) {\n+            if (rt->rtm_addrs & (1 << i)) {\n+                if (i == RTAX_DST) {\n+                    dst = FromSockAddr(sa);\n+                } else if (i == RTAX_GATEWAY) {\n+                    gateway = FromSockAddr(sa);\n+                }\n+                sa = (const struct sockaddr*)((std::byte*)sa + ROUNDUP(sa->sa_len));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1612003469",
      "id" : 1612003469,
      "in_reply_to_id" : 1611731634,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gFTiN",
      "original_commit_id" : "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "original_line" : 208,
      "original_position" : 208,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : null,
      "pull_request_review_id" : 2074495742,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612003469/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T16:31:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612003469",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1612015499"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612015499"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Currently i have the following, having changed the pointer arithmetic to byte offsets:\r\n```c++\r\n    // Iterate over messages (each message is a routing table entry).\r\n    for (size_t msgptr = 0; msgptr < buf.size(); ) {\r\n        Assume((msgptr + sizeof(rt_msghdr)) <= buf.size());\r\n        const struct rt_msghdr* rt = (const struct rt_msghdr*)(buf.data() + msgptr);\r\n        // Iterate over addresses within entry, get destination and gateway (if present).\r\n        // Pointer to address data within message, starts after header.\r\n        size_t saptr = msgptr + sizeof(rt_msghdr);\r\n        size_t next_msgptr = msgptr + rt->rtm_msglen;\r\n        Assume(next_msgptr <= buf.size());\r\n        std::optional<CNetAddr> dst;\r\n        std::optional<CNetAddr> gateway;\r\n        for (int i = 0; i < RTAX_MAX; i++) {\r\n            if (rt->rtm_addrs & (1 << i)) {\r\n                Assume((saptr + 1) <= next_msgptr);\r\n                const struct sockaddr* sa = (const struct sockaddr*)(buf.data() + saptr);\r\n                Assume((saptr + sa->sa_len) <= next_msgptr);\r\n                if (i == RTAX_DST) {\r\n                    dst = FromSockAddr(sa);\r\n                } else if (i == RTAX_GATEWAY) {\r\n                    gateway = FromSockAddr(sa);\r\n                }\r\n                // Skip to next address.\r\n                saptr += sa->sa_len;\r\n            }\r\n        }\r\n        // Found default gateway?\r\n        if (dst && gateway && dst->IsBindAny()) { // Route to 0.0.0.0 or :: ?\r\n            return *gateway;\r\n        }\r\n        // Skip to next message.\r\n        msgptr = next_msgptr;\r\n    }\r\n```\r\nEdit: add anti-overflow assumptions.",
      "commit_id" : "82b1c25b9ca61f5b0382a5196e0ff7016b4d1429",
      "created_at" : "2024-05-23T16:39:59Z",
      "diff_hunk" : "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), buf.data(), &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    const struct rt_msghdr* rt = nullptr;\n+    for (const std::byte* p = buf.data(); p < buf.data() + buf.size(); p += rt->rtm_msglen) {\n+        // Iterate over routing entry addresses, get destination and gateway (if present).\n+        rt = (const struct rt_msghdr*)p;\n+        const struct sockaddr* sa = (const struct sockaddr*)(rt + 1);\n+        std::optional<CNetAddr> dst;\n+        std::optional<CNetAddr> gateway;\n+        for (int i = 0; i < RTAX_MAX; i++) {\n+            if (rt->rtm_addrs & (1 << i)) {\n+                if (i == RTAX_DST) {\n+                    dst = FromSockAddr(sa);\n+                } else if (i == RTAX_GATEWAY) {\n+                    gateway = FromSockAddr(sa);\n+                }\n+                sa = (const struct sockaddr*)((std::byte*)sa + ROUNDUP(sa->sa_len));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1612015499",
      "id" : 1612015499,
      "in_reply_to_id" : 1611731634,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gFWeL",
      "original_commit_id" : "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "original_line" : 208,
      "original_position" : 208,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : null,
      "pull_request_review_id" : 2074515775,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612015499/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T17:02:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612015499",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1612022021"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612022021"
         }
      },
      "author_association" : "MEMBER",
      "body" : "If it appears after the IPv4 gateway log message it's for the IPv4 gateway, if it's after the IPv6 one it's for the IPv6 gateway. No more than two gateways are ever used. i don't think adding it to every log message is worth it.\r\n\r\n> Update: this happens when I'm connected with a physical LAN cable and wifi. So the warning was safe to ignore, but I'm still curious about it.\r\n\r\nRight i think that's the reason-if you have multiple internet connections, then mapping the IPv6 addresses connected to the other one (that's not the default gateway) will fail. This is a scenario too complex for automatic mapping to handle, anyhow. Glad to hear some addresses were still mapped correctly.\r\n\r\n(fairly sure this issue does not arise with IPv4, because it maps one port on the internal address toward the default gateway)",
      "commit_id" : "82b1c25b9ca61f5b0382a5196e0ff7016b4d1429",
      "created_at" : "2024-05-23T16:45:35Z",
      "diff_hunk" : "@@ -0,0 +1,517 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RPC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RPC6886 3.5). Result codes <=2 match PCP.\n+static const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RPC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RPC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RPC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RPC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RPC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RPC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RPC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RPC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RPC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RPC6887 7.4). Result codes <=2 match NAT-PMP.\n+static const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+static std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+static std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RPC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] static bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RPC6887.\n+static CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+static std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::function<bool(const Span<const uint8_t>)> check_packet)\n+{\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1612022021",
      "id" : 1612022021,
      "in_reply_to_id" : 1611906833,
      "line" : 228,
      "node_id" : "PRRC_kwDOABII585gFYEF",
      "original_commit_id" : "82b1c25b9ca61f5b0382a5196e0ff7016b4d1429",
      "original_line" : 228,
      "original_position" : 228,
      "original_start_line" : null,
      "path" : "src/util/pcp.cpp",
      "position" : 228,
      "pull_request_review_id" : 2074526400,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612022021/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T17:50:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612022021",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1612025592"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612025592"
         }
      },
      "author_association" : "MEMBER",
      "body" : "i moved the cast to the if() inside the inner loop.",
      "commit_id" : "82b1c25b9ca61f5b0382a5196e0ff7016b4d1429",
      "created_at" : "2024-05-23T16:48:22Z",
      "diff_hunk" : "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), buf.data(), &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    const struct rt_msghdr* rt = nullptr;\n+    for (const std::byte* p = buf.data(); p < buf.data() + buf.size(); p += rt->rtm_msglen) {\n+        // Iterate over routing entry addresses, get destination and gateway (if present).\n+        rt = (const struct rt_msghdr*)p;\n+        const struct sockaddr* sa = (const struct sockaddr*)(rt + 1);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1612025592",
      "id" : 1612025592,
      "in_reply_to_id" : 1611691990,
      "line" : 194,
      "node_id" : "PRRC_kwDOABII585gFY74",
      "original_commit_id" : "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "original_line" : 198,
      "original_position" : 198,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : 194,
      "pull_request_review_id" : 2074533276,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612025592/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T16:48:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612025592",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1612076306"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612076306"
         }
      },
      "author_association" : "MEMBER",
      "body" : "That indeed looks better.\r\n\r\nThe *ptr variables are no longer actually pointers, so I suggest renaming them:\r\n\r\nmsgptr -> msg_pos\r\nwithin entry - within message\r\nsaptr -> sa_pos\r\nnext_msgptr -> next_msg_pos\r\n\r\nLet's set and check next_msgptr _before_ saptr and make it const.\r\n\r\n",
      "commit_id" : "82b1c25b9ca61f5b0382a5196e0ff7016b4d1429",
      "created_at" : "2024-05-23T17:32:37Z",
      "diff_hunk" : "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), buf.data(), &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    const struct rt_msghdr* rt = nullptr;\n+    for (const std::byte* p = buf.data(); p < buf.data() + buf.size(); p += rt->rtm_msglen) {\n+        // Iterate over routing entry addresses, get destination and gateway (if present).\n+        rt = (const struct rt_msghdr*)p;\n+        const struct sockaddr* sa = (const struct sockaddr*)(rt + 1);\n+        std::optional<CNetAddr> dst;\n+        std::optional<CNetAddr> gateway;\n+        for (int i = 0; i < RTAX_MAX; i++) {\n+            if (rt->rtm_addrs & (1 << i)) {\n+                if (i == RTAX_DST) {\n+                    dst = FromSockAddr(sa);\n+                } else if (i == RTAX_GATEWAY) {\n+                    gateway = FromSockAddr(sa);\n+                }\n+                sa = (const struct sockaddr*)((std::byte*)sa + ROUNDUP(sa->sa_len));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1612076306",
      "id" : 1612076306,
      "in_reply_to_id" : 1611731634,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gFlUS",
      "original_commit_id" : "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "original_line" : 208,
      "original_position" : 208,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : null,
      "pull_request_review_id" : 2074627014,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612076306/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T17:32:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612076306",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1612195743"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612195743"
         }
      },
      "author_association" : "MEMBER",
      "body" : "From what i understand, the error signalling and many of the flags and operations in the `rt_msghdr` are used with `PF_ROUTE` sockets, interactively. `sysctl` stores a read-only copy of the routing table data so that non-root users can access it.\r\nGranted, it's kind of a weird API.",
      "commit_id" : "9a265c6d75136991125730b8a6a901e95cfeb8f6",
      "created_at" : "2024-05-23T19:20:19Z",
      "diff_hunk" : "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), buf.data(), &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    const struct rt_msghdr* rt = nullptr;\n+    for (const std::byte* p = buf.data(); p < buf.data() + buf.size(); p += rt->rtm_msglen) {\n+        // Iterate over routing entry addresses, get destination and gateway (if present).\n+        rt = (const struct rt_msghdr*)p;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1612195743",
      "id" : 1612195743,
      "in_reply_to_id" : 1611661588,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gGCef",
      "original_commit_id" : "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "original_line" : 197,
      "original_position" : 197,
      "original_start_line" : null,
      "path" : "src/util/netif.cpp",
      "position" : null,
      "pull_request_review_id" : 2074820375,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612195743/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T19:22:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612195743",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1613016087"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613016087"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'm a bit surprised that when we ask for the default gateway, we get results for both network connections. But I guess we're not asking for the _default_ gateway on macOS, but rather all of them?",
      "commit_id" : "9a265c6d75136991125730b8a6a901e95cfeb8f6",
      "created_at" : "2024-05-24T07:46:40Z",
      "diff_hunk" : "@@ -0,0 +1,517 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RPC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RPC6886 3.5). Result codes <=2 match PCP.\n+static const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RPC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RPC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RPC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RPC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RPC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RPC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RPC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RPC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RPC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RPC6887 7.4). Result codes <=2 match NAT-PMP.\n+static const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+static std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+static std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RPC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] static bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RPC6887.\n+static CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+static std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::function<bool(const Span<const uint8_t>)> check_packet)\n+{\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1613016087",
      "id" : 1613016087,
      "in_reply_to_id" : 1611906833,
      "line" : 228,
      "node_id" : "PRRC_kwDOABII585gJKwX",
      "original_commit_id" : "82b1c25b9ca61f5b0382a5196e0ff7016b4d1429",
      "original_line" : 228,
      "original_position" : 228,
      "original_start_line" : null,
      "path" : "src/util/pcp.cpp",
      "position" : 228,
      "pull_request_review_id" : 2076113676,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613016087/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T07:46:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613016087",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Ok, happy with `QueryDefaultGateway(Impl)` as of 9a265c6d75136991125730b8a6a901e95cfeb8f6, except for not compiling on BSD 13.2:\r\n\r\n```\r\nutil/netif.cpp:84:82: error: use of undeclared identifier 'typeof'; did you mean 'typeid'?\r\n    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\r\n```\r\n\r\nIt also throws a warning:\r\n\r\n```\r\nutil/netif.cpp:84:47: warning: comparison of integers of different signs: 'int' and 'size_t' (aka 'unsigned long') [-Wsign-compare]\r\n    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\r\n```\r\n\r\nFreeBSD clang version 14.0.5\r\n\r\nSo I guess that's not supposed to work, since clang 15.0 is the minimum.\r\n\r\n```\r\npkg install llvm15\r\n./configure CC=/usr/local/bin/clang15 CXX=/usr/local/bin/clang++15 MAKE=gmake\r\ngmake\r\n```\r\n\r\nThat still results in the same error and warning though.\r\n\r\n",
      "created_at" : "2024-05-24T08:15:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2128880081",
      "id" : 2128880081,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585-5CHR",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2128880081/reactions"
      },
      "updated_at" : "2024-05-24T08:29:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2128880081",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1613185703"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613185703"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Oh I think I get it. In `ProcessPCP` (`mapport.cpp`) we call `PCPRequestPortMap` for every IPv6 address we have, as determined by `GetLocalAddresses()`.\r\n\r\nEach port map request is made to the default gateway. This is (usually) a scope-local addresses, see https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610568498 \r\nSo unlike with IPv4, where a gateway like 192.168.1.1 is reachable through both network connections, the IPv6 default gateway is only reachable through _one_ connection.\r\n\r\nIn `PCPRequestPortMap` we create a socket and bind it to the intended destination address. I'm still a bit puzzled why `sock.Connect` doesn't fail and instead `sock.Send` is where the error is triggered. I suppose that's because that's where the OS realizes there's no route and gives up? That's indeed what the error `No route to host (65)` implies.\r\n\r\nAnd indeed we don't have to \"fix\" this. Section 2.3 says:\r\n\r\n> for a given IP address of a host, only one default route exists to reach other hosts on the Internet from that source IP address\r\n\r\nPCP itself doesn't support this kind of setup either.\r\n\r\nThe only thing that matters is that nodes in the outside world can connect to us, we don't care which of the two network connections ends up getting used.\r\n\r\nI guess if I were to turn off the wifi, and that happened to have been the default gateway, I won't get new inbound connections until 20 minutes have passed and we request a new mapping via the LAN default gateway. Haven't tested this.",
      "commit_id" : "9a265c6d75136991125730b8a6a901e95cfeb8f6",
      "created_at" : "2024-05-24T09:36:42Z",
      "diff_hunk" : "@@ -0,0 +1,517 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RPC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RPC6886 3.5). Result codes <=2 match PCP.\n+static const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RPC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RPC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RPC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RPC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RPC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RPC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RPC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RPC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RPC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RPC6887 7.4). Result codes <=2 match NAT-PMP.\n+static const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+static std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+static std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RPC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] static bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RPC6887.\n+static CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+static std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::function<bool(const Span<const uint8_t>)> check_packet)\n+{\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1613185703",
      "id" : 1613185703,
      "in_reply_to_id" : 1611906833,
      "line" : 228,
      "node_id" : "PRRC_kwDOABII585gJ0Kn",
      "original_commit_id" : "82b1c25b9ca61f5b0382a5196e0ff7016b4d1429",
      "original_line" : 228,
      "original_position" : 228,
      "original_start_line" : null,
      "path" : "src/util/pcp.cpp",
      "position" : 228,
      "pull_request_review_id" : 2076391051,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613185703/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T09:47:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613185703",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1613246935"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613246935"
         }
      },
      "author_association" : "MEMBER",
      "body" : "typo: portmap",
      "commit_id" : "1cbbcba42cf1c050022a73cb02b9d385fa184f2e",
      "created_at" : "2024-05-24T10:23:06Z",
      "diff_hunk" : "@@ -46,104 +43,95 @@ using namespace std::chrono_literals;\n static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD{20min};\n static constexpr auto PORT_MAPPING_RETRY_PERIOD{5min};\n \n-#ifdef USE_NATPMP\n-static uint16_t g_mapport_external_port = 0;\n-static bool NatpmpInit(natpmp_t* natpmp)\n+static bool ProcessPCP()\n {\n-    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n-    if (r_init == 0) return true;\n-    LogPrintf(\"natpmp: initnatpmp() failed with %d error.\\n\", r_init);\n-    return false;\n-}\n+    // The same nonce is used for all mappings, this is allowed by the spec, and simplifies keeping track of them.\n+    PCPMappingNonce pcp_nonce;\n+    GetRandBytes(pcp_nonce);\n \n-static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n-{\n-    const int r_send = sendpublicaddressrequest(natpmp);\n-    if (r_send == 2 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            external_ipv4_addr = response.pnu.publicaddress.addr;\n-            return true;\n-        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n-            LogPrintf(\"natpmp: The gateway does not support NAT-PMP.\\n\");\n+    bool ret = false;\n+    bool no_resources = false;\n+    const uint16_t private_port = GetListenPort();\n+    const uint32_t requested_lifetime = std::chrono::seconds(PORT_MAPPING_REANNOUNCE_PERIOD).count();\n+    uint32_t actual_lifetime = 0;\n+    std::chrono::milliseconds sleep_time;\n+\n+    // Local functor to handle result from PCP/NATPMP mapping.\n+    auto handle_mapping = [&](std::variant<MappingResult, MappingError> &res) -> void {\n+        if (MappingResult* mapping = std::get_if<MappingResult>(&res)) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Info, \"portmap: Added mapping %s\\n\", mapping->ToString());\n+            AddLocal(mapping->external, LOCAL_MAPPED);\n+            ret = true;\n+            actual_lifetime = std::min(actual_lifetime, mapping->lifetime);\n+        } else if (MappingError *err = std::get_if<MappingError>(&res)) {\n+            // Detailed error will already have been logged internally in respective Pormap function.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1613246935",
      "id" : 1613246935,
      "line" : 67,
      "node_id" : "PRRC_kwDOABII585gKDHX",
      "original_commit_id" : "9a265c6d75136991125730b8a6a901e95cfeb8f6",
      "original_line" : 67,
      "original_position" : 74,
      "original_start_line" : null,
      "path" : "src/mapport.cpp",
      "position" : 74,
      "pull_request_review_id" : 2076503238,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613246935/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T12:10:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613246935",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1613266348"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613266348"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```cpp\r\n// We only attempt renewal once.\r\n```\r\n\r\nThe spec recommend trying again with ever shorter intervals, but no less than 4 seconds, as the deadline approached. But it seems fine to not bother.\r\n\r\nIf renewal fails we fall out of the loop, `ProcessPCP` returns. At that point we fall back to UPNP (if enabled) and/or try again 5 minutes later.\r\n\r\nRenewal for NAT-PMP works the same it seems, see towards the end of https://datatracker.ietf.org/doc/html/rfc6886#section-3.3",
      "commit_id" : "1cbbcba42cf1c050022a73cb02b9d385fa184f2e",
      "created_at" : "2024-05-24T10:38:30Z",
      "diff_hunk" : "@@ -46,104 +43,95 @@ using namespace std::chrono_literals;\n static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD{20min};\n static constexpr auto PORT_MAPPING_RETRY_PERIOD{5min};\n \n-#ifdef USE_NATPMP\n-static uint16_t g_mapport_external_port = 0;\n-static bool NatpmpInit(natpmp_t* natpmp)\n+static bool ProcessPCP()\n {\n-    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n-    if (r_init == 0) return true;\n-    LogPrintf(\"natpmp: initnatpmp() failed with %d error.\\n\", r_init);\n-    return false;\n-}\n+    // The same nonce is used for all mappings, this is allowed by the spec, and simplifies keeping track of them.\n+    PCPMappingNonce pcp_nonce;\n+    GetRandBytes(pcp_nonce);\n \n-static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n-{\n-    const int r_send = sendpublicaddressrequest(natpmp);\n-    if (r_send == 2 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            external_ipv4_addr = response.pnu.publicaddress.addr;\n-            return true;\n-        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n-            LogPrintf(\"natpmp: The gateway does not support NAT-PMP.\\n\");\n+    bool ret = false;\n+    bool no_resources = false;\n+    const uint16_t private_port = GetListenPort();\n+    const uint32_t requested_lifetime = std::chrono::seconds(PORT_MAPPING_REANNOUNCE_PERIOD).count();\n+    uint32_t actual_lifetime = 0;\n+    std::chrono::milliseconds sleep_time;\n+\n+    // Local functor to handle result from PCP/NATPMP mapping.\n+    auto handle_mapping = [&](std::variant<MappingResult, MappingError> &res) -> void {\n+        if (MappingResult* mapping = std::get_if<MappingResult>(&res)) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Info, \"portmap: Added mapping %s\\n\", mapping->ToString());\n+            AddLocal(mapping->external, LOCAL_MAPPED);\n+            ret = true;\n+            actual_lifetime = std::min(actual_lifetime, mapping->lifetime);\n+        } else if (MappingError *err = std::get_if<MappingError>(&res)) {\n+            // Detailed error will already have been logged internally in respective Pormap function.\n+            if (*err == MappingError::NO_RESOURCES) {\n+                no_resources = true;\n+            }\n+        }\n+    };\n+\n+    do {\n+        actual_lifetime = requested_lifetime;\n+        no_resources = false; // Set to true if there was any \"no resources\" error.\n+        ret = false; // Set to true if any mapping succeeds.\n+\n+        // IPv4\n+        std::optional<CNetAddr> gateway4 = QueryDefaultGateway(NET_IPV4);\n+        if (!gateway4) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Could not determine IPv4 default gateway\\n\");\n         } else {\n-            LogPrintf(\"natpmp: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: gateway [IPv4]: %s\\n\", gateway4->ToStringAddr());\n+\n+            // Open a port mapping on whatever local address we have toward the gateway.\n+            struct in_addr inaddr_any;\n+            inaddr_any.s_addr = htonl(INADDR_ANY);\n+            auto res = PCPRequestPortMap(pcp_nonce, *gateway4, CNetAddr(inaddr_any), private_port, requested_lifetime);\n+            MappingError* pcp_err = std::get_if<MappingError>(&res);\n+            if (pcp_err && *pcp_err == MappingError::UNSUPP_VERSION) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Got unsupported PCP version response, falling back to NAT-PMP\\n\");\n+                res = NATPMPRequestPortMap(*gateway4, private_port, requested_lifetime);\n+            }\n+            handle_mapping(res);\n         }\n-    } else {\n-        LogPrintf(\"natpmp: sendpublicaddressrequest() failed with %d error.\\n\", r_send);\n-    }\n \n-    return false;\n-}\n+        // IPv6\n+        std::optional<CNetAddr> gateway6 = QueryDefaultGateway(NET_IPV6);\n+        if (!gateway6) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Could not determine IPv6 default gateway\\n\");\n+        } else {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: gateway [IPv6]: %s\\n\", gateway6->ToStringAddr());\n \n-static bool NatpmpMapping(natpmp_t* natpmp, const struct in_addr& external_ipv4_addr, uint16_t private_port, bool& external_ip_discovered)\n-{\n-    const uint16_t suggested_external_port = g_mapport_external_port ? g_mapport_external_port : private_port;\n-    const int r_send = sendnewportmappingrequest(natpmp, NATPMP_PROTOCOL_TCP, private_port, suggested_external_port, 3600 /*seconds*/);\n-    if (r_send == 12 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            auto pm = response.pnu.newportmapping;\n-            if (private_port == pm.privateport && pm.lifetime > 0) {\n-                g_mapport_external_port = pm.mappedpublicport;\n-                const CService external{external_ipv4_addr, pm.mappedpublicport};\n-                if (!external_ip_discovered && fDiscover) {\n-                    AddLocal(external, LOCAL_MAPPED);\n-                    external_ip_discovered = true;\n-                }\n-                LogPrintf(\"natpmp: Port mapping successful. External address = %s\\n\", external.ToStringAddrPort());\n-                return true;\n-            } else {\n-                LogPrintf(\"natpmp: Port mapping failed.\\n\");\n+            // Try to open pinholes for all routable local IPv6 addresses.\n+            for (const auto &addr: GetLocalAddresses()) {\n+                if (!addr.IsRoutable() || !addr.IsIPv6()) continue;\n+                auto res = PCPRequestPortMap(pcp_nonce, *gateway6, addr, private_port, requested_lifetime);\n+                handle_mapping(res);\n             }\n-        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n-            LogPrintf(\"natpmp: The gateway does not support NAT-PMP.\\n\");\n-        } else {\n-            LogPrintf(\"natpmp: readnatpmpresponseorretry() for port mapping failed with %d error.\\n\", r_read);\n         }\n-    } else {\n-        LogPrintf(\"natpmp: sendnewportmappingrequest() failed with %d error.\\n\", r_send);\n-    }\n-\n-    return false;\n-}\n \n-static bool ProcessNatpmp()\n-{\n-    bool ret = false;\n-    natpmp_t natpmp;\n-    struct in_addr external_ipv4_addr;\n-    if (NatpmpInit(&natpmp) && NatpmpDiscover(&natpmp, external_ipv4_addr)) {\n-        bool external_ip_discovered = false;\n-        const uint16_t private_port = GetListenPort();\n-        do {\n-            ret = NatpmpMapping(&natpmp, external_ipv4_addr, private_port, external_ip_discovered);\n-        } while (ret && g_mapport_interrupt.sleep_for(PORT_MAPPING_REANNOUNCE_PERIOD));\n-        g_mapport_interrupt.reset();\n+        // Log message if we got NO_RESOURCES.\n+        if (no_resources) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"portmap: At least one mapping failed because of a NO_RESOURCES error. This usually indicates that the port is already used on the router. If this is the only instance of bitcoin running on the network, this will resolve itself automatically. Otherwise, you might want to choose a different P2P port to prevent this conflict.\\n\");\n+        }\n \n-        const int r_send = sendnewportmappingrequest(&natpmp, NATPMP_PROTOCOL_TCP, private_port, g_mapport_external_port, /* remove a port mapping */ 0);\n-        g_mapport_external_port = 0;\n-        if (r_send == 12 /* OK */) {\n-            LogPrintf(\"natpmp: Port mapping removed successfully.\\n\");\n-        } else {\n-            LogPrintf(\"natpmp: sendnewportmappingrequest(0) failed with %d error.\\n\", r_send);\n+        // Sanity-check returned lifetime.\n+        if (actual_lifetime < 30) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"portmap: Got impossibly short mapping lifetime of %d seconds\\n\", actual_lifetime);\n+            return false;\n         }\n-    }\n+        // RFC6887 11.2.1 recommends that clients send their first renewal packet at a time chosen with uniform random\n+        // distribution in the range 1/2 to 5/8 of expiration time.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1613266348",
      "id" : 1613266348,
      "line" : 124,
      "node_id" : "PRRC_kwDOABII585gKH2s",
      "original_commit_id" : "9a265c6d75136991125730b8a6a901e95cfeb8f6",
      "original_line" : 124,
      "original_position" : 190,
      "original_start_line" : null,
      "path" : "src/mapport.cpp",
      "position" : 190,
      "pull_request_review_id" : 2076503238,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613266348/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T12:10:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613266348",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Do you know what's the minimum FreeBSD version it can be compiled on? Let's bump the version bound to that.\r\n\r\n> util/netif.cpp:84:82: error: use of undeclared identifier 'typeof'; did you mean 'typeid'?\r\n>    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\r\n\r\nIt is strange though. There isn't even a \"typeof\" on that line. It must be part of the system macro itself? In which case, why do they provide macros that don't work with their own compilers.\r\n\r\nEdit: googling for the issue, `typeof` is a GCC specific extension that's not available in C++. It should be using `__typeof__` instead. Unfortunately, it is not in our own code.",
      "created_at" : "2024-05-24T11:33:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2129306509",
      "id" : 2129306509,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585-6qON",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2129306509/reactions"
      },
      "updated_at" : "2024-05-24T11:49:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2129306509",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Do you know what's the minimum FreeBSD version it can be compiled on? Let's bump the version bound to that.\r\n\r\nI'll spin up some more recent VMs to test, probably next week though. ",
      "created_at" : "2024-05-24T11:34:53Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2129309096",
      "id" : 2129309096,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585-6q2o",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2129309096/reactions"
      },
      "updated_at" : "2024-05-24T11:34:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2129309096",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "For testing, something like https://github.com/bitcoin/bitcoin/pull/30164 could be used",
      "created_at" : "2024-05-24T11:46:54Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2129331327",
      "id" : 2129331327,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585-6wR_",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2129331327/reactions"
      },
      "updated_at" : "2024-05-24T11:46:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2129331327",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/maflcko/events{/privacy}",
         "followers_url" : "https://api.github.com/users/maflcko/followers",
         "following_url" : "https://api.github.com/users/maflcko/following{/other_user}",
         "gists_url" : "https://api.github.com/users/maflcko/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/maflcko",
         "id" : 6399679,
         "login" : "maflcko",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/maflcko/orgs",
         "received_events_url" : "https://api.github.com/users/maflcko/received_events",
         "repos_url" : "https://api.github.com/users/maflcko/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/maflcko/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/maflcko/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/maflcko"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1613380035"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613380035"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It seems like the gateway can keep us waiting forever by sending an invalid response at least once per second. Should we give up at some point?",
      "commit_id" : "1cbbcba42cf1c050022a73cb02b9d385fa184f2e",
      "created_at" : "2024-05-24T12:10:02Z",
      "diff_hunk" : "@@ -0,0 +1,517 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RPC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RPC6886 3.5). Result codes <=2 match PCP.\n+static const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RPC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RPC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RPC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RPC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RPC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RPC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RPC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RPC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RPC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RPC6887 7.4). Result codes <=2 match NAT-PMP.\n+static const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+static std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+static std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RPC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] static bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RPC6887.\n+static CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+static std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::function<bool(const Span<const uint8_t>)> check_packet)\n+{\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+            return std::nullopt; // Network-level error, probably no use retrying.\n+        }\n+\n+        // Wait for response(s) until we get a valid response, a network error, or time out.\n+        while (true) {\n+            Sock::Event occurred = 0;\n+            if (!sock.Wait(std::chrono::milliseconds(1000), Sock::RECV, &occurred)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not wait on socket: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            if (!occurred) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Timeout\\n\", protocol);\n+                break; // Retry.\n+            }\n+\n+            // Receive response.\n+            recvsz = sock.Recv(response, sizeof(response), MSG_DONTWAIT);\n+            if (recvsz < 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not receive response: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Received response of %d bytes: %s\\n\", protocol, recvsz, HexStr(Span(response, recvsz)));\n+\n+            if (check_packet(Span<uint8_t>(response, recvsz))) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1613380035",
      "id" : 1613380035,
      "line" : 252,
      "node_id" : "PRRC_kwDOABII585gKjnD",
      "original_commit_id" : "9a265c6d75136991125730b8a6a901e95cfeb8f6",
      "original_line" : 252,
      "original_position" : 252,
      "original_start_line" : null,
      "path" : "src/util/pcp.cpp",
      "position" : 252,
      "pull_request_review_id" : 2076503238,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613380035/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T12:11:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613380035",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "The first two commits of https://github.com/bitcoin/bitcoin/pull/26812 would make it possible to test and fuzz how this code interacts with a router.",
      "created_at" : "2024-05-24T12:30:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2129421039",
      "id" : 2129421039,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585-7GLv",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2129421039/reactions"
      },
      "updated_at" : "2024-05-24T12:30:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2129421039",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1613775486"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613775486"
         }
      },
      "author_association" : "MEMBER",
      "body" : "yes, the proper way would be to set a deadline with a monotonic clock, instead of using the same timeout every time\r\nthough, everything considered, the gateway can only hold up this thread; it's not like the rest of bitcoind is waiting on it, and if the gateway is not to be trusted then it's not like we're going to get any useful mappings anyway",
      "commit_id" : "1cbbcba42cf1c050022a73cb02b9d385fa184f2e",
      "created_at" : "2024-05-24T16:57:35Z",
      "diff_hunk" : "@@ -0,0 +1,517 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RPC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RPC6886 3.5). Result codes <=2 match PCP.\n+static const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RPC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RPC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RPC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RPC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RPC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RPC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RPC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RPC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RPC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RPC6887 7.4). Result codes <=2 match NAT-PMP.\n+static const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+static std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+static std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RPC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] static bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RPC6887.\n+static CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+static std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::function<bool(const Span<const uint8_t>)> check_packet)\n+{\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+            return std::nullopt; // Network-level error, probably no use retrying.\n+        }\n+\n+        // Wait for response(s) until we get a valid response, a network error, or time out.\n+        while (true) {\n+            Sock::Event occurred = 0;\n+            if (!sock.Wait(std::chrono::milliseconds(1000), Sock::RECV, &occurred)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not wait on socket: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            if (!occurred) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Timeout\\n\", protocol);\n+                break; // Retry.\n+            }\n+\n+            // Receive response.\n+            recvsz = sock.Recv(response, sizeof(response), MSG_DONTWAIT);\n+            if (recvsz < 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not receive response: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Received response of %d bytes: %s\\n\", protocol, recvsz, HexStr(Span(response, recvsz)));\n+\n+            if (check_packet(Span<uint8_t>(response, recvsz))) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1613775486",
      "id" : 1613775486,
      "in_reply_to_id" : 1613380035,
      "line" : 252,
      "node_id" : "PRRC_kwDOABII585gMEJ-",
      "original_commit_id" : "9a265c6d75136991125730b8a6a901e95cfeb8f6",
      "original_line" : 252,
      "original_position" : 252,
      "original_start_line" : null,
      "path" : "src/util/pcp.cpp",
      "position" : 252,
      "pull_request_review_id" : 2077437627,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613775486/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T16:57:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613775486",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1613785831"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785831"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> The spec recommend trying again with ever shorter intervals, but no less than 4 seconds, as the deadline approached. But it seems fine to not bother.\r\n\r\nRight, the retrying is not according to spec-because i had the same thought. It seems overkill to adaptive timing for something that's meant to interact with the local router. If it doesn't have enough capacity to handle a PCP/NAT-PMP packet it sure won't be routing a lot of traffic. i was more afraid that bitcoind (or the system it's running on) itself is blocked (due to heavy verification i/o load) that i implemented the \"start about halfway with renewal\" instead of having a margin of a minute :smile: \r\n\r\n> If renewal fails we fall out of the loop, ProcessPCP returns. At that point we fall back to UPNP (if enabled) and/or try again 5 minutes later.\r\n\r\nIndeed, that's my intent. Network configuration can always change, either by the user logging into another network or installing a different router/firmware update, so i think it's a feature that it keeps trying and it's otherwise stateless.",
      "commit_id" : "1cbbcba42cf1c050022a73cb02b9d385fa184f2e",
      "created_at" : "2024-05-24T17:08:42Z",
      "diff_hunk" : "@@ -46,104 +43,95 @@ using namespace std::chrono_literals;\n static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD{20min};\n static constexpr auto PORT_MAPPING_RETRY_PERIOD{5min};\n \n-#ifdef USE_NATPMP\n-static uint16_t g_mapport_external_port = 0;\n-static bool NatpmpInit(natpmp_t* natpmp)\n+static bool ProcessPCP()\n {\n-    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n-    if (r_init == 0) return true;\n-    LogPrintf(\"natpmp: initnatpmp() failed with %d error.\\n\", r_init);\n-    return false;\n-}\n+    // The same nonce is used for all mappings, this is allowed by the spec, and simplifies keeping track of them.\n+    PCPMappingNonce pcp_nonce;\n+    GetRandBytes(pcp_nonce);\n \n-static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n-{\n-    const int r_send = sendpublicaddressrequest(natpmp);\n-    if (r_send == 2 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            external_ipv4_addr = response.pnu.publicaddress.addr;\n-            return true;\n-        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n-            LogPrintf(\"natpmp: The gateway does not support NAT-PMP.\\n\");\n+    bool ret = false;\n+    bool no_resources = false;\n+    const uint16_t private_port = GetListenPort();\n+    const uint32_t requested_lifetime = std::chrono::seconds(PORT_MAPPING_REANNOUNCE_PERIOD).count();\n+    uint32_t actual_lifetime = 0;\n+    std::chrono::milliseconds sleep_time;\n+\n+    // Local functor to handle result from PCP/NATPMP mapping.\n+    auto handle_mapping = [&](std::variant<MappingResult, MappingError> &res) -> void {\n+        if (MappingResult* mapping = std::get_if<MappingResult>(&res)) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Info, \"portmap: Added mapping %s\\n\", mapping->ToString());\n+            AddLocal(mapping->external, LOCAL_MAPPED);\n+            ret = true;\n+            actual_lifetime = std::min(actual_lifetime, mapping->lifetime);\n+        } else if (MappingError *err = std::get_if<MappingError>(&res)) {\n+            // Detailed error will already have been logged internally in respective Pormap function.\n+            if (*err == MappingError::NO_RESOURCES) {\n+                no_resources = true;\n+            }\n+        }\n+    };\n+\n+    do {\n+        actual_lifetime = requested_lifetime;\n+        no_resources = false; // Set to true if there was any \"no resources\" error.\n+        ret = false; // Set to true if any mapping succeeds.\n+\n+        // IPv4\n+        std::optional<CNetAddr> gateway4 = QueryDefaultGateway(NET_IPV4);\n+        if (!gateway4) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Could not determine IPv4 default gateway\\n\");\n         } else {\n-            LogPrintf(\"natpmp: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: gateway [IPv4]: %s\\n\", gateway4->ToStringAddr());\n+\n+            // Open a port mapping on whatever local address we have toward the gateway.\n+            struct in_addr inaddr_any;\n+            inaddr_any.s_addr = htonl(INADDR_ANY);\n+            auto res = PCPRequestPortMap(pcp_nonce, *gateway4, CNetAddr(inaddr_any), private_port, requested_lifetime);\n+            MappingError* pcp_err = std::get_if<MappingError>(&res);\n+            if (pcp_err && *pcp_err == MappingError::UNSUPP_VERSION) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Got unsupported PCP version response, falling back to NAT-PMP\\n\");\n+                res = NATPMPRequestPortMap(*gateway4, private_port, requested_lifetime);\n+            }\n+            handle_mapping(res);\n         }\n-    } else {\n-        LogPrintf(\"natpmp: sendpublicaddressrequest() failed with %d error.\\n\", r_send);\n-    }\n \n-    return false;\n-}\n+        // IPv6\n+        std::optional<CNetAddr> gateway6 = QueryDefaultGateway(NET_IPV6);\n+        if (!gateway6) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Could not determine IPv6 default gateway\\n\");\n+        } else {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: gateway [IPv6]: %s\\n\", gateway6->ToStringAddr());\n \n-static bool NatpmpMapping(natpmp_t* natpmp, const struct in_addr& external_ipv4_addr, uint16_t private_port, bool& external_ip_discovered)\n-{\n-    const uint16_t suggested_external_port = g_mapport_external_port ? g_mapport_external_port : private_port;\n-    const int r_send = sendnewportmappingrequest(natpmp, NATPMP_PROTOCOL_TCP, private_port, suggested_external_port, 3600 /*seconds*/);\n-    if (r_send == 12 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            auto pm = response.pnu.newportmapping;\n-            if (private_port == pm.privateport && pm.lifetime > 0) {\n-                g_mapport_external_port = pm.mappedpublicport;\n-                const CService external{external_ipv4_addr, pm.mappedpublicport};\n-                if (!external_ip_discovered && fDiscover) {\n-                    AddLocal(external, LOCAL_MAPPED);\n-                    external_ip_discovered = true;\n-                }\n-                LogPrintf(\"natpmp: Port mapping successful. External address = %s\\n\", external.ToStringAddrPort());\n-                return true;\n-            } else {\n-                LogPrintf(\"natpmp: Port mapping failed.\\n\");\n+            // Try to open pinholes for all routable local IPv6 addresses.\n+            for (const auto &addr: GetLocalAddresses()) {\n+                if (!addr.IsRoutable() || !addr.IsIPv6()) continue;\n+                auto res = PCPRequestPortMap(pcp_nonce, *gateway6, addr, private_port, requested_lifetime);\n+                handle_mapping(res);\n             }\n-        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n-            LogPrintf(\"natpmp: The gateway does not support NAT-PMP.\\n\");\n-        } else {\n-            LogPrintf(\"natpmp: readnatpmpresponseorretry() for port mapping failed with %d error.\\n\", r_read);\n         }\n-    } else {\n-        LogPrintf(\"natpmp: sendnewportmappingrequest() failed with %d error.\\n\", r_send);\n-    }\n-\n-    return false;\n-}\n \n-static bool ProcessNatpmp()\n-{\n-    bool ret = false;\n-    natpmp_t natpmp;\n-    struct in_addr external_ipv4_addr;\n-    if (NatpmpInit(&natpmp) && NatpmpDiscover(&natpmp, external_ipv4_addr)) {\n-        bool external_ip_discovered = false;\n-        const uint16_t private_port = GetListenPort();\n-        do {\n-            ret = NatpmpMapping(&natpmp, external_ipv4_addr, private_port, external_ip_discovered);\n-        } while (ret && g_mapport_interrupt.sleep_for(PORT_MAPPING_REANNOUNCE_PERIOD));\n-        g_mapport_interrupt.reset();\n+        // Log message if we got NO_RESOURCES.\n+        if (no_resources) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"portmap: At least one mapping failed because of a NO_RESOURCES error. This usually indicates that the port is already used on the router. If this is the only instance of bitcoin running on the network, this will resolve itself automatically. Otherwise, you might want to choose a different P2P port to prevent this conflict.\\n\");\n+        }\n \n-        const int r_send = sendnewportmappingrequest(&natpmp, NATPMP_PROTOCOL_TCP, private_port, g_mapport_external_port, /* remove a port mapping */ 0);\n-        g_mapport_external_port = 0;\n-        if (r_send == 12 /* OK */) {\n-            LogPrintf(\"natpmp: Port mapping removed successfully.\\n\");\n-        } else {\n-            LogPrintf(\"natpmp: sendnewportmappingrequest(0) failed with %d error.\\n\", r_send);\n+        // Sanity-check returned lifetime.\n+        if (actual_lifetime < 30) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"portmap: Got impossibly short mapping lifetime of %d seconds\\n\", actual_lifetime);\n+            return false;\n         }\n-    }\n+        // RFC6887 11.2.1 recommends that clients send their first renewal packet at a time chosen with uniform random\n+        // distribution in the range 1/2 to 5/8 of expiration time.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1613785831",
      "id" : 1613785831,
      "in_reply_to_id" : 1613266348,
      "line" : 124,
      "node_id" : "PRRC_kwDOABII585gMGrn",
      "original_commit_id" : "9a265c6d75136991125730b8a6a901e95cfeb8f6",
      "original_line" : 124,
      "original_position" : 190,
      "original_start_line" : null,
      "path" : "src/mapport.cpp",
      "position" : 190,
      "pull_request_review_id" : 2077455116,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785831/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T17:08:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785831",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "1cbbcba42cf1c050022a73cb02b9d385fa184f2e: squashed all fixups to clean up the list of commits, no other changes",
      "created_at" : "2024-05-24T17:13:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2130021361",
      "id" : 2130021361,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585-9Yvx",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2130021361/reactions"
      },
      "updated_at" : "2024-05-24T17:13:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2130021361",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1613903504"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613903504"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The chrono timepoint/duration stuff kind of confuses me. Would this be the idea? (assuming `timeout` is  per retry). `sock.Wait` takes milliseconds while the steady clock returns microseconds, so the cast seems unavoidable.\r\n```diff\r\n         }\r\n \r\n         // Wait for response(s) until we get a valid response, a network error, or time out.\r\n-        while (true) {\r\n+        auto cur_time = std::chrono::time_point_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now());\r\n+        auto deadline = cur_time + timeout;\r\n+        while ((cur_time = std::chrono::time_point_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now())) < deadline) {\r\n             Sock::Event occurred = 0;\r\n-            if (!sock.Wait(std::chrono::milliseconds(1000), Sock::RECV, &occurred)) {\r\n+            if (!sock.Wait(deadline - cur_time, Sock::RECV, &occurred)) {\r\n                 LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not wait on socket: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\r\n                 return std::nullopt; // Network-level error, probably no use retrying.\r\n             }\r\n```",
      "commit_id" : "1cbbcba42cf1c050022a73cb02b9d385fa184f2e",
      "created_at" : "2024-05-24T19:07:02Z",
      "diff_hunk" : "@@ -0,0 +1,517 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RPC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RPC6886 3.5). Result codes <=2 match PCP.\n+static const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RPC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RPC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RPC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RPC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RPC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RPC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RPC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RPC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RPC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RPC6887 7.4). Result codes <=2 match NAT-PMP.\n+static const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+static std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+static std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RPC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] static bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RPC6887.\n+static CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+static std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::function<bool(const Span<const uint8_t>)> check_packet)\n+{\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+            return std::nullopt; // Network-level error, probably no use retrying.\n+        }\n+\n+        // Wait for response(s) until we get a valid response, a network error, or time out.\n+        while (true) {\n+            Sock::Event occurred = 0;\n+            if (!sock.Wait(std::chrono::milliseconds(1000), Sock::RECV, &occurred)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not wait on socket: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            if (!occurred) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Timeout\\n\", protocol);\n+                break; // Retry.\n+            }\n+\n+            // Receive response.\n+            recvsz = sock.Recv(response, sizeof(response), MSG_DONTWAIT);\n+            if (recvsz < 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not receive response: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Received response of %d bytes: %s\\n\", protocol, recvsz, HexStr(Span(response, recvsz)));\n+\n+            if (check_packet(Span<uint8_t>(response, recvsz))) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1613903504",
      "id" : 1613903504,
      "in_reply_to_id" : 1613380035,
      "line" : 252,
      "node_id" : "PRRC_kwDOABII585gMjaQ",
      "original_commit_id" : "9a265c6d75136991125730b8a6a901e95cfeb8f6",
      "original_line" : 252,
      "original_position" : 252,
      "original_start_line" : null,
      "path" : "src/util/pcp.cpp",
      "position" : 252,
      "pull_request_review_id" : 2077658541,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613903504/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T19:33:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613903504",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> The first two commits of https://github.com/bitcoin/bitcoin/pull/26812 would make it possible to test and fuzz how this code interacts with a router.\r\n\r\nSo ive been thinking about this, do we have a mockable way to do `std::optional<Sock> socket(int domain, int type, int protocol)`? i was thinking of passing in a `SocketFactory` (please don't kill me, this could be just a functor ð ). It's slightly nicer than passing in a pre-made `Sock` because it allows testing the \"create a socket of the right family\" logic.\r\n(also ping @vasild)",
      "created_at" : "2024-05-25T07:47:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2131092539",
      "id" : 2131092539,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585_BeQ7",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2131092539/reactions"
      },
      "updated_at" : "2024-05-25T07:50:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2131092539",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1615586509"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1615586509"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I guess this could work if `timeout` isn't too long. Since if the router doens't support NAT-PMP / PCP it's not going to reply, it delays when we fall back to UPNP. But a few seconds seems fine.",
      "commit_id" : "97ae5d4eefe4a1f17c0742407875661c17654296",
      "created_at" : "2024-05-27T07:20:04Z",
      "diff_hunk" : "@@ -0,0 +1,517 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RPC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RPC6886 3.5). Result codes <=2 match PCP.\n+static const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RPC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RPC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RPC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RPC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RPC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RPC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RPC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RPC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RPC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RPC6887 7.4). Result codes <=2 match NAT-PMP.\n+static const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+static std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+static std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RPC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] static bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RPC6887.\n+static CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+static std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::function<bool(const Span<const uint8_t>)> check_packet)\n+{\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+            return std::nullopt; // Network-level error, probably no use retrying.\n+        }\n+\n+        // Wait for response(s) until we get a valid response, a network error, or time out.\n+        while (true) {\n+            Sock::Event occurred = 0;\n+            if (!sock.Wait(std::chrono::milliseconds(1000), Sock::RECV, &occurred)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not wait on socket: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            if (!occurred) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Timeout\\n\", protocol);\n+                break; // Retry.\n+            }\n+\n+            // Receive response.\n+            recvsz = sock.Recv(response, sizeof(response), MSG_DONTWAIT);\n+            if (recvsz < 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not receive response: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Received response of %d bytes: %s\\n\", protocol, recvsz, HexStr(Span(response, recvsz)));\n+\n+            if (check_packet(Span<uint8_t>(response, recvsz))) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1615586509",
      "id" : 1615586509,
      "in_reply_to_id" : 1613380035,
      "line" : 255,
      "node_id" : "PRRC_kwDOABII585gS-TN",
      "original_commit_id" : "9a265c6d75136991125730b8a6a901e95cfeb8f6",
      "original_line" : 252,
      "original_position" : 252,
      "original_start_line" : null,
      "path" : "src/util/pcp.cpp",
      "position" : 255,
      "pull_request_review_id" : 2080168933,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1615586509/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-27T07:20:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1615586509",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1615628209"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1615628209"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The timeout is still one second per try (so three seconds in total maximum, given current retries), it's just not possible to extend it indefinitely anymore by sending rejected packets.",
      "commit_id" : "97ae5d4eefe4a1f17c0742407875661c17654296",
      "created_at" : "2024-05-27T07:52:58Z",
      "diff_hunk" : "@@ -0,0 +1,517 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RPC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RPC6886 3.5). Result codes <=2 match PCP.\n+static const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RPC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RPC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RPC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RPC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RPC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RPC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RPC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RPC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RPC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RPC6887 7.4). Result codes <=2 match NAT-PMP.\n+static const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+static std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+static std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RPC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] static bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RPC6887.\n+static CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+static std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::function<bool(const Span<const uint8_t>)> check_packet)\n+{\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+            return std::nullopt; // Network-level error, probably no use retrying.\n+        }\n+\n+        // Wait for response(s) until we get a valid response, a network error, or time out.\n+        while (true) {\n+            Sock::Event occurred = 0;\n+            if (!sock.Wait(std::chrono::milliseconds(1000), Sock::RECV, &occurred)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not wait on socket: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            if (!occurred) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Timeout\\n\", protocol);\n+                break; // Retry.\n+            }\n+\n+            // Receive response.\n+            recvsz = sock.Recv(response, sizeof(response), MSG_DONTWAIT);\n+            if (recvsz < 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not receive response: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Received response of %d bytes: %s\\n\", protocol, recvsz, HexStr(Span(response, recvsz)));\n+\n+            if (check_packet(Span<uint8_t>(response, recvsz))) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1615628209",
      "id" : 1615628209,
      "in_reply_to_id" : 1613380035,
      "line" : 255,
      "node_id" : "PRRC_kwDOABII585gTIex",
      "original_commit_id" : "9a265c6d75136991125730b8a6a901e95cfeb8f6",
      "original_line" : 252,
      "original_position" : 252,
      "original_start_line" : null,
      "path" : "src/util/pcp.cpp",
      "position" : 255,
      "pull_request_review_id" : 2080239658,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1615628209/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-27T07:52:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1615628209",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Do you know what's the minimum FreeBSD version it can be compiled on? Let's bump the version bound to that.\r\n\r\nJust tried on 14.0 with its default clang 16 and I get the same error. So we should either find a workaround or disable FreeBSD for this feature and a TODO comment. I don't know how popular this is as a desktop distro?",
      "created_at" : "2024-05-27T08:33:20Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2132952090",
      "id" : 2132952090,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585_IkQa",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2132952090/reactions"
      },
      "updated_at" : "2024-05-27T08:33:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2132952090",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1615728471"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1615728471"
         }
      },
      "author_association" : "MEMBER",
      "body" : "bfde83050ece1f617efdb4098b5efeeb1a08b65e nit: `UPnP, PCP or NAT-PMP`",
      "commit_id" : "97ae5d4eefe4a1f17c0742407875661c17654296",
      "created_at" : "2024-05-27T08:54:29Z",
      "diff_hunk" : "@@ -148,7 +148,7 @@ enum\n     LOCAL_NONE,   // unknown\n     LOCAL_IF,     // address a local interface listens on\n     LOCAL_BIND,   // address explicit bound to\n-    LOCAL_MAPPED, // address reported by UPnP or NAT-PMP\n+    LOCAL_MAPPED, // address reported by UPnP or PCP",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1615728471",
      "id" : 1615728471,
      "line" : 151,
      "node_id" : "PRRC_kwDOABII585gTg9X",
      "original_commit_id" : "bfde83050ece1f617efdb4098b5efeeb1a08b65e",
      "original_line" : 151,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 5,
      "pull_request_review_id" : 2080398804,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1615728471/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-27T10:14:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1615728471",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Just tried on 14.0 with its default clang 16 and I get the same error. So we should either find a workaround or disable FreeBSD for this feature and a TODO comment. I don't know how popular this is as a desktop distro?\r\n\r\ni would feel bad disabling FreeBSD support after @vasild contributed the code for that, but if this gets close to merge and FreeBSD is still broken i'll remove it (added a TODO).\r\ni expect `#define typeof __typeof__` would go a long way to work around this error.",
      "created_at" : "2024-05-27T09:00:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2133003388",
      "id" : 2133003388,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585_Iwx8",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133003388/reactions"
      },
      "updated_at" : "2024-05-27T09:17:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133003388",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1615868425"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1615868425"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Sure, ok, really i'm just considering NAT-PMP to be PCPv0.",
      "commit_id" : "97ae5d4eefe4a1f17c0742407875661c17654296",
      "created_at" : "2024-05-27T10:41:36Z",
      "diff_hunk" : "@@ -148,7 +148,7 @@ enum\n     LOCAL_NONE,   // unknown\n     LOCAL_IF,     // address a local interface listens on\n     LOCAL_BIND,   // address explicit bound to\n-    LOCAL_MAPPED, // address reported by UPnP or NAT-PMP\n+    LOCAL_MAPPED, // address reported by UPnP or PCP",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1615868425",
      "id" : 1615868425,
      "in_reply_to_id" : 1615728471,
      "line" : 151,
      "node_id" : "PRRC_kwDOABII585gUDIJ",
      "original_commit_id" : "bfde83050ece1f617efdb4098b5efeeb1a08b65e",
      "original_line" : 151,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 5,
      "pull_request_review_id" : 2080624352,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1615868425/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-27T10:41:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1615868425",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> I noticed that the renewal for IPv6 fails (at least on Ubuntu and macOS) with NO_RESOURCES. IPv4 renewal works fine. Ten minutes later it tries again and the mapping succeeds.\r\n\r\nIs this after re-launching bitcoind? Mind that restarting will roll a new mapping nonce, which means that from the point of your router it's a new application trying to get the port, which will prevent it from making the mapping until the old mapping expires. But that should go away after one cycle and not happen again the next one, as the nonce is stored and reused for renewals (as is specified in the RFC).\r\n\r\ni doubt this has anything to do with specifiic intervals. If renewal is avoided while there is already a mapping *at all* then there will be holes in reachability, which is worse than some spurious errors.\r\n\r\n> Windows decided to quarantine bitocin-qt.exe (built with guix). I haven't seen that before in earlier tests, so I wonder if it's related to this change.\r\n\r\nPossible, but that would be strange, given that we're not communicating to any different ports than before. Were you building with libnatpmp before? (oh, a guix build, yes it will have libnatpmp enabled).\r\nThings like this make me so close to just closing this PR in frustration tbh.\r\n",
      "created_at" : "2024-05-27T10:45:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2133203743",
      "id" : 2133203743,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585_Jhsf",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133203743/reactions"
      },
      "updated_at" : "2024-05-27T10:48:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133203743",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Is this after re-launching bitcoind? \r\n\r\nNo, I hadn't run the node in a while. At startup it opens the port, only renewal fails. Leaving the node running, this seems to happen half the time, as you would expect: port is opened, renewal fails, mapping expires, so opening succeeds again, renewal fails, etc.\r\n\r\n> Were you building with libnatpmp before? \r\n\r\nNo, I had that disabled in the past. I'll see if I can trigger it again with more detailed logs. But you're right, it might be an existing issue.\r\n\r\n---\r\n\r\nI downloaded v27.0 and tried it on Windows, but NAT-PMP doesn't work at all there (`natpmp: Port mapping failed`). It tried turning the windows firewall off but that made no difference. It does on macOS (`[mapport] natpmp: Port mapping successful. External address = ...`).",
      "created_at" : "2024-05-27T10:50:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2133212294",
      "id" : 2133212294,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585_JjyG",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133212294/reactions"
      },
      "updated_at" : "2024-05-27T11:06:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133212294",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> No, I hadn't run the node in a while. At startup it opens the port, only renewal fails. Leaving the node running, this seems to happen half the time, as you would expect: port is opened, renewal fails, mapping expires, so opening succeeds again, renewal fails, etc.\r\n\r\nThis is the opposite from what's expected.\r\n\r\n- But it only happens for IPv6, not IPv4. i wonder if that's because IPv4 is the first mapping created? Maybe it doesn't like the same nonce being used for multiple different mappings existing at the same time?\r\nMaybe try putting the IPv6 block first and see if it reverses the issue? Or at least makes it succeed for the first IPv6 address.\r\n\r\n- Alternatively, maybe try generating a new nonce every call to `PCPRequestPortMap`. This violates the protocol but ... if it's implemented wrongly on the server this may trigger it to generate a fresh mapping. i dunno...\r\n",
      "created_at" : "2024-05-27T11:02:08Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2133233029",
      "id" : 2133233029,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585_Jo2F",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133233029/reactions"
      },
      "updated_at" : "2024-05-27T11:02:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133233029",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "On macOS I recompiled with `PORT_MAPPING_REANNOUNCE_PERIOD` set to 5 minutes and IPv4 commented out. At startup it adds three mappings. After a few minutes at renewal it complains with `NO_RESOURCES`",
      "created_at" : "2024-05-27T11:17:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2133257542",
      "id" : 2133257542,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585_Ju1G",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133257542/reactions"
      },
      "updated_at" : "2024-05-27T11:24:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133257542",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> After a few minutes at renewal it complains with NO_RESOURCES.\r\n\r\nDoes it complain for all three mappings?",
      "created_at" : "2024-05-27T11:21:35Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2133264508",
      "id" : 2133264508,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585_Jwh8",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133264508/reactions"
      },
      "updated_at" : "2024-05-27T11:21:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133264508",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Yes, for all three.\r\n\r\nI then recompiled and set the renewal interval at 6/8 - 7/8. Started the node again (using a fresh port). Same pattern: three mappings succeeed, at renewal all three complain about NO_RESOURCES. (And then a few minutes later they succesfully get a mapping again).",
      "created_at" : "2024-05-27T11:25:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2133270608",
      "id" : 2133270608,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585_JyBQ",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133270608/reactions"
      },
      "updated_at" : "2024-05-27T11:25:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133270608",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Actually this might be an existing bug: https://github.com/miniupnp/miniupnp/commit/7bd0877b8fd9a1c1c59cdf426b4640b3cee2bf61\r\n\r\nI'll see if I can convince OPNsense to ship >= 2.3.6, tracking at https://github.com/opnsense/plugins/issues/4003.",
      "created_at" : "2024-05-27T11:30:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2133279400",
      "id" : 2133279400,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585_J0Ko",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133279400/reactions"
      },
      "updated_at" : "2024-05-27T11:48:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133279400",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "That does look like an issue that would affect renewal, but i'm not sure it would cause this specific issue, if i understand correctly it'd bump the renewal timestamp so far it would live forever. It wouln't make it complain about the port being used. Unless it's an old mapping that sticks around. But that wouldn'e explain why it only happens on renewal.",
      "created_at" : "2024-05-27T11:48:20Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2133309242",
      "id" : 2133309242,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585_J7c6",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133309242/reactions"
      },
      "updated_at" : "2024-05-28T14:58:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133309242",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> generating a new nonce every time for every mapping\r\n\r\nThat doesn't seem like a good idea. IIUC the nonce is used to recognise the requesting application, and to distinguish a renew request from some other app trying to use the same port.",
      "created_at" : "2024-05-27T12:06:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2133341499",
      "id" : 2133341499,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585_KDU7",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133341499/reactions"
      },
      "updated_at" : "2024-05-27T12:06:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133341499",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> That doesn't seem like a good idea. IIUC the nonce is used to recognise the requesting application, and to distinguish a renew request from some other app trying to use the same port.\r\n\r\nIt's not supposed to be a good idea, but i wonder if it works around the issue with your router, if they implemented the protocol wrongly. i honestly have no idea what could be the problem here i'm just guessing.",
      "created_at" : "2024-05-27T12:10:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2133347999",
      "id" : 2133347999,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585_KE6f",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133347999/reactions"
      },
      "updated_at" : "2024-05-27T12:10:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133347999",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I thought perhaps the issue was that miniupnpd checks whether at least half the lease time went by and would refuse if not. So then if the lease time was too far in the future, it wouldn't allow renewal.\r\n\r\nBut looking through the source code it doesn't appear to care about that. There's a few places that can trigger a `PCP_ERR_NO_RESOURCES` reply, but so far those don't offer an obvious explanation.\r\n\r\n---\r\n\r\nThe pinhole code is mostly seperate from port mappings. Depending on `pcp_msg_info->is_fw` it will call `CreatePCPMap_FW` for an IPv6 pinhole. My guess is this function doesn't recognise the renewal attempt as such, treats it as a new request and then fails. I need to figure out how to read the router log messages.\r\n\r\n---\r\n\r\nFigured out how to get verbose logging (https://github.com/opnsense/plugins/issues/4004).\r\n\r\nIt does log `updating pinhole to` before the failure, so it _does_ find the existing route and knows that it should update. The line after that log statement calls `upnp_update_inboundpinhole` and interprets any failure as `PCP_ERR_NO_RESOURCES`. There's only two ways that can fail:\r\n\r\n1. If `#if defined(USE_PF) || defined(USE_NETFILTER)` is false, because it'll return `-42; /* not implemented */`. But `upnp_find_inboundpinhole` has the same guard, so that can't be it.\r\n\r\n2. If `update_pinhole` fails, which can only fail if `get_pinhole` fails. That implies that the `uid` returned by `find_pinhole` is wrong.\r\n \r\nI'm probably still missing something... I should test if deleting an IPv6 pinhole does work.\r\n\r\n---\r\n\r\nDeleting a pinhole succeeds. The log message is wrong (`PCP: UDP port 8 mapping removed`), which is an unrelated bug https://github.com/miniupnp/miniupnp/issues/743.\r\n\r\nI also tried opening only a single pinhole, to rule out some race condition. But that doesn't make a difference.\r\n\r\n---\r\n\r\nAnyway, I'm fairly sure it's not a bug in this PR.",
      "created_at" : "2024-05-27T12:29:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2133381489",
      "id" : 2133381489,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585_KNFx",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133381489/reactions"
      },
      "updated_at" : "2024-05-27T16:54:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133381489",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1615998227"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1615998227"
         }
      },
      "author_association" : "MEMBER",
      "body" : "RPC -> RFC (in a few other places too)",
      "commit_id" : "8878b3e7907899e3d054549392e66896f08e9b87",
      "created_at" : "2024-05-27T12:38:16Z",
      "diff_hunk" : "@@ -0,0 +1,520 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RPC6887 section 1.1).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1615998227",
      "id" : 1615998227,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gUi0T",
      "original_commit_id" : "97ae5d4eefe4a1f17c0742407875661c17654296",
      "original_line" : 22,
      "original_position" : 22,
      "original_start_line" : null,
      "path" : "src/util/pcp.cpp",
      "position" : null,
      "pull_request_review_id" : 2080835616,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 1,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1615998227/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-27T12:38:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1615998227",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Thanks for investigating in detail.\r\nFWIW, i'm not seeing that problem on TurrisOS (openwrt) with miniupnpd 2.3.3. Renewals work fine, both with 20 minute and 5 minute reannounce period. Both for IPv4 and IPv6. So it's either something that was solved in the meantime, or something different in your networking situation.",
      "created_at" : "2024-05-28T12:40:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2135121750",
      "id" : 2135121750,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585_Q19W",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2135121750/reactions"
      },
      "updated_at" : "2024-05-28T12:42:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2135121750",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Both our setups are at miniupnpd 2.3.3; the plugin description incorrectly says 2.3.1: https://github.com/opnsense/plugins/issues/4003#issuecomment-2133421334\r\n\r\nSo perhaps there's a difference in how miniupnpd controls the router / firewall itself, which causes the renewal to fail on my end. This is above my pay grade...",
      "created_at" : "2024-05-28T13:17:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2135196336",
      "id" : 2135196336,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585_RIKw",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2135196336/reactions"
      },
      "updated_at" : "2024-05-28T13:17:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2135196336",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "i've been trying to build the package myself, and there's miniupnpd-nftables and miniupnpd-iptables, do you know which one you have? i see i have -iptables installed at the moment, it appears.\r\n\r\nEdit: i installed the -nftables variant and rebooted, and it's giving me `NO_RESOURCES` even on first rquest, for IPv4 and IPv6! Restored the -iptables variant and it worked again. No idea if it's the same issue of course. May just be a kernel issue.",
      "created_at" : "2024-05-28T13:27:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2135219680",
      "id" : 2135219680,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585_RN3g",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2135219680/reactions"
      },
      "updated_at" : "2024-05-28T13:58:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2135219680",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "No idea. [OPNsense](https://opnsense.org/about/about-opnsense/) is built on FreeBSD and I think the plugin just relies on whatever miniupnpd comes with the OS:\r\n\r\n```\r\n# pkg info miniupnpd\r\nminiupnpd-2.3.3_3,1\r\nName           : miniupnpd\r\nVersion        : 2.3.3_3,1\r\nInstalled on   : Thu May  2 10:44:17 2024 CEST\r\nOrigin         : net/miniupnpd\r\nArchitecture   : FreeBSD:13:amd64\r\nPrefix         : /usr/local\r\nCategories     : net\r\nLicenses       : BSD3CLAUSE\r\nMaintainer     : squat@squat.no\r\nWWW            : http://miniupnp.free.fr/\r\nComment        : UPnP IGD implementation which uses pf\r\nOptions        :\r\n\tCHECK_PORTINUSE: on\r\n\tIPV6           : on\r\n\tLEASEFILE      : off\r\n\tUPNP_IGDV2     : off\r\n\tUPNP_STRICT    : off\r\nShared Libs required:\r\n\tlibssl.so.12\r\n\tlibpfctl.so.0\r\n\tlibcrypto.so.12\r\nAnnotations    :\r\n\tFreeBSD_version: 1302001\r\n\tcpe            : cpe:2.3:a:miniupnp_project:miniupnpd:2.3.3:::::freebsd13:x64:3\r\n\trepo_type      : binary\r\n\trepository     : OPNsense\r\nFlat size      : 160KiB\r\nDescription    :\r\nMini UPnPd is a lightweight implementation of a UPnP IGD daemon. This is\r\nsupposed to be run on your gateway machine to allow client systems to redirect\r\nports and punch holes in the firewall.\r\n```\r\n\r\n---\r\n\r\nI installed 2.3.6 from source and got the same `NO_RESOURCES` error upon IPv6 pinhole renewal. Tried 5fcf0c281fd4e3fa3f32114824c1dee8f78cca03 for good measure. Ditto fail.",
      "created_at" : "2024-05-28T14:41:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2135407342",
      "id" : 2135407342,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
      "node_id" : "IC_kwDOABII585_R7ru",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2135407342/reactions"
      },
      "updated_at" : "2024-05-28T15:34:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2135407342",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   }
]
