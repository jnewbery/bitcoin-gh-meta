[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage\nFor detailed information about the code coverage, see the [test coverage report](https://corecheck.dev/bitcoin/bitcoin/pulls/30005).\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| Concept NACK | [fanquake](https://github.com/bitcoin/bitcoin/pull/30005#issuecomment-2090550845) |\n| Concept ACK | [Sjors](https://github.com/bitcoin/bitcoin/pull/30005#pullrequestreview-2035221223) |\n\nIf your review is incorrectly listed, please react with ð to this comment and the bot will ignore it on the next update.\n",
      "created_at" : "2024-04-30T11:35:30Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30005#issuecomment-2085061946",
      "id" : 2085061946,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30005",
      "node_id" : "IC_kwDOABII5858R4U6",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2085061946/reactions"
      },
      "updated_at" : "2024-05-02T13:49:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2085061946",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Tried with a router running OPNsense:\r\n\r\n```\r\n2024-04-30T12:16:13Z [net:debug] pcp6: gateway: ...\r\n2024-04-30T12:16:13Z [net:warning] pcp6: Opening pinhole for addr: ...\r\n2024-04-30T12:16:14Z [net:debug] pcp6: Timeout\r\n2024-04-30T12:16:14Z [net:debug] pcp6: Retrying (1)\r\n2024-04-30T12:16:15Z [net:debug] pcp6: Timeout\r\n2024-04-30T12:16:15Z [net:debug] pcp6: Retrying (2)\r\n2024-04-30T12:16:16Z [net:debug] pcp6: Timeout\r\n2024-04-30T12:16:16Z [net:debug] pcp6: Giving up after 3 tries\r\n2024-04-30T12:16:16Z [net:warning] pcp6: Opening pinhole for addr: ...\r\n2024-04-30T12:16:17Z [net:debug] pcp6: Timeout\r\n2024-04-30T12:16:17Z [net:debug] pcp6: Retrying (1)\r\n2024-04-30T12:16:18Z [net:debug] pcp6: Timeout\r\n2024-04-30T12:16:18Z [net:debug] pcp6: Retrying (2)\r\n2024-04-30T12:16:19Z [net:debug] pcp6: Timeout\r\n2024-04-30T12:16:19Z [net:debug] pcp6: Giving up after 3 tries\r\n2024-04-30T12:16:19Z [net:warning] pcp6: Opening pinhole for addr: ...\r\n2024-04-30T12:16:20Z [net:debug] pcp6: Timeout\r\n2024-04-30T12:16:20Z [net:debug] pcp6: Retrying (1)\r\n2024-04-30T12:16:21Z [net:debug] pcp6: Timeout\r\n2024-04-30T12:16:21Z [net:debug] pcp6: Retrying (2)\r\n2024-04-30T12:16:22Z [net:debug] pcp6: Timeout\r\n2024-04-30T12:16:22Z [net:debug] pcp6: Giving up after 3 tries\r\n```\r\n\r\nI probably have to actively turn on some permission.",
      "created_at" : "2024-04-30T12:18:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30005#issuecomment-2085177069",
      "id" : 2085177069,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30005",
      "node_id" : "IC_kwDOABII5858SUbt",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2085177069/reactions"
      },
      "updated_at" : "2024-04-30T12:18:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2085177069",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "It may be some router setting to enable it, the more secure routers have these kind of protocols disabled by default. Or maybe it doesn't support it. There isn't any reply, not even 2  NOT_AUTHORIZED (but nice to see the retry code is working ð ).",
      "created_at" : "2024-04-30T12:23:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30005#issuecomment-2085190180",
      "id" : 2085190180,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30005",
      "node_id" : "IC_kwDOABII5858SXok",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2085190180/reactions"
      },
      "updated_at" : "2024-04-30T12:56:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2085190180",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Unfortunately I'm not able to find any documentation for this.\r\n\r\nThere is a UPnP plugin, but that's not what you're using (and probably best left uninstalled).\r\n\r\nAnyway, people who run OPNsense will now how to manually forward a port, so that's not really the target demographic here.",
      "created_at" : "2024-04-30T13:10:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30005#issuecomment-2085298601",
      "id" : 2085298601,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30005",
      "node_id" : "IC_kwDOABII5858SyGp",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2085298601/reactions"
      },
      "updated_at" : "2024-04-30T13:10:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2085298601",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : ">There is a UPnP plugin, but that's not what you're using (and probably best left uninstalled).\r\n\r\nYea, according to [this list](https://github.com/opnsense/plugins/tree/master), UPnP and PCP is the same plugin. It could be that they can be turned on and off seperately in the plugin configuration (it's similar for OpenWRT). The most well-known open source implementation of a PCP server is... ironically, [miniupnpd](https://github.com/miniupnp/miniupnp/blob/master/miniupnpd/pcpserver.c).",
      "created_at" : "2024-04-30T19:02:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30005#issuecomment-2086638251",
      "id" : 2086638251,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30005",
      "node_id" : "IC_kwDOABII5858X5Kr",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2086638251/reactions"
      },
      "updated_at" : "2024-04-30T20:48:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2086638251",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Ah, that's confusing. The OPNsense is indeed just [MiniUPnPd](https://miniupnp.tuxfamily.org/) and described as \"Universal Plug and Play (UPnP IGD & PCP/NAT-PMP) Service\", in other words: all the things :-)\r\n\r\nIt lets you choose what to enable, in this case I selected \"PCP/NAT-PMP Port Mapping\".\r\n\r\nNow your utility is happy.\r\n\r\nOn Ubuntu I additionally had to do `sudo ufw allow 1234` though for the nc connection to succeed (ufw is disabled by default on new systems).\r\n\r\nI tested that the machine was indeed reachable from the outside world (and that it no longer is after 120 seconds, existing connections are preserved).",
      "created_at" : "2024-05-02T08:53:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30005#issuecomment-2089935185",
      "id" : 2089935185,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30005",
      "node_id" : "IC_kwDOABII5858keFR",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2089935185/reactions"
      },
      "updated_at" : "2024-05-02T09:09:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2089935185",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587310888"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30005"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587310888"
         }
      },
      "author_association" : "MEMBER",
      "body" : "You could make this a permanent debugging utility by adding it to `bitcoin-util`.",
      "commit_id" : "4395a42c5df14e211ca78405f599a2ed24466334",
      "created_at" : "2024-05-02T09:08:05Z",
      "diff_hunk" : "@@ -801,6 +801,15 @@ bitcoind_CXXFLAGS = $(bitcoin_bin_cxxflags)\n bitcoind_LDFLAGS = $(bitcoin_bin_ldflags)\n bitcoind_LDADD = $(LIBBITCOIN_NODE) $(bitcoin_bin_ldadd)\n \n+#################################################################\n+bin_PROGRAMS += ipv6-pinhole-test",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587310888",
      "id" : 1587310888,
      "line" : 805,
      "node_id" : "PRRC_kwDOABII585enHEo",
      "original_commit_id" : "fb499f555e0c559fb595fbc7b375aa632d8635ed",
      "original_line" : 805,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/Makefile.am",
      "position" : 5,
      "pull_request_review_id" : 2035221223,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30005",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587310888/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-02T12:45:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587310888",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587412293"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30005"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587412293"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Did you mean `pcp6: Could not connect to gateway`?",
      "commit_id" : "4395a42c5df14e211ca78405f599a2ed24466334",
      "created_at" : "2024-05-02T10:35:41Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+#include <util/translation.h> // Remove this\n+\n+#include <linux/route.h>\n+\n+const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr; // Remove this\n+\n+// RFC 6887 Port Control Protocol (PCP) implementation.\n+// PCP uses network byte order (big-endian).\n+// References to sections and figures in the code below refer to https://datatracker.ietf.org/doc/html/rfc6887.\n+\n+// Protocol constants.\n+//! Maximum packet size in bytes (see section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (see section 19.1).\n+constexpr uint16_t PCP_SERVER_PORT = 5351;\n+//! Version byte. 0 is NAT-PMP, 1 is forbidden, 2 for PCP RFC-6887.\n+constexpr uint8_t PCP_VERSION = 2;\n+//! Map request opcode. See sections 19.2, 7.1.\n+constexpr uint8_t PCP_OP_MAP_REQUEST = 0x01;\n+//! Map response opcode. See sections 19.2, 7.2.\n+constexpr uint8_t PCP_OP_MAP_RESPONSE = 0x01 | 0x80;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Option: prefer failure to half-functional mapping. See section 13.2.\n+constexpr uint8_t PCP_OPTION_PREFER_FAILURE = 2;\n+//! Request header size in bytes (see secion 7.1).\n+constexpr size_t PCP_REQUEST_HDR_SIZE = 24;\n+//! Response header size in bytes (see secion 7.2).\n+constexpr size_t PCP_RESPONSE_HDR_SIZE = 24;\n+//! Option header size in bytes (see secion 7.2).\n+constexpr size_t PCP_OPTION_HDR_SIZE = 4;\n+//! Map request size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_REQUEST_SIZE = 36;\n+//! Map response size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_RESPONSE_SIZE = 36;\n+//! Mapping nonce size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_NONCE_SIZE = 12;\n+//! Result code representing SUCCESS status (7.4).\n+constexpr uint8_t PCP_RESULT_SUCCESS = 0;\n+\n+//! Find IPv6 default gateway.\n+std::optional<sockaddr_in6> FindIPv6DefaultGateway()\n+{\n+    const auto& [read_ok, data] = ReadBinaryFile(\"/proc/net/ipv6_route\");\n+    if (!read_ok) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not read /proc/net/ipv6_route to find default IPv6 gateway\\n\");\n+        return std::nullopt;\n+    }\n+    // 149 length (longer if interface name is longer)\n+    // destination                      prefix                                 nexthop                                                     flags     iface\n+    // 00000000000000000000000000000000 00 00000000000000000000000000000000 00 fe80000000000000da58d7fffe0077cd 00000064 00000007 00000000 00000003     eth0\n+    for(std::string &line: SplitString(data, \"\\n\")) {\n+        if (line.size() < 149) continue;\n+        const std::optional<std::vector<uint8_t>> nexthop(TryParseHex<uint8_t>(line.substr(72, 32)));\n+        const std::optional<uint8_t> prefix(ToIntegral<uint8_t>(line.substr(33,  2), ADDR_IPV6_SIZE));\n+        const std::optional<uint32_t> flags(ToIntegral<uint32_t>(line.substr(132,  8), ADDR_IPV6_SIZE));\n+        const std::string iface(TrimString(line.substr(141)));\n+        if (!prefix || !nexthop | !flags || nexthop->size() != ADDR_IPV6_SIZE || iface.empty()) continue; // Parse error\n+        if (prefix.value() != 0 || (flags.value() & (RTF_GATEWAY | RTF_UP)) != (RTF_GATEWAY | RTF_UP)) continue; // Not default gw\n+        // Look up scope id for interface name string.\n+        int gateway_scope_id = if_nametoindex(iface.c_str());\n+        if (gateway_scope_id <= 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not parse gateway interface %s\\n\", iface.c_str());\n+            return std::nullopt;\n+        }\n+\n+        sockaddr_in6 dest_addr = {};\n+        dest_addr.sin6_family = AF_INET6;\n+        memcpy(&dest_addr.sin6_addr, nexthop->data(), ADDR_IPV6_SIZE);\n+        dest_addr.sin6_scope_id = gateway_scope_id;\n+        return dest_addr;\n+    }\n+    return std::nullopt;\n+}\n+\n+//! Try to open a IPv6 pinhole port using RFC 6887 Port Control Protocol (PCP).\n+bool OpenPinhole(const sockaddr_in6 &gateway, const struct in6_addr &my_addr, uint16_t port, uint32_t lifetime, int num_tries = 3)\n+{\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Opening pinhole for addr: %s\\n\", CNetAddr(my_addr).ToStringAddr());\n+\n+    // Create IPv6 UDP socket.\n+    SOCKET sock_fd = socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);\n+    if (sock_fd == INVALID_SOCKET) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not create IPv6 UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+    Sock sock(sock_fd);\n+\n+    // Make sure that we send from requested address, anything else will be\n+    // rejected by a security-conscious router.\n+    sockaddr_in6 bind_addr = {};\n+    bind_addr.sin6_family = AF_INET6;\n+    bind_addr.sin6_addr = my_addr;\n+    if (sock.Bind((struct sockaddr*)&bind_addr, sizeof(sockaddr_in6)) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not bind to address: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    sockaddr_in6 dest_addr = gateway;\n+    dest_addr.sin6_port = htons(PCP_SERVER_PORT);\n+    if (sock.Connect((struct sockaddr*)&dest_addr, sizeof(sockaddr_in6)) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not bind to connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587412293",
      "id" : 1587412293,
      "line" : 117,
      "node_id" : "PRRC_kwDOABII585enf1F",
      "original_commit_id" : "fb499f555e0c559fb595fbc7b375aa632d8635ed",
      "original_line" : 117,
      "original_position" : 117,
      "original_start_line" : null,
      "path" : "src/ipv6-pinhole-test.cpp",
      "position" : 117,
      "pull_request_review_id" : 2035221223,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30005",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587412293/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-02T12:45:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587412293",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587415945"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30005"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587415945"
         }
      },
      "author_association" : "MEMBER",
      "body" : "See also the mockackable sockets introduced by @vasild in #26812, which - if this goes beyond just PoC - can be used to test how we handle the various failure modes. ",
      "commit_id" : "4395a42c5df14e211ca78405f599a2ed24466334",
      "created_at" : "2024-05-02T10:39:23Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+#include <util/translation.h> // Remove this\n+\n+#include <linux/route.h>\n+\n+const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr; // Remove this\n+\n+// RFC 6887 Port Control Protocol (PCP) implementation.\n+// PCP uses network byte order (big-endian).\n+// References to sections and figures in the code below refer to https://datatracker.ietf.org/doc/html/rfc6887.\n+\n+// Protocol constants.\n+//! Maximum packet size in bytes (see section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (see section 19.1).\n+constexpr uint16_t PCP_SERVER_PORT = 5351;\n+//! Version byte. 0 is NAT-PMP, 1 is forbidden, 2 for PCP RFC-6887.\n+constexpr uint8_t PCP_VERSION = 2;\n+//! Map request opcode. See sections 19.2, 7.1.\n+constexpr uint8_t PCP_OP_MAP_REQUEST = 0x01;\n+//! Map response opcode. See sections 19.2, 7.2.\n+constexpr uint8_t PCP_OP_MAP_RESPONSE = 0x01 | 0x80;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Option: prefer failure to half-functional mapping. See section 13.2.\n+constexpr uint8_t PCP_OPTION_PREFER_FAILURE = 2;\n+//! Request header size in bytes (see secion 7.1).\n+constexpr size_t PCP_REQUEST_HDR_SIZE = 24;\n+//! Response header size in bytes (see secion 7.2).\n+constexpr size_t PCP_RESPONSE_HDR_SIZE = 24;\n+//! Option header size in bytes (see secion 7.2).\n+constexpr size_t PCP_OPTION_HDR_SIZE = 4;\n+//! Map request size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_REQUEST_SIZE = 36;\n+//! Map response size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_RESPONSE_SIZE = 36;\n+//! Mapping nonce size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_NONCE_SIZE = 12;\n+//! Result code representing SUCCESS status (7.4).\n+constexpr uint8_t PCP_RESULT_SUCCESS = 0;\n+\n+//! Find IPv6 default gateway.\n+std::optional<sockaddr_in6> FindIPv6DefaultGateway()\n+{\n+    const auto& [read_ok, data] = ReadBinaryFile(\"/proc/net/ipv6_route\");\n+    if (!read_ok) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not read /proc/net/ipv6_route to find default IPv6 gateway\\n\");\n+        return std::nullopt;\n+    }\n+    // 149 length (longer if interface name is longer)\n+    // destination                      prefix                                 nexthop                                                     flags     iface\n+    // 00000000000000000000000000000000 00 00000000000000000000000000000000 00 fe80000000000000da58d7fffe0077cd 00000064 00000007 00000000 00000003     eth0\n+    for(std::string &line: SplitString(data, \"\\n\")) {\n+        if (line.size() < 149) continue;\n+        const std::optional<std::vector<uint8_t>> nexthop(TryParseHex<uint8_t>(line.substr(72, 32)));\n+        const std::optional<uint8_t> prefix(ToIntegral<uint8_t>(line.substr(33,  2), ADDR_IPV6_SIZE));\n+        const std::optional<uint32_t> flags(ToIntegral<uint32_t>(line.substr(132,  8), ADDR_IPV6_SIZE));\n+        const std::string iface(TrimString(line.substr(141)));\n+        if (!prefix || !nexthop | !flags || nexthop->size() != ADDR_IPV6_SIZE || iface.empty()) continue; // Parse error\n+        if (prefix.value() != 0 || (flags.value() & (RTF_GATEWAY | RTF_UP)) != (RTF_GATEWAY | RTF_UP)) continue; // Not default gw\n+        // Look up scope id for interface name string.\n+        int gateway_scope_id = if_nametoindex(iface.c_str());\n+        if (gateway_scope_id <= 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not parse gateway interface %s\\n\", iface.c_str());\n+            return std::nullopt;\n+        }\n+\n+        sockaddr_in6 dest_addr = {};\n+        dest_addr.sin6_family = AF_INET6;\n+        memcpy(&dest_addr.sin6_addr, nexthop->data(), ADDR_IPV6_SIZE);\n+        dest_addr.sin6_scope_id = gateway_scope_id;\n+        return dest_addr;\n+    }\n+    return std::nullopt;\n+}\n+\n+//! Try to open a IPv6 pinhole port using RFC 6887 Port Control Protocol (PCP).\n+bool OpenPinhole(const sockaddr_in6 &gateway, const struct in6_addr &my_addr, uint16_t port, uint32_t lifetime, int num_tries = 3)\n+{\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Opening pinhole for addr: %s\\n\", CNetAddr(my_addr).ToStringAddr());\n+\n+    // Create IPv6 UDP socket.\n+    SOCKET sock_fd = socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587415945",
      "id" : 1587415945,
      "line" : 97,
      "node_id" : "PRRC_kwDOABII585enguJ",
      "original_commit_id" : "fb499f555e0c559fb595fbc7b375aa632d8635ed",
      "original_line" : 97,
      "original_position" : 97,
      "original_start_line" : null,
      "path" : "src/ipv6-pinhole-test.cpp",
      "position" : 97,
      "pull_request_review_id" : 2035221223,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30005",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587415945/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-02T12:45:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587415945",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587530201"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30005"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587530201"
         }
      },
      "author_association" : "MEMBER",
      "body" : "To make it easier to understand that 0x80 refers to R, which happens to be the most significant bit of second byte of the message, and 0x01 is the actual Opcode:\r\n\r\n```h\r\n// PCP Request Header. See section 7.1\r\nconstexpr uint8_t PCP_REQUEST = 0x00; // R = 0\r\n// PCP Response Header. See section 7.2\r\nconstexpr uint8_t PCP_RESPONSE = 0x80; // R = 1\r\n//! Map opcode. See section 19.2\r\nconstexpr uint8_t PCP_OP_MAP = 0x01;\r\n//! Map request opcode.\r\nconstexpr uint8_t PCP_OP_MAP_REQUEST = PCP_REQUEST | PCP_OP_MAP;\r\n//! Map response opcode.\r\nconstexpr uint8_t PCP_OP_MAP_RESPONSE = PCP_RESPONSE | PCP_OP_MAP;\r\n```",
      "commit_id" : "4395a42c5df14e211ca78405f599a2ed24466334",
      "created_at" : "2024-05-02T12:09:49Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+#include <util/translation.h> // Remove this\n+\n+#include <linux/route.h>\n+\n+const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr; // Remove this\n+\n+// RFC 6887 Port Control Protocol (PCP) implementation.\n+// PCP uses network byte order (big-endian).\n+// References to sections and figures in the code below refer to https://datatracker.ietf.org/doc/html/rfc6887.\n+\n+// Protocol constants.\n+//! Maximum packet size in bytes (see section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (see section 19.1).\n+constexpr uint16_t PCP_SERVER_PORT = 5351;\n+//! Version byte. 0 is NAT-PMP, 1 is forbidden, 2 for PCP RFC-6887.\n+constexpr uint8_t PCP_VERSION = 2;\n+//! Map request opcode. See sections 19.2, 7.1.\n+constexpr uint8_t PCP_OP_MAP_REQUEST = 0x01;\n+//! Map response opcode. See sections 19.2, 7.2.\n+constexpr uint8_t PCP_OP_MAP_RESPONSE = 0x01 | 0x80;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587530201",
      "id" : 1587530201,
      "line" : 36,
      "node_id" : "PRRC_kwDOABII585en8nZ",
      "original_commit_id" : "fb499f555e0c559fb595fbc7b375aa632d8635ed",
      "original_line" : 36,
      "original_position" : 36,
      "original_start_line" : null,
      "path" : "src/ipv6-pinhole-test.cpp",
      "position" : 36,
      "pull_request_review_id" : 2035221223,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30005",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587530201/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-02T12:45:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587530201",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587540017"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30005"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587540017"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In a real implementation we should log the meaning of each result code, if known. Especially `UNSUPP_OPTION` and `CANNOT_PROVIDE_EXTERNAL` seems useful to know about.",
      "commit_id" : "4395a42c5df14e211ca78405f599a2ed24466334",
      "created_at" : "2024-05-02T12:18:15Z",
      "diff_hunk" : "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+#include <util/translation.h> // Remove this\n+\n+#include <linux/route.h>\n+\n+const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr; // Remove this\n+\n+// RFC 6887 Port Control Protocol (PCP) implementation.\n+// PCP uses network byte order (big-endian).\n+// References to sections and figures in the code below refer to https://datatracker.ietf.org/doc/html/rfc6887.\n+\n+// Protocol constants.\n+//! Maximum packet size in bytes (see section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (see section 19.1).\n+constexpr uint16_t PCP_SERVER_PORT = 5351;\n+//! Version byte. 0 is NAT-PMP, 1 is forbidden, 2 for PCP RFC-6887.\n+constexpr uint8_t PCP_VERSION = 2;\n+//! Map request opcode. See sections 19.2, 7.1.\n+constexpr uint8_t PCP_OP_MAP_REQUEST = 0x01;\n+//! Map response opcode. See sections 19.2, 7.2.\n+constexpr uint8_t PCP_OP_MAP_RESPONSE = 0x01 | 0x80;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Option: prefer failure to half-functional mapping. See section 13.2.\n+constexpr uint8_t PCP_OPTION_PREFER_FAILURE = 2;\n+//! Request header size in bytes (see section 7.1).\n+constexpr size_t PCP_REQUEST_HDR_SIZE = 24;\n+//! Response header size in bytes (see section 7.2).\n+constexpr size_t PCP_RESPONSE_HDR_SIZE = 24;\n+//! Option header size in bytes (see section 7.2).\n+constexpr size_t PCP_OPTION_HDR_SIZE = 4;\n+//! Map request size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_REQUEST_SIZE = 36;\n+//! Map response size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_RESPONSE_SIZE = 36;\n+//! Mapping nonce size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_NONCE_SIZE = 12;\n+//! Result code representing SUCCESS status (7.4).\n+constexpr uint8_t PCP_RESULT_SUCCESS = 0;\n+\n+//! Find IPv6 default gateway.\n+std::optional<sockaddr_in6> FindIPv6DefaultGateway()\n+{\n+    const auto& [read_ok, data] = ReadBinaryFile(\"/proc/net/ipv6_route\");\n+    if (!read_ok) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not read /proc/net/ipv6_route to find default IPv6 gateway\\n\");\n+        return std::nullopt;\n+    }\n+    // 149 length (longer if interface name is longer)\n+    // destination                      prefix                                 nexthop                                                     flags     iface\n+    // 00000000000000000000000000000000 00 00000000000000000000000000000000 00 fe80000000000000da58d7fffe0077cd 00000064 00000007 00000000 00000003     eth0\n+    for(std::string &line: SplitString(data, \"\\n\")) {\n+        if (line.size() < 149) continue;\n+        const std::optional<std::vector<uint8_t>> nexthop(TryParseHex<uint8_t>(line.substr(72, 32)));\n+        const std::optional<uint8_t> prefix(ToIntegral<uint8_t>(line.substr(33,  2), ADDR_IPV6_SIZE));\n+        const std::optional<uint32_t> flags(ToIntegral<uint32_t>(line.substr(132,  8), ADDR_IPV6_SIZE));\n+        const std::string iface(TrimString(line.substr(141)));\n+        if (!prefix || !nexthop | !flags || nexthop->size() != ADDR_IPV6_SIZE || iface.empty()) continue; // Parse error\n+        if (prefix.value() != 0 || (flags.value() & (RTF_GATEWAY | RTF_UP)) != (RTF_GATEWAY | RTF_UP)) continue; // Not default gw\n+        // Look up scope id for interface name string.\n+        int gateway_scope_id = if_nametoindex(iface.c_str());\n+        if (gateway_scope_id <= 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not parse gateway interface %s\\n\", iface.c_str());\n+            return std::nullopt;\n+        }\n+\n+        sockaddr_in6 dest_addr = {};\n+        dest_addr.sin6_family = AF_INET6;\n+        memcpy(&dest_addr.sin6_addr, nexthop->data(), ADDR_IPV6_SIZE);\n+        dest_addr.sin6_scope_id = gateway_scope_id;\n+        return dest_addr;\n+    }\n+    return std::nullopt;\n+}\n+\n+//! Try to open a IPv6 pinhole port using RFC 6887 Port Control Protocol (PCP).\n+bool OpenPinhole(const sockaddr_in6 &gateway, const struct in6_addr &my_addr, uint16_t port, uint32_t lifetime, int num_tries = 3)\n+{\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Opening pinhole for addr: %s\\n\", CNetAddr(my_addr).ToStringAddr());\n+\n+    // Create IPv6 UDP socket.\n+    SOCKET sock_fd = socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);\n+    if (sock_fd == INVALID_SOCKET) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not create IPv6 UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+    Sock sock(sock_fd);\n+\n+    // Make sure that we send from requested address, anything else will be\n+    // rejected by a security-conscious router.\n+    sockaddr_in6 bind_addr = {};\n+    bind_addr.sin6_family = AF_INET6;\n+    bind_addr.sin6_addr = my_addr;\n+    if (sock.Bind((struct sockaddr*)&bind_addr, sizeof(sockaddr_in6)) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not bind to address: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    sockaddr_in6 dest_addr = gateway;\n+    dest_addr.sin6_port = htons(PCP_SERVER_PORT);\n+    if (sock.Connect((struct sockaddr*)&dest_addr, sizeof(sockaddr_in6)) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not bind to connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    // Build request packet. Make sure the packet is zeroed so that reserved fields are zero\n+    // as required by the spec (and not potentially leak data).\n+    // Make sure there's space for the request header, MAP specific request\n+    // data, and one option header.\n+    uint8_t request[PCP_REQUEST_HDR_SIZE + PCP_MAP_REQUEST_SIZE + PCP_OPTION_HDR_SIZE] = {};\n+    // Fill in request header, See Figure 2.\n+    size_t ofs = 0;\n+    request[ofs + 0] = PCP_VERSION;\n+    request[ofs + 1] = PCP_OP_MAP_REQUEST;\n+    WriteBE32(request + ofs + 4, lifetime);\n+    memcpy(request + ofs + 8, &my_addr, ADDR_IPV6_SIZE);\n+\n+    ofs += PCP_REQUEST_HDR_SIZE;\n+\n+    // Fill in MAP request packet, See Figure 9.\n+    // Randomize mapping nonce (this is repeated in the response, to be able to\n+    // correlate requests and responses, and used to authenticate changes to the mapping).\n+    // TODO: remember this value when periodically renewing a mapping.\n+    GetRandBytes(Span(request + ofs + 0, PCP_MAP_NONCE_SIZE));\n+    request[ofs + 12] = PCP_PROTOCOL_TCP;\n+    WriteBE16(request + ofs + 16, port);\n+    WriteBE16(request + ofs + 18, port);\n+    memcpy(request + ofs + 20, &my_addr, ADDR_IPV6_SIZE);\n+\n+    ofs += PCP_MAP_REQUEST_SIZE;\n+\n+    // Fill in option header. See Figure 4.\n+    // Prefer failure to a different external address mapping than we expect.\n+    request[ofs] = PCP_OPTION_PREFER_FAILURE;\n+\n+    ofs += PCP_OPTION_HDR_SIZE;\n+\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    bool got_response = false;\n+    uint8_t response[PCP_MAX_SIZE];\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp6: Retrying (%d)\\n\", ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request, ofs, 0) != static_cast<ssize_t>(ofs)) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not send request: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+            return false; // Network-level error, probably no use retrying.\n+        }\n+\n+        // Wait for response(s) until we get a valid response, a network error, or time out.\n+        while (true) {\n+            Sock::Event occured = 0;\n+            if (!sock.Wait(std::chrono::milliseconds(1000), Sock::RECV, &occured)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not wait on socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+                return false; // Network-level error, probably no use retrying.\n+            }\n+            if (!occured) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp6: Timeout\\n\");\n+                break; // Retry.\n+            }\n+\n+            // Receive response.\n+            int recvsz = sock.Recv(response, sizeof(response), MSG_DONTWAIT);\n+            if (recvsz < 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not receive response: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+                return false; // Network-level error, probably no use retrying.\n+            }\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp6: Received response of %d bytes: %s\\n\", recvsz, HexStr(Span(response, recvsz)));\n+            if (static_cast<size_t>(recvsz) < (PCP_RESPONSE_HDR_SIZE + PCP_MAP_RESPONSE_SIZE)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Response too small\\n\");\n+                continue; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[0] != PCP_VERSION || response[1] != PCP_OP_MAP_RESPONSE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Response to wrong command\\n\");\n+                continue; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            // Handle MAP opcode response. See Figure 10.\n+            // Check that returned mapping nonce matches our request.\n+            if (memcmp(response + PCP_RESPONSE_HDR_SIZE, request + PCP_REQUEST_HDR_SIZE, PCP_MAP_NONCE_SIZE) != 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Mapping nonce mismatch\\n\");\n+                continue; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            uint8_t protocol = response[PCP_RESPONSE_HDR_SIZE + 12];\n+            uint16_t internal_port = ReadBE16(response + PCP_RESPONSE_HDR_SIZE + 16);\n+            if (protocol != PCP_PROTOCOL_TCP || internal_port != port) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Response protocol or port doesn't match request\\n\");\n+                continue; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            got_response = true; // Got expected response, break from receive loop as well as from retry loop.\n+            break;\n+        }\n+    }\n+    if (!got_response) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp6: Giving up after %d tries\\n\", num_tries);\n+        return false;\n+    }\n+    // If we get here, we got a valid MAP response to our request.\n+    // Check to see if we got the result we expected.\n+    int result_code = response[3];\n+    uint32_t lifetime_ret = ReadBE32(response + 4);\n+    uint16_t external_port = ReadBE16(response + PCP_RESPONSE_HDR_SIZE + 18);\n+    struct in6_addr external_addr;\n+    memcpy(&external_addr, response + PCP_RESPONSE_HDR_SIZE + 20, ADDR_IPV6_SIZE);\n+    if (result_code != PCP_RESULT_SUCCESS) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Mapping failed with result code %d\\n\", result_code);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587540017",
      "id" : 1587540017,
      "line" : 221,
      "node_id" : "PRRC_kwDOABII585en_Ax",
      "original_commit_id" : "4395a42c5df14e211ca78405f599a2ed24466334",
      "original_line" : 221,
      "original_position" : 221,
      "original_start_line" : null,
      "path" : "src/ipv6-pinhole-test.cpp",
      "position" : 221,
      "pull_request_review_id" : 2035221223,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30005",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587540017/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-02T12:48:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587540017",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587549683"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30005"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587549683"
         }
      },
      "author_association" : "MEMBER",
      "body" : "We should explicitly set that we want this option to be mandatory (if we do indeed care that much):\r\n\r\n> Its most significant bit indicates if this\r\n> option is mandatory (0) or optional (1) to process.",
      "commit_id" : "4395a42c5df14e211ca78405f599a2ed24466334",
      "created_at" : "2024-05-02T12:26:35Z",
      "diff_hunk" : "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+#include <util/translation.h> // Remove this\n+\n+#include <linux/route.h>\n+\n+const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr; // Remove this\n+\n+// RFC 6887 Port Control Protocol (PCP) implementation.\n+// PCP uses network byte order (big-endian).\n+// References to sections and figures in the code below refer to https://datatracker.ietf.org/doc/html/rfc6887.\n+\n+// Protocol constants.\n+//! Maximum packet size in bytes (see section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (see section 19.1).\n+constexpr uint16_t PCP_SERVER_PORT = 5351;\n+//! Version byte. 0 is NAT-PMP, 1 is forbidden, 2 for PCP RFC-6887.\n+constexpr uint8_t PCP_VERSION = 2;\n+//! Map request opcode. See sections 19.2, 7.1.\n+constexpr uint8_t PCP_OP_MAP_REQUEST = 0x01;\n+//! Map response opcode. See sections 19.2, 7.2.\n+constexpr uint8_t PCP_OP_MAP_RESPONSE = 0x01 | 0x80;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Option: prefer failure to half-functional mapping. See section 13.2.\n+constexpr uint8_t PCP_OPTION_PREFER_FAILURE = 2;\n+//! Request header size in bytes (see section 7.1).\n+constexpr size_t PCP_REQUEST_HDR_SIZE = 24;\n+//! Response header size in bytes (see section 7.2).\n+constexpr size_t PCP_RESPONSE_HDR_SIZE = 24;\n+//! Option header size in bytes (see section 7.2).\n+constexpr size_t PCP_OPTION_HDR_SIZE = 4;\n+//! Map request size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_REQUEST_SIZE = 36;\n+//! Map response size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_RESPONSE_SIZE = 36;\n+//! Mapping nonce size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_NONCE_SIZE = 12;\n+//! Result code representing SUCCESS status (7.4).\n+constexpr uint8_t PCP_RESULT_SUCCESS = 0;\n+\n+//! Find IPv6 default gateway.\n+std::optional<sockaddr_in6> FindIPv6DefaultGateway()\n+{\n+    const auto& [read_ok, data] = ReadBinaryFile(\"/proc/net/ipv6_route\");\n+    if (!read_ok) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not read /proc/net/ipv6_route to find default IPv6 gateway\\n\");\n+        return std::nullopt;\n+    }\n+    // 149 length (longer if interface name is longer)\n+    // destination                      prefix                                 nexthop                                                     flags     iface\n+    // 00000000000000000000000000000000 00 00000000000000000000000000000000 00 fe80000000000000da58d7fffe0077cd 00000064 00000007 00000000 00000003     eth0\n+    for(std::string &line: SplitString(data, \"\\n\")) {\n+        if (line.size() < 149) continue;\n+        const std::optional<std::vector<uint8_t>> nexthop(TryParseHex<uint8_t>(line.substr(72, 32)));\n+        const std::optional<uint8_t> prefix(ToIntegral<uint8_t>(line.substr(33,  2), ADDR_IPV6_SIZE));\n+        const std::optional<uint32_t> flags(ToIntegral<uint32_t>(line.substr(132,  8), ADDR_IPV6_SIZE));\n+        const std::string iface(TrimString(line.substr(141)));\n+        if (!prefix || !nexthop | !flags || nexthop->size() != ADDR_IPV6_SIZE || iface.empty()) continue; // Parse error\n+        if (prefix.value() != 0 || (flags.value() & (RTF_GATEWAY | RTF_UP)) != (RTF_GATEWAY | RTF_UP)) continue; // Not default gw\n+        // Look up scope id for interface name string.\n+        int gateway_scope_id = if_nametoindex(iface.c_str());\n+        if (gateway_scope_id <= 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not parse gateway interface %s\\n\", iface.c_str());\n+            return std::nullopt;\n+        }\n+\n+        sockaddr_in6 dest_addr = {};\n+        dest_addr.sin6_family = AF_INET6;\n+        memcpy(&dest_addr.sin6_addr, nexthop->data(), ADDR_IPV6_SIZE);\n+        dest_addr.sin6_scope_id = gateway_scope_id;\n+        return dest_addr;\n+    }\n+    return std::nullopt;\n+}\n+\n+//! Try to open a IPv6 pinhole port using RFC 6887 Port Control Protocol (PCP).\n+bool OpenPinhole(const sockaddr_in6 &gateway, const struct in6_addr &my_addr, uint16_t port, uint32_t lifetime, int num_tries = 3)\n+{\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Opening pinhole for addr: %s\\n\", CNetAddr(my_addr).ToStringAddr());\n+\n+    // Create IPv6 UDP socket.\n+    SOCKET sock_fd = socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);\n+    if (sock_fd == INVALID_SOCKET) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not create IPv6 UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+    Sock sock(sock_fd);\n+\n+    // Make sure that we send from requested address, anything else will be\n+    // rejected by a security-conscious router.\n+    sockaddr_in6 bind_addr = {};\n+    bind_addr.sin6_family = AF_INET6;\n+    bind_addr.sin6_addr = my_addr;\n+    if (sock.Bind((struct sockaddr*)&bind_addr, sizeof(sockaddr_in6)) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not bind to address: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    sockaddr_in6 dest_addr = gateway;\n+    dest_addr.sin6_port = htons(PCP_SERVER_PORT);\n+    if (sock.Connect((struct sockaddr*)&dest_addr, sizeof(sockaddr_in6)) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not bind to connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    // Build request packet. Make sure the packet is zeroed so that reserved fields are zero\n+    // as required by the spec (and not potentially leak data).\n+    // Make sure there's space for the request header, MAP specific request\n+    // data, and one option header.\n+    uint8_t request[PCP_REQUEST_HDR_SIZE + PCP_MAP_REQUEST_SIZE + PCP_OPTION_HDR_SIZE] = {};\n+    // Fill in request header, See Figure 2.\n+    size_t ofs = 0;\n+    request[ofs + 0] = PCP_VERSION;\n+    request[ofs + 1] = PCP_OP_MAP_REQUEST;\n+    WriteBE32(request + ofs + 4, lifetime);\n+    memcpy(request + ofs + 8, &my_addr, ADDR_IPV6_SIZE);\n+\n+    ofs += PCP_REQUEST_HDR_SIZE;\n+\n+    // Fill in MAP request packet, See Figure 9.\n+    // Randomize mapping nonce (this is repeated in the response, to be able to\n+    // correlate requests and responses, and used to authenticate changes to the mapping).\n+    // TODO: remember this value when periodically renewing a mapping.\n+    GetRandBytes(Span(request + ofs + 0, PCP_MAP_NONCE_SIZE));\n+    request[ofs + 12] = PCP_PROTOCOL_TCP;\n+    WriteBE16(request + ofs + 16, port);\n+    WriteBE16(request + ofs + 18, port);\n+    memcpy(request + ofs + 20, &my_addr, ADDR_IPV6_SIZE);\n+\n+    ofs += PCP_MAP_REQUEST_SIZE;\n+\n+    // Fill in option header. See Figure 4.\n+    // Prefer failure to a different external address mapping than we expect.\n+    request[ofs] = PCP_OPTION_PREFER_FAILURE;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587549683",
      "id" : 1587549683,
      "line" : 149,
      "node_id" : "PRRC_kwDOABII585eoBXz",
      "original_commit_id" : "4395a42c5df14e211ca78405f599a2ed24466334",
      "original_line" : 149,
      "original_position" : 149,
      "original_start_line" : null,
      "path" : "src/ipv6-pinhole-test.cpp",
      "position" : 149,
      "pull_request_review_id" : 2035221223,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30005",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587549683/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-02T12:45:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587549683",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587555746"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30005"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587555746"
         }
      },
      "author_association" : "MEMBER",
      "body" : "So this has the effect of expanding the message by 4 bytes, where we set the first byte to `PCP_OPTION_PREFER_FAILURE` and the rest to zero (since there's no option data)?",
      "commit_id" : "4395a42c5df14e211ca78405f599a2ed24466334",
      "created_at" : "2024-05-02T12:30:18Z",
      "diff_hunk" : "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+#include <util/translation.h> // Remove this\n+\n+#include <linux/route.h>\n+\n+const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr; // Remove this\n+\n+// RFC 6887 Port Control Protocol (PCP) implementation.\n+// PCP uses network byte order (big-endian).\n+// References to sections and figures in the code below refer to https://datatracker.ietf.org/doc/html/rfc6887.\n+\n+// Protocol constants.\n+//! Maximum packet size in bytes (see section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (see section 19.1).\n+constexpr uint16_t PCP_SERVER_PORT = 5351;\n+//! Version byte. 0 is NAT-PMP, 1 is forbidden, 2 for PCP RFC-6887.\n+constexpr uint8_t PCP_VERSION = 2;\n+//! Map request opcode. See sections 19.2, 7.1.\n+constexpr uint8_t PCP_OP_MAP_REQUEST = 0x01;\n+//! Map response opcode. See sections 19.2, 7.2.\n+constexpr uint8_t PCP_OP_MAP_RESPONSE = 0x01 | 0x80;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Option: prefer failure to half-functional mapping. See section 13.2.\n+constexpr uint8_t PCP_OPTION_PREFER_FAILURE = 2;\n+//! Request header size in bytes (see section 7.1).\n+constexpr size_t PCP_REQUEST_HDR_SIZE = 24;\n+//! Response header size in bytes (see section 7.2).\n+constexpr size_t PCP_RESPONSE_HDR_SIZE = 24;\n+//! Option header size in bytes (see section 7.2).\n+constexpr size_t PCP_OPTION_HDR_SIZE = 4;\n+//! Map request size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_REQUEST_SIZE = 36;\n+//! Map response size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_RESPONSE_SIZE = 36;\n+//! Mapping nonce size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_NONCE_SIZE = 12;\n+//! Result code representing SUCCESS status (7.4).\n+constexpr uint8_t PCP_RESULT_SUCCESS = 0;\n+\n+//! Find IPv6 default gateway.\n+std::optional<sockaddr_in6> FindIPv6DefaultGateway()\n+{\n+    const auto& [read_ok, data] = ReadBinaryFile(\"/proc/net/ipv6_route\");\n+    if (!read_ok) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not read /proc/net/ipv6_route to find default IPv6 gateway\\n\");\n+        return std::nullopt;\n+    }\n+    // 149 length (longer if interface name is longer)\n+    // destination                      prefix                                 nexthop                                                     flags     iface\n+    // 00000000000000000000000000000000 00 00000000000000000000000000000000 00 fe80000000000000da58d7fffe0077cd 00000064 00000007 00000000 00000003     eth0\n+    for(std::string &line: SplitString(data, \"\\n\")) {\n+        if (line.size() < 149) continue;\n+        const std::optional<std::vector<uint8_t>> nexthop(TryParseHex<uint8_t>(line.substr(72, 32)));\n+        const std::optional<uint8_t> prefix(ToIntegral<uint8_t>(line.substr(33,  2), ADDR_IPV6_SIZE));\n+        const std::optional<uint32_t> flags(ToIntegral<uint32_t>(line.substr(132,  8), ADDR_IPV6_SIZE));\n+        const std::string iface(TrimString(line.substr(141)));\n+        if (!prefix || !nexthop | !flags || nexthop->size() != ADDR_IPV6_SIZE || iface.empty()) continue; // Parse error\n+        if (prefix.value() != 0 || (flags.value() & (RTF_GATEWAY | RTF_UP)) != (RTF_GATEWAY | RTF_UP)) continue; // Not default gw\n+        // Look up scope id for interface name string.\n+        int gateway_scope_id = if_nametoindex(iface.c_str());\n+        if (gateway_scope_id <= 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not parse gateway interface %s\\n\", iface.c_str());\n+            return std::nullopt;\n+        }\n+\n+        sockaddr_in6 dest_addr = {};\n+        dest_addr.sin6_family = AF_INET6;\n+        memcpy(&dest_addr.sin6_addr, nexthop->data(), ADDR_IPV6_SIZE);\n+        dest_addr.sin6_scope_id = gateway_scope_id;\n+        return dest_addr;\n+    }\n+    return std::nullopt;\n+}\n+\n+//! Try to open a IPv6 pinhole port using RFC 6887 Port Control Protocol (PCP).\n+bool OpenPinhole(const sockaddr_in6 &gateway, const struct in6_addr &my_addr, uint16_t port, uint32_t lifetime, int num_tries = 3)\n+{\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Opening pinhole for addr: %s\\n\", CNetAddr(my_addr).ToStringAddr());\n+\n+    // Create IPv6 UDP socket.\n+    SOCKET sock_fd = socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);\n+    if (sock_fd == INVALID_SOCKET) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not create IPv6 UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+    Sock sock(sock_fd);\n+\n+    // Make sure that we send from requested address, anything else will be\n+    // rejected by a security-conscious router.\n+    sockaddr_in6 bind_addr = {};\n+    bind_addr.sin6_family = AF_INET6;\n+    bind_addr.sin6_addr = my_addr;\n+    if (sock.Bind((struct sockaddr*)&bind_addr, sizeof(sockaddr_in6)) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not bind to address: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    sockaddr_in6 dest_addr = gateway;\n+    dest_addr.sin6_port = htons(PCP_SERVER_PORT);\n+    if (sock.Connect((struct sockaddr*)&dest_addr, sizeof(sockaddr_in6)) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not bind to connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    // Build request packet. Make sure the packet is zeroed so that reserved fields are zero\n+    // as required by the spec (and not potentially leak data).\n+    // Make sure there's space for the request header, MAP specific request\n+    // data, and one option header.\n+    uint8_t request[PCP_REQUEST_HDR_SIZE + PCP_MAP_REQUEST_SIZE + PCP_OPTION_HDR_SIZE] = {};\n+    // Fill in request header, See Figure 2.\n+    size_t ofs = 0;\n+    request[ofs + 0] = PCP_VERSION;\n+    request[ofs + 1] = PCP_OP_MAP_REQUEST;\n+    WriteBE32(request + ofs + 4, lifetime);\n+    memcpy(request + ofs + 8, &my_addr, ADDR_IPV6_SIZE);\n+\n+    ofs += PCP_REQUEST_HDR_SIZE;\n+\n+    // Fill in MAP request packet, See Figure 9.\n+    // Randomize mapping nonce (this is repeated in the response, to be able to\n+    // correlate requests and responses, and used to authenticate changes to the mapping).\n+    // TODO: remember this value when periodically renewing a mapping.\n+    GetRandBytes(Span(request + ofs + 0, PCP_MAP_NONCE_SIZE));\n+    request[ofs + 12] = PCP_PROTOCOL_TCP;\n+    WriteBE16(request + ofs + 16, port);\n+    WriteBE16(request + ofs + 18, port);\n+    memcpy(request + ofs + 20, &my_addr, ADDR_IPV6_SIZE);\n+\n+    ofs += PCP_MAP_REQUEST_SIZE;\n+\n+    // Fill in option header. See Figure 4.\n+    // Prefer failure to a different external address mapping than we expect.\n+    request[ofs] = PCP_OPTION_PREFER_FAILURE;\n+\n+    ofs += PCP_OPTION_HDR_SIZE;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587555746",
      "id" : 1587555746,
      "line" : 151,
      "node_id" : "PRRC_kwDOABII585eoC2i",
      "original_commit_id" : "4395a42c5df14e211ca78405f599a2ed24466334",
      "original_line" : 151,
      "original_position" : 151,
      "original_start_line" : null,
      "path" : "src/ipv6-pinhole-test.cpp",
      "position" : 151,
      "pull_request_review_id" : 2035221223,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30005",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587555746/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-02T12:45:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587555746",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587560006"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30005"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587560006"
         }
      },
      "author_association" : "MEMBER",
      "body" : "IIUC this might as well be called `RequestPortMap`, with the clarification that this boils down to a pinhole for IPv6.",
      "commit_id" : "4395a42c5df14e211ca78405f599a2ed24466334",
      "created_at" : "2024-05-02T12:33:29Z",
      "diff_hunk" : "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+#include <util/translation.h> // Remove this\n+\n+#include <linux/route.h>\n+\n+const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr; // Remove this\n+\n+// RFC 6887 Port Control Protocol (PCP) implementation.\n+// PCP uses network byte order (big-endian).\n+// References to sections and figures in the code below refer to https://datatracker.ietf.org/doc/html/rfc6887.\n+\n+// Protocol constants.\n+//! Maximum packet size in bytes (see section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (see section 19.1).\n+constexpr uint16_t PCP_SERVER_PORT = 5351;\n+//! Version byte. 0 is NAT-PMP, 1 is forbidden, 2 for PCP RFC-6887.\n+constexpr uint8_t PCP_VERSION = 2;\n+//! Map request opcode. See sections 19.2, 7.1.\n+constexpr uint8_t PCP_OP_MAP_REQUEST = 0x01;\n+//! Map response opcode. See sections 19.2, 7.2.\n+constexpr uint8_t PCP_OP_MAP_RESPONSE = 0x01 | 0x80;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Option: prefer failure to half-functional mapping. See section 13.2.\n+constexpr uint8_t PCP_OPTION_PREFER_FAILURE = 2;\n+//! Request header size in bytes (see section 7.1).\n+constexpr size_t PCP_REQUEST_HDR_SIZE = 24;\n+//! Response header size in bytes (see section 7.2).\n+constexpr size_t PCP_RESPONSE_HDR_SIZE = 24;\n+//! Option header size in bytes (see section 7.2).\n+constexpr size_t PCP_OPTION_HDR_SIZE = 4;\n+//! Map request size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_REQUEST_SIZE = 36;\n+//! Map response size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_RESPONSE_SIZE = 36;\n+//! Mapping nonce size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_NONCE_SIZE = 12;\n+//! Result code representing SUCCESS status (7.4).\n+constexpr uint8_t PCP_RESULT_SUCCESS = 0;\n+\n+//! Find IPv6 default gateway.\n+std::optional<sockaddr_in6> FindIPv6DefaultGateway()\n+{\n+    const auto& [read_ok, data] = ReadBinaryFile(\"/proc/net/ipv6_route\");\n+    if (!read_ok) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not read /proc/net/ipv6_route to find default IPv6 gateway\\n\");\n+        return std::nullopt;\n+    }\n+    // 149 length (longer if interface name is longer)\n+    // destination                      prefix                                 nexthop                                                     flags     iface\n+    // 00000000000000000000000000000000 00 00000000000000000000000000000000 00 fe80000000000000da58d7fffe0077cd 00000064 00000007 00000000 00000003     eth0\n+    for(std::string &line: SplitString(data, \"\\n\")) {\n+        if (line.size() < 149) continue;\n+        const std::optional<std::vector<uint8_t>> nexthop(TryParseHex<uint8_t>(line.substr(72, 32)));\n+        const std::optional<uint8_t> prefix(ToIntegral<uint8_t>(line.substr(33,  2), ADDR_IPV6_SIZE));\n+        const std::optional<uint32_t> flags(ToIntegral<uint32_t>(line.substr(132,  8), ADDR_IPV6_SIZE));\n+        const std::string iface(TrimString(line.substr(141)));\n+        if (!prefix || !nexthop | !flags || nexthop->size() != ADDR_IPV6_SIZE || iface.empty()) continue; // Parse error\n+        if (prefix.value() != 0 || (flags.value() & (RTF_GATEWAY | RTF_UP)) != (RTF_GATEWAY | RTF_UP)) continue; // Not default gw\n+        // Look up scope id for interface name string.\n+        int gateway_scope_id = if_nametoindex(iface.c_str());\n+        if (gateway_scope_id <= 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not parse gateway interface %s\\n\", iface.c_str());\n+            return std::nullopt;\n+        }\n+\n+        sockaddr_in6 dest_addr = {};\n+        dest_addr.sin6_family = AF_INET6;\n+        memcpy(&dest_addr.sin6_addr, nexthop->data(), ADDR_IPV6_SIZE);\n+        dest_addr.sin6_scope_id = gateway_scope_id;\n+        return dest_addr;\n+    }\n+    return std::nullopt;\n+}\n+\n+//! Try to open a IPv6 pinhole port using RFC 6887 Port Control Protocol (PCP).\n+bool OpenPinhole(const sockaddr_in6 &gateway, const struct in6_addr &my_addr, uint16_t port, uint32_t lifetime, int num_tries = 3)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587560006",
      "id" : 1587560006,
      "line" : 92,
      "node_id" : "PRRC_kwDOABII585eoD5G",
      "original_commit_id" : "4395a42c5df14e211ca78405f599a2ed24466334",
      "original_line" : 92,
      "original_position" : 92,
      "original_start_line" : null,
      "path" : "src/ipv6-pinhole-test.cpp",
      "position" : 92,
      "pull_request_review_id" : 2035221223,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30005",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587560006/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-02T12:45:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587560006",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587569941"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30005"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587569941"
         }
      },
      "author_association" : "MEMBER",
      "body" : "For IPv4 we should print the external address regardless, since we had no expectation.",
      "commit_id" : "4395a42c5df14e211ca78405f599a2ed24466334",
      "created_at" : "2024-05-02T12:41:15Z",
      "diff_hunk" : "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+#include <util/translation.h> // Remove this\n+\n+#include <linux/route.h>\n+\n+const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr; // Remove this\n+\n+// RFC 6887 Port Control Protocol (PCP) implementation.\n+// PCP uses network byte order (big-endian).\n+// References to sections and figures in the code below refer to https://datatracker.ietf.org/doc/html/rfc6887.\n+\n+// Protocol constants.\n+//! Maximum packet size in bytes (see section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (see section 19.1).\n+constexpr uint16_t PCP_SERVER_PORT = 5351;\n+//! Version byte. 0 is NAT-PMP, 1 is forbidden, 2 for PCP RFC-6887.\n+constexpr uint8_t PCP_VERSION = 2;\n+//! Map request opcode. See sections 19.2, 7.1.\n+constexpr uint8_t PCP_OP_MAP_REQUEST = 0x01;\n+//! Map response opcode. See sections 19.2, 7.2.\n+constexpr uint8_t PCP_OP_MAP_RESPONSE = 0x01 | 0x80;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Option: prefer failure to half-functional mapping. See section 13.2.\n+constexpr uint8_t PCP_OPTION_PREFER_FAILURE = 2;\n+//! Request header size in bytes (see section 7.1).\n+constexpr size_t PCP_REQUEST_HDR_SIZE = 24;\n+//! Response header size in bytes (see section 7.2).\n+constexpr size_t PCP_RESPONSE_HDR_SIZE = 24;\n+//! Option header size in bytes (see section 7.2).\n+constexpr size_t PCP_OPTION_HDR_SIZE = 4;\n+//! Map request size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_REQUEST_SIZE = 36;\n+//! Map response size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_RESPONSE_SIZE = 36;\n+//! Mapping nonce size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_NONCE_SIZE = 12;\n+//! Result code representing SUCCESS status (7.4).\n+constexpr uint8_t PCP_RESULT_SUCCESS = 0;\n+\n+//! Find IPv6 default gateway.\n+std::optional<sockaddr_in6> FindIPv6DefaultGateway()\n+{\n+    const auto& [read_ok, data] = ReadBinaryFile(\"/proc/net/ipv6_route\");\n+    if (!read_ok) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not read /proc/net/ipv6_route to find default IPv6 gateway\\n\");\n+        return std::nullopt;\n+    }\n+    // 149 length (longer if interface name is longer)\n+    // destination                      prefix                                 nexthop                                                     flags     iface\n+    // 00000000000000000000000000000000 00 00000000000000000000000000000000 00 fe80000000000000da58d7fffe0077cd 00000064 00000007 00000000 00000003     eth0\n+    for(std::string &line: SplitString(data, \"\\n\")) {\n+        if (line.size() < 149) continue;\n+        const std::optional<std::vector<uint8_t>> nexthop(TryParseHex<uint8_t>(line.substr(72, 32)));\n+        const std::optional<uint8_t> prefix(ToIntegral<uint8_t>(line.substr(33,  2), ADDR_IPV6_SIZE));\n+        const std::optional<uint32_t> flags(ToIntegral<uint32_t>(line.substr(132,  8), ADDR_IPV6_SIZE));\n+        const std::string iface(TrimString(line.substr(141)));\n+        if (!prefix || !nexthop | !flags || nexthop->size() != ADDR_IPV6_SIZE || iface.empty()) continue; // Parse error\n+        if (prefix.value() != 0 || (flags.value() & (RTF_GATEWAY | RTF_UP)) != (RTF_GATEWAY | RTF_UP)) continue; // Not default gw\n+        // Look up scope id for interface name string.\n+        int gateway_scope_id = if_nametoindex(iface.c_str());\n+        if (gateway_scope_id <= 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not parse gateway interface %s\\n\", iface.c_str());\n+            return std::nullopt;\n+        }\n+\n+        sockaddr_in6 dest_addr = {};\n+        dest_addr.sin6_family = AF_INET6;\n+        memcpy(&dest_addr.sin6_addr, nexthop->data(), ADDR_IPV6_SIZE);\n+        dest_addr.sin6_scope_id = gateway_scope_id;\n+        return dest_addr;\n+    }\n+    return std::nullopt;\n+}\n+\n+//! Try to open a IPv6 pinhole port using RFC 6887 Port Control Protocol (PCP).\n+bool OpenPinhole(const sockaddr_in6 &gateway, const struct in6_addr &my_addr, uint16_t port, uint32_t lifetime, int num_tries = 3)\n+{\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Opening pinhole for addr: %s\\n\", CNetAddr(my_addr).ToStringAddr());\n+\n+    // Create IPv6 UDP socket.\n+    SOCKET sock_fd = socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);\n+    if (sock_fd == INVALID_SOCKET) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not create IPv6 UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+    Sock sock(sock_fd);\n+\n+    // Make sure that we send from requested address, anything else will be\n+    // rejected by a security-conscious router.\n+    sockaddr_in6 bind_addr = {};\n+    bind_addr.sin6_family = AF_INET6;\n+    bind_addr.sin6_addr = my_addr;\n+    if (sock.Bind((struct sockaddr*)&bind_addr, sizeof(sockaddr_in6)) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not bind to address: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    sockaddr_in6 dest_addr = gateway;\n+    dest_addr.sin6_port = htons(PCP_SERVER_PORT);\n+    if (sock.Connect((struct sockaddr*)&dest_addr, sizeof(sockaddr_in6)) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not bind to connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    // Build request packet. Make sure the packet is zeroed so that reserved fields are zero\n+    // as required by the spec (and not potentially leak data).\n+    // Make sure there's space for the request header, MAP specific request\n+    // data, and one option header.\n+    uint8_t request[PCP_REQUEST_HDR_SIZE + PCP_MAP_REQUEST_SIZE + PCP_OPTION_HDR_SIZE] = {};\n+    // Fill in request header, See Figure 2.\n+    size_t ofs = 0;\n+    request[ofs + 0] = PCP_VERSION;\n+    request[ofs + 1] = PCP_OP_MAP_REQUEST;\n+    WriteBE32(request + ofs + 4, lifetime);\n+    memcpy(request + ofs + 8, &my_addr, ADDR_IPV6_SIZE);\n+\n+    ofs += PCP_REQUEST_HDR_SIZE;\n+\n+    // Fill in MAP request packet, See Figure 9.\n+    // Randomize mapping nonce (this is repeated in the response, to be able to\n+    // correlate requests and responses, and used to authenticate changes to the mapping).\n+    // TODO: remember this value when periodically renewing a mapping.\n+    GetRandBytes(Span(request + ofs + 0, PCP_MAP_NONCE_SIZE));\n+    request[ofs + 12] = PCP_PROTOCOL_TCP;\n+    WriteBE16(request + ofs + 16, port);\n+    WriteBE16(request + ofs + 18, port);\n+    memcpy(request + ofs + 20, &my_addr, ADDR_IPV6_SIZE);\n+\n+    ofs += PCP_MAP_REQUEST_SIZE;\n+\n+    // Fill in option header. See Figure 4.\n+    // Prefer failure to a different external address mapping than we expect.\n+    request[ofs] = PCP_OPTION_PREFER_FAILURE;\n+\n+    ofs += PCP_OPTION_HDR_SIZE;\n+\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    bool got_response = false;\n+    uint8_t response[PCP_MAX_SIZE];\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp6: Retrying (%d)\\n\", ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request, ofs, 0) != static_cast<ssize_t>(ofs)) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not send request: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+            return false; // Network-level error, probably no use retrying.\n+        }\n+\n+        // Wait for response(s) until we get a valid response, a network error, or time out.\n+        while (true) {\n+            Sock::Event occured = 0;\n+            if (!sock.Wait(std::chrono::milliseconds(1000), Sock::RECV, &occured)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not wait on socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+                return false; // Network-level error, probably no use retrying.\n+            }\n+            if (!occured) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp6: Timeout\\n\");\n+                break; // Retry.\n+            }\n+\n+            // Receive response.\n+            int recvsz = sock.Recv(response, sizeof(response), MSG_DONTWAIT);\n+            if (recvsz < 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not receive response: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+                return false; // Network-level error, probably no use retrying.\n+            }\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp6: Received response of %d bytes: %s\\n\", recvsz, HexStr(Span(response, recvsz)));\n+            if (static_cast<size_t>(recvsz) < (PCP_RESPONSE_HDR_SIZE + PCP_MAP_RESPONSE_SIZE)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Response too small\\n\");\n+                continue; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[0] != PCP_VERSION || response[1] != PCP_OP_MAP_RESPONSE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Response to wrong command\\n\");\n+                continue; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            // Handle MAP opcode response. See Figure 10.\n+            // Check that returned mapping nonce matches our request.\n+            if (memcmp(response + PCP_RESPONSE_HDR_SIZE, request + PCP_REQUEST_HDR_SIZE, PCP_MAP_NONCE_SIZE) != 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Mapping nonce mismatch\\n\");\n+                continue; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            uint8_t protocol = response[PCP_RESPONSE_HDR_SIZE + 12];\n+            uint16_t internal_port = ReadBE16(response + PCP_RESPONSE_HDR_SIZE + 16);\n+            if (protocol != PCP_PROTOCOL_TCP || internal_port != port) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Response protocol or port doesn't match request\\n\");\n+                continue; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            got_response = true; // Got expected response, break from receive loop as well as from retry loop.\n+            break;\n+        }\n+    }\n+    if (!got_response) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp6: Giving up after %d tries\\n\", num_tries);\n+        return false;\n+    }\n+    // If we get here, we got a valid MAP response to our request.\n+    // Check to see if we got the result we expected.\n+    int result_code = response[3];\n+    uint32_t lifetime_ret = ReadBE32(response + 4);\n+    uint16_t external_port = ReadBE16(response + PCP_RESPONSE_HDR_SIZE + 18);\n+    struct in6_addr external_addr;\n+    memcpy(&external_addr, response + PCP_RESPONSE_HDR_SIZE + 20, ADDR_IPV6_SIZE);\n+    if (result_code != PCP_RESULT_SUCCESS) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Mapping failed with result code %d\\n\", result_code);\n+        return false;\n+    } else {\n+        // Mapping was successful. Just to be sure, check that the external port and address match what we expect.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587569941",
      "id" : 1587569941,
      "line" : 224,
      "node_id" : "PRRC_kwDOABII585eoGUV",
      "original_commit_id" : "4395a42c5df14e211ca78405f599a2ed24466334",
      "original_line" : 224,
      "original_position" : 224,
      "original_start_line" : null,
      "path" : "src/ipv6-pinhole-test.cpp",
      "position" : 224,
      "pull_request_review_id" : 2035221223,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30005",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587569941/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-02T12:45:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587569941",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Thanks for the review!\r\n\r\n> IPv6 always returns multiple addresses. I'm not sure what the logic behind that is, but should we gossiping and pinholing all of them? Or is one \"supposed\" to be used?\r\n\r\nThat's a good question. Sometimes routers will give out temporary addresses as well as permanent addresses, i'm not sure it's possible to discover the intent of an address at application level. If so it is going to be OS specific. Currently in master the application Discover()s alll publicly routable IPv6 addresses, which seems like a sensible default.\r\n\r\nMore advanced networking users will hand-configure things anyway. And if specific addresses are being `-listen`ed on, we should heed that.\r\n\r\n> Why not also use PCP for IPv4 NAT? If it's widely supported enough, maybe it lets us drop both upnp and natpmp from the dependencies (immediately or at some point in the future if there's actually a problem with them).\r\n\r\ni agree with this, but it's not as urgent. We have good coverage for IPv4 port mapping methods, i'm kind of hestitant to touch that, given how hard it already is to find people to test these kind of things ð \r\n\r\nSo called \"dual stack lite\" are getting quite popular for ISPs, which essentially means no publicly routable IPv4 (\"carrier-grade NAT\") only IPv6. So for home users this is a better focus.\r\n\r\n> One nice feature of PCP is that it gives us the external IP(v4) address. \r\n\r\nAFAIK, UPnP and natpmp also give you this information. In regard to IPv4, natpmp and pcp are essentially the same with slightly different packet layout.",
      "created_at" : "2024-05-02T13:02:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30005#issuecomment-2090448249",
      "id" : 2090448249,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30005",
      "node_id" : "IC_kwDOABII5858mbV5",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2090448249/reactions"
      },
      "updated_at" : "2024-05-02T13:06:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2090448249",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Could you rebase this on master, now that we are using the latest version of miniupnpc (#29707).",
      "created_at" : "2024-05-02T13:05:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30005#issuecomment-2090454836",
      "id" : 2090454836,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30005",
      "node_id" : "IC_kwDOABII5858mc80",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2090454836/reactions"
      },
      "updated_at" : "2024-05-02T13:05:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2090454836",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587614730"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30005"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587614730"
         }
      },
      "author_association" : "MEMBER",
      "body" : "As i understand, mandatory or optional is a property of the opcode. `PCP_OPTION_PREFER_FAILURE` is `0x02`, so It's always mandatory.\r\n\r\nWe want the address and port that we request, if not possible, it's better to fail fast, instead of having to deal with having to cancel unwanted mappings etc.",
      "commit_id" : "4395a42c5df14e211ca78405f599a2ed24466334",
      "created_at" : "2024-05-02T13:13:07Z",
      "diff_hunk" : "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+#include <util/translation.h> // Remove this\n+\n+#include <linux/route.h>\n+\n+const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr; // Remove this\n+\n+// RFC 6887 Port Control Protocol (PCP) implementation.\n+// PCP uses network byte order (big-endian).\n+// References to sections and figures in the code below refer to https://datatracker.ietf.org/doc/html/rfc6887.\n+\n+// Protocol constants.\n+//! Maximum packet size in bytes (see section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (see section 19.1).\n+constexpr uint16_t PCP_SERVER_PORT = 5351;\n+//! Version byte. 0 is NAT-PMP, 1 is forbidden, 2 for PCP RFC-6887.\n+constexpr uint8_t PCP_VERSION = 2;\n+//! Map request opcode. See sections 19.2, 7.1.\n+constexpr uint8_t PCP_OP_MAP_REQUEST = 0x01;\n+//! Map response opcode. See sections 19.2, 7.2.\n+constexpr uint8_t PCP_OP_MAP_RESPONSE = 0x01 | 0x80;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Option: prefer failure to half-functional mapping. See section 13.2.\n+constexpr uint8_t PCP_OPTION_PREFER_FAILURE = 2;\n+//! Request header size in bytes (see section 7.1).\n+constexpr size_t PCP_REQUEST_HDR_SIZE = 24;\n+//! Response header size in bytes (see section 7.2).\n+constexpr size_t PCP_RESPONSE_HDR_SIZE = 24;\n+//! Option header size in bytes (see section 7.2).\n+constexpr size_t PCP_OPTION_HDR_SIZE = 4;\n+//! Map request size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_REQUEST_SIZE = 36;\n+//! Map response size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_RESPONSE_SIZE = 36;\n+//! Mapping nonce size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_NONCE_SIZE = 12;\n+//! Result code representing SUCCESS status (7.4).\n+constexpr uint8_t PCP_RESULT_SUCCESS = 0;\n+\n+//! Find IPv6 default gateway.\n+std::optional<sockaddr_in6> FindIPv6DefaultGateway()\n+{\n+    const auto& [read_ok, data] = ReadBinaryFile(\"/proc/net/ipv6_route\");\n+    if (!read_ok) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not read /proc/net/ipv6_route to find default IPv6 gateway\\n\");\n+        return std::nullopt;\n+    }\n+    // 149 length (longer if interface name is longer)\n+    // destination                      prefix                                 nexthop                                                     flags     iface\n+    // 00000000000000000000000000000000 00 00000000000000000000000000000000 00 fe80000000000000da58d7fffe0077cd 00000064 00000007 00000000 00000003     eth0\n+    for(std::string &line: SplitString(data, \"\\n\")) {\n+        if (line.size() < 149) continue;\n+        const std::optional<std::vector<uint8_t>> nexthop(TryParseHex<uint8_t>(line.substr(72, 32)));\n+        const std::optional<uint8_t> prefix(ToIntegral<uint8_t>(line.substr(33,  2), ADDR_IPV6_SIZE));\n+        const std::optional<uint32_t> flags(ToIntegral<uint32_t>(line.substr(132,  8), ADDR_IPV6_SIZE));\n+        const std::string iface(TrimString(line.substr(141)));\n+        if (!prefix || !nexthop | !flags || nexthop->size() != ADDR_IPV6_SIZE || iface.empty()) continue; // Parse error\n+        if (prefix.value() != 0 || (flags.value() & (RTF_GATEWAY | RTF_UP)) != (RTF_GATEWAY | RTF_UP)) continue; // Not default gw\n+        // Look up scope id for interface name string.\n+        int gateway_scope_id = if_nametoindex(iface.c_str());\n+        if (gateway_scope_id <= 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not parse gateway interface %s\\n\", iface.c_str());\n+            return std::nullopt;\n+        }\n+\n+        sockaddr_in6 dest_addr = {};\n+        dest_addr.sin6_family = AF_INET6;\n+        memcpy(&dest_addr.sin6_addr, nexthop->data(), ADDR_IPV6_SIZE);\n+        dest_addr.sin6_scope_id = gateway_scope_id;\n+        return dest_addr;\n+    }\n+    return std::nullopt;\n+}\n+\n+//! Try to open a IPv6 pinhole port using RFC 6887 Port Control Protocol (PCP).\n+bool OpenPinhole(const sockaddr_in6 &gateway, const struct in6_addr &my_addr, uint16_t port, uint32_t lifetime, int num_tries = 3)\n+{\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Opening pinhole for addr: %s\\n\", CNetAddr(my_addr).ToStringAddr());\n+\n+    // Create IPv6 UDP socket.\n+    SOCKET sock_fd = socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);\n+    if (sock_fd == INVALID_SOCKET) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not create IPv6 UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+    Sock sock(sock_fd);\n+\n+    // Make sure that we send from requested address, anything else will be\n+    // rejected by a security-conscious router.\n+    sockaddr_in6 bind_addr = {};\n+    bind_addr.sin6_family = AF_INET6;\n+    bind_addr.sin6_addr = my_addr;\n+    if (sock.Bind((struct sockaddr*)&bind_addr, sizeof(sockaddr_in6)) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not bind to address: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    sockaddr_in6 dest_addr = gateway;\n+    dest_addr.sin6_port = htons(PCP_SERVER_PORT);\n+    if (sock.Connect((struct sockaddr*)&dest_addr, sizeof(sockaddr_in6)) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not bind to connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    // Build request packet. Make sure the packet is zeroed so that reserved fields are zero\n+    // as required by the spec (and not potentially leak data).\n+    // Make sure there's space for the request header, MAP specific request\n+    // data, and one option header.\n+    uint8_t request[PCP_REQUEST_HDR_SIZE + PCP_MAP_REQUEST_SIZE + PCP_OPTION_HDR_SIZE] = {};\n+    // Fill in request header, See Figure 2.\n+    size_t ofs = 0;\n+    request[ofs + 0] = PCP_VERSION;\n+    request[ofs + 1] = PCP_OP_MAP_REQUEST;\n+    WriteBE32(request + ofs + 4, lifetime);\n+    memcpy(request + ofs + 8, &my_addr, ADDR_IPV6_SIZE);\n+\n+    ofs += PCP_REQUEST_HDR_SIZE;\n+\n+    // Fill in MAP request packet, See Figure 9.\n+    // Randomize mapping nonce (this is repeated in the response, to be able to\n+    // correlate requests and responses, and used to authenticate changes to the mapping).\n+    // TODO: remember this value when periodically renewing a mapping.\n+    GetRandBytes(Span(request + ofs + 0, PCP_MAP_NONCE_SIZE));\n+    request[ofs + 12] = PCP_PROTOCOL_TCP;\n+    WriteBE16(request + ofs + 16, port);\n+    WriteBE16(request + ofs + 18, port);\n+    memcpy(request + ofs + 20, &my_addr, ADDR_IPV6_SIZE);\n+\n+    ofs += PCP_MAP_REQUEST_SIZE;\n+\n+    // Fill in option header. See Figure 4.\n+    // Prefer failure to a different external address mapping than we expect.\n+    request[ofs] = PCP_OPTION_PREFER_FAILURE;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587614730",
      "id" : 1587614730,
      "in_reply_to_id" : 1587549683,
      "line" : 149,
      "node_id" : "PRRC_kwDOABII585eoRQK",
      "original_commit_id" : "4395a42c5df14e211ca78405f599a2ed24466334",
      "original_line" : 149,
      "original_position" : 149,
      "original_start_line" : null,
      "path" : "src/ipv6-pinhole-test.cpp",
      "position" : 149,
      "pull_request_review_id" : 2035710828,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30005",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587614730/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-02T13:13:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587614730",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587616006"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30005"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587616006"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Correct. The rest of the fields can be left at 0. i'll add a comment.",
      "commit_id" : "4395a42c5df14e211ca78405f599a2ed24466334",
      "created_at" : "2024-05-02T13:14:09Z",
      "diff_hunk" : "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+#include <util/translation.h> // Remove this\n+\n+#include <linux/route.h>\n+\n+const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr; // Remove this\n+\n+// RFC 6887 Port Control Protocol (PCP) implementation.\n+// PCP uses network byte order (big-endian).\n+// References to sections and figures in the code below refer to https://datatracker.ietf.org/doc/html/rfc6887.\n+\n+// Protocol constants.\n+//! Maximum packet size in bytes (see section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (see section 19.1).\n+constexpr uint16_t PCP_SERVER_PORT = 5351;\n+//! Version byte. 0 is NAT-PMP, 1 is forbidden, 2 for PCP RFC-6887.\n+constexpr uint8_t PCP_VERSION = 2;\n+//! Map request opcode. See sections 19.2, 7.1.\n+constexpr uint8_t PCP_OP_MAP_REQUEST = 0x01;\n+//! Map response opcode. See sections 19.2, 7.2.\n+constexpr uint8_t PCP_OP_MAP_RESPONSE = 0x01 | 0x80;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Option: prefer failure to half-functional mapping. See section 13.2.\n+constexpr uint8_t PCP_OPTION_PREFER_FAILURE = 2;\n+//! Request header size in bytes (see section 7.1).\n+constexpr size_t PCP_REQUEST_HDR_SIZE = 24;\n+//! Response header size in bytes (see section 7.2).\n+constexpr size_t PCP_RESPONSE_HDR_SIZE = 24;\n+//! Option header size in bytes (see section 7.2).\n+constexpr size_t PCP_OPTION_HDR_SIZE = 4;\n+//! Map request size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_REQUEST_SIZE = 36;\n+//! Map response size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_RESPONSE_SIZE = 36;\n+//! Mapping nonce size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_NONCE_SIZE = 12;\n+//! Result code representing SUCCESS status (7.4).\n+constexpr uint8_t PCP_RESULT_SUCCESS = 0;\n+\n+//! Find IPv6 default gateway.\n+std::optional<sockaddr_in6> FindIPv6DefaultGateway()\n+{\n+    const auto& [read_ok, data] = ReadBinaryFile(\"/proc/net/ipv6_route\");\n+    if (!read_ok) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not read /proc/net/ipv6_route to find default IPv6 gateway\\n\");\n+        return std::nullopt;\n+    }\n+    // 149 length (longer if interface name is longer)\n+    // destination                      prefix                                 nexthop                                                     flags     iface\n+    // 00000000000000000000000000000000 00 00000000000000000000000000000000 00 fe80000000000000da58d7fffe0077cd 00000064 00000007 00000000 00000003     eth0\n+    for(std::string &line: SplitString(data, \"\\n\")) {\n+        if (line.size() < 149) continue;\n+        const std::optional<std::vector<uint8_t>> nexthop(TryParseHex<uint8_t>(line.substr(72, 32)));\n+        const std::optional<uint8_t> prefix(ToIntegral<uint8_t>(line.substr(33,  2), ADDR_IPV6_SIZE));\n+        const std::optional<uint32_t> flags(ToIntegral<uint32_t>(line.substr(132,  8), ADDR_IPV6_SIZE));\n+        const std::string iface(TrimString(line.substr(141)));\n+        if (!prefix || !nexthop | !flags || nexthop->size() != ADDR_IPV6_SIZE || iface.empty()) continue; // Parse error\n+        if (prefix.value() != 0 || (flags.value() & (RTF_GATEWAY | RTF_UP)) != (RTF_GATEWAY | RTF_UP)) continue; // Not default gw\n+        // Look up scope id for interface name string.\n+        int gateway_scope_id = if_nametoindex(iface.c_str());\n+        if (gateway_scope_id <= 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not parse gateway interface %s\\n\", iface.c_str());\n+            return std::nullopt;\n+        }\n+\n+        sockaddr_in6 dest_addr = {};\n+        dest_addr.sin6_family = AF_INET6;\n+        memcpy(&dest_addr.sin6_addr, nexthop->data(), ADDR_IPV6_SIZE);\n+        dest_addr.sin6_scope_id = gateway_scope_id;\n+        return dest_addr;\n+    }\n+    return std::nullopt;\n+}\n+\n+//! Try to open a IPv6 pinhole port using RFC 6887 Port Control Protocol (PCP).\n+bool OpenPinhole(const sockaddr_in6 &gateway, const struct in6_addr &my_addr, uint16_t port, uint32_t lifetime, int num_tries = 3)\n+{\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Opening pinhole for addr: %s\\n\", CNetAddr(my_addr).ToStringAddr());\n+\n+    // Create IPv6 UDP socket.\n+    SOCKET sock_fd = socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);\n+    if (sock_fd == INVALID_SOCKET) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not create IPv6 UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+    Sock sock(sock_fd);\n+\n+    // Make sure that we send from requested address, anything else will be\n+    // rejected by a security-conscious router.\n+    sockaddr_in6 bind_addr = {};\n+    bind_addr.sin6_family = AF_INET6;\n+    bind_addr.sin6_addr = my_addr;\n+    if (sock.Bind((struct sockaddr*)&bind_addr, sizeof(sockaddr_in6)) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not bind to address: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    sockaddr_in6 dest_addr = gateway;\n+    dest_addr.sin6_port = htons(PCP_SERVER_PORT);\n+    if (sock.Connect((struct sockaddr*)&dest_addr, sizeof(sockaddr_in6)) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not bind to connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    // Build request packet. Make sure the packet is zeroed so that reserved fields are zero\n+    // as required by the spec (and not potentially leak data).\n+    // Make sure there's space for the request header, MAP specific request\n+    // data, and one option header.\n+    uint8_t request[PCP_REQUEST_HDR_SIZE + PCP_MAP_REQUEST_SIZE + PCP_OPTION_HDR_SIZE] = {};\n+    // Fill in request header, See Figure 2.\n+    size_t ofs = 0;\n+    request[ofs + 0] = PCP_VERSION;\n+    request[ofs + 1] = PCP_OP_MAP_REQUEST;\n+    WriteBE32(request + ofs + 4, lifetime);\n+    memcpy(request + ofs + 8, &my_addr, ADDR_IPV6_SIZE);\n+\n+    ofs += PCP_REQUEST_HDR_SIZE;\n+\n+    // Fill in MAP request packet, See Figure 9.\n+    // Randomize mapping nonce (this is repeated in the response, to be able to\n+    // correlate requests and responses, and used to authenticate changes to the mapping).\n+    // TODO: remember this value when periodically renewing a mapping.\n+    GetRandBytes(Span(request + ofs + 0, PCP_MAP_NONCE_SIZE));\n+    request[ofs + 12] = PCP_PROTOCOL_TCP;\n+    WriteBE16(request + ofs + 16, port);\n+    WriteBE16(request + ofs + 18, port);\n+    memcpy(request + ofs + 20, &my_addr, ADDR_IPV6_SIZE);\n+\n+    ofs += PCP_MAP_REQUEST_SIZE;\n+\n+    // Fill in option header. See Figure 4.\n+    // Prefer failure to a different external address mapping than we expect.\n+    request[ofs] = PCP_OPTION_PREFER_FAILURE;\n+\n+    ofs += PCP_OPTION_HDR_SIZE;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587616006",
      "id" : 1587616006,
      "in_reply_to_id" : 1587555746,
      "line" : 151,
      "node_id" : "PRRC_kwDOABII585eoRkG",
      "original_commit_id" : "4395a42c5df14e211ca78405f599a2ed24466334",
      "original_line" : 151,
      "original_position" : 151,
      "original_start_line" : null,
      "path" : "src/ipv6-pinhole-test.cpp",
      "position" : 151,
      "pull_request_review_id" : 2035713025,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30005",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587616006/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-02T13:14:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587616006",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587616861"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30005"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587616861"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Agree. There's not that many anyway.",
      "commit_id" : "4395a42c5df14e211ca78405f599a2ed24466334",
      "created_at" : "2024-05-02T13:14:46Z",
      "diff_hunk" : "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+#include <util/translation.h> // Remove this\n+\n+#include <linux/route.h>\n+\n+const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr; // Remove this\n+\n+// RFC 6887 Port Control Protocol (PCP) implementation.\n+// PCP uses network byte order (big-endian).\n+// References to sections and figures in the code below refer to https://datatracker.ietf.org/doc/html/rfc6887.\n+\n+// Protocol constants.\n+//! Maximum packet size in bytes (see section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (see section 19.1).\n+constexpr uint16_t PCP_SERVER_PORT = 5351;\n+//! Version byte. 0 is NAT-PMP, 1 is forbidden, 2 for PCP RFC-6887.\n+constexpr uint8_t PCP_VERSION = 2;\n+//! Map request opcode. See sections 19.2, 7.1.\n+constexpr uint8_t PCP_OP_MAP_REQUEST = 0x01;\n+//! Map response opcode. See sections 19.2, 7.2.\n+constexpr uint8_t PCP_OP_MAP_RESPONSE = 0x01 | 0x80;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Option: prefer failure to half-functional mapping. See section 13.2.\n+constexpr uint8_t PCP_OPTION_PREFER_FAILURE = 2;\n+//! Request header size in bytes (see section 7.1).\n+constexpr size_t PCP_REQUEST_HDR_SIZE = 24;\n+//! Response header size in bytes (see section 7.2).\n+constexpr size_t PCP_RESPONSE_HDR_SIZE = 24;\n+//! Option header size in bytes (see section 7.2).\n+constexpr size_t PCP_OPTION_HDR_SIZE = 4;\n+//! Map request size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_REQUEST_SIZE = 36;\n+//! Map response size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_RESPONSE_SIZE = 36;\n+//! Mapping nonce size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_NONCE_SIZE = 12;\n+//! Result code representing SUCCESS status (7.4).\n+constexpr uint8_t PCP_RESULT_SUCCESS = 0;\n+\n+//! Find IPv6 default gateway.\n+std::optional<sockaddr_in6> FindIPv6DefaultGateway()\n+{\n+    const auto& [read_ok, data] = ReadBinaryFile(\"/proc/net/ipv6_route\");\n+    if (!read_ok) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not read /proc/net/ipv6_route to find default IPv6 gateway\\n\");\n+        return std::nullopt;\n+    }\n+    // 149 length (longer if interface name is longer)\n+    // destination                      prefix                                 nexthop                                                     flags     iface\n+    // 00000000000000000000000000000000 00 00000000000000000000000000000000 00 fe80000000000000da58d7fffe0077cd 00000064 00000007 00000000 00000003     eth0\n+    for(std::string &line: SplitString(data, \"\\n\")) {\n+        if (line.size() < 149) continue;\n+        const std::optional<std::vector<uint8_t>> nexthop(TryParseHex<uint8_t>(line.substr(72, 32)));\n+        const std::optional<uint8_t> prefix(ToIntegral<uint8_t>(line.substr(33,  2), ADDR_IPV6_SIZE));\n+        const std::optional<uint32_t> flags(ToIntegral<uint32_t>(line.substr(132,  8), ADDR_IPV6_SIZE));\n+        const std::string iface(TrimString(line.substr(141)));\n+        if (!prefix || !nexthop | !flags || nexthop->size() != ADDR_IPV6_SIZE || iface.empty()) continue; // Parse error\n+        if (prefix.value() != 0 || (flags.value() & (RTF_GATEWAY | RTF_UP)) != (RTF_GATEWAY | RTF_UP)) continue; // Not default gw\n+        // Look up scope id for interface name string.\n+        int gateway_scope_id = if_nametoindex(iface.c_str());\n+        if (gateway_scope_id <= 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not parse gateway interface %s\\n\", iface.c_str());\n+            return std::nullopt;\n+        }\n+\n+        sockaddr_in6 dest_addr = {};\n+        dest_addr.sin6_family = AF_INET6;\n+        memcpy(&dest_addr.sin6_addr, nexthop->data(), ADDR_IPV6_SIZE);\n+        dest_addr.sin6_scope_id = gateway_scope_id;\n+        return dest_addr;\n+    }\n+    return std::nullopt;\n+}\n+\n+//! Try to open a IPv6 pinhole port using RFC 6887 Port Control Protocol (PCP).\n+bool OpenPinhole(const sockaddr_in6 &gateway, const struct in6_addr &my_addr, uint16_t port, uint32_t lifetime, int num_tries = 3)\n+{\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Opening pinhole for addr: %s\\n\", CNetAddr(my_addr).ToStringAddr());\n+\n+    // Create IPv6 UDP socket.\n+    SOCKET sock_fd = socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);\n+    if (sock_fd == INVALID_SOCKET) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not create IPv6 UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+    Sock sock(sock_fd);\n+\n+    // Make sure that we send from requested address, anything else will be\n+    // rejected by a security-conscious router.\n+    sockaddr_in6 bind_addr = {};\n+    bind_addr.sin6_family = AF_INET6;\n+    bind_addr.sin6_addr = my_addr;\n+    if (sock.Bind((struct sockaddr*)&bind_addr, sizeof(sockaddr_in6)) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not bind to address: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    sockaddr_in6 dest_addr = gateway;\n+    dest_addr.sin6_port = htons(PCP_SERVER_PORT);\n+    if (sock.Connect((struct sockaddr*)&dest_addr, sizeof(sockaddr_in6)) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not bind to connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    // Build request packet. Make sure the packet is zeroed so that reserved fields are zero\n+    // as required by the spec (and not potentially leak data).\n+    // Make sure there's space for the request header, MAP specific request\n+    // data, and one option header.\n+    uint8_t request[PCP_REQUEST_HDR_SIZE + PCP_MAP_REQUEST_SIZE + PCP_OPTION_HDR_SIZE] = {};\n+    // Fill in request header, See Figure 2.\n+    size_t ofs = 0;\n+    request[ofs + 0] = PCP_VERSION;\n+    request[ofs + 1] = PCP_OP_MAP_REQUEST;\n+    WriteBE32(request + ofs + 4, lifetime);\n+    memcpy(request + ofs + 8, &my_addr, ADDR_IPV6_SIZE);\n+\n+    ofs += PCP_REQUEST_HDR_SIZE;\n+\n+    // Fill in MAP request packet, See Figure 9.\n+    // Randomize mapping nonce (this is repeated in the response, to be able to\n+    // correlate requests and responses, and used to authenticate changes to the mapping).\n+    // TODO: remember this value when periodically renewing a mapping.\n+    GetRandBytes(Span(request + ofs + 0, PCP_MAP_NONCE_SIZE));\n+    request[ofs + 12] = PCP_PROTOCOL_TCP;\n+    WriteBE16(request + ofs + 16, port);\n+    WriteBE16(request + ofs + 18, port);\n+    memcpy(request + ofs + 20, &my_addr, ADDR_IPV6_SIZE);\n+\n+    ofs += PCP_MAP_REQUEST_SIZE;\n+\n+    // Fill in option header. See Figure 4.\n+    // Prefer failure to a different external address mapping than we expect.\n+    request[ofs] = PCP_OPTION_PREFER_FAILURE;\n+\n+    ofs += PCP_OPTION_HDR_SIZE;\n+\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    bool got_response = false;\n+    uint8_t response[PCP_MAX_SIZE];\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp6: Retrying (%d)\\n\", ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request, ofs, 0) != static_cast<ssize_t>(ofs)) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not send request: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+            return false; // Network-level error, probably no use retrying.\n+        }\n+\n+        // Wait for response(s) until we get a valid response, a network error, or time out.\n+        while (true) {\n+            Sock::Event occured = 0;\n+            if (!sock.Wait(std::chrono::milliseconds(1000), Sock::RECV, &occured)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not wait on socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+                return false; // Network-level error, probably no use retrying.\n+            }\n+            if (!occured) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp6: Timeout\\n\");\n+                break; // Retry.\n+            }\n+\n+            // Receive response.\n+            int recvsz = sock.Recv(response, sizeof(response), MSG_DONTWAIT);\n+            if (recvsz < 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not receive response: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+                return false; // Network-level error, probably no use retrying.\n+            }\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp6: Received response of %d bytes: %s\\n\", recvsz, HexStr(Span(response, recvsz)));\n+            if (static_cast<size_t>(recvsz) < (PCP_RESPONSE_HDR_SIZE + PCP_MAP_RESPONSE_SIZE)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Response too small\\n\");\n+                continue; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[0] != PCP_VERSION || response[1] != PCP_OP_MAP_RESPONSE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Response to wrong command\\n\");\n+                continue; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            // Handle MAP opcode response. See Figure 10.\n+            // Check that returned mapping nonce matches our request.\n+            if (memcmp(response + PCP_RESPONSE_HDR_SIZE, request + PCP_REQUEST_HDR_SIZE, PCP_MAP_NONCE_SIZE) != 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Mapping nonce mismatch\\n\");\n+                continue; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            uint8_t protocol = response[PCP_RESPONSE_HDR_SIZE + 12];\n+            uint16_t internal_port = ReadBE16(response + PCP_RESPONSE_HDR_SIZE + 16);\n+            if (protocol != PCP_PROTOCOL_TCP || internal_port != port) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Response protocol or port doesn't match request\\n\");\n+                continue; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            got_response = true; // Got expected response, break from receive loop as well as from retry loop.\n+            break;\n+        }\n+    }\n+    if (!got_response) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp6: Giving up after %d tries\\n\", num_tries);\n+        return false;\n+    }\n+    // If we get here, we got a valid MAP response to our request.\n+    // Check to see if we got the result we expected.\n+    int result_code = response[3];\n+    uint32_t lifetime_ret = ReadBE32(response + 4);\n+    uint16_t external_port = ReadBE16(response + PCP_RESPONSE_HDR_SIZE + 18);\n+    struct in6_addr external_addr;\n+    memcpy(&external_addr, response + PCP_RESPONSE_HDR_SIZE + 20, ADDR_IPV6_SIZE);\n+    if (result_code != PCP_RESULT_SUCCESS) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Mapping failed with result code %d\\n\", result_code);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587616861",
      "id" : 1587616861,
      "in_reply_to_id" : 1587540017,
      "line" : 221,
      "node_id" : "PRRC_kwDOABII585eoRxd",
      "original_commit_id" : "4395a42c5df14e211ca78405f599a2ed24466334",
      "original_line" : 221,
      "original_position" : 221,
      "original_start_line" : null,
      "path" : "src/ipv6-pinhole-test.cpp",
      "position" : 221,
      "pull_request_review_id" : 2035714509,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30005",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587616861/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-02T13:14:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587616861",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587618250"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30005"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587618250"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Maybe I misread it, but I think we're implicitly doing:\r\n\r\n```h\r\nPCP_OPTION_MANDATORY = 0x00\r\n... PCP_OPTION_PREFER_FAILURE | PCP_OPTION_MANDATORY\r\n```",
      "commit_id" : "4395a42c5df14e211ca78405f599a2ed24466334",
      "created_at" : "2024-05-02T13:15:50Z",
      "diff_hunk" : "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+#include <util/translation.h> // Remove this\n+\n+#include <linux/route.h>\n+\n+const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr; // Remove this\n+\n+// RFC 6887 Port Control Protocol (PCP) implementation.\n+// PCP uses network byte order (big-endian).\n+// References to sections and figures in the code below refer to https://datatracker.ietf.org/doc/html/rfc6887.\n+\n+// Protocol constants.\n+//! Maximum packet size in bytes (see section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (see section 19.1).\n+constexpr uint16_t PCP_SERVER_PORT = 5351;\n+//! Version byte. 0 is NAT-PMP, 1 is forbidden, 2 for PCP RFC-6887.\n+constexpr uint8_t PCP_VERSION = 2;\n+//! Map request opcode. See sections 19.2, 7.1.\n+constexpr uint8_t PCP_OP_MAP_REQUEST = 0x01;\n+//! Map response opcode. See sections 19.2, 7.2.\n+constexpr uint8_t PCP_OP_MAP_RESPONSE = 0x01 | 0x80;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Option: prefer failure to half-functional mapping. See section 13.2.\n+constexpr uint8_t PCP_OPTION_PREFER_FAILURE = 2;\n+//! Request header size in bytes (see section 7.1).\n+constexpr size_t PCP_REQUEST_HDR_SIZE = 24;\n+//! Response header size in bytes (see section 7.2).\n+constexpr size_t PCP_RESPONSE_HDR_SIZE = 24;\n+//! Option header size in bytes (see section 7.2).\n+constexpr size_t PCP_OPTION_HDR_SIZE = 4;\n+//! Map request size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_REQUEST_SIZE = 36;\n+//! Map response size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_RESPONSE_SIZE = 36;\n+//! Mapping nonce size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_NONCE_SIZE = 12;\n+//! Result code representing SUCCESS status (7.4).\n+constexpr uint8_t PCP_RESULT_SUCCESS = 0;\n+\n+//! Find IPv6 default gateway.\n+std::optional<sockaddr_in6> FindIPv6DefaultGateway()\n+{\n+    const auto& [read_ok, data] = ReadBinaryFile(\"/proc/net/ipv6_route\");\n+    if (!read_ok) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not read /proc/net/ipv6_route to find default IPv6 gateway\\n\");\n+        return std::nullopt;\n+    }\n+    // 149 length (longer if interface name is longer)\n+    // destination                      prefix                                 nexthop                                                     flags     iface\n+    // 00000000000000000000000000000000 00 00000000000000000000000000000000 00 fe80000000000000da58d7fffe0077cd 00000064 00000007 00000000 00000003     eth0\n+    for(std::string &line: SplitString(data, \"\\n\")) {\n+        if (line.size() < 149) continue;\n+        const std::optional<std::vector<uint8_t>> nexthop(TryParseHex<uint8_t>(line.substr(72, 32)));\n+        const std::optional<uint8_t> prefix(ToIntegral<uint8_t>(line.substr(33,  2), ADDR_IPV6_SIZE));\n+        const std::optional<uint32_t> flags(ToIntegral<uint32_t>(line.substr(132,  8), ADDR_IPV6_SIZE));\n+        const std::string iface(TrimString(line.substr(141)));\n+        if (!prefix || !nexthop | !flags || nexthop->size() != ADDR_IPV6_SIZE || iface.empty()) continue; // Parse error\n+        if (prefix.value() != 0 || (flags.value() & (RTF_GATEWAY | RTF_UP)) != (RTF_GATEWAY | RTF_UP)) continue; // Not default gw\n+        // Look up scope id for interface name string.\n+        int gateway_scope_id = if_nametoindex(iface.c_str());\n+        if (gateway_scope_id <= 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not parse gateway interface %s\\n\", iface.c_str());\n+            return std::nullopt;\n+        }\n+\n+        sockaddr_in6 dest_addr = {};\n+        dest_addr.sin6_family = AF_INET6;\n+        memcpy(&dest_addr.sin6_addr, nexthop->data(), ADDR_IPV6_SIZE);\n+        dest_addr.sin6_scope_id = gateway_scope_id;\n+        return dest_addr;\n+    }\n+    return std::nullopt;\n+}\n+\n+//! Try to open a IPv6 pinhole port using RFC 6887 Port Control Protocol (PCP).\n+bool OpenPinhole(const sockaddr_in6 &gateway, const struct in6_addr &my_addr, uint16_t port, uint32_t lifetime, int num_tries = 3)\n+{\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Opening pinhole for addr: %s\\n\", CNetAddr(my_addr).ToStringAddr());\n+\n+    // Create IPv6 UDP socket.\n+    SOCKET sock_fd = socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);\n+    if (sock_fd == INVALID_SOCKET) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not create IPv6 UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+    Sock sock(sock_fd);\n+\n+    // Make sure that we send from requested address, anything else will be\n+    // rejected by a security-conscious router.\n+    sockaddr_in6 bind_addr = {};\n+    bind_addr.sin6_family = AF_INET6;\n+    bind_addr.sin6_addr = my_addr;\n+    if (sock.Bind((struct sockaddr*)&bind_addr, sizeof(sockaddr_in6)) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not bind to address: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    sockaddr_in6 dest_addr = gateway;\n+    dest_addr.sin6_port = htons(PCP_SERVER_PORT);\n+    if (sock.Connect((struct sockaddr*)&dest_addr, sizeof(sockaddr_in6)) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not bind to connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    // Build request packet. Make sure the packet is zeroed so that reserved fields are zero\n+    // as required by the spec (and not potentially leak data).\n+    // Make sure there's space for the request header, MAP specific request\n+    // data, and one option header.\n+    uint8_t request[PCP_REQUEST_HDR_SIZE + PCP_MAP_REQUEST_SIZE + PCP_OPTION_HDR_SIZE] = {};\n+    // Fill in request header, See Figure 2.\n+    size_t ofs = 0;\n+    request[ofs + 0] = PCP_VERSION;\n+    request[ofs + 1] = PCP_OP_MAP_REQUEST;\n+    WriteBE32(request + ofs + 4, lifetime);\n+    memcpy(request + ofs + 8, &my_addr, ADDR_IPV6_SIZE);\n+\n+    ofs += PCP_REQUEST_HDR_SIZE;\n+\n+    // Fill in MAP request packet, See Figure 9.\n+    // Randomize mapping nonce (this is repeated in the response, to be able to\n+    // correlate requests and responses, and used to authenticate changes to the mapping).\n+    // TODO: remember this value when periodically renewing a mapping.\n+    GetRandBytes(Span(request + ofs + 0, PCP_MAP_NONCE_SIZE));\n+    request[ofs + 12] = PCP_PROTOCOL_TCP;\n+    WriteBE16(request + ofs + 16, port);\n+    WriteBE16(request + ofs + 18, port);\n+    memcpy(request + ofs + 20, &my_addr, ADDR_IPV6_SIZE);\n+\n+    ofs += PCP_MAP_REQUEST_SIZE;\n+\n+    // Fill in option header. See Figure 4.\n+    // Prefer failure to a different external address mapping than we expect.\n+    request[ofs] = PCP_OPTION_PREFER_FAILURE;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587618250",
      "id" : 1587618250,
      "in_reply_to_id" : 1587549683,
      "line" : 149,
      "node_id" : "PRRC_kwDOABII585eoSHK",
      "original_commit_id" : "4395a42c5df14e211ca78405f599a2ed24466334",
      "original_line" : 149,
      "original_position" : 149,
      "original_start_line" : null,
      "path" : "src/ipv6-pinhole-test.cpp",
      "position" : 149,
      "pull_request_review_id" : 2035717039,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30005",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587618250/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-02T13:15:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587618250",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587621612"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30005"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587621612"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`Sock` is used below, which is the mockable socket. The only exception is construction, so yea for testing we'd want a function where the Sock is passed in.",
      "commit_id" : "4395a42c5df14e211ca78405f599a2ed24466334",
      "created_at" : "2024-05-02T13:17:40Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+#include <util/translation.h> // Remove this\n+\n+#include <linux/route.h>\n+\n+const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr; // Remove this\n+\n+// RFC 6887 Port Control Protocol (PCP) implementation.\n+// PCP uses network byte order (big-endian).\n+// References to sections and figures in the code below refer to https://datatracker.ietf.org/doc/html/rfc6887.\n+\n+// Protocol constants.\n+//! Maximum packet size in bytes (see section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (see section 19.1).\n+constexpr uint16_t PCP_SERVER_PORT = 5351;\n+//! Version byte. 0 is NAT-PMP, 1 is forbidden, 2 for PCP RFC-6887.\n+constexpr uint8_t PCP_VERSION = 2;\n+//! Map request opcode. See sections 19.2, 7.1.\n+constexpr uint8_t PCP_OP_MAP_REQUEST = 0x01;\n+//! Map response opcode. See sections 19.2, 7.2.\n+constexpr uint8_t PCP_OP_MAP_RESPONSE = 0x01 | 0x80;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Option: prefer failure to half-functional mapping. See section 13.2.\n+constexpr uint8_t PCP_OPTION_PREFER_FAILURE = 2;\n+//! Request header size in bytes (see secion 7.1).\n+constexpr size_t PCP_REQUEST_HDR_SIZE = 24;\n+//! Response header size in bytes (see secion 7.2).\n+constexpr size_t PCP_RESPONSE_HDR_SIZE = 24;\n+//! Option header size in bytes (see secion 7.2).\n+constexpr size_t PCP_OPTION_HDR_SIZE = 4;\n+//! Map request size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_REQUEST_SIZE = 36;\n+//! Map response size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_RESPONSE_SIZE = 36;\n+//! Mapping nonce size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_NONCE_SIZE = 12;\n+//! Result code representing SUCCESS status (7.4).\n+constexpr uint8_t PCP_RESULT_SUCCESS = 0;\n+\n+//! Find IPv6 default gateway.\n+std::optional<sockaddr_in6> FindIPv6DefaultGateway()\n+{\n+    const auto& [read_ok, data] = ReadBinaryFile(\"/proc/net/ipv6_route\");\n+    if (!read_ok) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not read /proc/net/ipv6_route to find default IPv6 gateway\\n\");\n+        return std::nullopt;\n+    }\n+    // 149 length (longer if interface name is longer)\n+    // destination                      prefix                                 nexthop                                                     flags     iface\n+    // 00000000000000000000000000000000 00 00000000000000000000000000000000 00 fe80000000000000da58d7fffe0077cd 00000064 00000007 00000000 00000003     eth0\n+    for(std::string &line: SplitString(data, \"\\n\")) {\n+        if (line.size() < 149) continue;\n+        const std::optional<std::vector<uint8_t>> nexthop(TryParseHex<uint8_t>(line.substr(72, 32)));\n+        const std::optional<uint8_t> prefix(ToIntegral<uint8_t>(line.substr(33,  2), ADDR_IPV6_SIZE));\n+        const std::optional<uint32_t> flags(ToIntegral<uint32_t>(line.substr(132,  8), ADDR_IPV6_SIZE));\n+        const std::string iface(TrimString(line.substr(141)));\n+        if (!prefix || !nexthop | !flags || nexthop->size() != ADDR_IPV6_SIZE || iface.empty()) continue; // Parse error\n+        if (prefix.value() != 0 || (flags.value() & (RTF_GATEWAY | RTF_UP)) != (RTF_GATEWAY | RTF_UP)) continue; // Not default gw\n+        // Look up scope id for interface name string.\n+        int gateway_scope_id = if_nametoindex(iface.c_str());\n+        if (gateway_scope_id <= 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not parse gateway interface %s\\n\", iface.c_str());\n+            return std::nullopt;\n+        }\n+\n+        sockaddr_in6 dest_addr = {};\n+        dest_addr.sin6_family = AF_INET6;\n+        memcpy(&dest_addr.sin6_addr, nexthop->data(), ADDR_IPV6_SIZE);\n+        dest_addr.sin6_scope_id = gateway_scope_id;\n+        return dest_addr;\n+    }\n+    return std::nullopt;\n+}\n+\n+//! Try to open a IPv6 pinhole port using RFC 6887 Port Control Protocol (PCP).\n+bool OpenPinhole(const sockaddr_in6 &gateway, const struct in6_addr &my_addr, uint16_t port, uint32_t lifetime, int num_tries = 3)\n+{\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Opening pinhole for addr: %s\\n\", CNetAddr(my_addr).ToStringAddr());\n+\n+    // Create IPv6 UDP socket.\n+    SOCKET sock_fd = socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587621612",
      "id" : 1587621612,
      "in_reply_to_id" : 1587415945,
      "line" : 97,
      "node_id" : "PRRC_kwDOABII585eoS7s",
      "original_commit_id" : "fb499f555e0c559fb595fbc7b375aa632d8635ed",
      "original_line" : 97,
      "original_position" : 97,
      "original_start_line" : null,
      "path" : "src/ipv6-pinhole-test.cpp",
      "position" : 97,
      "pull_request_review_id" : 2035723020,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30005",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587621612/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-02T13:17:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587621612",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587626026"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30005"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587626026"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It might be useful for troubleshooting, though i'm not sure how happy people will be to add networking stuff to bitcoin-util. Currently it's pure-function stuff only ð ",
      "commit_id" : "4395a42c5df14e211ca78405f599a2ed24466334",
      "created_at" : "2024-05-02T13:20:40Z",
      "diff_hunk" : "@@ -801,6 +801,15 @@ bitcoind_CXXFLAGS = $(bitcoin_bin_cxxflags)\n bitcoind_LDFLAGS = $(bitcoin_bin_ldflags)\n bitcoind_LDADD = $(LIBBITCOIN_NODE) $(bitcoin_bin_ldadd)\n \n+#################################################################\n+bin_PROGRAMS += ipv6-pinhole-test",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587626026",
      "id" : 1587626026,
      "in_reply_to_id" : 1587310888,
      "line" : 805,
      "node_id" : "PRRC_kwDOABII585eoUAq",
      "original_commit_id" : "fb499f555e0c559fb595fbc7b375aa632d8635ed",
      "original_line" : 805,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/Makefile.am",
      "position" : 5,
      "pull_request_review_id" : 2035730162,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30005",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587626026/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-02T13:20:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587626026",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : ">  i'm kind of hestitant to touch that, given how hard it already is to find people to test these kind of things\r\n\r\nFor now we could add support in the test, but stick to IPv6 in the implementation. OTOH both UPnP and NAP-PMP are off by default. Adding another off-by-default checkbox \"IPv6 pinhole\" to the GUI seems pretty confusing, and probably doesn't increase the chance of users trying this.",
      "created_at" : "2024-05-02T13:21:37Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30005#issuecomment-2090487679",
      "id" : 2090487679,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30005",
      "node_id" : "IC_kwDOABII5858mk9_",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2090487679/reactions"
      },
      "updated_at" : "2024-05-02T13:21:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2090487679",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Could you rebase this on master, now that we are using the latest version of miniupnpc (https://github.com/bitcoin/bitcoin/pull/29707).\r\n\r\nYes, but first want to address @Sjors's comments. Mind that this adds an utility and is orthogonal to UPnP. Adding IPv6 pinholing through UPnP would be useful too (for routers that support that, and not PCP), so we'll likely want to be able to do both in the eventual design like we do for natpmp/UPnP for IPv4.\r\n\r\n> For now we could add support in the test, but stick to IPv6 in the implementation.\r\n\r\nSure, could. But mind that IPv4 will be mostly a different path. Default gateway discovery is different (mind that i still have to implement that for Windows and MacOS), port mapping semantics are slightly different from pinholing, the code will have to handle IPv4 addresses. This added complexity makes it harder to review, too.\r\n\r\n> Adding another off-by-default checkbox \"IPv6 pinhole\" to the GUI seems pretty confusing, and probably doesn't increase the chance of users trying this.\r\n\r\ni would like it enabled by default, i am not sure people have that much confidence in my code lol. But it's a discussion for the integration PR, we'll probably aim to merge it with disabled-default first to move forward at all.",
      "created_at" : "2024-05-02T13:31:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30005#issuecomment-2090509155",
      "id" : 2090509155,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30005",
      "node_id" : "IC_kwDOABII5858mqNj",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2090509155/reactions"
      },
      "updated_at" : "2024-05-02T13:31:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2090509155",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Mind that this adds an utility and is orthogonal to UPnP.\r\n\r\n~0. Right, I have misunderstood what this is/does. This could be a useful tool (for some % of users of this software), but I don't think this repository is the right place for it to live, or that it fits into the set of things we should be maintaining here (I'm really suprised there isn't software that already exists, for doing the same thing, that we could just point users to?).",
      "created_at" : "2024-05-02T13:36:44Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30005#issuecomment-2090522477",
      "id" : 2090522477,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30005",
      "node_id" : "IC_kwDOABII5858mtdt",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2090522477/reactions"
      },
      "updated_at" : "2024-05-02T13:37:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2090522477",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "This is a temporary PR for people to test this code, i intend to integrate it in bitcoind just like the current IPv4 port mapping stuff. I did not intend it to be a useful tool to keep around. This is why the title says \"nomerge\".",
      "created_at" : "2024-05-02T13:47:41Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30005#issuecomment-2090546884",
      "id" : 2090546884,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30005",
      "node_id" : "IC_kwDOABII5858mzbE",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2090546884/reactions"
      },
      "updated_at" : "2024-05-02T13:47:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2090546884",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> I did not intend it to be a useful tool to keep around. \r\n\r\nFair enough, I'll -redirect my NACK to this thread: https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587310888.",
      "created_at" : "2024-05-02T13:49:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30005#issuecomment-2090550845",
      "id" : 2090550845,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30005",
      "node_id" : "IC_kwDOABII5858m0Y9",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2090550845/reactions"
      },
      "updated_at" : "2024-05-02T13:49:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2090550845",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587671315"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30005"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587671315"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> You could make this a permanent debugging utility by adding it to bitcoin-util.\r\n\r\nConcept NACK.",
      "commit_id" : "4395a42c5df14e211ca78405f599a2ed24466334",
      "created_at" : "2024-05-02T13:49:46Z",
      "diff_hunk" : "@@ -801,6 +801,15 @@ bitcoind_CXXFLAGS = $(bitcoin_bin_cxxflags)\n bitcoind_LDFLAGS = $(bitcoin_bin_ldflags)\n bitcoind_LDADD = $(LIBBITCOIN_NODE) $(bitcoin_bin_ldadd)\n \n+#################################################################\n+bin_PROGRAMS += ipv6-pinhole-test",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587671315",
      "id" : 1587671315,
      "in_reply_to_id" : 1587310888,
      "line" : 805,
      "node_id" : "PRRC_kwDOABII585eofET",
      "original_commit_id" : "fb499f555e0c559fb595fbc7b375aa632d8635ed",
      "original_line" : 805,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/Makefile.am",
      "position" : 5,
      "pull_request_review_id" : 2035804931,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30005",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587671315/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-02T13:49:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587671315",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Sure, could. But mind that IPv4 will be mostly a different path.\r\n\r\nI see. I guess future UI confusion can ben prevented by calling this \"PCP\" with a note saying that it works with IPv6 only for now.\r\n\r\nThe GUI could also hide the kitchen sink of methods under some advanced toggle. In any case that doesn't affect testing.",
      "created_at" : "2024-05-02T14:02:21Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30005#issuecomment-2090577873",
      "id" : 2090577873,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30005",
      "node_id" : "IC_kwDOABII5858m6_R",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2090577873/reactions"
      },
      "updated_at" : "2024-05-02T14:02:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2090577873",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> I see. I guess future UI confusion can ben prevented by calling this \"PCP\" with a note saying that it works with IPv6 only for now.\r\n\r\nOK, i see your point now. Let's replace NAT-PMP for IPv4 at the same time, so we keep the same number of options (PCP and UPnP), and lose one dependency (libnatpnp).",
      "created_at" : "2024-05-02T14:23:35Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30005#issuecomment-2090624771",
      "id" : 2090624771,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30005",
      "node_id" : "IC_kwDOABII5858nGcD",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2090624771/reactions"
      },
      "updated_at" : "2024-05-02T14:48:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2090624771",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> I'm really suprised there isn't software that already exists, for doing the same thing, that we could just point users to?\r\n\r\nIf there's a library that does the same thing, and doesn't have 1 million lines of code, then it seems fine to include it. We can also make it a library under the core repo, which perhaps other projects will find useful for its simplicity. At least now I have a sense of what that library should be doing.\r\n\r\nI don't think we should ask users to install a separate piece of software. For HWI I understand the argument of not wanting to include USB support in our codebase. But this protocol is much simpler (one UDP message and one reply).\r\n\r\nSome extra maintenance work seems justified here because there's at least a plausible risk that we're running short on listening nodes, if we turn on Asmap: https://github.com/bitcoin/bitcoin/issues/16599#issuecomment-1917362538\r\n\r\n\r\n\r\nAlso, I was under the assumption that the reason we added NAT-PMP originally was to eventually replace UPnP (see #11902). Have those concerns been reduced? Do you see PCP as a potential replacement for both NAT-PMP and UPnP? Or not sure, let's keep them all around for now?",
      "created_at" : "2024-05-02T15:19:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30005#issuecomment-2090792385",
      "id" : 2090792385,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30005",
      "node_id" : "IC_kwDOABII5858nvXB",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2090792385/reactions"
      },
      "updated_at" : "2024-05-02T15:29:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2090792385",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587827580"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30005"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587827580"
         }
      },
      "author_association" : "MEMBER",
      "body" : "No need to add networking indeed. As long as the eventual implementation (library or otherwise) has proper debug logging, we probably won't need a standalone tool for that.",
      "commit_id" : "4395a42c5df14e211ca78405f599a2ed24466334",
      "created_at" : "2024-05-02T15:20:51Z",
      "diff_hunk" : "@@ -801,6 +801,15 @@ bitcoind_CXXFLAGS = $(bitcoin_bin_cxxflags)\n bitcoind_LDFLAGS = $(bitcoin_bin_ldflags)\n bitcoind_LDADD = $(LIBBITCOIN_NODE) $(bitcoin_bin_ldadd)\n \n+#################################################################\n+bin_PROGRAMS += ipv6-pinhole-test",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587827580",
      "id" : 1587827580,
      "in_reply_to_id" : 1587310888,
      "line" : 805,
      "node_id" : "PRRC_kwDOABII585epFN8",
      "original_commit_id" : "fb499f555e0c559fb595fbc7b375aa632d8635ed",
      "original_line" : 805,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/Makefile.am",
      "position" : 5,
      "pull_request_review_id" : 2036061995,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30005",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587827580/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-02T15:20:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587827580",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "i mean, there's probably some crappy C implementation of PCP out there that we could include, but this one is written in C++, it integrates with bitcoin's networking and logging, well commented, and it's straightforward enough. Besides, any code included from a third party would have to be reviewed just as well.\r\n\r\ni've already agreed to add IPv4 support so it can replace libnatpmp.\r\n\r\n@fanquake's comment was based on a misunderstanding.",
      "created_at" : "2024-05-02T16:18:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30005#issuecomment-2090946812",
      "id" : 2090946812,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30005",
      "node_id" : "IC_kwDOABII5858oVD8",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2090946812/reactions"
      },
      "updated_at" : "2024-05-02T16:18:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2090946812",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587940735"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30005"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587940735"
         }
      },
      "author_association" : "MEMBER",
      "body" : "i don't think that's the case. The mandatory flag is not a user choice, it's part of the RFC definition of the option:\r\n- Figure 14 says \"Option Code=2\" only.\r\n- Section 19.4 says \"The values 0-127 are mandatory to process, and 128-255 are optional to process.\" This implies these are disjunct ranges.\r\n\r\nIn any case, we could be more lenient about this and leave out the option if we're willing to accept different addresses (or maybe even ports) and advertise them (which is necessary for IPv4 anyway).",
      "commit_id" : "4395a42c5df14e211ca78405f599a2ed24466334",
      "created_at" : "2024-05-02T16:32:01Z",
      "diff_hunk" : "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+#include <util/translation.h> // Remove this\n+\n+#include <linux/route.h>\n+\n+const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr; // Remove this\n+\n+// RFC 6887 Port Control Protocol (PCP) implementation.\n+// PCP uses network byte order (big-endian).\n+// References to sections and figures in the code below refer to https://datatracker.ietf.org/doc/html/rfc6887.\n+\n+// Protocol constants.\n+//! Maximum packet size in bytes (see section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (see section 19.1).\n+constexpr uint16_t PCP_SERVER_PORT = 5351;\n+//! Version byte. 0 is NAT-PMP, 1 is forbidden, 2 for PCP RFC-6887.\n+constexpr uint8_t PCP_VERSION = 2;\n+//! Map request opcode. See sections 19.2, 7.1.\n+constexpr uint8_t PCP_OP_MAP_REQUEST = 0x01;\n+//! Map response opcode. See sections 19.2, 7.2.\n+constexpr uint8_t PCP_OP_MAP_RESPONSE = 0x01 | 0x80;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Option: prefer failure to half-functional mapping. See section 13.2.\n+constexpr uint8_t PCP_OPTION_PREFER_FAILURE = 2;\n+//! Request header size in bytes (see section 7.1).\n+constexpr size_t PCP_REQUEST_HDR_SIZE = 24;\n+//! Response header size in bytes (see section 7.2).\n+constexpr size_t PCP_RESPONSE_HDR_SIZE = 24;\n+//! Option header size in bytes (see section 7.2).\n+constexpr size_t PCP_OPTION_HDR_SIZE = 4;\n+//! Map request size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_REQUEST_SIZE = 36;\n+//! Map response size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_RESPONSE_SIZE = 36;\n+//! Mapping nonce size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_NONCE_SIZE = 12;\n+//! Result code representing SUCCESS status (7.4).\n+constexpr uint8_t PCP_RESULT_SUCCESS = 0;\n+\n+//! Find IPv6 default gateway.\n+std::optional<sockaddr_in6> FindIPv6DefaultGateway()\n+{\n+    const auto& [read_ok, data] = ReadBinaryFile(\"/proc/net/ipv6_route\");\n+    if (!read_ok) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not read /proc/net/ipv6_route to find default IPv6 gateway\\n\");\n+        return std::nullopt;\n+    }\n+    // 149 length (longer if interface name is longer)\n+    // destination                      prefix                                 nexthop                                                     flags     iface\n+    // 00000000000000000000000000000000 00 00000000000000000000000000000000 00 fe80000000000000da58d7fffe0077cd 00000064 00000007 00000000 00000003     eth0\n+    for(std::string &line: SplitString(data, \"\\n\")) {\n+        if (line.size() < 149) continue;\n+        const std::optional<std::vector<uint8_t>> nexthop(TryParseHex<uint8_t>(line.substr(72, 32)));\n+        const std::optional<uint8_t> prefix(ToIntegral<uint8_t>(line.substr(33,  2), ADDR_IPV6_SIZE));\n+        const std::optional<uint32_t> flags(ToIntegral<uint32_t>(line.substr(132,  8), ADDR_IPV6_SIZE));\n+        const std::string iface(TrimString(line.substr(141)));\n+        if (!prefix || !nexthop | !flags || nexthop->size() != ADDR_IPV6_SIZE || iface.empty()) continue; // Parse error\n+        if (prefix.value() != 0 || (flags.value() & (RTF_GATEWAY | RTF_UP)) != (RTF_GATEWAY | RTF_UP)) continue; // Not default gw\n+        // Look up scope id for interface name string.\n+        int gateway_scope_id = if_nametoindex(iface.c_str());\n+        if (gateway_scope_id <= 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not parse gateway interface %s\\n\", iface.c_str());\n+            return std::nullopt;\n+        }\n+\n+        sockaddr_in6 dest_addr = {};\n+        dest_addr.sin6_family = AF_INET6;\n+        memcpy(&dest_addr.sin6_addr, nexthop->data(), ADDR_IPV6_SIZE);\n+        dest_addr.sin6_scope_id = gateway_scope_id;\n+        return dest_addr;\n+    }\n+    return std::nullopt;\n+}\n+\n+//! Try to open a IPv6 pinhole port using RFC 6887 Port Control Protocol (PCP).\n+bool OpenPinhole(const sockaddr_in6 &gateway, const struct in6_addr &my_addr, uint16_t port, uint32_t lifetime, int num_tries = 3)\n+{\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Opening pinhole for addr: %s\\n\", CNetAddr(my_addr).ToStringAddr());\n+\n+    // Create IPv6 UDP socket.\n+    SOCKET sock_fd = socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);\n+    if (sock_fd == INVALID_SOCKET) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not create IPv6 UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+    Sock sock(sock_fd);\n+\n+    // Make sure that we send from requested address, anything else will be\n+    // rejected by a security-conscious router.\n+    sockaddr_in6 bind_addr = {};\n+    bind_addr.sin6_family = AF_INET6;\n+    bind_addr.sin6_addr = my_addr;\n+    if (sock.Bind((struct sockaddr*)&bind_addr, sizeof(sockaddr_in6)) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not bind to address: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    sockaddr_in6 dest_addr = gateway;\n+    dest_addr.sin6_port = htons(PCP_SERVER_PORT);\n+    if (sock.Connect((struct sockaddr*)&dest_addr, sizeof(sockaddr_in6)) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not bind to connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    // Build request packet. Make sure the packet is zeroed so that reserved fields are zero\n+    // as required by the spec (and not potentially leak data).\n+    // Make sure there's space for the request header, MAP specific request\n+    // data, and one option header.\n+    uint8_t request[PCP_REQUEST_HDR_SIZE + PCP_MAP_REQUEST_SIZE + PCP_OPTION_HDR_SIZE] = {};\n+    // Fill in request header, See Figure 2.\n+    size_t ofs = 0;\n+    request[ofs + 0] = PCP_VERSION;\n+    request[ofs + 1] = PCP_OP_MAP_REQUEST;\n+    WriteBE32(request + ofs + 4, lifetime);\n+    memcpy(request + ofs + 8, &my_addr, ADDR_IPV6_SIZE);\n+\n+    ofs += PCP_REQUEST_HDR_SIZE;\n+\n+    // Fill in MAP request packet, See Figure 9.\n+    // Randomize mapping nonce (this is repeated in the response, to be able to\n+    // correlate requests and responses, and used to authenticate changes to the mapping).\n+    // TODO: remember this value when periodically renewing a mapping.\n+    GetRandBytes(Span(request + ofs + 0, PCP_MAP_NONCE_SIZE));\n+    request[ofs + 12] = PCP_PROTOCOL_TCP;\n+    WriteBE16(request + ofs + 16, port);\n+    WriteBE16(request + ofs + 18, port);\n+    memcpy(request + ofs + 20, &my_addr, ADDR_IPV6_SIZE);\n+\n+    ofs += PCP_MAP_REQUEST_SIZE;\n+\n+    // Fill in option header. See Figure 4.\n+    // Prefer failure to a different external address mapping than we expect.\n+    request[ofs] = PCP_OPTION_PREFER_FAILURE;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587940735",
      "id" : 1587940735,
      "in_reply_to_id" : 1587549683,
      "line" : 149,
      "node_id" : "PRRC_kwDOABII585epg1_",
      "original_commit_id" : "4395a42c5df14e211ca78405f599a2ed24466334",
      "original_line" : 149,
      "original_position" : 149,
      "original_start_line" : null,
      "path" : "src/ipv6-pinhole-test.cpp",
      "position" : 149,
      "pull_request_review_id" : 2036262494,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30005",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587940735/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-02T16:41:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587940735",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587955428"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30005"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587955428"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Right. Let's not do this. Such a stand-alone tool, if it is useful, doesn't need to be part of bitcoin.",
      "commit_id" : "4395a42c5df14e211ca78405f599a2ed24466334",
      "created_at" : "2024-05-02T16:40:15Z",
      "diff_hunk" : "@@ -801,6 +801,15 @@ bitcoind_CXXFLAGS = $(bitcoin_bin_cxxflags)\n bitcoind_LDFLAGS = $(bitcoin_bin_ldflags)\n bitcoind_LDADD = $(LIBBITCOIN_NODE) $(bitcoin_bin_ldadd)\n \n+#################################################################\n+bin_PROGRAMS += ipv6-pinhole-test",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587955428",
      "id" : 1587955428,
      "in_reply_to_id" : 1587310888,
      "line" : 805,
      "node_id" : "PRRC_kwDOABII585epkbk",
      "original_commit_id" : "fb499f555e0c559fb595fbc7b375aa632d8635ed",
      "original_line" : 805,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/Makefile.am",
      "position" : 5,
      "pull_request_review_id" : 2036284085,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30005",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587955428/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-02T16:40:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587955428",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587973156"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30005"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587973156"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I was looking at 7.3:\r\n\r\n> Option Code:  8 bits.  Its most significant bit indicates if this\r\n>      option is mandatory (0) or optional (1) to process.\r\n\r\nBut that's implied by using these integer ranges.\r\n\r\n\r\nTend to agree we should drop this option, though we should pay attention to its return value. Otherwise we'd potentially gossip the wrong port (in practice this likely only happens if you have two nodes in the same home).",
      "commit_id" : "4395a42c5df14e211ca78405f599a2ed24466334",
      "created_at" : "2024-05-02T16:55:03Z",
      "diff_hunk" : "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+#include <util/translation.h> // Remove this\n+\n+#include <linux/route.h>\n+\n+const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr; // Remove this\n+\n+// RFC 6887 Port Control Protocol (PCP) implementation.\n+// PCP uses network byte order (big-endian).\n+// References to sections and figures in the code below refer to https://datatracker.ietf.org/doc/html/rfc6887.\n+\n+// Protocol constants.\n+//! Maximum packet size in bytes (see section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (see section 19.1).\n+constexpr uint16_t PCP_SERVER_PORT = 5351;\n+//! Version byte. 0 is NAT-PMP, 1 is forbidden, 2 for PCP RFC-6887.\n+constexpr uint8_t PCP_VERSION = 2;\n+//! Map request opcode. See sections 19.2, 7.1.\n+constexpr uint8_t PCP_OP_MAP_REQUEST = 0x01;\n+//! Map response opcode. See sections 19.2, 7.2.\n+constexpr uint8_t PCP_OP_MAP_RESPONSE = 0x01 | 0x80;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Option: prefer failure to half-functional mapping. See section 13.2.\n+constexpr uint8_t PCP_OPTION_PREFER_FAILURE = 2;\n+//! Request header size in bytes (see section 7.1).\n+constexpr size_t PCP_REQUEST_HDR_SIZE = 24;\n+//! Response header size in bytes (see section 7.2).\n+constexpr size_t PCP_RESPONSE_HDR_SIZE = 24;\n+//! Option header size in bytes (see section 7.2).\n+constexpr size_t PCP_OPTION_HDR_SIZE = 4;\n+//! Map request size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_REQUEST_SIZE = 36;\n+//! Map response size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_RESPONSE_SIZE = 36;\n+//! Mapping nonce size in bytes (see section 11.1).\n+constexpr size_t PCP_MAP_NONCE_SIZE = 12;\n+//! Result code representing SUCCESS status (7.4).\n+constexpr uint8_t PCP_RESULT_SUCCESS = 0;\n+\n+//! Find IPv6 default gateway.\n+std::optional<sockaddr_in6> FindIPv6DefaultGateway()\n+{\n+    const auto& [read_ok, data] = ReadBinaryFile(\"/proc/net/ipv6_route\");\n+    if (!read_ok) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not read /proc/net/ipv6_route to find default IPv6 gateway\\n\");\n+        return std::nullopt;\n+    }\n+    // 149 length (longer if interface name is longer)\n+    // destination                      prefix                                 nexthop                                                     flags     iface\n+    // 00000000000000000000000000000000 00 00000000000000000000000000000000 00 fe80000000000000da58d7fffe0077cd 00000064 00000007 00000000 00000003     eth0\n+    for(std::string &line: SplitString(data, \"\\n\")) {\n+        if (line.size() < 149) continue;\n+        const std::optional<std::vector<uint8_t>> nexthop(TryParseHex<uint8_t>(line.substr(72, 32)));\n+        const std::optional<uint8_t> prefix(ToIntegral<uint8_t>(line.substr(33,  2), ADDR_IPV6_SIZE));\n+        const std::optional<uint32_t> flags(ToIntegral<uint32_t>(line.substr(132,  8), ADDR_IPV6_SIZE));\n+        const std::string iface(TrimString(line.substr(141)));\n+        if (!prefix || !nexthop | !flags || nexthop->size() != ADDR_IPV6_SIZE || iface.empty()) continue; // Parse error\n+        if (prefix.value() != 0 || (flags.value() & (RTF_GATEWAY | RTF_UP)) != (RTF_GATEWAY | RTF_UP)) continue; // Not default gw\n+        // Look up scope id for interface name string.\n+        int gateway_scope_id = if_nametoindex(iface.c_str());\n+        if (gateway_scope_id <= 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not parse gateway interface %s\\n\", iface.c_str());\n+            return std::nullopt;\n+        }\n+\n+        sockaddr_in6 dest_addr = {};\n+        dest_addr.sin6_family = AF_INET6;\n+        memcpy(&dest_addr.sin6_addr, nexthop->data(), ADDR_IPV6_SIZE);\n+        dest_addr.sin6_scope_id = gateway_scope_id;\n+        return dest_addr;\n+    }\n+    return std::nullopt;\n+}\n+\n+//! Try to open a IPv6 pinhole port using RFC 6887 Port Control Protocol (PCP).\n+bool OpenPinhole(const sockaddr_in6 &gateway, const struct in6_addr &my_addr, uint16_t port, uint32_t lifetime, int num_tries = 3)\n+{\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Opening pinhole for addr: %s\\n\", CNetAddr(my_addr).ToStringAddr());\n+\n+    // Create IPv6 UDP socket.\n+    SOCKET sock_fd = socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);\n+    if (sock_fd == INVALID_SOCKET) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not create IPv6 UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+    Sock sock(sock_fd);\n+\n+    // Make sure that we send from requested address, anything else will be\n+    // rejected by a security-conscious router.\n+    sockaddr_in6 bind_addr = {};\n+    bind_addr.sin6_family = AF_INET6;\n+    bind_addr.sin6_addr = my_addr;\n+    if (sock.Bind((struct sockaddr*)&bind_addr, sizeof(sockaddr_in6)) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not bind to address: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    sockaddr_in6 dest_addr = gateway;\n+    dest_addr.sin6_port = htons(PCP_SERVER_PORT);\n+    if (sock.Connect((struct sockaddr*)&dest_addr, sizeof(sockaddr_in6)) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp6: Could not bind to connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    // Build request packet. Make sure the packet is zeroed so that reserved fields are zero\n+    // as required by the spec (and not potentially leak data).\n+    // Make sure there's space for the request header, MAP specific request\n+    // data, and one option header.\n+    uint8_t request[PCP_REQUEST_HDR_SIZE + PCP_MAP_REQUEST_SIZE + PCP_OPTION_HDR_SIZE] = {};\n+    // Fill in request header, See Figure 2.\n+    size_t ofs = 0;\n+    request[ofs + 0] = PCP_VERSION;\n+    request[ofs + 1] = PCP_OP_MAP_REQUEST;\n+    WriteBE32(request + ofs + 4, lifetime);\n+    memcpy(request + ofs + 8, &my_addr, ADDR_IPV6_SIZE);\n+\n+    ofs += PCP_REQUEST_HDR_SIZE;\n+\n+    // Fill in MAP request packet, See Figure 9.\n+    // Randomize mapping nonce (this is repeated in the response, to be able to\n+    // correlate requests and responses, and used to authenticate changes to the mapping).\n+    // TODO: remember this value when periodically renewing a mapping.\n+    GetRandBytes(Span(request + ofs + 0, PCP_MAP_NONCE_SIZE));\n+    request[ofs + 12] = PCP_PROTOCOL_TCP;\n+    WriteBE16(request + ofs + 16, port);\n+    WriteBE16(request + ofs + 18, port);\n+    memcpy(request + ofs + 20, &my_addr, ADDR_IPV6_SIZE);\n+\n+    ofs += PCP_MAP_REQUEST_SIZE;\n+\n+    // Fill in option header. See Figure 4.\n+    // Prefer failure to a different external address mapping than we expect.\n+    request[ofs] = PCP_OPTION_PREFER_FAILURE;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30005#discussion_r1587973156",
      "id" : 1587973156,
      "in_reply_to_id" : 1587549683,
      "line" : 149,
      "node_id" : "PRRC_kwDOABII585epowk",
      "original_commit_id" : "4395a42c5df14e211ca78405f599a2ed24466334",
      "original_line" : 149,
      "original_position" : 149,
      "original_start_line" : null,
      "path" : "src/ipv6-pinhole-test.cpp",
      "position" : 149,
      "pull_request_review_id" : 2036313619,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30005",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587973156/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-02T16:55:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1587973156",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@sjors It creates a IPv4 as well as IPv6 mappings now. The added complexity isn't even too bad, mostly a matter of using CNetAddr/CService/Sock abstraction that we already have.",
      "created_at" : "2024-05-04T15:48:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30005#issuecomment-2094269014",
      "id" : 2094269014,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30005",
      "node_id" : "IC_kwDOABII58581AJW",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2094269014/reactions"
      },
      "updated_at" : "2024-05-04T15:48:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2094269014",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   }
]
