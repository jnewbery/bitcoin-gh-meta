[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage\nFor detailed information about the code coverage, see the [test coverage report](https://corecheck.dev/bitcoin/bitcoin/pulls/30083).\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\nA summary of reviews will appear here.\n",
      "created_at" : "2024-05-10T20:43:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30083#issuecomment-2105247787",
      "id" : 2105247787,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30083",
      "node_id" : "IC_kwDOABII5859e4gr",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2105247787/reactions"
      },
      "updated_at" : "2024-05-10T20:43:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2105247787",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30083#discussion_r1598754079"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30083"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1598754079"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"kernel: Remove batchpriority from kernel library\" (04ffe4061da2d0135f206032e167703772b5da78)\r\n\r\nI think it might be useful to keep the `// End scope of ImportNow` comment here. If someone is adding new code at this point, it's possible they might want to add it with importing set to false, or importing set to true, so the comment would be a reminder that the value will change at this point.",
      "commit_id" : "04ffe4061da2d0135f206032e167703772b5da78",
      "created_at" : "2024-05-13T16:34:05Z",
      "diff_hunk" : "@@ -1175,69 +1175,65 @@ class ImportingNow\n \n void ImportBlocks(ChainstateManager& chainman, std::vector<fs::path> vImportFiles)\n {\n-    ScheduleBatchPriority();\n-\n-    {\n-        ImportingNow imp{chainman.m_blockman.m_importing};\n-\n-        // -reindex\n-        if (fReindex) {\n-            int nFile = 0;\n-            // Map of disk positions for blocks with unknown parent (only used for reindex);\n-            // parent hash -> child disk position, multiple children can have the same parent.\n-            std::multimap<uint256, FlatFilePos> blocks_with_unknown_parent;\n-            while (true) {\n-                FlatFilePos pos(nFile, 0);\n-                if (!fs::exists(chainman.m_blockman.GetBlockPosFilename(pos))) {\n-                    break; // No block files left to reindex\n-                }\n-                AutoFile file{chainman.m_blockman.OpenBlockFile(pos, true)};\n-                if (file.IsNull()) {\n-                    break; // This error is logged in OpenBlockFile\n-                }\n-                LogPrintf(\"Reindexing block file blk%05u.dat...\\n\", (unsigned int)nFile);\n-                chainman.LoadExternalBlockFile(file, &pos, &blocks_with_unknown_parent);\n-                if (chainman.m_interrupt) {\n-                    LogPrintf(\"Interrupt requested. Exit %s\\n\", __func__);\n-                    return;\n-                }\n-                nFile++;\n+    ImportingNow imp{chainman.m_blockman.m_importing};\n+\n+    // -reindex\n+    if (fReindex) {\n+        int nFile = 0;\n+        // Map of disk positions for blocks with unknown parent (only used for reindex);\n+        // parent hash -> child disk position, multiple children can have the same parent.\n+        std::multimap<uint256, FlatFilePos> blocks_with_unknown_parent;\n+        while (true) {\n+            FlatFilePos pos(nFile, 0);\n+            if (!fs::exists(chainman.m_blockman.GetBlockPosFilename(pos))) {\n+                break; // No block files left to reindex\n             }\n-            WITH_LOCK(::cs_main, chainman.m_blockman.m_block_tree_db->WriteReindexing(false));\n-            fReindex = false;\n-            LogPrintf(\"Reindexing finished\\n\");\n-            // To avoid ending up in a situation without genesis block, re-try initializing (no-op if reindexing worked):\n-            chainman.ActiveChainstate().LoadGenesisBlock();\n+            AutoFile file{chainman.m_blockman.OpenBlockFile(pos, true)};\n+            if (file.IsNull()) {\n+                break; // This error is logged in OpenBlockFile\n+            }\n+            LogPrintf(\"Reindexing block file blk%05u.dat...\\n\", (unsigned int)nFile);\n+            chainman.LoadExternalBlockFile(file, &pos, &blocks_with_unknown_parent);\n+            if (chainman.m_interrupt) {\n+                LogPrintf(\"Interrupt requested. Exit %s\\n\", __func__);\n+                return;\n+            }\n+            nFile++;\n         }\n-\n-        // -loadblock=\n-        for (const fs::path& path : vImportFiles) {\n-            AutoFile file{fsbridge::fopen(path, \"rb\")};\n-            if (!file.IsNull()) {\n-                LogPrintf(\"Importing blocks file %s...\\n\", fs::PathToString(path));\n-                chainman.LoadExternalBlockFile(file);\n-                if (chainman.m_interrupt) {\n-                    LogPrintf(\"Interrupt requested. Exit %s\\n\", __func__);\n-                    return;\n-                }\n-            } else {\n-                LogPrintf(\"Warning: Could not open blocks file %s\\n\", fs::PathToString(path));\n+        WITH_LOCK(::cs_main, chainman.m_blockman.m_block_tree_db->WriteReindexing(false));\n+        fReindex = false;\n+        LogPrintf(\"Reindexing finished\\n\");\n+        // To avoid ending up in a situation without genesis block, re-try initializing (no-op if reindexing worked):\n+        chainman.ActiveChainstate().LoadGenesisBlock();\n+    }\n+\n+    // -loadblock=\n+    for (const fs::path& path : vImportFiles) {\n+        AutoFile file{fsbridge::fopen(path, \"rb\")};\n+        if (!file.IsNull()) {\n+            LogPrintf(\"Importing blocks file %s...\\n\", fs::PathToString(path));\n+            chainman.LoadExternalBlockFile(file);\n+            if (chainman.m_interrupt) {\n+                LogPrintf(\"Interrupt requested. Exit %s\\n\", __func__);\n+                return;\n             }\n+        } else {\n+            LogPrintf(\"Warning: Could not open blocks file %s\\n\", fs::PathToString(path));\n         }\n+    }\n \n-        // scan for better chains in the block chain database, that are not yet connected in the active best chain\n+    // scan for better chains in the block chain database, that are not yet connected in the active best chain\n \n-        // We can't hold cs_main during ActivateBestChain even though we're accessing\n-        // the chainman unique_ptrs since ABC requires us not to be holding cs_main, so retrieve\n-        // the relevant pointers before the ABC call.\n-        for (Chainstate* chainstate : WITH_LOCK(::cs_main, return chainman.GetAll())) {\n-            BlockValidationState state;\n-            if (!chainstate->ActivateBestChain(state, nullptr)) {\n-                chainman.GetNotifications().fatalError(strprintf(_(\"Failed to connect best block (%s).\"), state.ToString()));\n-                return;\n-            }\n+    // We can't hold cs_main during ActivateBestChain even though we're accessing\n+    // the chainman unique_ptrs since ABC requires us not to be holding cs_main, so retrieve\n+    // the relevant pointers before the ABC call.\n+    for (Chainstate* chainstate : WITH_LOCK(::cs_main, return chainman.GetAll())) {\n+        BlockValidationState state;\n+        if (!chainstate->ActivateBestChain(state, nullptr)) {\n+            chainman.GetNotifications().fatalError(strprintf(_(\"Failed to connect best block (%s).\"), state.ToString()));\n+            return;\n         }\n-    } // End scope of ImportingNow",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30083#discussion_r1598754079",
      "id" : 1598754079,
      "line" : 1240,
      "node_id" : "PRRC_kwDOABII585fSw0f",
      "original_commit_id" : "04ffe4061da2d0135f206032e167703772b5da78",
      "original_line" : 1240,
      "original_position" : 117,
      "original_start_line" : null,
      "path" : "src/node/blockstorage.cpp",
      "position" : 117,
      "pull_request_review_id" : 2053188813,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30083",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1598754079/reactions"
      },
      "side" : "LEFT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-13T16:35:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1598754079",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30083#discussion_r1598809395"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30083"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1598809395"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Do you want to preserve the comment or the scoping? I was on the fence about this, but decided to drop the scoping after the introduced RAII wrappers for the ECC context, which don't scope either: https://github.com/bitcoin/bitcoin/pull/29252/files#diff-dbfadb3e0332664bff298a329b1d27065d2decbbe43fd391388af18f5861c114R17\r\n\r\nBesides, I don't think it is likely that his function will grow. It is finally scoped in a reasonably limited way now. If a more functionality is added, it should probably go in another function and removing the scoping as done here encourages that.",
      "commit_id" : "04ffe4061da2d0135f206032e167703772b5da78",
      "created_at" : "2024-05-13T17:23:28Z",
      "diff_hunk" : "@@ -1175,69 +1175,65 @@ class ImportingNow\n \n void ImportBlocks(ChainstateManager& chainman, std::vector<fs::path> vImportFiles)\n {\n-    ScheduleBatchPriority();\n-\n-    {\n-        ImportingNow imp{chainman.m_blockman.m_importing};\n-\n-        // -reindex\n-        if (fReindex) {\n-            int nFile = 0;\n-            // Map of disk positions for blocks with unknown parent (only used for reindex);\n-            // parent hash -> child disk position, multiple children can have the same parent.\n-            std::multimap<uint256, FlatFilePos> blocks_with_unknown_parent;\n-            while (true) {\n-                FlatFilePos pos(nFile, 0);\n-                if (!fs::exists(chainman.m_blockman.GetBlockPosFilename(pos))) {\n-                    break; // No block files left to reindex\n-                }\n-                AutoFile file{chainman.m_blockman.OpenBlockFile(pos, true)};\n-                if (file.IsNull()) {\n-                    break; // This error is logged in OpenBlockFile\n-                }\n-                LogPrintf(\"Reindexing block file blk%05u.dat...\\n\", (unsigned int)nFile);\n-                chainman.LoadExternalBlockFile(file, &pos, &blocks_with_unknown_parent);\n-                if (chainman.m_interrupt) {\n-                    LogPrintf(\"Interrupt requested. Exit %s\\n\", __func__);\n-                    return;\n-                }\n-                nFile++;\n+    ImportingNow imp{chainman.m_blockman.m_importing};\n+\n+    // -reindex\n+    if (fReindex) {\n+        int nFile = 0;\n+        // Map of disk positions for blocks with unknown parent (only used for reindex);\n+        // parent hash -> child disk position, multiple children can have the same parent.\n+        std::multimap<uint256, FlatFilePos> blocks_with_unknown_parent;\n+        while (true) {\n+            FlatFilePos pos(nFile, 0);\n+            if (!fs::exists(chainman.m_blockman.GetBlockPosFilename(pos))) {\n+                break; // No block files left to reindex\n             }\n-            WITH_LOCK(::cs_main, chainman.m_blockman.m_block_tree_db->WriteReindexing(false));\n-            fReindex = false;\n-            LogPrintf(\"Reindexing finished\\n\");\n-            // To avoid ending up in a situation without genesis block, re-try initializing (no-op if reindexing worked):\n-            chainman.ActiveChainstate().LoadGenesisBlock();\n+            AutoFile file{chainman.m_blockman.OpenBlockFile(pos, true)};\n+            if (file.IsNull()) {\n+                break; // This error is logged in OpenBlockFile\n+            }\n+            LogPrintf(\"Reindexing block file blk%05u.dat...\\n\", (unsigned int)nFile);\n+            chainman.LoadExternalBlockFile(file, &pos, &blocks_with_unknown_parent);\n+            if (chainman.m_interrupt) {\n+                LogPrintf(\"Interrupt requested. Exit %s\\n\", __func__);\n+                return;\n+            }\n+            nFile++;\n         }\n-\n-        // -loadblock=\n-        for (const fs::path& path : vImportFiles) {\n-            AutoFile file{fsbridge::fopen(path, \"rb\")};\n-            if (!file.IsNull()) {\n-                LogPrintf(\"Importing blocks file %s...\\n\", fs::PathToString(path));\n-                chainman.LoadExternalBlockFile(file);\n-                if (chainman.m_interrupt) {\n-                    LogPrintf(\"Interrupt requested. Exit %s\\n\", __func__);\n-                    return;\n-                }\n-            } else {\n-                LogPrintf(\"Warning: Could not open blocks file %s\\n\", fs::PathToString(path));\n+        WITH_LOCK(::cs_main, chainman.m_blockman.m_block_tree_db->WriteReindexing(false));\n+        fReindex = false;\n+        LogPrintf(\"Reindexing finished\\n\");\n+        // To avoid ending up in a situation without genesis block, re-try initializing (no-op if reindexing worked):\n+        chainman.ActiveChainstate().LoadGenesisBlock();\n+    }\n+\n+    // -loadblock=\n+    for (const fs::path& path : vImportFiles) {\n+        AutoFile file{fsbridge::fopen(path, \"rb\")};\n+        if (!file.IsNull()) {\n+            LogPrintf(\"Importing blocks file %s...\\n\", fs::PathToString(path));\n+            chainman.LoadExternalBlockFile(file);\n+            if (chainman.m_interrupt) {\n+                LogPrintf(\"Interrupt requested. Exit %s\\n\", __func__);\n+                return;\n             }\n+        } else {\n+            LogPrintf(\"Warning: Could not open blocks file %s\\n\", fs::PathToString(path));\n         }\n+    }\n \n-        // scan for better chains in the block chain database, that are not yet connected in the active best chain\n+    // scan for better chains in the block chain database, that are not yet connected in the active best chain\n \n-        // We can't hold cs_main during ActivateBestChain even though we're accessing\n-        // the chainman unique_ptrs since ABC requires us not to be holding cs_main, so retrieve\n-        // the relevant pointers before the ABC call.\n-        for (Chainstate* chainstate : WITH_LOCK(::cs_main, return chainman.GetAll())) {\n-            BlockValidationState state;\n-            if (!chainstate->ActivateBestChain(state, nullptr)) {\n-                chainman.GetNotifications().fatalError(strprintf(_(\"Failed to connect best block (%s).\"), state.ToString()));\n-                return;\n-            }\n+    // We can't hold cs_main during ActivateBestChain even though we're accessing\n+    // the chainman unique_ptrs since ABC requires us not to be holding cs_main, so retrieve\n+    // the relevant pointers before the ABC call.\n+    for (Chainstate* chainstate : WITH_LOCK(::cs_main, return chainman.GetAll())) {\n+        BlockValidationState state;\n+        if (!chainstate->ActivateBestChain(state, nullptr)) {\n+            chainman.GetNotifications().fatalError(strprintf(_(\"Failed to connect best block (%s).\"), state.ToString()));\n+            return;\n         }\n-    } // End scope of ImportingNow",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30083#discussion_r1598809395",
      "id" : 1598809395,
      "in_reply_to_id" : 1598754079,
      "line" : 1240,
      "node_id" : "PRRC_kwDOABII585fS-Uz",
      "original_commit_id" : "04ffe4061da2d0135f206032e167703772b5da78",
      "original_line" : 1240,
      "original_position" : 117,
      "original_start_line" : null,
      "path" : "src/node/blockstorage.cpp",
      "position" : 117,
      "pull_request_review_id" : 2053295748,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30083",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1598809395/reactions"
      },
      "side" : "LEFT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-13T17:23:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1598809395",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8421793?v=4",
         "events_url" : "https://api.github.com/users/TheCharlatan/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheCharlatan/followers",
         "following_url" : "https://api.github.com/users/TheCharlatan/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheCharlatan/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheCharlatan",
         "id" : 8421793,
         "login" : "TheCharlatan",
         "node_id" : "MDQ6VXNlcjg0MjE3OTM=",
         "organizations_url" : "https://api.github.com/users/TheCharlatan/orgs",
         "received_events_url" : "https://api.github.com/users/TheCharlatan/received_events",
         "repos_url" : "https://api.github.com/users/TheCharlatan/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheCharlatan/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheCharlatan/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheCharlatan"
      }
   }
]
