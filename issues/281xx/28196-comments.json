[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\nA summary of reviews will appear here.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#27114](https://github.com/bitcoin/bitcoin/pull/27114) (p2p: Allow whitelisting outgoing connections by brunoerg)\n* [#26938](https://github.com/bitcoin/bitcoin/pull/26938) ([WIP] p2p: asmap, avoid inbound connections from a specific AS by brunoerg)\n* [#26114](https://github.com/bitcoin/bitcoin/pull/26114) (net: Make AddrFetch connections to fixed seeds by mzumsande)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "created_at" : "2023-08-01T17:57:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#issuecomment-1660822807",
      "id" : 1660822807,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28196",
      "node_id" : "IC_kwDOABII585i_iUX",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1660822807/reactions"
      },
      "updated_at" : "2023-08-22T09:59:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1660822807",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1303013011"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303013011"
         }
      },
      "author_association" : "MEMBER",
      "body" : "163d93304dea08bf8f2ea79d79cabceec1a13d96: I assume this is because of the short message ID's? Can you mention that in the commit message, so it's easy to find with `git blame`?",
      "commit_id" : "ec39432a674ef012e24391f2daa9480c2a14075a",
      "created_at" : "2023-08-23T13:21:16Z",
      "diff_hunk" : "@@ -595,12 +595,12 @@ def connect_nodes(self, a, b):\n         # * Must have a verack message before anything else\n         self.wait_until(lambda: sum(peer['version'] != 0 for peer in from_connection.getpeerinfo()) == from_num_peers)\n         self.wait_until(lambda: sum(peer['version'] != 0 for peer in to_connection.getpeerinfo()) == to_num_peers)\n-        self.wait_until(lambda: sum(peer['bytesrecv_per_msg'].pop('verack', 0) == 24 for peer in from_connection.getpeerinfo()) == from_num_peers)\n-        self.wait_until(lambda: sum(peer['bytesrecv_per_msg'].pop('verack', 0) == 24 for peer in to_connection.getpeerinfo()) == to_num_peers)\n+        self.wait_until(lambda: sum(peer['bytesrecv_per_msg'].pop('verack', 0) >= 21 for peer in from_connection.getpeerinfo()) == from_num_peers)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1303013011",
      "id" : 1303013011,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NqmaT",
      "original_commit_id" : "163d93304dea08bf8f2ea79d79cabceec1a13d96",
      "original_line" : 598,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/test_framework.py",
      "position" : null,
      "pull_request_review_id" : 1591588401,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303013011/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-23T13:43:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303013011",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1303026846"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303026846"
         }
      },
      "author_association" : "MEMBER",
      "body" : "9c3159378658c4b1535ab6c546512f7d1b2b3979: what's the difference between these two scenarios? `m_use_v1` vs `m_recv_state == RecvState::V1`?\r\n\r\nWhy not return `{}`? Unsafe / bad / not great?",
      "commit_id" : "ec39432a674ef012e24391f2daa9480c2a14075a",
      "created_at" : "2023-08-23T13:30:52Z",
      "diff_hunk" : "@@ -1434,6 +1435,20 @@ size_t V2Transport::GetSendMemoryUsage() const noexcept\n     return sizeof(m_send_buffer) + memusage::DynamicUsage(m_send_buffer);\n }\n \n+Span<const std::byte> V2Transport::GetSessionID() const noexcept\n+{\n+    if (m_use_v1) return m_v1_fallback.GetSessionID();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.GetSessionID();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1303026846",
      "id" : 1303026846,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Nqpye",
      "original_commit_id" : "9c3159378658c4b1535ab6c546512f7d1b2b3979",
      "original_line" : 1442,
      "original_position" : 16,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1591588401,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303026846/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-23T13:43:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303026846",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Started doing review, out of order. Some quick initial questions and remarks...\r\n\r\nI tend to get spontaneous v2 connections eventually, both inbound and outbound. But are there any known reachable mainnet nodes folks can test against? (testnet and signet is fine too I suppose)\r\n\r\nI would be useful to have at least one log message in the lifetime of a peer to indicate it's a v2. E.g. `[net] Added v2 connection peer=â¦` (haven't checked if we already know it's v2 at that point)\r\n\r\nDo I assume correctly that `0` refers to size of the message payload, i.e. ignoring the (short) message id (what was a header in v1)? `[net] sending verack (0 bytes)`",
      "created_at" : "2023-08-23T13:36:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#issuecomment-1689980940",
      "id" : 1689980940,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28196",
      "node_id" : "IC_kwDOABII585kuxAM",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1689980940/reactions"
      },
      "updated_at" : "2023-08-23T13:43:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1689980940",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1303059175"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303059175"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This commit will disappear eventually, when integration is done more properly.\n\nBut in short, yes, this is because when short IDs are in use, messages have a 21 byte overhead (on top of the payload) in V2 vs. 24 bytes in V1.",
      "commit_id" : "ec39432a674ef012e24391f2daa9480c2a14075a",
      "created_at" : "2023-08-23T13:52:50Z",
      "diff_hunk" : "@@ -595,12 +595,12 @@ def connect_nodes(self, a, b):\n         # * Must have a verack message before anything else\n         self.wait_until(lambda: sum(peer['version'] != 0 for peer in from_connection.getpeerinfo()) == from_num_peers)\n         self.wait_until(lambda: sum(peer['version'] != 0 for peer in to_connection.getpeerinfo()) == to_num_peers)\n-        self.wait_until(lambda: sum(peer['bytesrecv_per_msg'].pop('verack', 0) == 24 for peer in from_connection.getpeerinfo()) == from_num_peers)\n-        self.wait_until(lambda: sum(peer['bytesrecv_per_msg'].pop('verack', 0) == 24 for peer in to_connection.getpeerinfo()) == to_num_peers)\n+        self.wait_until(lambda: sum(peer['bytesrecv_per_msg'].pop('verack', 0) >= 21 for peer in from_connection.getpeerinfo()) == from_num_peers)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1303059175",
      "id" : 1303059175,
      "in_reply_to_id" : 1303013011,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Nqxrn",
      "original_commit_id" : "163d93304dea08bf8f2ea79d79cabceec1a13d96",
      "original_line" : 598,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/test_framework.py",
      "position" : null,
      "pull_request_review_id" : 1591662321,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303059175/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-23T13:52:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303059175",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1303071712"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303071712"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The difference between these scenarios: nothing, but it's possible that the m_use_v1 atomic gets set in between it being checked here and the lock being grabbed. So the m_use_v1 is there as an optimization that almost always works, but the RecvState::V1 check is necessary to make it always work. For other Transport member functions the m_use_v1 is introduced in a separate commit, which hopefully explains it.\n\nThere's also nothing wrong with `return {};` here, but I thought it'd be more obviously correct to explicitly call the V1Transport function.",
      "commit_id" : "ec39432a674ef012e24391f2daa9480c2a14075a",
      "created_at" : "2023-08-23T14:01:35Z",
      "diff_hunk" : "@@ -1434,6 +1435,20 @@ size_t V2Transport::GetSendMemoryUsage() const noexcept\n     return sizeof(m_send_buffer) + memusage::DynamicUsage(m_send_buffer);\n }\n \n+Span<const std::byte> V2Transport::GetSessionID() const noexcept\n+{\n+    if (m_use_v1) return m_v1_fallback.GetSessionID();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.GetSessionID();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1303071712",
      "id" : 1303071712,
      "in_reply_to_id" : 1303026846,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Nq0vg",
      "original_commit_id" : "9c3159378658c4b1535ab6c546512f7d1b2b3979",
      "original_line" : 1442,
      "original_position" : 16,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1591682059,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303071712/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-23T14:01:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303071712",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1308061759"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308061759"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In `V1Transport::GetReceivedMessage`, we call `RandAddEvent()` to harvest entropy from the time and checksum of the received messages. Should something similar be done for V2?",
      "commit_id" : "ec39432a674ef012e24391f2daa9480c2a14075a",
      "created_at" : "2023-08-28T23:53:59Z",
      "diff_hunk" : "@@ -912,6 +912,351 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::WAITING:\n+        // One byte is enough to transition to KEY.\n+        return 1;\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+\n+        // At this point we have a valid packed decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            m_recv_state = RecvState::VERSION;\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is\n+                // ignored, but can be used for future extensions.\n+                m_recv_state = RecvState::APP;\n+            }\n+            break;\n+        case RecvState::APP:\n+            if (!ignore) {\n+                // Application message decrypted correctly. It can be extracted using GetMessage().\n+                m_recv_state = RecvState::APP_READY;\n+            }\n+            break;\n+        default:\n+            // Any other state is invalid (this function should not have been called).\n+            assert(false);\n+        }\n+        // Wipe the receive buffer where the next packet will be received into.\n+        m_recv_buffer = {};\n+        // In all but APP_READY state, we can wipe the decoded contents.\n+        if (m_recv_state != RecvState::APP_READY) m_recv_decode_buffer = {};\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ReceivedBytes(Span<const uint8_t>& msg_bytes) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    while (!msg_bytes.empty()) {\n+        // Decide how many bytes to copy from msg_bytes to m_recv_buffer.\n+        size_t max_read = GetMaxBytesToProcess();\n+        // Can't read more than provided input.\n+        max_read = std::min<uint32_t>(msg_bytes.size(), max_read);\n+        // Copy data to buffer.\n+        m_recv_buffer.insert(m_recv_buffer.end(), UCharCast(msg_bytes.data()), UCharCast(msg_bytes.data() + max_read));\n+        msg_bytes = msg_bytes.subspan(max_read);\n+\n+        // Process data in the buffer.\n+        switch (m_recv_state) {\n+        case RecvState::WAITING:\n+            if (!m_recv_buffer.empty()) {\n+                m_recv_state = RecvState::KEY;\n+                LOCK(m_send_mutex);\n+                assert(m_send_state == SendState::KEY_WAITING);\n+                m_send_state = SendState::KEY;\n+            }\n+            break;\n+\n+        case RecvState::KEY:\n+            ProcessReceivedKey();\n+            break;\n+\n+        case RecvState::GARB_GARBTERM:\n+            if (!ProcessReceivedGarbage()) return false;\n+            break;\n+\n+        case RecvState::GARBAUTH:\n+        case RecvState::VERSION:\n+        case RecvState::APP:\n+            if (!ProcessReceivedPacket()) return false;\n+            break;\n+\n+        case RecvState::APP_READY:\n+            return true;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+std::optional<std::string> V2Transport::GetMessageType(Span<const uint8_t>& contents) noexcept\n+{\n+    if (contents.size() < 13 || contents[0] != 0) return std::nullopt; // Short encoding not yet supported\n+\n+    size_t msg_type_len{0};\n+    while (msg_type_len < 12 && contents[1 + msg_type_len] != 0) {\n+        if (contents[1 + msg_type_len] < ' ' || contents[1 + msg_type_len] > 0x7F) {\n+            return {};\n+        }\n+        ++msg_type_len;\n+    }\n+    std::string ret{reinterpret_cast<const char*>(contents.data() + 1), msg_type_len};\n+    while (msg_type_len < 12) {\n+        if (contents[1 + msg_type_len] != 0) return {};\n+        ++msg_type_len;\n+    }\n+    contents = contents.subspan(13);\n+    return {std::move(ret)};\n+}\n+\n+CNetMessage V2Transport::GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    assert(m_recv_state == RecvState::APP_READY);\n+    Span<const uint8_t> contents{m_recv_decode_buffer};\n+    auto msg_type = GetMessageType(contents);\n+    CDataStream ret(m_recv_type, m_recv_version);\n+    CNetMessage msg{std::move(ret)};\n+    msg.m_raw_message_size = m_recv_decode_buffer.size() + BIP324Cipher::EXPANSION;\n+    if (msg_type) {\n+        reject_message = false;\n+        msg.m_type = std::move(*msg_type);\n+        msg.m_time = time;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1308061759",
      "id" : 1308061759,
      "line" : 1342,
      "node_id" : "PRRC_kwDOABII585N93A_",
      "original_commit_id" : "f41a1a0ae49c3ada8073edb3c051deaa7534d494",
      "original_line" : 1185,
      "original_position" : 274,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 459,
      "pull_request_review_id" : 1599275947,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308061759/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-28T23:53:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308061759",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1308143623"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308143623"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Good idea. Done (in `V2Transport::ProcessReceivedPacket`, which sees the authentication tags).",
      "commit_id" : "d9344fd5c77e69a544c2d80aa6cbd20827f2e169",
      "created_at" : "2023-08-29T03:02:00Z",
      "diff_hunk" : "@@ -912,6 +912,351 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::WAITING:\n+        // One byte is enough to transition to KEY.\n+        return 1;\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+\n+        // At this point we have a valid packed decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            m_recv_state = RecvState::VERSION;\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is\n+                // ignored, but can be used for future extensions.\n+                m_recv_state = RecvState::APP;\n+            }\n+            break;\n+        case RecvState::APP:\n+            if (!ignore) {\n+                // Application message decrypted correctly. It can be extracted using GetMessage().\n+                m_recv_state = RecvState::APP_READY;\n+            }\n+            break;\n+        default:\n+            // Any other state is invalid (this function should not have been called).\n+            assert(false);\n+        }\n+        // Wipe the receive buffer where the next packet will be received into.\n+        m_recv_buffer = {};\n+        // In all but APP_READY state, we can wipe the decoded contents.\n+        if (m_recv_state != RecvState::APP_READY) m_recv_decode_buffer = {};\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ReceivedBytes(Span<const uint8_t>& msg_bytes) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    while (!msg_bytes.empty()) {\n+        // Decide how many bytes to copy from msg_bytes to m_recv_buffer.\n+        size_t max_read = GetMaxBytesToProcess();\n+        // Can't read more than provided input.\n+        max_read = std::min<uint32_t>(msg_bytes.size(), max_read);\n+        // Copy data to buffer.\n+        m_recv_buffer.insert(m_recv_buffer.end(), UCharCast(msg_bytes.data()), UCharCast(msg_bytes.data() + max_read));\n+        msg_bytes = msg_bytes.subspan(max_read);\n+\n+        // Process data in the buffer.\n+        switch (m_recv_state) {\n+        case RecvState::WAITING:\n+            if (!m_recv_buffer.empty()) {\n+                m_recv_state = RecvState::KEY;\n+                LOCK(m_send_mutex);\n+                assert(m_send_state == SendState::KEY_WAITING);\n+                m_send_state = SendState::KEY;\n+            }\n+            break;\n+\n+        case RecvState::KEY:\n+            ProcessReceivedKey();\n+            break;\n+\n+        case RecvState::GARB_GARBTERM:\n+            if (!ProcessReceivedGarbage()) return false;\n+            break;\n+\n+        case RecvState::GARBAUTH:\n+        case RecvState::VERSION:\n+        case RecvState::APP:\n+            if (!ProcessReceivedPacket()) return false;\n+            break;\n+\n+        case RecvState::APP_READY:\n+            return true;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+std::optional<std::string> V2Transport::GetMessageType(Span<const uint8_t>& contents) noexcept\n+{\n+    if (contents.size() < 13 || contents[0] != 0) return std::nullopt; // Short encoding not yet supported\n+\n+    size_t msg_type_len{0};\n+    while (msg_type_len < 12 && contents[1 + msg_type_len] != 0) {\n+        if (contents[1 + msg_type_len] < ' ' || contents[1 + msg_type_len] > 0x7F) {\n+            return {};\n+        }\n+        ++msg_type_len;\n+    }\n+    std::string ret{reinterpret_cast<const char*>(contents.data() + 1), msg_type_len};\n+    while (msg_type_len < 12) {\n+        if (contents[1 + msg_type_len] != 0) return {};\n+        ++msg_type_len;\n+    }\n+    contents = contents.subspan(13);\n+    return {std::move(ret)};\n+}\n+\n+CNetMessage V2Transport::GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    assert(m_recv_state == RecvState::APP_READY);\n+    Span<const uint8_t> contents{m_recv_decode_buffer};\n+    auto msg_type = GetMessageType(contents);\n+    CDataStream ret(m_recv_type, m_recv_version);\n+    CNetMessage msg{std::move(ret)};\n+    msg.m_raw_message_size = m_recv_decode_buffer.size() + BIP324Cipher::EXPANSION;\n+    if (msg_type) {\n+        reject_message = false;\n+        msg.m_type = std::move(*msg_type);\n+        msg.m_time = time;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1308143623",
      "id" : 1308143623,
      "in_reply_to_id" : 1308061759,
      "line" : 1344,
      "node_id" : "PRRC_kwDOABII585N-LAH",
      "original_commit_id" : "f41a1a0ae49c3ada8073edb3c051deaa7534d494",
      "original_line" : 1344,
      "original_position" : 274,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 461,
      "pull_request_review_id" : 1599399238,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308143623/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-29T03:02:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308143623",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1308716718"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308716718"
         }
      },
      "author_association" : "NONE",
      "body" : "maybe this is for a followup PR, but I think here it is better to print the status of the state, this makes trivial to debug the problem if happens.",
      "commit_id" : "d9344fd5c77e69a544c2d80aa6cbd20827f2e169",
      "created_at" : "2023-08-29T12:08:21Z",
      "diff_hunk" : "@@ -912,6 +912,353 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::WAITING:\n+        // One byte is enough to transition to KEY.\n+        return 1;\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packed decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            m_recv_state = RecvState::VERSION;\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is\n+                // ignored, but can be used for future extensions.\n+                m_recv_state = RecvState::APP;\n+            }\n+            break;\n+        case RecvState::APP:\n+            if (!ignore) {\n+                // Application message decrypted correctly. It can be extracted using GetMessage().\n+                m_recv_state = RecvState::APP_READY;\n+            }\n+            break;\n+        default:\n+            // Any other state is invalid (this function should not have been called).\n+            assert(false);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1308716718",
      "id" : 1308716718,
      "line" : 1217,
      "node_id" : "PRRC_kwDOABII585OAW6u",
      "original_commit_id" : "aa1da1a0ef0504d4f30ab3b101b334e11b8868ac",
      "original_line" : 1098,
      "original_position" : 187,
      "original_start_line" : 1097,
      "path" : "src/net.cpp",
      "position" : 334,
      "pull_request_review_id" : 1600253188,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308716718/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 1216,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-29T12:08:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308716718",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/17150045?v=4",
         "events_url" : "https://api.github.com/users/vincenzopalazzo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vincenzopalazzo/followers",
         "following_url" : "https://api.github.com/users/vincenzopalazzo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vincenzopalazzo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vincenzopalazzo",
         "id" : 17150045,
         "login" : "vincenzopalazzo",
         "node_id" : "MDQ6VXNlcjE3MTUwMDQ1",
         "organizations_url" : "https://api.github.com/users/vincenzopalazzo/orgs",
         "received_events_url" : "https://api.github.com/users/vincenzopalazzo/received_events",
         "repos_url" : "https://api.github.com/users/vincenzopalazzo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vincenzopalazzo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vincenzopalazzo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vincenzopalazzo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1308718127"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308718127"
         }
      },
      "author_association" : "MEMBER",
      "body" : "No, this code is unreachable. If it gets hit, it would be obvious what is wrong.",
      "commit_id" : "d9344fd5c77e69a544c2d80aa6cbd20827f2e169",
      "created_at" : "2023-08-29T12:09:37Z",
      "diff_hunk" : "@@ -912,6 +912,353 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::WAITING:\n+        // One byte is enough to transition to KEY.\n+        return 1;\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packed decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            m_recv_state = RecvState::VERSION;\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is\n+                // ignored, but can be used for future extensions.\n+                m_recv_state = RecvState::APP;\n+            }\n+            break;\n+        case RecvState::APP:\n+            if (!ignore) {\n+                // Application message decrypted correctly. It can be extracted using GetMessage().\n+                m_recv_state = RecvState::APP_READY;\n+            }\n+            break;\n+        default:\n+            // Any other state is invalid (this function should not have been called).\n+            assert(false);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1308718127",
      "id" : 1308718127,
      "in_reply_to_id" : 1308716718,
      "line" : 1217,
      "node_id" : "PRRC_kwDOABII585OAXQv",
      "original_commit_id" : "aa1da1a0ef0504d4f30ab3b101b334e11b8868ac",
      "original_line" : 1098,
      "original_position" : 187,
      "original_start_line" : 1097,
      "path" : "src/net.cpp",
      "position" : 334,
      "pull_request_review_id" : 1600255297,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308718127/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 1216,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-29T12:09:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308718127",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1308731485"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308731485"
         }
      },
      "author_association" : "NONE",
      "body" : "I see now your point, ok make sense",
      "commit_id" : "d9344fd5c77e69a544c2d80aa6cbd20827f2e169",
      "created_at" : "2023-08-29T12:20:02Z",
      "diff_hunk" : "@@ -912,6 +912,353 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::WAITING:\n+        // One byte is enough to transition to KEY.\n+        return 1;\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packed decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            m_recv_state = RecvState::VERSION;\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is\n+                // ignored, but can be used for future extensions.\n+                m_recv_state = RecvState::APP;\n+            }\n+            break;\n+        case RecvState::APP:\n+            if (!ignore) {\n+                // Application message decrypted correctly. It can be extracted using GetMessage().\n+                m_recv_state = RecvState::APP_READY;\n+            }\n+            break;\n+        default:\n+            // Any other state is invalid (this function should not have been called).\n+            assert(false);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1308731485",
      "id" : 1308731485,
      "in_reply_to_id" : 1308716718,
      "line" : 1217,
      "node_id" : "PRRC_kwDOABII585OAahd",
      "original_commit_id" : "aa1da1a0ef0504d4f30ab3b101b334e11b8868ac",
      "original_line" : 1098,
      "original_position" : 187,
      "original_start_line" : 1097,
      "path" : "src/net.cpp",
      "position" : 334,
      "pull_request_review_id" : 1600275509,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308731485/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 1216,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-29T12:20:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308731485",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/17150045?v=4",
         "events_url" : "https://api.github.com/users/vincenzopalazzo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vincenzopalazzo/followers",
         "following_url" : "https://api.github.com/users/vincenzopalazzo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vincenzopalazzo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vincenzopalazzo",
         "id" : 17150045,
         "login" : "vincenzopalazzo",
         "node_id" : "MDQ6VXNlcjE3MTUwMDQ1",
         "organizations_url" : "https://api.github.com/users/vincenzopalazzo/orgs",
         "received_events_url" : "https://api.github.com/users/vincenzopalazzo/received_events",
         "repos_url" : "https://api.github.com/users/vincenzopalazzo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vincenzopalazzo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vincenzopalazzo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vincenzopalazzo"
      }
   }
]
