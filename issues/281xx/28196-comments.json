[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\nA summary of reviews will appear here.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#27114](https://github.com/bitcoin/bitcoin/pull/27114) (p2p: Allow whitelisting outgoing connections by brunoerg)\n* [#26938](https://github.com/bitcoin/bitcoin/pull/26938) ([WIP] p2p: asmap, avoid inbound connections from a specific AS by brunoerg)\n* [#26114](https://github.com/bitcoin/bitcoin/pull/26114) (net: Make AddrFetch connections to fixed seeds by mzumsande)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "created_at" : "2023-08-01T17:57:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#issuecomment-1660822807",
      "id" : 1660822807,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28196",
      "node_id" : "IC_kwDOABII585i_iUX",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1660822807/reactions"
      },
      "updated_at" : "2023-08-22T09:59:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1660822807",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1303013011"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303013011"
         }
      },
      "author_association" : "MEMBER",
      "body" : "163d93304dea08bf8f2ea79d79cabceec1a13d96: I assume this is because of the short message ID's? Can you mention that in the commit message, so it's easy to find with `git blame`?",
      "commit_id" : "ec39432a674ef012e24391f2daa9480c2a14075a",
      "created_at" : "2023-08-23T13:21:16Z",
      "diff_hunk" : "@@ -595,12 +595,12 @@ def connect_nodes(self, a, b):\n         # * Must have a verack message before anything else\n         self.wait_until(lambda: sum(peer['version'] != 0 for peer in from_connection.getpeerinfo()) == from_num_peers)\n         self.wait_until(lambda: sum(peer['version'] != 0 for peer in to_connection.getpeerinfo()) == to_num_peers)\n-        self.wait_until(lambda: sum(peer['bytesrecv_per_msg'].pop('verack', 0) == 24 for peer in from_connection.getpeerinfo()) == from_num_peers)\n-        self.wait_until(lambda: sum(peer['bytesrecv_per_msg'].pop('verack', 0) == 24 for peer in to_connection.getpeerinfo()) == to_num_peers)\n+        self.wait_until(lambda: sum(peer['bytesrecv_per_msg'].pop('verack', 0) >= 21 for peer in from_connection.getpeerinfo()) == from_num_peers)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1303013011",
      "id" : 1303013011,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NqmaT",
      "original_commit_id" : "163d93304dea08bf8f2ea79d79cabceec1a13d96",
      "original_line" : 598,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/test_framework.py",
      "position" : null,
      "pull_request_review_id" : 1591588401,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303013011/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-23T13:43:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303013011",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1303026846"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303026846"
         }
      },
      "author_association" : "MEMBER",
      "body" : "9c3159378658c4b1535ab6c546512f7d1b2b3979: what's the difference between these two scenarios? `m_use_v1` vs `m_recv_state == RecvState::V1`?\r\n\r\nWhy not return `{}`? Unsafe / bad / not great?",
      "commit_id" : "ec39432a674ef012e24391f2daa9480c2a14075a",
      "created_at" : "2023-08-23T13:30:52Z",
      "diff_hunk" : "@@ -1434,6 +1435,20 @@ size_t V2Transport::GetSendMemoryUsage() const noexcept\n     return sizeof(m_send_buffer) + memusage::DynamicUsage(m_send_buffer);\n }\n \n+Span<const std::byte> V2Transport::GetSessionID() const noexcept\n+{\n+    if (m_use_v1) return m_v1_fallback.GetSessionID();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.GetSessionID();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1303026846",
      "id" : 1303026846,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Nqpye",
      "original_commit_id" : "9c3159378658c4b1535ab6c546512f7d1b2b3979",
      "original_line" : 1442,
      "original_position" : 16,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1591588401,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303026846/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-23T13:43:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303026846",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Started doing review, out of order. Some quick initial questions and remarks...\r\n\r\nI tend to get spontaneous v2 connections eventually, both inbound and outbound. But are there any known reachable mainnet nodes folks can test against? (testnet and signet is fine too I suppose)\r\n\r\nI would be useful to have at least one log message in the lifetime of a peer to indicate it's a v2. E.g. `[net] Added v2 connection peer=â¦` (haven't checked if we already know it's v2 at that point)\r\n\r\nDo I assume correctly that `0` refers to size of the message payload, i.e. ignoring the (short) message id (what was a header in v1)? `[net] sending verack (0 bytes)`",
      "created_at" : "2023-08-23T13:36:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#issuecomment-1689980940",
      "id" : 1689980940,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28196",
      "node_id" : "IC_kwDOABII585kuxAM",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1689980940/reactions"
      },
      "updated_at" : "2023-08-23T13:43:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1689980940",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1303059175"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303059175"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This commit will disappear eventually, when integration is done more properly.\n\nBut in short, yes, this is because when short IDs are in use, messages have a 21 byte overhead (on top of the payload) in V2 vs. 24 bytes in V1.",
      "commit_id" : "ec39432a674ef012e24391f2daa9480c2a14075a",
      "created_at" : "2023-08-23T13:52:50Z",
      "diff_hunk" : "@@ -595,12 +595,12 @@ def connect_nodes(self, a, b):\n         # * Must have a verack message before anything else\n         self.wait_until(lambda: sum(peer['version'] != 0 for peer in from_connection.getpeerinfo()) == from_num_peers)\n         self.wait_until(lambda: sum(peer['version'] != 0 for peer in to_connection.getpeerinfo()) == to_num_peers)\n-        self.wait_until(lambda: sum(peer['bytesrecv_per_msg'].pop('verack', 0) == 24 for peer in from_connection.getpeerinfo()) == from_num_peers)\n-        self.wait_until(lambda: sum(peer['bytesrecv_per_msg'].pop('verack', 0) == 24 for peer in to_connection.getpeerinfo()) == to_num_peers)\n+        self.wait_until(lambda: sum(peer['bytesrecv_per_msg'].pop('verack', 0) >= 21 for peer in from_connection.getpeerinfo()) == from_num_peers)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1303059175",
      "id" : 1303059175,
      "in_reply_to_id" : 1303013011,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Nqxrn",
      "original_commit_id" : "163d93304dea08bf8f2ea79d79cabceec1a13d96",
      "original_line" : 598,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/test_framework.py",
      "position" : null,
      "pull_request_review_id" : 1591662321,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303059175/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-23T13:52:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303059175",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1303071712"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303071712"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The difference between these scenarios: nothing, but it's possible that the m_use_v1 atomic gets set in between it being checked here and the lock being grabbed. So the m_use_v1 is there as an optimization that almost always works, but the RecvState::V1 check is necessary to make it always work. For other Transport member functions the m_use_v1 is introduced in a separate commit, which hopefully explains it.\n\nThere's also nothing wrong with `return {};` here, but I thought it'd be more obviously correct to explicitly call the V1Transport function.",
      "commit_id" : "ec39432a674ef012e24391f2daa9480c2a14075a",
      "created_at" : "2023-08-23T14:01:35Z",
      "diff_hunk" : "@@ -1434,6 +1435,20 @@ size_t V2Transport::GetSendMemoryUsage() const noexcept\n     return sizeof(m_send_buffer) + memusage::DynamicUsage(m_send_buffer);\n }\n \n+Span<const std::byte> V2Transport::GetSessionID() const noexcept\n+{\n+    if (m_use_v1) return m_v1_fallback.GetSessionID();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.GetSessionID();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1303071712",
      "id" : 1303071712,
      "in_reply_to_id" : 1303026846,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Nq0vg",
      "original_commit_id" : "9c3159378658c4b1535ab6c546512f7d1b2b3979",
      "original_line" : 1442,
      "original_position" : 16,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1591682059,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303071712/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-23T14:01:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303071712",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1308061759"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308061759"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In `V1Transport::GetReceivedMessage`, we call `RandAddEvent()` to harvest entropy from the time and checksum of the received messages. Should something similar be done for V2?",
      "commit_id" : "ec39432a674ef012e24391f2daa9480c2a14075a",
      "created_at" : "2023-08-28T23:53:59Z",
      "diff_hunk" : "@@ -912,6 +912,351 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::WAITING:\n+        // One byte is enough to transition to KEY.\n+        return 1;\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+\n+        // At this point we have a valid packed decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            m_recv_state = RecvState::VERSION;\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is\n+                // ignored, but can be used for future extensions.\n+                m_recv_state = RecvState::APP;\n+            }\n+            break;\n+        case RecvState::APP:\n+            if (!ignore) {\n+                // Application message decrypted correctly. It can be extracted using GetMessage().\n+                m_recv_state = RecvState::APP_READY;\n+            }\n+            break;\n+        default:\n+            // Any other state is invalid (this function should not have been called).\n+            assert(false);\n+        }\n+        // Wipe the receive buffer where the next packet will be received into.\n+        m_recv_buffer = {};\n+        // In all but APP_READY state, we can wipe the decoded contents.\n+        if (m_recv_state != RecvState::APP_READY) m_recv_decode_buffer = {};\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ReceivedBytes(Span<const uint8_t>& msg_bytes) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    while (!msg_bytes.empty()) {\n+        // Decide how many bytes to copy from msg_bytes to m_recv_buffer.\n+        size_t max_read = GetMaxBytesToProcess();\n+        // Can't read more than provided input.\n+        max_read = std::min<uint32_t>(msg_bytes.size(), max_read);\n+        // Copy data to buffer.\n+        m_recv_buffer.insert(m_recv_buffer.end(), UCharCast(msg_bytes.data()), UCharCast(msg_bytes.data() + max_read));\n+        msg_bytes = msg_bytes.subspan(max_read);\n+\n+        // Process data in the buffer.\n+        switch (m_recv_state) {\n+        case RecvState::WAITING:\n+            if (!m_recv_buffer.empty()) {\n+                m_recv_state = RecvState::KEY;\n+                LOCK(m_send_mutex);\n+                assert(m_send_state == SendState::KEY_WAITING);\n+                m_send_state = SendState::KEY;\n+            }\n+            break;\n+\n+        case RecvState::KEY:\n+            ProcessReceivedKey();\n+            break;\n+\n+        case RecvState::GARB_GARBTERM:\n+            if (!ProcessReceivedGarbage()) return false;\n+            break;\n+\n+        case RecvState::GARBAUTH:\n+        case RecvState::VERSION:\n+        case RecvState::APP:\n+            if (!ProcessReceivedPacket()) return false;\n+            break;\n+\n+        case RecvState::APP_READY:\n+            return true;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+std::optional<std::string> V2Transport::GetMessageType(Span<const uint8_t>& contents) noexcept\n+{\n+    if (contents.size() < 13 || contents[0] != 0) return std::nullopt; // Short encoding not yet supported\n+\n+    size_t msg_type_len{0};\n+    while (msg_type_len < 12 && contents[1 + msg_type_len] != 0) {\n+        if (contents[1 + msg_type_len] < ' ' || contents[1 + msg_type_len] > 0x7F) {\n+            return {};\n+        }\n+        ++msg_type_len;\n+    }\n+    std::string ret{reinterpret_cast<const char*>(contents.data() + 1), msg_type_len};\n+    while (msg_type_len < 12) {\n+        if (contents[1 + msg_type_len] != 0) return {};\n+        ++msg_type_len;\n+    }\n+    contents = contents.subspan(13);\n+    return {std::move(ret)};\n+}\n+\n+CNetMessage V2Transport::GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    assert(m_recv_state == RecvState::APP_READY);\n+    Span<const uint8_t> contents{m_recv_decode_buffer};\n+    auto msg_type = GetMessageType(contents);\n+    CDataStream ret(m_recv_type, m_recv_version);\n+    CNetMessage msg{std::move(ret)};\n+    msg.m_raw_message_size = m_recv_decode_buffer.size() + BIP324Cipher::EXPANSION;\n+    if (msg_type) {\n+        reject_message = false;\n+        msg.m_type = std::move(*msg_type);\n+        msg.m_time = time;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1308061759",
      "id" : 1308061759,
      "line" : 1342,
      "node_id" : "PRRC_kwDOABII585N93A_",
      "original_commit_id" : "f41a1a0ae49c3ada8073edb3c051deaa7534d494",
      "original_line" : 1185,
      "original_position" : 274,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 459,
      "pull_request_review_id" : 1599275947,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308061759/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-28T23:53:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308061759",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1308143623"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308143623"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Good idea. Done (in `V2Transport::ProcessReceivedPacket`, which sees the authentication tags).",
      "commit_id" : "d9344fd5c77e69a544c2d80aa6cbd20827f2e169",
      "created_at" : "2023-08-29T03:02:00Z",
      "diff_hunk" : "@@ -912,6 +912,351 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::WAITING:\n+        // One byte is enough to transition to KEY.\n+        return 1;\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+\n+        // At this point we have a valid packed decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            m_recv_state = RecvState::VERSION;\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is\n+                // ignored, but can be used for future extensions.\n+                m_recv_state = RecvState::APP;\n+            }\n+            break;\n+        case RecvState::APP:\n+            if (!ignore) {\n+                // Application message decrypted correctly. It can be extracted using GetMessage().\n+                m_recv_state = RecvState::APP_READY;\n+            }\n+            break;\n+        default:\n+            // Any other state is invalid (this function should not have been called).\n+            assert(false);\n+        }\n+        // Wipe the receive buffer where the next packet will be received into.\n+        m_recv_buffer = {};\n+        // In all but APP_READY state, we can wipe the decoded contents.\n+        if (m_recv_state != RecvState::APP_READY) m_recv_decode_buffer = {};\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ReceivedBytes(Span<const uint8_t>& msg_bytes) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    while (!msg_bytes.empty()) {\n+        // Decide how many bytes to copy from msg_bytes to m_recv_buffer.\n+        size_t max_read = GetMaxBytesToProcess();\n+        // Can't read more than provided input.\n+        max_read = std::min<uint32_t>(msg_bytes.size(), max_read);\n+        // Copy data to buffer.\n+        m_recv_buffer.insert(m_recv_buffer.end(), UCharCast(msg_bytes.data()), UCharCast(msg_bytes.data() + max_read));\n+        msg_bytes = msg_bytes.subspan(max_read);\n+\n+        // Process data in the buffer.\n+        switch (m_recv_state) {\n+        case RecvState::WAITING:\n+            if (!m_recv_buffer.empty()) {\n+                m_recv_state = RecvState::KEY;\n+                LOCK(m_send_mutex);\n+                assert(m_send_state == SendState::KEY_WAITING);\n+                m_send_state = SendState::KEY;\n+            }\n+            break;\n+\n+        case RecvState::KEY:\n+            ProcessReceivedKey();\n+            break;\n+\n+        case RecvState::GARB_GARBTERM:\n+            if (!ProcessReceivedGarbage()) return false;\n+            break;\n+\n+        case RecvState::GARBAUTH:\n+        case RecvState::VERSION:\n+        case RecvState::APP:\n+            if (!ProcessReceivedPacket()) return false;\n+            break;\n+\n+        case RecvState::APP_READY:\n+            return true;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+std::optional<std::string> V2Transport::GetMessageType(Span<const uint8_t>& contents) noexcept\n+{\n+    if (contents.size() < 13 || contents[0] != 0) return std::nullopt; // Short encoding not yet supported\n+\n+    size_t msg_type_len{0};\n+    while (msg_type_len < 12 && contents[1 + msg_type_len] != 0) {\n+        if (contents[1 + msg_type_len] < ' ' || contents[1 + msg_type_len] > 0x7F) {\n+            return {};\n+        }\n+        ++msg_type_len;\n+    }\n+    std::string ret{reinterpret_cast<const char*>(contents.data() + 1), msg_type_len};\n+    while (msg_type_len < 12) {\n+        if (contents[1 + msg_type_len] != 0) return {};\n+        ++msg_type_len;\n+    }\n+    contents = contents.subspan(13);\n+    return {std::move(ret)};\n+}\n+\n+CNetMessage V2Transport::GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    assert(m_recv_state == RecvState::APP_READY);\n+    Span<const uint8_t> contents{m_recv_decode_buffer};\n+    auto msg_type = GetMessageType(contents);\n+    CDataStream ret(m_recv_type, m_recv_version);\n+    CNetMessage msg{std::move(ret)};\n+    msg.m_raw_message_size = m_recv_decode_buffer.size() + BIP324Cipher::EXPANSION;\n+    if (msg_type) {\n+        reject_message = false;\n+        msg.m_type = std::move(*msg_type);\n+        msg.m_time = time;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1308143623",
      "id" : 1308143623,
      "in_reply_to_id" : 1308061759,
      "line" : 1344,
      "node_id" : "PRRC_kwDOABII585N-LAH",
      "original_commit_id" : "f41a1a0ae49c3ada8073edb3c051deaa7534d494",
      "original_line" : 1344,
      "original_position" : 274,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 461,
      "pull_request_review_id" : 1599399238,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308143623/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-29T03:02:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308143623",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1308716718"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308716718"
         }
      },
      "author_association" : "NONE",
      "body" : "maybe this is for a followup PR, but I think here it is better to print the status of the state, this makes trivial to debug the problem if happens.",
      "commit_id" : "d9344fd5c77e69a544c2d80aa6cbd20827f2e169",
      "created_at" : "2023-08-29T12:08:21Z",
      "diff_hunk" : "@@ -912,6 +912,353 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::WAITING:\n+        // One byte is enough to transition to KEY.\n+        return 1;\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packed decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            m_recv_state = RecvState::VERSION;\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is\n+                // ignored, but can be used for future extensions.\n+                m_recv_state = RecvState::APP;\n+            }\n+            break;\n+        case RecvState::APP:\n+            if (!ignore) {\n+                // Application message decrypted correctly. It can be extracted using GetMessage().\n+                m_recv_state = RecvState::APP_READY;\n+            }\n+            break;\n+        default:\n+            // Any other state is invalid (this function should not have been called).\n+            assert(false);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1308716718",
      "id" : 1308716718,
      "line" : 1217,
      "node_id" : "PRRC_kwDOABII585OAW6u",
      "original_commit_id" : "aa1da1a0ef0504d4f30ab3b101b334e11b8868ac",
      "original_line" : 1098,
      "original_position" : 187,
      "original_start_line" : 1097,
      "path" : "src/net.cpp",
      "position" : 334,
      "pull_request_review_id" : 1600253188,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308716718/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 1216,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-29T12:08:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308716718",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/17150045?v=4",
         "events_url" : "https://api.github.com/users/vincenzopalazzo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vincenzopalazzo/followers",
         "following_url" : "https://api.github.com/users/vincenzopalazzo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vincenzopalazzo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vincenzopalazzo",
         "id" : 17150045,
         "login" : "vincenzopalazzo",
         "node_id" : "MDQ6VXNlcjE3MTUwMDQ1",
         "organizations_url" : "https://api.github.com/users/vincenzopalazzo/orgs",
         "received_events_url" : "https://api.github.com/users/vincenzopalazzo/received_events",
         "repos_url" : "https://api.github.com/users/vincenzopalazzo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vincenzopalazzo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vincenzopalazzo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vincenzopalazzo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1308718127"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308718127"
         }
      },
      "author_association" : "MEMBER",
      "body" : "No, this code is unreachable. If it gets hit, it would be obvious what is wrong.",
      "commit_id" : "d9344fd5c77e69a544c2d80aa6cbd20827f2e169",
      "created_at" : "2023-08-29T12:09:37Z",
      "diff_hunk" : "@@ -912,6 +912,353 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::WAITING:\n+        // One byte is enough to transition to KEY.\n+        return 1;\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packed decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            m_recv_state = RecvState::VERSION;\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is\n+                // ignored, but can be used for future extensions.\n+                m_recv_state = RecvState::APP;\n+            }\n+            break;\n+        case RecvState::APP:\n+            if (!ignore) {\n+                // Application message decrypted correctly. It can be extracted using GetMessage().\n+                m_recv_state = RecvState::APP_READY;\n+            }\n+            break;\n+        default:\n+            // Any other state is invalid (this function should not have been called).\n+            assert(false);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1308718127",
      "id" : 1308718127,
      "in_reply_to_id" : 1308716718,
      "line" : 1217,
      "node_id" : "PRRC_kwDOABII585OAXQv",
      "original_commit_id" : "aa1da1a0ef0504d4f30ab3b101b334e11b8868ac",
      "original_line" : 1098,
      "original_position" : 187,
      "original_start_line" : 1097,
      "path" : "src/net.cpp",
      "position" : 334,
      "pull_request_review_id" : 1600255297,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308718127/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 1216,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-29T12:09:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308718127",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1308731485"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308731485"
         }
      },
      "author_association" : "NONE",
      "body" : "I see now your point, ok make sense",
      "commit_id" : "d9344fd5c77e69a544c2d80aa6cbd20827f2e169",
      "created_at" : "2023-08-29T12:20:02Z",
      "diff_hunk" : "@@ -912,6 +912,353 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::WAITING:\n+        // One byte is enough to transition to KEY.\n+        return 1;\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packed decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            m_recv_state = RecvState::VERSION;\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is\n+                // ignored, but can be used for future extensions.\n+                m_recv_state = RecvState::APP;\n+            }\n+            break;\n+        case RecvState::APP:\n+            if (!ignore) {\n+                // Application message decrypted correctly. It can be extracted using GetMessage().\n+                m_recv_state = RecvState::APP_READY;\n+            }\n+            break;\n+        default:\n+            // Any other state is invalid (this function should not have been called).\n+            assert(false);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1308731485",
      "id" : 1308731485,
      "in_reply_to_id" : 1308716718,
      "line" : 1217,
      "node_id" : "PRRC_kwDOABII585OAahd",
      "original_commit_id" : "aa1da1a0ef0504d4f30ab3b101b334e11b8868ac",
      "original_line" : 1098,
      "original_position" : 187,
      "original_start_line" : 1097,
      "path" : "src/net.cpp",
      "position" : 334,
      "pull_request_review_id" : 1600275509,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308731485/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 1216,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-29T12:20:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308731485",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/17150045?v=4",
         "events_url" : "https://api.github.com/users/vincenzopalazzo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vincenzopalazzo/followers",
         "following_url" : "https://api.github.com/users/vincenzopalazzo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vincenzopalazzo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vincenzopalazzo",
         "id" : 17150045,
         "login" : "vincenzopalazzo",
         "node_id" : "MDQ6VXNlcjE3MTUwMDQ1",
         "organizations_url" : "https://api.github.com/users/vincenzopalazzo/orgs",
         "received_events_url" : "https://api.github.com/users/vincenzopalazzo/received_events",
         "repos_url" : "https://api.github.com/users/vincenzopalazzo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vincenzopalazzo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vincenzopalazzo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vincenzopalazzo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1309329927"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1309329927"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Looks like `SetReceiveVersion` is never used anywhere, neither for V1 nor V2, because the version is set in the respective constructors. Should we just remove it from the `Transport` interface?",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-29T20:38:08Z",
      "diff_hunk" : "@@ -912,6 +912,353 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1309329927",
      "id" : 1309329927,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OCsoH",
      "original_commit_id" : "f7c0be500adeeddba1671b6f4478ce369fc0c6b3",
      "original_line" : 1020,
      "original_position" : 33,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1601240500,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1309329927/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-30T20:03:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1309329927",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1309344192"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1309344192"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "could put some of the magic numbers (13 here and in a few other places like `SetMessageToSend`, 12 in `GetMessageType()`) into  constants or maybe use `CMessageHeader::COMMAND_SIZE`.",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-29T20:53:44Z",
      "diff_hunk" : "@@ -912,6 +912,353 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::WAITING:\n+        // One byte is enough to transition to KEY.\n+        return 1;\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1309344192",
      "id" : 1309344192,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OCwHA",
      "original_commit_id" : "f7c0be500adeeddba1671b6f4478ce369fc0c6b3",
      "original_line" : 1171,
      "original_position" : 141,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1601240500,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1309344192/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-30T20:03:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1309344192",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1309532823"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1309532823"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit-like: For the long encoding processing, it might be worthwhile to advance for one byte in the contents span first, to work with the remaining 12 bytes and avoid the plus ones everywhere below (especially for the array indices in the while loops)?\r\n```suggestion\r\n    contents = contents.subspan(1);\r\n    if (contents.size() < 12) return std::nullopt; // Long encoding needs at least 12 bytes (after the short message id)\r\n```\r\n",
      "commit_id" : "040ea05dae05ef513ac79306dd560c8c1f228942",
      "created_at" : "2023-08-30T02:06:04Z",
      "diff_hunk" : "@@ -1213,7 +1276,22 @@ bool V2Transport::ReceivedBytes(Span<const uint8_t>& msg_bytes) noexcept\n \n std::optional<std::string> V2Transport::GetMessageType(Span<const uint8_t>& contents) noexcept\n {\n-    if (contents.size() < 13 || contents[0] != 0) return std::nullopt; // Short encoding not yet supported\n+    if (contents.size() == 0) return std::nullopt; // Empty contents\n+    uint8_t first_byte = contents[0];\n+\n+    if (first_byte != 0) {\n+        // Short (1 byte) encoding.\n+        if (first_byte < std::size(V2_MESSAGE_IDS)) {\n+            // Valid short message id.\n+            contents = contents.subspan(1);\n+            return V2_MESSAGE_IDS[first_byte];\n+        } else {\n+            // Unknown short message id.\n+            return std::nullopt;\n+        }\n+    }\n+\n+    if (contents.size() < 13) return std::nullopt; // Long encoding needs at least 13 bytes",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1309532823",
      "id" : 1309532823,
      "line" : 1310,
      "node_id" : "PRRC_kwDOABII585ODeKX",
      "original_commit_id" : "8a2e9f6fb909436f3c849c1088a3b79b2cfba119",
      "original_line" : 1310,
      "original_position" : 90,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 427,
      "pull_request_review_id" : 1601752363,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1309532823/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-30T02:28:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1309532823",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1309537403"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1309537403"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: though logically identical with the current code, could be explicit about the fill value of the resize (in contrast to the short message case above, not all of the new elments after the resize are overwritten):\r\n```suggestion\r\n        contents.resize(13 + msg.data.size(), 0);\r\n```",
      "commit_id" : "040ea05dae05ef513ac79306dd560c8c1f228942",
      "created_at" : "2023-08-30T02:12:58Z",
      "diff_hunk" : "@@ -1270,9 +1348,17 @@ bool V2Transport::SetMessageToSend(CSerializedNetMsg& msg) noexcept\n \n     if (m_send_state != SendState::APP_READY) return false;\n     // Construct contents (encoding message type + payload).\n-    std::vector<uint8_t> contents(13 + msg.data.size(), 0);\n-    std::copy(msg.m_type.begin(), msg.m_type.end(), reinterpret_cast<char*>(contents.data() + 1));\n-    std::copy(msg.data.begin(), msg.data.end(), contents.begin() + 13);\n+    std::vector<uint8_t> contents;\n+    auto short_message_id = V2_MESSAGE_MAP(msg.m_type);\n+    if (short_message_id) {\n+        contents.resize(1 + msg.data.size());\n+        contents[0] = *short_message_id;\n+        std::copy(msg.data.begin(), msg.data.end(), contents.begin() + 1);\n+    } else {\n+        contents.resize(13 + msg.data.size());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1309537403",
      "id" : 1309537403,
      "line" : 1374,
      "node_id" : "PRRC_kwDOABII585ODfR7",
      "original_commit_id" : "8a2e9f6fb909436f3c849c1088a3b79b2cfba119",
      "original_line" : 1374,
      "original_position" : 108,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 491,
      "pull_request_review_id" : 1601752363,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1309537403/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-30T02:28:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1309537403",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310237002"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310237002"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: tell doxygen about the parameter (and maybe about the return value):\r\n\r\n```cpp\r\n/**\r\n * Title sentence up to first dot.\r\n * Further elaborate description. Many sentences whatever.\r\n * @param[in] have_next_message Controls whether the \"more\"...\r\n * @return The bytes returned by this function...\r\n */",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-30T12:58:56Z",
      "diff_hunk" : "@@ -320,7 +328,7 @@ class Transport {\n      * Note that m_type and to_send refer to data that is internal to the transport, and calling\n      * any non-const function on this object may invalidate them.\n      */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310237002",
      "id" : 1310237002,
      "line" : 328,
      "node_id" : "PRRC_kwDOABII585OGKFK",
      "original_commit_id" : "040ea05dae05ef513ac79306dd560c8c1f228942",
      "original_line" : 328,
      "original_position" : 34,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 43,
      "pull_request_review_id" : 1602648914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310237002/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T13:28:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310237002",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310277982"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310277982"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "```suggestion\r\n         * A packet is received, and decrypted/verified. If that succeeds, the state becomes APP and the decrypted contents is\r\n```",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-30T13:24:38Z",
      "diff_hunk" : "@@ -416,7 +424,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the contents of the receive buffer. */\n+    enum class RecvState {\n+        /** (Responder only) either v2 public key or v1 header.\n+         *\n+         * This is the initial state for responders, before data has been received to distinguish\n+         * v1 from v2 connections. When that happens, the state becomes either KEY (for v2) or V1\n+         * (for v1). */\n+        KEY_MAYBE_V1,\n+\n+        /** Public key.\n+         *\n+         * This is the initial state for initiators, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, its contents is",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310277982",
      "id" : 1310277982,
      "line" : 467,
      "node_id" : "PRRC_kwDOABII585OGUFe",
      "original_commit_id" : "040ea05dae05ef513ac79306dd560c8c1f228942",
      "original_line" : 467,
      "original_position" : 94,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 119,
      "pull_request_review_id" : 1602648914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310277982/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T13:28:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310277982",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310288598"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310288598"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "```\r\nEnum 'RecvState' uses a larger base type ('int', size: 4 bytes) than necessary for its value set, consider using 'std::uint8_t' (1 byte) as the base type to reduce its size [performance-enum-size]\r\n```\r\n(same for `SendState`)",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-30T13:31:33Z",
      "diff_hunk" : "@@ -416,7 +424,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the contents of the receive buffer. */\n+    enum class RecvState {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310288598",
      "id" : 1310288598,
      "line" : 435,
      "node_id" : "PRRC_kwDOABII585OGWrW",
      "original_commit_id" : "040ea05dae05ef513ac79306dd560c8c1f228942",
      "original_line" : 435,
      "original_position" : 62,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 87,
      "pull_request_review_id" : 1602648914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310288598/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T13:28:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310288598",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310305445"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310305445"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "It would be useful to have a diagram describing the possible state transitions of this state machine:\r\n\r\n```cpp\r\n    /** State type that defines the contents of the receive buffer. Possible transitions:\r\n     * KEY_MAYBE_V1 --> V1                                                   *--------<---------*\r\n     *            |                                                          v                  |\r\n     *            *---> KEY --> GARB_GARBTERM --> GARBAUTH --> VERSION --> APP --> APP_READY -->*\r\n     */\r\n```\r\n\r\n(same for `SendState`)",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-30T13:42:58Z",
      "diff_hunk" : "@@ -416,7 +424,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the contents of the receive buffer. */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310305445",
      "id" : 1310305445,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OGayl",
      "original_commit_id" : "040ea05dae05ef513ac79306dd560c8c1f228942",
      "original_line" : 443,
      "original_position" : 61,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1602648914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310305445/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T13:28:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310305445",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310362246"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310362246"
         }
      },
      "author_association" : "MEMBER",
      "body" : "377ae15917dc460f589614ec33f567b523181dc3: do we want to be a bit more robust here and also check against all / some known other network magic values? Especially if we move away from being on port 8333 all the time. Ultimately the v2 handshake will fail anyway if e.g. a Signet node connects to us, but seems nicer to detect (and log) it.",
      "commit_id" : "75b91740fdeb9ad14cc6cb073e75867b49875a00",
      "created_at" : "2023-08-30T14:21:31Z",
      "diff_hunk" : "@@ -973,11 +987,44 @@ size_t V2Transport::GetMaxBytesToProcess() noexcept\n     case RecvState::APP_READY:\n         // No bytes can be processed until GetMessage() is called.\n         return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n     }\n     assert(false); // unreachable\n     return 0;\n }\n \n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310362246",
      "id" : 1310362246,
      "line" : 1146,
      "node_id" : "PRRC_kwDOABII585OGoqG",
      "original_commit_id" : "faf5af3f6b96488ebf9585c1558710545cde05a6",
      "original_line" : 1146,
      "original_position" : 86,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 263,
      "pull_request_review_id" : 1602833673,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310362246/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-01T19:06:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310362246",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310367236"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310367236"
         }
      },
      "author_association" : "MEMBER",
      "body" : "377ae15917dc460f589614ec33f567b523181dc3: `v1 prefix`",
      "commit_id" : "75b91740fdeb9ad14cc6cb073e75867b49875a00",
      "created_at" : "2023-08-30T14:25:02Z",
      "diff_hunk" : "@@ -973,11 +987,44 @@ size_t V2Transport::GetMaxBytesToProcess() noexcept\n     case RecvState::APP_READY:\n         // No bytes can be processed until GetMessage() is called.\n         return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n     }\n     assert(false); // unreachable\n     return 0;\n }\n \n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_MAYBE_V1 || m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310367236",
      "id" : 1310367236,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OGp4E",
      "original_commit_id" : "faf5af3f6b96488ebf9585c1558710545cde05a6",
      "original_line" : 1152,
      "original_position" : 93,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1602833673,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310367236/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-01T19:06:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310367236",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310446507"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310446507"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Good idea, I've rewritten some part of the code here using that approach. Also added more comments.",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-30T15:20:02Z",
      "diff_hunk" : "@@ -1213,7 +1276,22 @@ bool V2Transport::ReceivedBytes(Span<const uint8_t>& msg_bytes) noexcept\n \n std::optional<std::string> V2Transport::GetMessageType(Span<const uint8_t>& contents) noexcept\n {\n-    if (contents.size() < 13 || contents[0] != 0) return std::nullopt; // Short encoding not yet supported\n+    if (contents.size() == 0) return std::nullopt; // Empty contents\n+    uint8_t first_byte = contents[0];\n+\n+    if (first_byte != 0) {\n+        // Short (1 byte) encoding.\n+        if (first_byte < std::size(V2_MESSAGE_IDS)) {\n+            // Valid short message id.\n+            contents = contents.subspan(1);\n+            return V2_MESSAGE_IDS[first_byte];\n+        } else {\n+            // Unknown short message id.\n+            return std::nullopt;\n+        }\n+    }\n+\n+    if (contents.size() < 13) return std::nullopt; // Long encoding needs at least 13 bytes",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310446507",
      "id" : 1310446507,
      "in_reply_to_id" : 1309532823,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OG9Or",
      "original_commit_id" : "8a2e9f6fb909436f3c849c1088a3b79b2cfba119",
      "original_line" : 1310,
      "original_position" : 90,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1602960483,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310446507/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-30T15:20:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310446507",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310446699"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310446699"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done, and added a comment.",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-30T15:20:10Z",
      "diff_hunk" : "@@ -1270,9 +1348,17 @@ bool V2Transport::SetMessageToSend(CSerializedNetMsg& msg) noexcept\n \n     if (m_send_state != SendState::APP_READY) return false;\n     // Construct contents (encoding message type + payload).\n-    std::vector<uint8_t> contents(13 + msg.data.size(), 0);\n-    std::copy(msg.m_type.begin(), msg.m_type.end(), reinterpret_cast<char*>(contents.data() + 1));\n-    std::copy(msg.data.begin(), msg.data.end(), contents.begin() + 13);\n+    std::vector<uint8_t> contents;\n+    auto short_message_id = V2_MESSAGE_MAP(msg.m_type);\n+    if (short_message_id) {\n+        contents.resize(1 + msg.data.size());\n+        contents[0] = *short_message_id;\n+        std::copy(msg.data.begin(), msg.data.end(), contents.begin() + 1);\n+    } else {\n+        contents.resize(13 + msg.data.size());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310446699",
      "id" : 1310446699,
      "in_reply_to_id" : 1309537403,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OG9Rr",
      "original_commit_id" : "8a2e9f6fb909436f3c849c1088a3b79b2cfba119",
      "original_line" : 1374,
      "original_position" : 108,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1602960755,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310446699/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-30T15:20:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310446699",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310647503"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310647503"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: this initially confused me a little; maybe stress that it defines what we are _expecting_ to retrieve from the receive buffer but not necessarily the current content of the receive buffer (which may be empty if we haven't received anything yet, or contain other data if the peer didn't follow the protocol) - this seems like a small difference to the send buffer, where it actually contains the given info when it's in the status.",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-30T18:08:54Z",
      "diff_hunk" : "@@ -427,6 +429,160 @@ class V1Transport final : public Transport\n     size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n };\n \n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the contents of the receive buffer. */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310647503",
      "id" : 1310647503,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OHuTP",
      "original_commit_id" : "de705988c330fc5b3c006337bd72ca0f0c8e2750",
      "original_line" : 443,
      "original_position" : 33,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1601240500,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310647503/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-30T20:03:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310647503",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310685384"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310685384"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "maybe add a comment that `BIP324Cipher::EXPANSION` includes `BIP324Cipher::LENGTH_LEN` - I was wondering at first whether that needed to be accounted for too here until I looked it up.",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-30T18:46:29Z",
      "diff_hunk" : "@@ -912,6 +912,347 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310685384",
      "id" : 1310685384,
      "line" : 1050,
      "node_id" : "PRRC_kwDOABII585OH3jI",
      "original_commit_id" : "de705988c330fc5b3c006337bd72ca0f0c8e2750",
      "original_line" : 1050,
      "original_position" : 60,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 167,
      "pull_request_review_id" : 1601240500,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310685384/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-30T20:03:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310685384",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310694585"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310694585"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "typo: packet",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-30T18:55:41Z",
      "diff_hunk" : "@@ -912,6 +912,347 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packed decrypted into m_recv_decode_buffer. Depending on",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310694585",
      "id" : 1310694585,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OH5y5",
      "original_commit_id" : "de705988c330fc5b3c006337bd72ca0f0c8e2750",
      "original_line" : 1071,
      "original_position" : 160,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1601240500,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310694585/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-30T20:03:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310694585",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310695744"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310695744"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "typo: content",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-30T18:56:47Z",
      "diff_hunk" : "@@ -912,6 +912,347 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packed decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            m_recv_state = RecvState::VERSION;\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310695744",
      "id" : 1310695744,
      "line" : 1199,
      "node_id" : "PRRC_kwDOABII585OH6FA",
      "original_commit_id" : "de705988c330fc5b3c006337bd72ca0f0c8e2750",
      "original_line" : 1199,
      "original_position" : 171,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 316,
      "pull_request_review_id" : 1601240500,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310695744/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-30T20:03:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310695744",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310794366"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310794366"
         }
      },
      "author_association" : "MEMBER",
      "body" : "BIP324 calls it `contents`.",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-30T20:38:05Z",
      "diff_hunk" : "@@ -912,6 +912,347 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packed decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            m_recv_state = RecvState::VERSION;\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310794366",
      "id" : 1310794366,
      "in_reply_to_id" : 1310695744,
      "line" : 1199,
      "node_id" : "PRRC_kwDOABII585OISJ-",
      "original_commit_id" : "de705988c330fc5b3c006337bd72ca0f0c8e2750",
      "original_line" : 1199,
      "original_position" : 171,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 316,
      "pull_request_review_id" : 1603457794,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310794366/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-30T20:38:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310794366",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310794510"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310794510"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-30T20:38:12Z",
      "diff_hunk" : "@@ -912,6 +912,347 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packed decrypted into m_recv_decode_buffer. Depending on",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310794510",
      "id" : 1310794510,
      "in_reply_to_id" : 1310694585,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OISMO",
      "original_commit_id" : "de705988c330fc5b3c006337bd72ca0f0c8e2750",
      "original_line" : 1071,
      "original_position" : 160,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1603457938,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310794510/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-30T20:38:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310794510",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310794587"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310794587"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-30T20:38:18Z",
      "diff_hunk" : "@@ -912,6 +912,347 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310794587",
      "id" : 1310794587,
      "in_reply_to_id" : 1310685384,
      "line" : 1050,
      "node_id" : "PRRC_kwDOABII585OISNb",
      "original_commit_id" : "de705988c330fc5b3c006337bd72ca0f0c8e2750",
      "original_line" : 1050,
      "original_position" : 60,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 167,
      "pull_request_review_id" : 1603458045,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310794587/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-30T20:38:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310794587",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310794782"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310794782"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Expanded the comment a bit.",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-30T20:38:31Z",
      "diff_hunk" : "@@ -427,6 +429,160 @@ class V1Transport final : public Transport\n     size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n };\n \n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the contents of the receive buffer. */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310794782",
      "id" : 1310794782,
      "in_reply_to_id" : 1310647503,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OISQe",
      "original_commit_id" : "de705988c330fc5b3c006337bd72ca0f0c8e2750",
      "original_line" : 443,
      "original_position" : 33,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1603458343,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310794782/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-30T20:38:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310794782",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310795003"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310795003"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've added `CMessageHeader::COMMAND_SIZE` in a bunch of places.",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-30T20:38:45Z",
      "diff_hunk" : "@@ -912,6 +912,353 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::WAITING:\n+        // One byte is enough to transition to KEY.\n+        return 1;\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310795003",
      "id" : 1310795003,
      "in_reply_to_id" : 1309344192,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OIST7",
      "original_commit_id" : "f7c0be500adeeddba1671b6f4478ce369fc0c6b3",
      "original_line" : 1171,
      "original_position" : 141,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1603458652,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310795003/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-30T20:38:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310795003",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310795146"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310795146"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Added a commit to remove it.",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-30T20:38:55Z",
      "diff_hunk" : "@@ -912,6 +912,353 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310795146",
      "id" : 1310795146,
      "in_reply_to_id" : 1309329927,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OISWK",
      "original_commit_id" : "f7c0be500adeeddba1671b6f4478ce369fc0c6b3",
      "original_line" : 1020,
      "original_position" : 33,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1603458871,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310795146/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-30T20:38:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310795146",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311222591"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311222591"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "From your comment https://github.com/bitcoin/bitcoin/pull/28196#issuecomment-1699574611\r\n\r\n> ... both the sender side and receiver side of V2Transport are state machines that are transitioned through, with each state corresponding to the meaning of what is in the respective send/receive buffers. The receive state is changed by receiving bytes, or extracting completed messages. The send state is changed by receiving bytes, sending bytes, or being given a message to send.\r\n\r\nThat would be useful to have as a comment in the source code, somewhere around `RecvState` or `SendState`.",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-31T07:40:17Z",
      "diff_hunk" : "@@ -416,7 +414,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted. */\n+    enum class RecvState {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311222591",
      "id" : 1311222591,
      "line" : 435,
      "node_id" : "PRRC_kwDOABII585OJ6s_",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 435,
      "original_position" : 87,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 87,
      "pull_request_review_id" : 1602648914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311222591/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T13:28:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311222591",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311249370"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311249370"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "What about using `std::optional` to represent \"not on behalf of any message\" instead of `\"\"`?\r\n\r\n```cpp\r\n    using BytesToSend = std::tuple<\r\n        Span<const uint8_t> /*to_send*/,\r\n        bool /*more*/,\r\n        const std::optional<std::string>& /*m_type*/\r\n    >;\r\n...\r\n    /** Type of the message being sent. */\r\n    std::optional<std::string> m_send_type GUARDED_BY(m_send_mutex);\r\n```",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-31T08:02:43Z",
      "diff_hunk" : "@@ -300,7 +299,8 @@ class Transport {\n      *  - Span<const uint8_t> to_send: span of bytes to be sent over the wire (possibly empty).\n      *  - bool more: whether there will be more bytes to be sent after the ones in to_send are\n      *    all sent (as signaled by MarkBytesSent()).\n-     *  - const std::string& m_type: message type on behalf of which this is being sent.\n+     *  - const std::string& m_type: message type on behalf of which this is being sent\n+     *    (\"\" for bytes that are not on behalf of any message).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311249370",
      "id" : 1311249370,
      "line" : 303,
      "node_id" : "PRRC_kwDOABII585OKBPa",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 303,
      "original_position" : 23,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 23,
      "pull_request_review_id" : 1602648914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311249370/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T13:28:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311249370",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311376345"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311376345"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Consider this: https://google.github.io/styleguide/cppguide#Declaration_Order, personally I find it easier to read the interface if that order is followed. Or at least I would avoid two `public:` sections.",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-31T09:43:29Z",
      "diff_hunk" : "@@ -416,7 +414,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311376345",
      "id" : 1311376345,
      "line" : 427,
      "node_id" : "PRRC_kwDOABII585OKgPZ",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 427,
      "original_position" : 79,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 79,
      "pull_request_review_id" : 1602648914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311376345/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T13:28:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311376345",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311381100"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311381100"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "typo and an extra `)`: \r\n```suggestion\r\n     *  m_recv_buffer.size() >= BIP324Cipher::LENGTH_LEN. Unspecified otherwise. */\r\n```",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-31T09:47:43Z",
      "diff_hunk" : "@@ -416,7 +414,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted. */\n+    enum class RecvState {\n+        /** (Responder only) either v2 public key or v1 header.\n+         *\n+         * This is the initial state for responders, before data has been received to distinguish\n+         * v1 from v2 connections. When that happens, the state becomes either KEY (for v2) or V1\n+         * (for v1). */\n+        KEY_MAYBE_V1,\n+\n+        /** Public key.\n+         *\n+         * This is the initial state for initiators, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, its contents is\n+         * interpreted as version negotiation (currently, that means ignoring it, but it can be\n+         * used for negotiating future extensions). If it fails, the connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All receive operations are redirected to m_v1_fallback. m_use_v1 is also set in this\n+         * state, so this redirection can usually happen without needing the m_cs_recv lock. */\n+        V1,\n+    };\n+\n+    /** State type that defines the contents of the send buffer. */\n+    enum class SendState {\n+        /** (Responder only) Public key and garbage.\n+         *\n+         * This is the initial state for responders. The send buffer contains the public key and\n+         * garbage to send, but nothing is sent in this state yet. When the receiver determines\n+         * whether this is a V1 or V2 connection, the sender state becomes KEY_GARB (for v2) or V1\n+         * (for v1) as well.\n+         */\n+        KEY_GARB_MAYBE_V1,\n+\n+        /** Public key and garbage.\n+         *\n+         * This is the initial state for initiators. The public key plus garbage are sent out. When\n+         * the receiver receives the other side's public key and transitions to GARB_GARBTERM, the\n+         * sender state becomes KEY_GARB_GARBTERM_GARBAUTH_VERSION. The key and garbage are left in\n+         * the send buffer when this happens, because they may not have been fully sent out yet. */\n+        KEY_GARB,\n+\n+        /** Public key + garbage + garbage terminator + garbage authenticator + version packet.\n+         *\n+         * This is the state the sender is in after the other side's public key has been received.\n+         * Whatever remains of the public key and garbage are sent, plus garbage terminator,\n+         * authentication packet, and version packet. When all of that is sent, the sender state\n+         * becomes APP_READY. */\n+        KEY_GARB_GARBTERM_GARBAUTH_VERSION,\n+\n+        /** Nothing (an application message to send can be provided).\n+         *\n+         * We're ready to start sending an application message at this point, but none are\n+         * currently provided. Upon SetMessageToSend() the sender state becomes APP. */\n+        APP_READY,\n+\n+        /** Application packet.\n+         *\n+         * There is an encrypted packet encoding an application message in the send buffer right now.\n+         * When it is fully sent, the sender state becomes APP_READY. */\n+        APP,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All send operations are redirected to m_v1_fallback. m_use_v1 is also set in this state,\n+         * so this redirection can usually happen without needing the m_cs_send lock. */\n+        V1,\n+    };\n+\n+    /** Cipher state. */\n+    BIP324Cipher m_cipher;\n+    /** Whether we are the initiator side. */\n+    const bool m_initiating;\n+    /** NodeId (for debug logging). */\n+    const NodeId m_nodeid;\n+    /** Whether the send/receive states are V1. This is an optimization allowing fallback to\n+     *  (typically) work without the m_cs_send or m_cs_recv locks. */\n+    std::atomic<bool> m_use_v1{false};\n+    /** Encapsulate a V1Transport to fall back to. */\n+    V1Transport m_v1_fallback;\n+    /** V1 prefix to look for (4-byte network magic + \"version\\x00\"; magic will be filled in). */\n+    std::array<uint8_t, 12> m_v1_prefix = {0, 0, 0, 0, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00};\n+\n+    /** Lock for receiver-side fields. */\n+    mutable Mutex m_recv_mutex;\n+    /** In {GARBAUTH, VERSION, APP}, the decrypted packet length, if\n+     *  m_recv_buffer.size() >= BIP324::LENGTH_LEN). Unspecified otherwise. */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311381100",
      "id" : 1311381100,
      "line" : 555,
      "node_id" : "PRRC_kwDOABII585OKhZs",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 555,
      "original_position" : 207,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 207,
      "pull_request_review_id" : 1602648914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311381100/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T13:28:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311381100",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311393641"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311393641"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Can be `const`?\r\n```suggestion\r\n    const int m_recv_type GUARDED_BY(m_recv_mutex);\r\n```\r\n\r\nSame for `m_recv_version`.",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-31T09:58:06Z",
      "diff_hunk" : "@@ -416,7 +414,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted. */\n+    enum class RecvState {\n+        /** (Responder only) either v2 public key or v1 header.\n+         *\n+         * This is the initial state for responders, before data has been received to distinguish\n+         * v1 from v2 connections. When that happens, the state becomes either KEY (for v2) or V1\n+         * (for v1). */\n+        KEY_MAYBE_V1,\n+\n+        /** Public key.\n+         *\n+         * This is the initial state for initiators, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, its contents is\n+         * interpreted as version negotiation (currently, that means ignoring it, but it can be\n+         * used for negotiating future extensions). If it fails, the connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All receive operations are redirected to m_v1_fallback. m_use_v1 is also set in this\n+         * state, so this redirection can usually happen without needing the m_cs_recv lock. */\n+        V1,\n+    };\n+\n+    /** State type that defines the contents of the send buffer. */\n+    enum class SendState {\n+        /** (Responder only) Public key and garbage.\n+         *\n+         * This is the initial state for responders. The send buffer contains the public key and\n+         * garbage to send, but nothing is sent in this state yet. When the receiver determines\n+         * whether this is a V1 or V2 connection, the sender state becomes KEY_GARB (for v2) or V1\n+         * (for v1) as well.\n+         */\n+        KEY_GARB_MAYBE_V1,\n+\n+        /** Public key and garbage.\n+         *\n+         * This is the initial state for initiators. The public key plus garbage are sent out. When\n+         * the receiver receives the other side's public key and transitions to GARB_GARBTERM, the\n+         * sender state becomes KEY_GARB_GARBTERM_GARBAUTH_VERSION. The key and garbage are left in\n+         * the send buffer when this happens, because they may not have been fully sent out yet. */\n+        KEY_GARB,\n+\n+        /** Public key + garbage + garbage terminator + garbage authenticator + version packet.\n+         *\n+         * This is the state the sender is in after the other side's public key has been received.\n+         * Whatever remains of the public key and garbage are sent, plus garbage terminator,\n+         * authentication packet, and version packet. When all of that is sent, the sender state\n+         * becomes APP_READY. */\n+        KEY_GARB_GARBTERM_GARBAUTH_VERSION,\n+\n+        /** Nothing (an application message to send can be provided).\n+         *\n+         * We're ready to start sending an application message at this point, but none are\n+         * currently provided. Upon SetMessageToSend() the sender state becomes APP. */\n+        APP_READY,\n+\n+        /** Application packet.\n+         *\n+         * There is an encrypted packet encoding an application message in the send buffer right now.\n+         * When it is fully sent, the sender state becomes APP_READY. */\n+        APP,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All send operations are redirected to m_v1_fallback. m_use_v1 is also set in this state,\n+         * so this redirection can usually happen without needing the m_cs_send lock. */\n+        V1,\n+    };\n+\n+    /** Cipher state. */\n+    BIP324Cipher m_cipher;\n+    /** Whether we are the initiator side. */\n+    const bool m_initiating;\n+    /** NodeId (for debug logging). */\n+    const NodeId m_nodeid;\n+    /** Whether the send/receive states are V1. This is an optimization allowing fallback to\n+     *  (typically) work without the m_cs_send or m_cs_recv locks. */\n+    std::atomic<bool> m_use_v1{false};\n+    /** Encapsulate a V1Transport to fall back to. */\n+    V1Transport m_v1_fallback;\n+    /** V1 prefix to look for (4-byte network magic + \"version\\x00\"; magic will be filled in). */\n+    std::array<uint8_t, 12> m_v1_prefix = {0, 0, 0, 0, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00};\n+\n+    /** Lock for receiver-side fields. */\n+    mutable Mutex m_recv_mutex;\n+    /** In {GARBAUTH, VERSION, APP}, the decrypted packet length, if\n+     *  m_recv_buffer.size() >= BIP324::LENGTH_LEN). Unspecified otherwise. */\n+    uint32_t m_recv_len GUARDED_BY(m_recv_mutex) {0};\n+    /** Receive buffer; meaning is determined by m_recv_state. */\n+    std::vector<uint8_t> m_recv_buffer GUARDED_BY(m_recv_mutex);\n+    /** During GARBAUTH, the garbage received during GARB_GARBTERM. */\n+    std::vector<uint8_t> m_recv_garbage GUARDED_BY(m_recv_mutex);\n+    /** Buffer to put decrypted contents in, for converting to CNetMessage. */\n+    std::vector<uint8_t> m_recv_decode_buffer GUARDED_BY(m_recv_mutex);\n+    /** Deserialization type. */\n+    int m_recv_type GUARDED_BY(m_recv_mutex);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311393641",
      "id" : 1311393641,
      "line" : 564,
      "node_id" : "PRRC_kwDOABII585OKkdp",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 564,
      "original_position" : 216,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 216,
      "pull_request_review_id" : 1602648914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311393641/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T13:28:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311393641",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311402373"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311402373"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In some places `uint8_t` is used and in some other `std::byte`. I guess they are used interchangeably? Maybe for consistency use just one of them everywhere.",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-31T10:05:18Z",
      "diff_hunk" : "@@ -416,7 +414,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted. */\n+    enum class RecvState {\n+        /** (Responder only) either v2 public key or v1 header.\n+         *\n+         * This is the initial state for responders, before data has been received to distinguish\n+         * v1 from v2 connections. When that happens, the state becomes either KEY (for v2) or V1\n+         * (for v1). */\n+        KEY_MAYBE_V1,\n+\n+        /** Public key.\n+         *\n+         * This is the initial state for initiators, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, its contents is\n+         * interpreted as version negotiation (currently, that means ignoring it, but it can be\n+         * used for negotiating future extensions). If it fails, the connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All receive operations are redirected to m_v1_fallback. m_use_v1 is also set in this\n+         * state, so this redirection can usually happen without needing the m_cs_recv lock. */\n+        V1,\n+    };\n+\n+    /** State type that defines the contents of the send buffer. */\n+    enum class SendState {\n+        /** (Responder only) Public key and garbage.\n+         *\n+         * This is the initial state for responders. The send buffer contains the public key and\n+         * garbage to send, but nothing is sent in this state yet. When the receiver determines\n+         * whether this is a V1 or V2 connection, the sender state becomes KEY_GARB (for v2) or V1\n+         * (for v1) as well.\n+         */\n+        KEY_GARB_MAYBE_V1,\n+\n+        /** Public key and garbage.\n+         *\n+         * This is the initial state for initiators. The public key plus garbage are sent out. When\n+         * the receiver receives the other side's public key and transitions to GARB_GARBTERM, the\n+         * sender state becomes KEY_GARB_GARBTERM_GARBAUTH_VERSION. The key and garbage are left in\n+         * the send buffer when this happens, because they may not have been fully sent out yet. */\n+        KEY_GARB,\n+\n+        /** Public key + garbage + garbage terminator + garbage authenticator + version packet.\n+         *\n+         * This is the state the sender is in after the other side's public key has been received.\n+         * Whatever remains of the public key and garbage are sent, plus garbage terminator,\n+         * authentication packet, and version packet. When all of that is sent, the sender state\n+         * becomes APP_READY. */\n+        KEY_GARB_GARBTERM_GARBAUTH_VERSION,\n+\n+        /** Nothing (an application message to send can be provided).\n+         *\n+         * We're ready to start sending an application message at this point, but none are\n+         * currently provided. Upon SetMessageToSend() the sender state becomes APP. */\n+        APP_READY,\n+\n+        /** Application packet.\n+         *\n+         * There is an encrypted packet encoding an application message in the send buffer right now.\n+         * When it is fully sent, the sender state becomes APP_READY. */\n+        APP,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All send operations are redirected to m_v1_fallback. m_use_v1 is also set in this state,\n+         * so this redirection can usually happen without needing the m_cs_send lock. */\n+        V1,\n+    };\n+\n+    /** Cipher state. */\n+    BIP324Cipher m_cipher;\n+    /** Whether we are the initiator side. */\n+    const bool m_initiating;\n+    /** NodeId (for debug logging). */\n+    const NodeId m_nodeid;\n+    /** Whether the send/receive states are V1. This is an optimization allowing fallback to\n+     *  (typically) work without the m_cs_send or m_cs_recv locks. */\n+    std::atomic<bool> m_use_v1{false};\n+    /** Encapsulate a V1Transport to fall back to. */\n+    V1Transport m_v1_fallback;\n+    /** V1 prefix to look for (4-byte network magic + \"version\\x00\"; magic will be filled in). */\n+    std::array<uint8_t, 12> m_v1_prefix = {0, 0, 0, 0, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00};\n+\n+    /** Lock for receiver-side fields. */\n+    mutable Mutex m_recv_mutex;\n+    /** In {GARBAUTH, VERSION, APP}, the decrypted packet length, if\n+     *  m_recv_buffer.size() >= BIP324::LENGTH_LEN). Unspecified otherwise. */\n+    uint32_t m_recv_len GUARDED_BY(m_recv_mutex) {0};\n+    /** Receive buffer; meaning is determined by m_recv_state. */\n+    std::vector<uint8_t> m_recv_buffer GUARDED_BY(m_recv_mutex);\n+    /** During GARBAUTH, the garbage received during GARB_GARBTERM. */\n+    std::vector<uint8_t> m_recv_garbage GUARDED_BY(m_recv_mutex);\n+    /** Buffer to put decrypted contents in, for converting to CNetMessage. */\n+    std::vector<uint8_t> m_recv_decode_buffer GUARDED_BY(m_recv_mutex);\n+    /** Deserialization type. */\n+    int m_recv_type GUARDED_BY(m_recv_mutex);\n+    /** Deserialization version number. */\n+    int m_recv_version GUARDED_BY(m_recv_mutex);\n+    /** Current receiver state. */\n+    RecvState m_recv_state GUARDED_BY(m_recv_mutex);\n+\n+    /** Lock for sending-side fields. */\n+    mutable Mutex m_send_mutex;\n+    /** The send buffer; meaning is determined by m_send_state. */\n+    std::vector<uint8_t> m_send_buffer GUARDED_BY(m_send_mutex);\n+    /** How many bytes from the send buffer have been sent so far. */\n+    uint32_t m_send_pos GUARDED_BY(m_send_mutex) {0};\n+    /** Type of the message being sent. */\n+    std::string m_send_type GUARDED_BY(m_send_mutex);\n+    /** Current sender state. */\n+    SendState m_send_state GUARDED_BY(m_send_mutex);\n+\n+    /** Given a packet's contents, find the message type (if valid), and strip it from contents. */\n+    static std::optional<std::string> GetMessageType(Span<const uint8_t>& contents) noexcept;\n+    /** Determine how many received bytes can be processed in one go (not allowed in V1 state). */\n+    size_t GetMaxBytesToProcess() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex);\n+    /** Process m_recv_buffer in KEY_MAYBE_V1 state. */\n+    void ProcessReceivedMaybeV1() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex, !m_send_mutex);\n+    /** Process m_recv_buffer in KEY state. */\n+    void ProcessReceivedKey() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex, !m_send_mutex);\n+    /** Process m_recv_buffer in GARB_GARBTERM state. */\n+    bool ProcessReceivedGarbage() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex);\n+    /** Process m_recv_buffer in GARBAUTH/VERSION/APP state. */\n+    bool ProcessReceivedPacket() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex);\n+\n+public:\n+\n+    /** Construct a V2 transport with securely generated random keys. */\n+    V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept;\n+    /** Construct a V2 transport with specified keys and garbage (test use only). */\n+    V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311402373",
      "id" : 1311402373,
      "line" : 599,
      "node_id" : "PRRC_kwDOABII585OKmmF",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 599,
      "original_position" : 251,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 251,
      "pull_request_review_id" : 1602648914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311402373/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T13:28:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311402373",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311460423"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311460423"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "It is not immediately obvious whether these subtractions can go negative. Should this be handled? Or if it cannot happen, then an assert/assume?",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-31T10:59:13Z",
      "diff_hunk" : "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311460423",
      "id" : 1311460423,
      "line" : 1034,
      "node_id" : "PRRC_kwDOABII585OK0xH",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 1034,
      "original_position" : 151,
      "original_start_line" : 1029,
      "path" : "src/net.cpp",
      "position" : 151,
      "pull_request_review_id" : 1602648914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311460423/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 1029,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-31T13:28:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311460423",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311500825"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311500825"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Maybe expand the comments with something like this:\r\n\r\nTo avoid deadlocks, if both `m_recv_mutex` and `m_send_mutex` have to be locked at the same time, always lock `m_recv_mutex` first. I.e. when locking `m_recv_mutex`, make sure that `m_send_mutex` is not already locked by the calling thread.",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-31T11:39:13Z",
      "diff_hunk" : "@@ -416,7 +414,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted. */\n+    enum class RecvState {\n+        /** (Responder only) either v2 public key or v1 header.\n+         *\n+         * This is the initial state for responders, before data has been received to distinguish\n+         * v1 from v2 connections. When that happens, the state becomes either KEY (for v2) or V1\n+         * (for v1). */\n+        KEY_MAYBE_V1,\n+\n+        /** Public key.\n+         *\n+         * This is the initial state for initiators, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, its contents is\n+         * interpreted as version negotiation (currently, that means ignoring it, but it can be\n+         * used for negotiating future extensions). If it fails, the connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All receive operations are redirected to m_v1_fallback. m_use_v1 is also set in this\n+         * state, so this redirection can usually happen without needing the m_cs_recv lock. */\n+        V1,\n+    };\n+\n+    /** State type that defines the contents of the send buffer. */\n+    enum class SendState {\n+        /** (Responder only) Public key and garbage.\n+         *\n+         * This is the initial state for responders. The send buffer contains the public key and\n+         * garbage to send, but nothing is sent in this state yet. When the receiver determines\n+         * whether this is a V1 or V2 connection, the sender state becomes KEY_GARB (for v2) or V1\n+         * (for v1) as well.\n+         */\n+        KEY_GARB_MAYBE_V1,\n+\n+        /** Public key and garbage.\n+         *\n+         * This is the initial state for initiators. The public key plus garbage are sent out. When\n+         * the receiver receives the other side's public key and transitions to GARB_GARBTERM, the\n+         * sender state becomes KEY_GARB_GARBTERM_GARBAUTH_VERSION. The key and garbage are left in\n+         * the send buffer when this happens, because they may not have been fully sent out yet. */\n+        KEY_GARB,\n+\n+        /** Public key + garbage + garbage terminator + garbage authenticator + version packet.\n+         *\n+         * This is the state the sender is in after the other side's public key has been received.\n+         * Whatever remains of the public key and garbage are sent, plus garbage terminator,\n+         * authentication packet, and version packet. When all of that is sent, the sender state\n+         * becomes APP_READY. */\n+        KEY_GARB_GARBTERM_GARBAUTH_VERSION,\n+\n+        /** Nothing (an application message to send can be provided).\n+         *\n+         * We're ready to start sending an application message at this point, but none are\n+         * currently provided. Upon SetMessageToSend() the sender state becomes APP. */\n+        APP_READY,\n+\n+        /** Application packet.\n+         *\n+         * There is an encrypted packet encoding an application message in the send buffer right now.\n+         * When it is fully sent, the sender state becomes APP_READY. */\n+        APP,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All send operations are redirected to m_v1_fallback. m_use_v1 is also set in this state,\n+         * so this redirection can usually happen without needing the m_cs_send lock. */\n+        V1,\n+    };\n+\n+    /** Cipher state. */\n+    BIP324Cipher m_cipher;\n+    /** Whether we are the initiator side. */\n+    const bool m_initiating;\n+    /** NodeId (for debug logging). */\n+    const NodeId m_nodeid;\n+    /** Whether the send/receive states are V1. This is an optimization allowing fallback to\n+     *  (typically) work without the m_cs_send or m_cs_recv locks. */\n+    std::atomic<bool> m_use_v1{false};\n+    /** Encapsulate a V1Transport to fall back to. */\n+    V1Transport m_v1_fallback;\n+    /** V1 prefix to look for (4-byte network magic + \"version\\x00\"; magic will be filled in). */\n+    std::array<uint8_t, 12> m_v1_prefix = {0, 0, 0, 0, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00};\n+\n+    /** Lock for receiver-side fields. */\n+    mutable Mutex m_recv_mutex;\n+    /** In {GARBAUTH, VERSION, APP}, the decrypted packet length, if\n+     *  m_recv_buffer.size() >= BIP324::LENGTH_LEN). Unspecified otherwise. */\n+    uint32_t m_recv_len GUARDED_BY(m_recv_mutex) {0};\n+    /** Receive buffer; meaning is determined by m_recv_state. */\n+    std::vector<uint8_t> m_recv_buffer GUARDED_BY(m_recv_mutex);\n+    /** During GARBAUTH, the garbage received during GARB_GARBTERM. */\n+    std::vector<uint8_t> m_recv_garbage GUARDED_BY(m_recv_mutex);\n+    /** Buffer to put decrypted contents in, for converting to CNetMessage. */\n+    std::vector<uint8_t> m_recv_decode_buffer GUARDED_BY(m_recv_mutex);\n+    /** Deserialization type. */\n+    int m_recv_type GUARDED_BY(m_recv_mutex);\n+    /** Deserialization version number. */\n+    int m_recv_version GUARDED_BY(m_recv_mutex);\n+    /** Current receiver state. */\n+    RecvState m_recv_state GUARDED_BY(m_recv_mutex);\n+\n+    /** Lock for sending-side fields. */\n+    mutable Mutex m_send_mutex;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311500825",
      "id" : 1311500825,
      "line" : 571,
      "node_id" : "PRRC_kwDOABII585OK-oZ",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 571,
      "original_position" : 223,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 223,
      "pull_request_review_id" : 1602648914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311500825/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T13:28:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311500825",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311508831"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311508831"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This is doing an extra copy of the key - first from the buffer to the array and then from the array to ~`m_cipher.m_pubkey`~ `EllSwiftPubKey::m_pubkey`. Is it possible to avoid that? Is it possible to initialize `m_cipher.m_pubkey` directly from the buffer? I think it is ok to take vector in `EllSwiftPubKey` and document that its size must be `EllSwiftPubKey::size()` and assert that it is indeed.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T11:47:02Z",
      "diff_hunk" : "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311508831",
      "id" : 1311508831,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OLAlf",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 1106,
      "original_position" : 223,
      "original_start_line" : 1103,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1602648914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311508831/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-09-01T09:27:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311508831",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311514245"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311514245"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "It would be good to enforce the state machine allowed transitions - in all places that change the state, assert that such transition is allowed. In this case: `assert(m_recv_state == RecvState::KEY)`. Or maybe have `m_recv_state` be a class that enforces correctness internally and is then called like:\r\n\r\n```cpp\r\nm_recv_state.ChangeTo(RecvState::GARB_GARBTERM);\r\n```",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-31T11:52:16Z",
      "diff_hunk" : "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311514245",
      "id" : 1311514245,
      "line" : 1109,
      "node_id" : "PRRC_kwDOABII585OLB6F",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 1109,
      "original_position" : 226,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 226,
      "pull_request_review_id" : 1602648914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311514245/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T13:28:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311514245",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311548994"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311548994"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "What about changing that `==` to `>=`? Otherwise, if it somehow happens that the buffer is larger, then this safety check will never catch it and it will keep receiving \"forever\".",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-31T12:24:14Z",
      "diff_hunk" : "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARB_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        size_t garbage_len = m_send_buffer.size() - EllSwiftPubKey::size();\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer (using the garbage data which\n+        // already there).\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            MakeByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size(), garbage_len),\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311548994",
      "id" : 1311548994,
      "line" : 1149,
      "node_id" : "PRRC_kwDOABII585OLKZC",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 1149,
      "original_position" : 266,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 266,
      "pull_request_review_id" : 1602648914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311548994/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T13:28:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311548994",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311553670"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311553670"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Would be nice if at the start of the function, or just before `m_recv_state = ...` there is something like `assert(current state is xyz);`",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-31T12:28:18Z",
      "diff_hunk" : "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARB_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        size_t garbage_len = m_send_buffer.size() - EllSwiftPubKey::size();\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer (using the garbage data which\n+        // already there).\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            MakeByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size(), garbage_len),\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311553670",
      "id" : 1311553670,
      "line" : 1148,
      "node_id" : "PRRC_kwDOABII585OLLiG",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 1148,
      "original_position" : 265,
      "original_start_line" : 1139,
      "path" : "src/net.cpp",
      "position" : 265,
      "pull_request_review_id" : 1602648914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311553670/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 1139,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-31T13:28:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311553670",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311560086"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311560086"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "```suggestion\r\n        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\r\n        const auto max = std::min(MAX_SIZE, MAX_PROTOCOL_MESSAGE_LENGTH) + 1 /* what is this? */ + CMessageHeader::COMMAND_SIZE;\r\n        if (m_recv_len > max) {\r\n            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes > %u), peer=%d\\n\", m_recv_len, max, m_nodeid);\r\n```",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-31T12:33:51Z",
      "diff_hunk" : "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARB_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        size_t garbage_len = m_send_buffer.size() - EllSwiftPubKey::size();\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer (using the garbage data which\n+        // already there).\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            MakeByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size(), garbage_len),\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 1 + CMessageHeader::COMMAND_SIZE ||\n+            m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 1 + CMessageHeader::COMMAND_SIZE) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311560086",
      "id" : 1311560086,
      "line" : 1167,
      "node_id" : "PRRC_kwDOABII585OLNGW",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 1167,
      "original_position" : 284,
      "original_start_line" : 1164,
      "path" : "src/net.cpp",
      "position" : 284,
      "pull_request_review_id" : 1602648914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311560086/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 1164,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-31T13:28:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311560086",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311568129"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311568129"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Is it possible that this branch executes before the one above? If the buffer is less than `LENGTH_LEN` (3) and then on the next invocation of this method, it is greater than `LENGTH_LEN` (3), equal to `EXPANSION` (20)?\r\n\r\nEdit: that's not possible currently. It relies on\r\n1. this method being called only if `m_recv_state` is one of `GARBAUTH`, `VERSION`, `APP` and\r\n2. `GetMaxBytesToProcess()` working correctly\r\n\r\nthat's a bit remote from the point of view inside this function. Maybe add assert or assume to ensure that?",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-31T12:40:31Z",
      "diff_hunk" : "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARB_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        size_t garbage_len = m_send_buffer.size() - EllSwiftPubKey::size();\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer (using the garbage data which\n+        // already there).\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            MakeByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size(), garbage_len),\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 1 + CMessageHeader::COMMAND_SIZE ||\n+            m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 1 + CMessageHeader::COMMAND_SIZE) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311568129",
      "id" : 1311568129,
      "line" : 1170,
      "node_id" : "PRRC_kwDOABII585OLPEB",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 1170,
      "original_position" : 287,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 287,
      "pull_request_review_id" : 1602648914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311568129/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T13:36:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311568129",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311613938"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311613938"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "The cast seems unnecessary?\r\n```suggestion\r\n        std::copy(msg.m_type.begin(), msg.m_type.end(), contents.data() + 1);\r\n        std::copy(msg.data.begin(), msg.data.end(), contents.begin() + 1 + CMessageHeader::COMMAND_SIZE);\r\n```",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-31T13:16:22Z",
      "diff_hunk" : "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARB_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        size_t garbage_len = m_send_buffer.size() - EllSwiftPubKey::size();\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer (using the garbage data which\n+        // already there).\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            MakeByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size(), garbage_len),\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 1 + CMessageHeader::COMMAND_SIZE ||\n+            m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 1 + CMessageHeader::COMMAND_SIZE) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packet decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            m_recv_state = RecvState::VERSION;\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is\n+                // ignored, but can be used for future extensions.\n+                m_recv_state = RecvState::APP;\n+            }\n+            break;\n+        case RecvState::APP:\n+            if (!ignore) {\n+                // Application message decrypted correctly. It can be extracted using GetMessage().\n+                m_recv_state = RecvState::APP_READY;\n+            }\n+            break;\n+        default:\n+            // Any other state is invalid (this function should not have been called).\n+            assert(false);\n+        }\n+        // Wipe the receive buffer where the next packet will be received into.\n+        m_recv_buffer = {};\n+        // In all but APP_READY state, we can wipe the decoded contents.\n+        if (m_recv_state != RecvState::APP_READY) m_recv_decode_buffer = {};\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ReceivedBytes(Span<const uint8_t>& msg_bytes) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    /** How many bytes to allocate in the receive buffer at most above what is received so far. */\n+    static constexpr size_t MAX_RESERVE_AHEAD = 250000;\n+\n+    if (m_use_v1) return m_v1_fallback.ReceivedBytes(msg_bytes);\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedBytes(msg_bytes);\n+\n+    while (!msg_bytes.empty()) {\n+        // Decide how many bytes to copy from msg_bytes to m_recv_buffer.\n+        size_t max_read = GetMaxBytesToProcess();\n+        // Reserve space in the buffer.\n+        if (m_recv_state == RecvState::KEY_MAYBE_V1 || m_recv_state == RecvState::KEY ||\n+            m_recv_state == RecvState::GARB_GARBTERM) {\n+            // During the initial states (key/garbage), allocate once to fit the maximum (4111\n+            // bytes).\n+            m_recv_buffer.reserve(MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        } else if (m_recv_state == RecvState::GARBAUTH || m_recv_state == RecvState::VERSION ||\n+            m_recv_state == RecvState::APP) {\n+            // During states where a packet is being received, as much as is expected but never\n+            // more than MAX_RESERVE_AHEAD bytes in addition to what is received so far.\n+            size_t alloc_add = std::min(max_read, msg_bytes.size() + MAX_RESERVE_AHEAD);\n+            m_recv_buffer.reserve(m_recv_buffer.size() + alloc_add);\n+        }\n+        // Can't read more than provided input.\n+        max_read = std::min<uint32_t>(msg_bytes.size(), max_read);\n+        // Copy data to buffer.\n+        m_recv_buffer.insert(m_recv_buffer.end(), UCharCast(msg_bytes.data()), UCharCast(msg_bytes.data() + max_read));\n+        msg_bytes = msg_bytes.subspan(max_read);\n+\n+        // Process data in the buffer.\n+        switch (m_recv_state) {\n+        case RecvState::KEY_MAYBE_V1:\n+            ProcessReceivedMaybeV1();\n+            if (m_recv_state == RecvState::V1) return true;\n+            break;\n+\n+        case RecvState::KEY:\n+            ProcessReceivedKey();\n+            break;\n+\n+        case RecvState::GARB_GARBTERM:\n+            if (!ProcessReceivedGarbage()) return false;\n+            break;\n+\n+        case RecvState::GARBAUTH:\n+        case RecvState::VERSION:\n+        case RecvState::APP:\n+            if (!ProcessReceivedPacket()) return false;\n+            break;\n+\n+        case RecvState::APP_READY:\n+            return true;\n+\n+        case RecvState::V1:\n+            // We should have bailed out before.\n+            assert(false);\n+            break;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+std::optional<std::string> V2Transport::GetMessageType(Span<const uint8_t>& contents) noexcept\n+{\n+    if (contents.size() == 0) return std::nullopt; // Empty contents\n+    uint8_t first_byte = contents[0];\n+    contents = contents.subspan(1); // Strip first byte.\n+\n+    if (first_byte != 0) {\n+        // Short (1 byte) encoding.\n+        if (first_byte < std::size(V2_MESSAGE_IDS)) {\n+            // Valid short message id.\n+            return V2_MESSAGE_IDS[first_byte];\n+        } else {\n+            // Unknown short message id.\n+            return std::nullopt;\n+        }\n+    }\n+\n+    if (contents.size() < CMessageHeader::COMMAND_SIZE) {\n+        return std::nullopt; // Long encoding needs 12 message type bytes.\n+    }\n+\n+    size_t msg_type_len{0};\n+    while (msg_type_len < CMessageHeader::COMMAND_SIZE && contents[msg_type_len] != 0) {\n+        // Verify that message type bytes before the first 0x00 are in range.\n+        if (contents[msg_type_len] < ' ' || contents[msg_type_len] > 0x7F) {\n+            return {};\n+        }\n+        ++msg_type_len;\n+    }\n+    std::string ret{reinterpret_cast<const char*>(contents.data()), msg_type_len};\n+    while (msg_type_len < CMessageHeader::COMMAND_SIZE) {\n+        // Verify that message type bytes after the first 0x00 are also 0x00.\n+        if (contents[msg_type_len] != 0) return {};\n+        ++msg_type_len;\n+    }\n+    // Strip message type bytes of contents.\n+    contents = contents.subspan(CMessageHeader::COMMAND_SIZE);\n+    return {std::move(ret)};\n+}\n+\n+CNetMessage V2Transport::GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.GetReceivedMessage(time, reject_message);\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.GetReceivedMessage(time, reject_message);\n+\n+    assert(m_recv_state == RecvState::APP_READY);\n+    Span<const uint8_t> contents{m_recv_decode_buffer};\n+    auto msg_type = GetMessageType(contents);\n+    CDataStream ret(m_recv_type, m_recv_version);\n+    CNetMessage msg{std::move(ret)};\n+    msg.m_raw_message_size = m_recv_decode_buffer.size() + BIP324Cipher::EXPANSION;\n+    if (msg_type) {\n+        reject_message = false;\n+        msg.m_type = std::move(*msg_type);\n+        msg.m_time = time;\n+        msg.m_message_size = contents.size();\n+        msg.m_recv.resize(contents.size());\n+        std::copy(contents.begin(), contents.end(), UCharCast(msg.m_recv.data()));\n+    } else {\n+        LogPrint(BCLog::NET, \"V2 transport error: invalid message type (%u bytes contents), peer=%d\\n\", m_recv_decode_buffer.size(), m_nodeid);\n+        reject_message = true;\n+    }\n+    m_recv_decode_buffer = {};\n+    m_recv_state = RecvState::APP;\n+\n+    return msg;\n+}\n+\n+bool V2Transport::SetMessageToSend(CSerializedNetMsg& msg) noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_use_v1) return m_v1_fallback.SetMessageToSend(msg);\n+    LOCK(m_send_mutex);\n+    if (m_send_state == SendState::V1) return m_v1_fallback.SetMessageToSend(msg);\n+\n+    if (m_send_state != SendState::APP_READY) return false;\n+    // Construct contents (encoding message type + payload).\n+    std::vector<uint8_t> contents;\n+    auto short_message_id = V2_MESSAGE_MAP(msg.m_type);\n+    if (short_message_id) {\n+        contents.resize(1 + msg.data.size());\n+        contents[0] = *short_message_id;\n+        std::copy(msg.data.begin(), msg.data.end(), contents.begin() + 1);\n+    } else {\n+        // Initialize with zeroes, and then write the message type string starting at offset 0.\n+        // This means contents[0] and the unused positions in contents[1..13] remain 0x00.\n+        contents.resize(1 + CMessageHeader::COMMAND_SIZE + msg.data.size(), 0);\n+        std::copy(msg.m_type.begin(), msg.m_type.end(), reinterpret_cast<char*>(contents.data() + 1));\n+        std::copy(msg.data.begin(), msg.data.end(), contents.begin() + 1 + CMessageHeader::COMMAND_SIZE);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311613938",
      "id" : 1311613938,
      "line" : 1378,
      "node_id" : "PRRC_kwDOABII585OLaPy",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 1378,
      "original_position" : 495,
      "original_start_line" : 1377,
      "path" : "src/net.cpp",
      "position" : 495,
      "pull_request_review_id" : 1602648914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311613938/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 1377,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-31T13:28:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311613938",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311986162"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311986162"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The `m_type` value is really only used to control the breakdown statistics of bytes sent/received per message type in the `getpeerinfo` RPC. We need string categories there, so it seems to me really the question is what category name to use for bytes not assignable to a specific message type. `\"\"` seems to be as good as any, so all this suggestion would entail is having a more complex `m_type` in `BytesToSend`, and logic in the RPC code to turn `std::nullopt` into `\"\"`. I don't think that improves much.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T17:45:22Z",
      "diff_hunk" : "@@ -300,7 +299,8 @@ class Transport {\n      *  - Span<const uint8_t> to_send: span of bytes to be sent over the wire (possibly empty).\n      *  - bool more: whether there will be more bytes to be sent after the ones in to_send are\n      *    all sent (as signaled by MarkBytesSent()).\n-     *  - const std::string& m_type: message type on behalf of which this is being sent.\n+     *  - const std::string& m_type: message type on behalf of which this is being sent\n+     *    (\"\" for bytes that are not on behalf of any message).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311986162",
      "id" : 1311986162,
      "in_reply_to_id" : 1311249370,
      "line" : 303,
      "node_id" : "PRRC_kwDOABII585OM1Hy",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 303,
      "original_position" : 23,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 23,
      "pull_request_review_id" : 1605335997,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311986162/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T17:45:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311986162",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312001695"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312001695"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The conflict is due to the fact that most of the cryptography code (at least the part used by V2Transport, directly and indirectly) has been converted to be entirely `Span<std::byte>`-based, while the network/serialization code is still mostly (`Span<uint8_t>` and `(uint8_t* data, size_t size)`-based). In `V2Transport` we interact with both, which means some silly conversions.\r\n\r\nI've opted not to try to convert the network/serialize code here to `Span<std::byte>` (as that's a bigger, and probably longer-term effort, though I do expect that to happen eventually), and as a result the internal `V2Transport` variables that are closer to that side also use `uint8_t*`. They're indeed interchangeable (even by the C++ spec: specifically only `char`, `unsigned char`, and `std::byte` pointers are allowed to be used to access data of any data type), but until the whole codebase this interacts with is `std::byte`-based, there will be some conversions.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T17:57:59Z",
      "diff_hunk" : "@@ -416,7 +414,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted. */\n+    enum class RecvState {\n+        /** (Responder only) either v2 public key or v1 header.\n+         *\n+         * This is the initial state for responders, before data has been received to distinguish\n+         * v1 from v2 connections. When that happens, the state becomes either KEY (for v2) or V1\n+         * (for v1). */\n+        KEY_MAYBE_V1,\n+\n+        /** Public key.\n+         *\n+         * This is the initial state for initiators, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, its contents is\n+         * interpreted as version negotiation (currently, that means ignoring it, but it can be\n+         * used for negotiating future extensions). If it fails, the connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All receive operations are redirected to m_v1_fallback. m_use_v1 is also set in this\n+         * state, so this redirection can usually happen without needing the m_cs_recv lock. */\n+        V1,\n+    };\n+\n+    /** State type that defines the contents of the send buffer. */\n+    enum class SendState {\n+        /** (Responder only) Public key and garbage.\n+         *\n+         * This is the initial state for responders. The send buffer contains the public key and\n+         * garbage to send, but nothing is sent in this state yet. When the receiver determines\n+         * whether this is a V1 or V2 connection, the sender state becomes KEY_GARB (for v2) or V1\n+         * (for v1) as well.\n+         */\n+        KEY_GARB_MAYBE_V1,\n+\n+        /** Public key and garbage.\n+         *\n+         * This is the initial state for initiators. The public key plus garbage are sent out. When\n+         * the receiver receives the other side's public key and transitions to GARB_GARBTERM, the\n+         * sender state becomes KEY_GARB_GARBTERM_GARBAUTH_VERSION. The key and garbage are left in\n+         * the send buffer when this happens, because they may not have been fully sent out yet. */\n+        KEY_GARB,\n+\n+        /** Public key + garbage + garbage terminator + garbage authenticator + version packet.\n+         *\n+         * This is the state the sender is in after the other side's public key has been received.\n+         * Whatever remains of the public key and garbage are sent, plus garbage terminator,\n+         * authentication packet, and version packet. When all of that is sent, the sender state\n+         * becomes APP_READY. */\n+        KEY_GARB_GARBTERM_GARBAUTH_VERSION,\n+\n+        /** Nothing (an application message to send can be provided).\n+         *\n+         * We're ready to start sending an application message at this point, but none are\n+         * currently provided. Upon SetMessageToSend() the sender state becomes APP. */\n+        APP_READY,\n+\n+        /** Application packet.\n+         *\n+         * There is an encrypted packet encoding an application message in the send buffer right now.\n+         * When it is fully sent, the sender state becomes APP_READY. */\n+        APP,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All send operations are redirected to m_v1_fallback. m_use_v1 is also set in this state,\n+         * so this redirection can usually happen without needing the m_cs_send lock. */\n+        V1,\n+    };\n+\n+    /** Cipher state. */\n+    BIP324Cipher m_cipher;\n+    /** Whether we are the initiator side. */\n+    const bool m_initiating;\n+    /** NodeId (for debug logging). */\n+    const NodeId m_nodeid;\n+    /** Whether the send/receive states are V1. This is an optimization allowing fallback to\n+     *  (typically) work without the m_cs_send or m_cs_recv locks. */\n+    std::atomic<bool> m_use_v1{false};\n+    /** Encapsulate a V1Transport to fall back to. */\n+    V1Transport m_v1_fallback;\n+    /** V1 prefix to look for (4-byte network magic + \"version\\x00\"; magic will be filled in). */\n+    std::array<uint8_t, 12> m_v1_prefix = {0, 0, 0, 0, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00};\n+\n+    /** Lock for receiver-side fields. */\n+    mutable Mutex m_recv_mutex;\n+    /** In {GARBAUTH, VERSION, APP}, the decrypted packet length, if\n+     *  m_recv_buffer.size() >= BIP324::LENGTH_LEN). Unspecified otherwise. */\n+    uint32_t m_recv_len GUARDED_BY(m_recv_mutex) {0};\n+    /** Receive buffer; meaning is determined by m_recv_state. */\n+    std::vector<uint8_t> m_recv_buffer GUARDED_BY(m_recv_mutex);\n+    /** During GARBAUTH, the garbage received during GARB_GARBTERM. */\n+    std::vector<uint8_t> m_recv_garbage GUARDED_BY(m_recv_mutex);\n+    /** Buffer to put decrypted contents in, for converting to CNetMessage. */\n+    std::vector<uint8_t> m_recv_decode_buffer GUARDED_BY(m_recv_mutex);\n+    /** Deserialization type. */\n+    int m_recv_type GUARDED_BY(m_recv_mutex);\n+    /** Deserialization version number. */\n+    int m_recv_version GUARDED_BY(m_recv_mutex);\n+    /** Current receiver state. */\n+    RecvState m_recv_state GUARDED_BY(m_recv_mutex);\n+\n+    /** Lock for sending-side fields. */\n+    mutable Mutex m_send_mutex;\n+    /** The send buffer; meaning is determined by m_send_state. */\n+    std::vector<uint8_t> m_send_buffer GUARDED_BY(m_send_mutex);\n+    /** How many bytes from the send buffer have been sent so far. */\n+    uint32_t m_send_pos GUARDED_BY(m_send_mutex) {0};\n+    /** Type of the message being sent. */\n+    std::string m_send_type GUARDED_BY(m_send_mutex);\n+    /** Current sender state. */\n+    SendState m_send_state GUARDED_BY(m_send_mutex);\n+\n+    /** Given a packet's contents, find the message type (if valid), and strip it from contents. */\n+    static std::optional<std::string> GetMessageType(Span<const uint8_t>& contents) noexcept;\n+    /** Determine how many received bytes can be processed in one go (not allowed in V1 state). */\n+    size_t GetMaxBytesToProcess() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex);\n+    /** Process m_recv_buffer in KEY_MAYBE_V1 state. */\n+    void ProcessReceivedMaybeV1() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex, !m_send_mutex);\n+    /** Process m_recv_buffer in KEY state. */\n+    void ProcessReceivedKey() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex, !m_send_mutex);\n+    /** Process m_recv_buffer in GARB_GARBTERM state. */\n+    bool ProcessReceivedGarbage() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex);\n+    /** Process m_recv_buffer in GARBAUTH/VERSION/APP state. */\n+    bool ProcessReceivedPacket() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex);\n+\n+public:\n+\n+    /** Construct a V2 transport with securely generated random keys. */\n+    V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept;\n+    /** Construct a V2 transport with specified keys and garbage (test use only). */\n+    V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312001695",
      "id" : 1312001695,
      "in_reply_to_id" : 1311402373,
      "line" : 627,
      "node_id" : "PRRC_kwDOABII585OM46f",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 627,
      "original_position" : 251,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 290,
      "pull_request_review_id" : 1605369802,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312001695/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T17:57:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312001695",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312003077"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312003077"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "name changed: m_recv_mutex / m_send_mutex - same a few lines above for the V1 states.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T17:58:30Z",
      "diff_hunk" : "@@ -538,6 +540,9 @@ class V2Transport final : public Transport\n     const bool m_initiating;\n     /** NodeId (for debug logging). */\n     const NodeId m_nodeid;\n+    /** Whether the send/receive states are V1. This is an optimization allowing fallback to\n+     *  (typically) work without the m_cs_send or m_cs_recv locks. */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312003077",
      "id" : 1312003077,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OM5QF",
      "original_commit_id" : "c3902f3f1dec2368b7e7b6ec77019324ae915b31",
      "original_line" : 572,
      "original_position" : 25,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1605372003,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312003077/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T20:32:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312003077",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312036062"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312036062"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Does the `m_use_v1` optimization result in a meaningful speedup? \r\nMy first thought was that the V1 functions are so similar to the respective V2 functions in terms of locking (have analogous `m_recv_mutex`/`m_send_mutex` locks for  analogous functions) so if there would be lock contention at the V2 level that `m_use_v1` avoids, we'd now just have the same contention for the analogous locks one level below at V1Transport instead, resulting in no real performance improvement.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T18:18:06Z",
      "diff_hunk" : "@@ -538,6 +540,9 @@ class V2Transport final : public Transport\n     const bool m_initiating;\n     /** NodeId (for debug logging). */\n     const NodeId m_nodeid;\n+    /** Whether the send/receive states are V1. This is an optimization allowing fallback to\n+     *  (typically) work without the m_cs_send or m_cs_recv locks. */\n+    std::atomic<bool> m_use_v1{false};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312036062",
      "id" : 1312036062,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585ONBTe",
      "original_commit_id" : "c3902f3f1dec2368b7e7b6ec77019324ae915b31",
      "original_line" : 573,
      "original_position" : 26,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1605372003,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312036062/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T20:32:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312036062",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312092279"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312092279"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T19:07:23Z",
      "diff_hunk" : "@@ -320,7 +328,7 @@ class Transport {\n      * Note that m_type and to_send refer to data that is internal to the transport, and calling\n      * any non-const function on this object may invalidate them.\n      */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312092279",
      "id" : 1312092279,
      "in_reply_to_id" : 1310237002,
      "line" : 328,
      "node_id" : "PRRC_kwDOABII585ONPB3",
      "original_commit_id" : "040ea05dae05ef513ac79306dd560c8c1f228942",
      "original_line" : 328,
      "original_position" : 34,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 54,
      "pull_request_review_id" : 1605515528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312092279/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T19:18:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312092279",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312092953"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312092953"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've merged the two `public:` sections.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T19:07:52Z",
      "diff_hunk" : "@@ -416,7 +414,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312092953",
      "id" : 1312092953,
      "in_reply_to_id" : 1311376345,
      "line" : 424,
      "node_id" : "PRRC_kwDOABII585ONPMZ",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 424,
      "original_position" : 79,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 87,
      "pull_request_review_id" : 1605515528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312092953/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T19:18:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312092953",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312106070"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312106070"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This is something I learned in college, though I've never seen it repeated elsewhere: when you have conditional code, make the conditional as narrow as necessary. The reason is that in general, if you let conditionals apply to states that shouldn't be hit at all, they'll hide the issue; the alternative generally leads to more obvious failures.\r\n\r\nI think it applies here: if we'd use `>=`, and we ever ended up in a `>` state, that would imply we're not actually testing for the garbage terminator after every byte, possibly leading to hard-to-discover connection failures. With just `==`, it'll keep receiving forever, likely stalling, or crashing, with an obvious too-large receive buffer.\r\n\r\nOf course, we can do even better: add an Assume that the receive buffer size never exceeds `MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN` in this state, which is what I've added here.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T19:12:17Z",
      "diff_hunk" : "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARB_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        size_t garbage_len = m_send_buffer.size() - EllSwiftPubKey::size();\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer (using the garbage data which\n+        // already there).\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            MakeByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size(), garbage_len),\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312106070",
      "id" : 1312106070,
      "in_reply_to_id" : 1311548994,
      "line" : 1221,
      "node_id" : "PRRC_kwDOABII585ONSZW",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 1221,
      "original_position" : 266,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 338,
      "pull_request_review_id" : 1605515528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312106070/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T19:18:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312106070",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312108759"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312108759"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'm not sure how I'd assert for it, but I've added a comment.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T19:12:57Z",
      "diff_hunk" : "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARB_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        size_t garbage_len = m_send_buffer.size() - EllSwiftPubKey::size();\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer (using the garbage data which\n+        // already there).\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            MakeByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size(), garbage_len),\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 1 + CMessageHeader::COMMAND_SIZE ||\n+            m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 1 + CMessageHeader::COMMAND_SIZE) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312108759",
      "id" : 1312108759,
      "in_reply_to_id" : 1311568129,
      "line" : 1249,
      "node_id" : "PRRC_kwDOABII585ONTDX",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 1249,
      "original_position" : 287,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 366,
      "pull_request_review_id" : 1605515528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312108759/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T19:18:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312108759",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312111598"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312111598"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T19:13:37Z",
      "diff_hunk" : "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARB_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        size_t garbage_len = m_send_buffer.size() - EllSwiftPubKey::size();\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer (using the garbage data which\n+        // already there).\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            MakeByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size(), garbage_len),\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 1 + CMessageHeader::COMMAND_SIZE ||\n+            m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 1 + CMessageHeader::COMMAND_SIZE) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packet decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            m_recv_state = RecvState::VERSION;\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is\n+                // ignored, but can be used for future extensions.\n+                m_recv_state = RecvState::APP;\n+            }\n+            break;\n+        case RecvState::APP:\n+            if (!ignore) {\n+                // Application message decrypted correctly. It can be extracted using GetMessage().\n+                m_recv_state = RecvState::APP_READY;\n+            }\n+            break;\n+        default:\n+            // Any other state is invalid (this function should not have been called).\n+            assert(false);\n+        }\n+        // Wipe the receive buffer where the next packet will be received into.\n+        m_recv_buffer = {};\n+        // In all but APP_READY state, we can wipe the decoded contents.\n+        if (m_recv_state != RecvState::APP_READY) m_recv_decode_buffer = {};\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ReceivedBytes(Span<const uint8_t>& msg_bytes) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    /** How many bytes to allocate in the receive buffer at most above what is received so far. */\n+    static constexpr size_t MAX_RESERVE_AHEAD = 250000;\n+\n+    if (m_use_v1) return m_v1_fallback.ReceivedBytes(msg_bytes);\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedBytes(msg_bytes);\n+\n+    while (!msg_bytes.empty()) {\n+        // Decide how many bytes to copy from msg_bytes to m_recv_buffer.\n+        size_t max_read = GetMaxBytesToProcess();\n+        // Reserve space in the buffer.\n+        if (m_recv_state == RecvState::KEY_MAYBE_V1 || m_recv_state == RecvState::KEY ||\n+            m_recv_state == RecvState::GARB_GARBTERM) {\n+            // During the initial states (key/garbage), allocate once to fit the maximum (4111\n+            // bytes).\n+            m_recv_buffer.reserve(MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        } else if (m_recv_state == RecvState::GARBAUTH || m_recv_state == RecvState::VERSION ||\n+            m_recv_state == RecvState::APP) {\n+            // During states where a packet is being received, as much as is expected but never\n+            // more than MAX_RESERVE_AHEAD bytes in addition to what is received so far.\n+            size_t alloc_add = std::min(max_read, msg_bytes.size() + MAX_RESERVE_AHEAD);\n+            m_recv_buffer.reserve(m_recv_buffer.size() + alloc_add);\n+        }\n+        // Can't read more than provided input.\n+        max_read = std::min<uint32_t>(msg_bytes.size(), max_read);\n+        // Copy data to buffer.\n+        m_recv_buffer.insert(m_recv_buffer.end(), UCharCast(msg_bytes.data()), UCharCast(msg_bytes.data() + max_read));\n+        msg_bytes = msg_bytes.subspan(max_read);\n+\n+        // Process data in the buffer.\n+        switch (m_recv_state) {\n+        case RecvState::KEY_MAYBE_V1:\n+            ProcessReceivedMaybeV1();\n+            if (m_recv_state == RecvState::V1) return true;\n+            break;\n+\n+        case RecvState::KEY:\n+            ProcessReceivedKey();\n+            break;\n+\n+        case RecvState::GARB_GARBTERM:\n+            if (!ProcessReceivedGarbage()) return false;\n+            break;\n+\n+        case RecvState::GARBAUTH:\n+        case RecvState::VERSION:\n+        case RecvState::APP:\n+            if (!ProcessReceivedPacket()) return false;\n+            break;\n+\n+        case RecvState::APP_READY:\n+            return true;\n+\n+        case RecvState::V1:\n+            // We should have bailed out before.\n+            assert(false);\n+            break;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+std::optional<std::string> V2Transport::GetMessageType(Span<const uint8_t>& contents) noexcept\n+{\n+    if (contents.size() == 0) return std::nullopt; // Empty contents\n+    uint8_t first_byte = contents[0];\n+    contents = contents.subspan(1); // Strip first byte.\n+\n+    if (first_byte != 0) {\n+        // Short (1 byte) encoding.\n+        if (first_byte < std::size(V2_MESSAGE_IDS)) {\n+            // Valid short message id.\n+            return V2_MESSAGE_IDS[first_byte];\n+        } else {\n+            // Unknown short message id.\n+            return std::nullopt;\n+        }\n+    }\n+\n+    if (contents.size() < CMessageHeader::COMMAND_SIZE) {\n+        return std::nullopt; // Long encoding needs 12 message type bytes.\n+    }\n+\n+    size_t msg_type_len{0};\n+    while (msg_type_len < CMessageHeader::COMMAND_SIZE && contents[msg_type_len] != 0) {\n+        // Verify that message type bytes before the first 0x00 are in range.\n+        if (contents[msg_type_len] < ' ' || contents[msg_type_len] > 0x7F) {\n+            return {};\n+        }\n+        ++msg_type_len;\n+    }\n+    std::string ret{reinterpret_cast<const char*>(contents.data()), msg_type_len};\n+    while (msg_type_len < CMessageHeader::COMMAND_SIZE) {\n+        // Verify that message type bytes after the first 0x00 are also 0x00.\n+        if (contents[msg_type_len] != 0) return {};\n+        ++msg_type_len;\n+    }\n+    // Strip message type bytes of contents.\n+    contents = contents.subspan(CMessageHeader::COMMAND_SIZE);\n+    return {std::move(ret)};\n+}\n+\n+CNetMessage V2Transport::GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.GetReceivedMessage(time, reject_message);\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.GetReceivedMessage(time, reject_message);\n+\n+    assert(m_recv_state == RecvState::APP_READY);\n+    Span<const uint8_t> contents{m_recv_decode_buffer};\n+    auto msg_type = GetMessageType(contents);\n+    CDataStream ret(m_recv_type, m_recv_version);\n+    CNetMessage msg{std::move(ret)};\n+    msg.m_raw_message_size = m_recv_decode_buffer.size() + BIP324Cipher::EXPANSION;\n+    if (msg_type) {\n+        reject_message = false;\n+        msg.m_type = std::move(*msg_type);\n+        msg.m_time = time;\n+        msg.m_message_size = contents.size();\n+        msg.m_recv.resize(contents.size());\n+        std::copy(contents.begin(), contents.end(), UCharCast(msg.m_recv.data()));\n+    } else {\n+        LogPrint(BCLog::NET, \"V2 transport error: invalid message type (%u bytes contents), peer=%d\\n\", m_recv_decode_buffer.size(), m_nodeid);\n+        reject_message = true;\n+    }\n+    m_recv_decode_buffer = {};\n+    m_recv_state = RecvState::APP;\n+\n+    return msg;\n+}\n+\n+bool V2Transport::SetMessageToSend(CSerializedNetMsg& msg) noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_use_v1) return m_v1_fallback.SetMessageToSend(msg);\n+    LOCK(m_send_mutex);\n+    if (m_send_state == SendState::V1) return m_v1_fallback.SetMessageToSend(msg);\n+\n+    if (m_send_state != SendState::APP_READY) return false;\n+    // Construct contents (encoding message type + payload).\n+    std::vector<uint8_t> contents;\n+    auto short_message_id = V2_MESSAGE_MAP(msg.m_type);\n+    if (short_message_id) {\n+        contents.resize(1 + msg.data.size());\n+        contents[0] = *short_message_id;\n+        std::copy(msg.data.begin(), msg.data.end(), contents.begin() + 1);\n+    } else {\n+        // Initialize with zeroes, and then write the message type string starting at offset 0.\n+        // This means contents[0] and the unused positions in contents[1..13] remain 0x00.\n+        contents.resize(1 + CMessageHeader::COMMAND_SIZE + msg.data.size(), 0);\n+        std::copy(msg.m_type.begin(), msg.m_type.end(), reinterpret_cast<char*>(contents.data() + 1));\n+        std::copy(msg.data.begin(), msg.data.end(), contents.begin() + 1 + CMessageHeader::COMMAND_SIZE);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312111598",
      "id" : 1312111598,
      "in_reply_to_id" : 1311613938,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585ONTvu",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 1456,
      "original_position" : 495,
      "original_start_line" : 1377,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1605515528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312111598/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-31T19:18:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312111598",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312112870"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312112870"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done (using a `static constexpr size_t` constant with comments higher up).",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T19:14:05Z",
      "diff_hunk" : "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARB_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        size_t garbage_len = m_send_buffer.size() - EllSwiftPubKey::size();\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer (using the garbage data which\n+        // already there).\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            MakeByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size(), garbage_len),\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 1 + CMessageHeader::COMMAND_SIZE ||\n+            m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 1 + CMessageHeader::COMMAND_SIZE) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312112870",
      "id" : 1312112870,
      "in_reply_to_id" : 1311560086,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585ONUDm",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 1246,
      "original_position" : 284,
      "original_start_line" : 1164,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1605515528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312112870/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-31T19:18:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312112870",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312113220"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312113220"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done, at the beginning of all `ProcessReceived*` functions.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T19:14:25Z",
      "diff_hunk" : "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARB_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        size_t garbage_len = m_send_buffer.size() - EllSwiftPubKey::size();\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer (using the garbage data which\n+        // already there).\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            MakeByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size(), garbage_len),\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312113220",
      "id" : 1312113220,
      "in_reply_to_id" : 1311553670,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585ONUJE",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 1148,
      "original_position" : 265,
      "original_start_line" : 1139,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1605515528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312113220/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-31T19:18:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312113220",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312113425"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312113425"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T19:14:40Z",
      "diff_hunk" : "@@ -416,7 +424,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the contents of the receive buffer. */\n+    enum class RecvState {\n+        /** (Responder only) either v2 public key or v1 header.\n+         *\n+         * This is the initial state for responders, before data has been received to distinguish\n+         * v1 from v2 connections. When that happens, the state becomes either KEY (for v2) or V1\n+         * (for v1). */\n+        KEY_MAYBE_V1,\n+\n+        /** Public key.\n+         *\n+         * This is the initial state for initiators, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, its contents is",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312113425",
      "id" : 1312113425,
      "in_reply_to_id" : 1310277982,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585ONUMR",
      "original_commit_id" : "040ea05dae05ef513ac79306dd560c8c1f228942",
      "original_line" : 467,
      "original_position" : 94,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1605515528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312113425/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T19:18:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312113425",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312113516"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312113516"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T19:14:46Z",
      "diff_hunk" : "@@ -416,7 +424,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the contents of the receive buffer. */\n+    enum class RecvState {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312113516",
      "id" : 1312113516,
      "in_reply_to_id" : 1310288598,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585ONUNs",
      "original_commit_id" : "040ea05dae05ef513ac79306dd560c8c1f228942",
      "original_line" : 435,
      "original_position" : 62,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1605515528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312113516/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T19:18:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312113516",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312113605"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312113605"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T19:14:50Z",
      "diff_hunk" : "@@ -416,7 +424,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the contents of the receive buffer. */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312113605",
      "id" : 1312113605,
      "in_reply_to_id" : 1310305445,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585ONUPF",
      "original_commit_id" : "040ea05dae05ef513ac79306dd560c8c1f228942",
      "original_line" : 443,
      "original_position" : 61,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1605515528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312113605/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T19:18:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312113605",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312113901"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312113901"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've added an overall comment above `enum class RecvState`.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T19:15:09Z",
      "diff_hunk" : "@@ -416,7 +414,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted. */\n+    enum class RecvState {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312113901",
      "id" : 1312113901,
      "in_reply_to_id" : 1311222591,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585ONUTt",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 435,
      "original_position" : 87,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1605515528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312113901/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T19:18:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312113901",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312114126"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312114126"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T19:15:16Z",
      "diff_hunk" : "@@ -416,7 +414,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted. */\n+    enum class RecvState {\n+        /** (Responder only) either v2 public key or v1 header.\n+         *\n+         * This is the initial state for responders, before data has been received to distinguish\n+         * v1 from v2 connections. When that happens, the state becomes either KEY (for v2) or V1\n+         * (for v1). */\n+        KEY_MAYBE_V1,\n+\n+        /** Public key.\n+         *\n+         * This is the initial state for initiators, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, its contents is\n+         * interpreted as version negotiation (currently, that means ignoring it, but it can be\n+         * used for negotiating future extensions). If it fails, the connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All receive operations are redirected to m_v1_fallback. m_use_v1 is also set in this\n+         * state, so this redirection can usually happen without needing the m_cs_recv lock. */\n+        V1,\n+    };\n+\n+    /** State type that defines the contents of the send buffer. */\n+    enum class SendState {\n+        /** (Responder only) Public key and garbage.\n+         *\n+         * This is the initial state for responders. The send buffer contains the public key and\n+         * garbage to send, but nothing is sent in this state yet. When the receiver determines\n+         * whether this is a V1 or V2 connection, the sender state becomes KEY_GARB (for v2) or V1\n+         * (for v1) as well.\n+         */\n+        KEY_GARB_MAYBE_V1,\n+\n+        /** Public key and garbage.\n+         *\n+         * This is the initial state for initiators. The public key plus garbage are sent out. When\n+         * the receiver receives the other side's public key and transitions to GARB_GARBTERM, the\n+         * sender state becomes KEY_GARB_GARBTERM_GARBAUTH_VERSION. The key and garbage are left in\n+         * the send buffer when this happens, because they may not have been fully sent out yet. */\n+        KEY_GARB,\n+\n+        /** Public key + garbage + garbage terminator + garbage authenticator + version packet.\n+         *\n+         * This is the state the sender is in after the other side's public key has been received.\n+         * Whatever remains of the public key and garbage are sent, plus garbage terminator,\n+         * authentication packet, and version packet. When all of that is sent, the sender state\n+         * becomes APP_READY. */\n+        KEY_GARB_GARBTERM_GARBAUTH_VERSION,\n+\n+        /** Nothing (an application message to send can be provided).\n+         *\n+         * We're ready to start sending an application message at this point, but none are\n+         * currently provided. Upon SetMessageToSend() the sender state becomes APP. */\n+        APP_READY,\n+\n+        /** Application packet.\n+         *\n+         * There is an encrypted packet encoding an application message in the send buffer right now.\n+         * When it is fully sent, the sender state becomes APP_READY. */\n+        APP,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All send operations are redirected to m_v1_fallback. m_use_v1 is also set in this state,\n+         * so this redirection can usually happen without needing the m_cs_send lock. */\n+        V1,\n+    };\n+\n+    /** Cipher state. */\n+    BIP324Cipher m_cipher;\n+    /** Whether we are the initiator side. */\n+    const bool m_initiating;\n+    /** NodeId (for debug logging). */\n+    const NodeId m_nodeid;\n+    /** Whether the send/receive states are V1. This is an optimization allowing fallback to\n+     *  (typically) work without the m_cs_send or m_cs_recv locks. */\n+    std::atomic<bool> m_use_v1{false};\n+    /** Encapsulate a V1Transport to fall back to. */\n+    V1Transport m_v1_fallback;\n+    /** V1 prefix to look for (4-byte network magic + \"version\\x00\"; magic will be filled in). */\n+    std::array<uint8_t, 12> m_v1_prefix = {0, 0, 0, 0, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00};\n+\n+    /** Lock for receiver-side fields. */\n+    mutable Mutex m_recv_mutex;\n+    /** In {GARBAUTH, VERSION, APP}, the decrypted packet length, if\n+     *  m_recv_buffer.size() >= BIP324::LENGTH_LEN). Unspecified otherwise. */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312114126",
      "id" : 1312114126,
      "in_reply_to_id" : 1311381100,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585ONUXO",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 555,
      "original_position" : 207,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1605515528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312114126/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T19:18:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312114126",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312114721"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312114721"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done. Also dropped the `GUARDED_BY(m_recv_mutex)` which is not needed for immutable variables.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T19:15:45Z",
      "diff_hunk" : "@@ -416,7 +414,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted. */\n+    enum class RecvState {\n+        /** (Responder only) either v2 public key or v1 header.\n+         *\n+         * This is the initial state for responders, before data has been received to distinguish\n+         * v1 from v2 connections. When that happens, the state becomes either KEY (for v2) or V1\n+         * (for v1). */\n+        KEY_MAYBE_V1,\n+\n+        /** Public key.\n+         *\n+         * This is the initial state for initiators, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, its contents is\n+         * interpreted as version negotiation (currently, that means ignoring it, but it can be\n+         * used for negotiating future extensions). If it fails, the connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All receive operations are redirected to m_v1_fallback. m_use_v1 is also set in this\n+         * state, so this redirection can usually happen without needing the m_cs_recv lock. */\n+        V1,\n+    };\n+\n+    /** State type that defines the contents of the send buffer. */\n+    enum class SendState {\n+        /** (Responder only) Public key and garbage.\n+         *\n+         * This is the initial state for responders. The send buffer contains the public key and\n+         * garbage to send, but nothing is sent in this state yet. When the receiver determines\n+         * whether this is a V1 or V2 connection, the sender state becomes KEY_GARB (for v2) or V1\n+         * (for v1) as well.\n+         */\n+        KEY_GARB_MAYBE_V1,\n+\n+        /** Public key and garbage.\n+         *\n+         * This is the initial state for initiators. The public key plus garbage are sent out. When\n+         * the receiver receives the other side's public key and transitions to GARB_GARBTERM, the\n+         * sender state becomes KEY_GARB_GARBTERM_GARBAUTH_VERSION. The key and garbage are left in\n+         * the send buffer when this happens, because they may not have been fully sent out yet. */\n+        KEY_GARB,\n+\n+        /** Public key + garbage + garbage terminator + garbage authenticator + version packet.\n+         *\n+         * This is the state the sender is in after the other side's public key has been received.\n+         * Whatever remains of the public key and garbage are sent, plus garbage terminator,\n+         * authentication packet, and version packet. When all of that is sent, the sender state\n+         * becomes APP_READY. */\n+        KEY_GARB_GARBTERM_GARBAUTH_VERSION,\n+\n+        /** Nothing (an application message to send can be provided).\n+         *\n+         * We're ready to start sending an application message at this point, but none are\n+         * currently provided. Upon SetMessageToSend() the sender state becomes APP. */\n+        APP_READY,\n+\n+        /** Application packet.\n+         *\n+         * There is an encrypted packet encoding an application message in the send buffer right now.\n+         * When it is fully sent, the sender state becomes APP_READY. */\n+        APP,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All send operations are redirected to m_v1_fallback. m_use_v1 is also set in this state,\n+         * so this redirection can usually happen without needing the m_cs_send lock. */\n+        V1,\n+    };\n+\n+    /** Cipher state. */\n+    BIP324Cipher m_cipher;\n+    /** Whether we are the initiator side. */\n+    const bool m_initiating;\n+    /** NodeId (for debug logging). */\n+    const NodeId m_nodeid;\n+    /** Whether the send/receive states are V1. This is an optimization allowing fallback to\n+     *  (typically) work without the m_cs_send or m_cs_recv locks. */\n+    std::atomic<bool> m_use_v1{false};\n+    /** Encapsulate a V1Transport to fall back to. */\n+    V1Transport m_v1_fallback;\n+    /** V1 prefix to look for (4-byte network magic + \"version\\x00\"; magic will be filled in). */\n+    std::array<uint8_t, 12> m_v1_prefix = {0, 0, 0, 0, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00};\n+\n+    /** Lock for receiver-side fields. */\n+    mutable Mutex m_recv_mutex;\n+    /** In {GARBAUTH, VERSION, APP}, the decrypted packet length, if\n+     *  m_recv_buffer.size() >= BIP324::LENGTH_LEN). Unspecified otherwise. */\n+    uint32_t m_recv_len GUARDED_BY(m_recv_mutex) {0};\n+    /** Receive buffer; meaning is determined by m_recv_state. */\n+    std::vector<uint8_t> m_recv_buffer GUARDED_BY(m_recv_mutex);\n+    /** During GARBAUTH, the garbage received during GARB_GARBTERM. */\n+    std::vector<uint8_t> m_recv_garbage GUARDED_BY(m_recv_mutex);\n+    /** Buffer to put decrypted contents in, for converting to CNetMessage. */\n+    std::vector<uint8_t> m_recv_decode_buffer GUARDED_BY(m_recv_mutex);\n+    /** Deserialization type. */\n+    int m_recv_type GUARDED_BY(m_recv_mutex);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312114721",
      "id" : 1312114721,
      "in_reply_to_id" : 1311393641,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585ONUgh",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 564,
      "original_position" : 216,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1605515528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312114721/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T19:18:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312114721",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312115309"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312115309"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It's impossible to hit, because `GetMaxBytesToProcess` only lets in as much as needed to reach the end of the buffer. I've added comments and Assumes.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T19:16:27Z",
      "diff_hunk" : "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312115309",
      "id" : 1312115309,
      "in_reply_to_id" : 1311460423,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585ONUpt",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 1107,
      "original_position" : 151,
      "original_start_line" : 1029,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1605515528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312115309/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-31T19:18:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312115309",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312116243"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312116243"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It turns out that we actually have locking annotations for that. I've added `ACQUIRED_BEFORE(m_send_mutex)` to `m_recv_mutex`, and `ACQUIRED_AFTER(m_recv_mutex)` to `m_send_mutex`, together with a shortened version of your suggested comment.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T19:17:21Z",
      "diff_hunk" : "@@ -416,7 +414,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted. */\n+    enum class RecvState {\n+        /** (Responder only) either v2 public key or v1 header.\n+         *\n+         * This is the initial state for responders, before data has been received to distinguish\n+         * v1 from v2 connections. When that happens, the state becomes either KEY (for v2) or V1\n+         * (for v1). */\n+        KEY_MAYBE_V1,\n+\n+        /** Public key.\n+         *\n+         * This is the initial state for initiators, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, its contents is\n+         * interpreted as version negotiation (currently, that means ignoring it, but it can be\n+         * used for negotiating future extensions). If it fails, the connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All receive operations are redirected to m_v1_fallback. m_use_v1 is also set in this\n+         * state, so this redirection can usually happen without needing the m_cs_recv lock. */\n+        V1,\n+    };\n+\n+    /** State type that defines the contents of the send buffer. */\n+    enum class SendState {\n+        /** (Responder only) Public key and garbage.\n+         *\n+         * This is the initial state for responders. The send buffer contains the public key and\n+         * garbage to send, but nothing is sent in this state yet. When the receiver determines\n+         * whether this is a V1 or V2 connection, the sender state becomes KEY_GARB (for v2) or V1\n+         * (for v1) as well.\n+         */\n+        KEY_GARB_MAYBE_V1,\n+\n+        /** Public key and garbage.\n+         *\n+         * This is the initial state for initiators. The public key plus garbage are sent out. When\n+         * the receiver receives the other side's public key and transitions to GARB_GARBTERM, the\n+         * sender state becomes KEY_GARB_GARBTERM_GARBAUTH_VERSION. The key and garbage are left in\n+         * the send buffer when this happens, because they may not have been fully sent out yet. */\n+        KEY_GARB,\n+\n+        /** Public key + garbage + garbage terminator + garbage authenticator + version packet.\n+         *\n+         * This is the state the sender is in after the other side's public key has been received.\n+         * Whatever remains of the public key and garbage are sent, plus garbage terminator,\n+         * authentication packet, and version packet. When all of that is sent, the sender state\n+         * becomes APP_READY. */\n+        KEY_GARB_GARBTERM_GARBAUTH_VERSION,\n+\n+        /** Nothing (an application message to send can be provided).\n+         *\n+         * We're ready to start sending an application message at this point, but none are\n+         * currently provided. Upon SetMessageToSend() the sender state becomes APP. */\n+        APP_READY,\n+\n+        /** Application packet.\n+         *\n+         * There is an encrypted packet encoding an application message in the send buffer right now.\n+         * When it is fully sent, the sender state becomes APP_READY. */\n+        APP,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All send operations are redirected to m_v1_fallback. m_use_v1 is also set in this state,\n+         * so this redirection can usually happen without needing the m_cs_send lock. */\n+        V1,\n+    };\n+\n+    /** Cipher state. */\n+    BIP324Cipher m_cipher;\n+    /** Whether we are the initiator side. */\n+    const bool m_initiating;\n+    /** NodeId (for debug logging). */\n+    const NodeId m_nodeid;\n+    /** Whether the send/receive states are V1. This is an optimization allowing fallback to\n+     *  (typically) work without the m_cs_send or m_cs_recv locks. */\n+    std::atomic<bool> m_use_v1{false};\n+    /** Encapsulate a V1Transport to fall back to. */\n+    V1Transport m_v1_fallback;\n+    /** V1 prefix to look for (4-byte network magic + \"version\\x00\"; magic will be filled in). */\n+    std::array<uint8_t, 12> m_v1_prefix = {0, 0, 0, 0, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00};\n+\n+    /** Lock for receiver-side fields. */\n+    mutable Mutex m_recv_mutex;\n+    /** In {GARBAUTH, VERSION, APP}, the decrypted packet length, if\n+     *  m_recv_buffer.size() >= BIP324::LENGTH_LEN). Unspecified otherwise. */\n+    uint32_t m_recv_len GUARDED_BY(m_recv_mutex) {0};\n+    /** Receive buffer; meaning is determined by m_recv_state. */\n+    std::vector<uint8_t> m_recv_buffer GUARDED_BY(m_recv_mutex);\n+    /** During GARBAUTH, the garbage received during GARB_GARBTERM. */\n+    std::vector<uint8_t> m_recv_garbage GUARDED_BY(m_recv_mutex);\n+    /** Buffer to put decrypted contents in, for converting to CNetMessage. */\n+    std::vector<uint8_t> m_recv_decode_buffer GUARDED_BY(m_recv_mutex);\n+    /** Deserialization type. */\n+    int m_recv_type GUARDED_BY(m_recv_mutex);\n+    /** Deserialization version number. */\n+    int m_recv_version GUARDED_BY(m_recv_mutex);\n+    /** Current receiver state. */\n+    RecvState m_recv_state GUARDED_BY(m_recv_mutex);\n+\n+    /** Lock for sending-side fields. */\n+    mutable Mutex m_send_mutex;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312116243",
      "id" : 1312116243,
      "in_reply_to_id" : 1311500825,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585ONU4T",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 571,
      "original_position" : 223,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1605515528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312116243/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T19:18:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312116243",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312116773"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312116773"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed in an extra preparatory commit (allowing `Span<const std::byte>` argument for `EllSwiftPubKey` constructor.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T19:17:54Z",
      "diff_hunk" : "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312116773",
      "id" : 1312116773,
      "in_reply_to_id" : 1311508831,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585ONVAl",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 1106,
      "original_position" : 223,
      "original_start_line" : 1103,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1605515528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312116773/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-31T19:18:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312116773",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312117427"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312117427"
         }
      },
      "author_association" : "MEMBER",
      "body" : "A wrapper felt like overkill to me, but I've added `SetReceiveState` and `SetSendState` functions for effecting state transitions, which enforce the allowed ones.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T19:18:34Z",
      "diff_hunk" : "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312117427",
      "id" : 1312117427,
      "in_reply_to_id" : 1311514245,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585ONVKz",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 1109,
      "original_position" : 226,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1605515528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312117427/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T19:18:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312117427",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312201855"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312201855"
         }
      },
      "author_association" : "MEMBER",
      "body" : "That sounds right; there will really only be contention on one of the two levels, and uncontended mutex grabs are in the 10s of nanonseconds I believe. I'll just drop this commit.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T20:37:21Z",
      "diff_hunk" : "@@ -538,6 +540,9 @@ class V2Transport final : public Transport\n     const bool m_initiating;\n     /** NodeId (for debug logging). */\n     const NodeId m_nodeid;\n+    /** Whether the send/receive states are V1. This is an optimization allowing fallback to\n+     *  (typically) work without the m_cs_send or m_cs_recv locks. */\n+    std::atomic<bool> m_use_v1{false};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312201855",
      "id" : 1312201855,
      "in_reply_to_id" : 1312036062,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585ONpx_",
      "original_commit_id" : "c3902f3f1dec2368b7e7b6ec77019324ae915b31",
      "original_line" : 573,
      "original_position" : 26,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1605676924,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312201855/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T20:37:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312201855",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312212320"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312212320"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "okay then, can be resolved.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T20:48:31Z",
      "diff_hunk" : "@@ -912,6 +912,347 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packed decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            m_recv_state = RecvState::VERSION;\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312212320",
      "id" : 1312212320,
      "in_reply_to_id" : 1310695744,
      "line" : 1280,
      "node_id" : "PRRC_kwDOABII585ONsVg",
      "original_commit_id" : "de705988c330fc5b3c006337bd72ca0f0c8e2750",
      "original_line" : 1280,
      "original_position" : 171,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 397,
      "pull_request_review_id" : 1605693293,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312212320/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T20:48:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312212320",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312213945"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312213945"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Resolved by dropping the commit.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T20:50:00Z",
      "diff_hunk" : "@@ -538,6 +540,9 @@ class V2Transport final : public Transport\n     const bool m_initiating;\n     /** NodeId (for debug logging). */\n     const NodeId m_nodeid;\n+    /** Whether the send/receive states are V1. This is an optimization allowing fallback to\n+     *  (typically) work without the m_cs_send or m_cs_recv locks. */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312213945",
      "id" : 1312213945,
      "in_reply_to_id" : 1312003077,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585ONsu5",
      "original_commit_id" : "c3902f3f1dec2368b7e7b6ec77019324ae915b31",
      "original_line" : 572,
      "original_position" : 25,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1605695923,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312213945/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T20:50:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312213945",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313012119"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313012119"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Maybe this is a bit more readable and easy to verify that it is correct:\r\n\r\n```suggestion\r\n    std::array<uint8_t, 12> m_v1_prefix = {0, 0, 0, 0, 'v', 'e', 'r', 's', 'i', 'o', 'n', 0x00};\r\n```",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-09-01T13:14:28Z",
      "diff_hunk" : "@@ -416,7 +414,226 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    // The sender side and receiver side of V2Transport are largely independent state machines that\n+    // are transitioned through, where each state corresponds to the meaning of the data in (or to\n+    // be received to) the respective (send/receive) buffer. The sender side is primarily\n+    // controlled by send-side functions (SetMessageToSend, MarkBytesSent), while the received side\n+    // is primarily controlled by receiver-side functions (ReceivedBytes, GetReceivedMessage),\n+    // though in some cases the sender state can also change as a result of receiving bytes.\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted.\n+     *\n+     * Diagram:\n+     *\n+     *   start(responder)\n+     *        |\n+     *        |  start(initiator)                                       /---------\\\n+     *        |          |                                              |         |\n+     *        v          v                                              v         |\n+     *  KEY_MAYBE_V1 -> KEY -> GARB_GARBTERM -> GARBAUTH -> VERSION -> APP -> APP_READY\n+     *        |\n+     *        \\-> V1\n+     */\n+    enum class RecvState : uint8_t {\n+        /** (Responder only) either v2 public key or v1 header.\n+         *\n+         * This is the initial state for responders, before data has been received to distinguish\n+         * v1 from v2 connections. When that happens, the state becomes either KEY (for v2) or V1\n+         * (for v1). */\n+        KEY_MAYBE_V1,\n+\n+        /** Public key.\n+         *\n+         * This is the initial state for initiators, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes APP,\n+         * and the decrypted contents is interpreted as version negotiation (currently, that means\n+         * ignoring it, but it can be used for negotiating future extensions). If it fails, the\n+         * connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All receive operations are redirected to m_v1_fallback. */\n+        V1,\n+    };\n+\n+    /** State type that defines the contents of the send buffer.\n+     *\n+     * Diagram:\n+     *\n+     *  start(responder)  start(initiator)                                        /----------\\\n+     *        |                  |                                                |          |\n+     *        v                  v                                                v          |\n+     *  KEY_GARB_MAYBE_V1 -> KEY_GARB -> KEY_GARB_GARBTERM_GARBAUTH_VERSION -> APP_READY -> APP\n+     *        |\n+     *        \\-> V1\n+     */\n+    enum class SendState : uint8_t {\n+        /** (Responder only) Public key and garbage.\n+         *\n+         * This is the initial state for responders. The send buffer contains the public key and\n+         * garbage to send, but nothing is sent in this state yet. When the receiver determines\n+         * whether this is a V1 or V2 connection, the sender state becomes KEY_GARB (for v2) or V1\n+         * (for v1) as well.\n+         */\n+        KEY_GARB_MAYBE_V1,\n+\n+        /** Public key and garbage.\n+         *\n+         * This is the initial state for initiators. The public key plus garbage are sent out. When\n+         * the receiver receives the other side's public key and transitions to GARB_GARBTERM, the\n+         * sender state becomes KEY_GARB_GARBTERM_GARBAUTH_VERSION. The key and garbage are left in\n+         * the send buffer when this happens, because they may not have been fully sent out yet. */\n+        KEY_GARB,\n+\n+        /** Public key + garbage + garbage terminator + garbage authenticator + version packet.\n+         *\n+         * This is the state the sender is in after the other side's public key has been received.\n+         * Whatever remains of the public key and garbage are sent, plus garbage terminator,\n+         * authentication packet, and version packet. When all of that is sent, the sender state\n+         * becomes APP_READY. */\n+        KEY_GARB_GARBTERM_GARBAUTH_VERSION,\n+\n+        /** Nothing (an application message to send can be provided).\n+         *\n+         * We're ready to start sending an application message at this point, but none are\n+         * currently provided. Upon SetMessageToSend() the sender state becomes APP. */\n+        APP_READY,\n+\n+        /** Application packet.\n+         *\n+         * There is an encrypted packet encoding an application message in the send buffer right now.\n+         * When it is fully sent, the sender state becomes APP_READY. */\n+        APP,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All send operations are redirected to m_v1_fallback. */\n+        V1,\n+    };\n+\n+    /** Cipher state. */\n+    BIP324Cipher m_cipher;\n+    /** Whether we are the initiator side. */\n+    const bool m_initiating;\n+    /** NodeId (for debug logging). */\n+    const NodeId m_nodeid;\n+    /** Encapsulate a V1Transport to fall back to. */\n+    V1Transport m_v1_fallback;\n+    /** V1 prefix to look for (4-byte network magic + \"version\\x00\"; magic will be filled in). */\n+    std::array<uint8_t, 12> m_v1_prefix = {0, 0, 0, 0, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313012119",
      "id" : 1313012119,
      "line" : 572,
      "node_id" : "PRRC_kwDOABII585OQvmX",
      "original_commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "original_line" : 572,
      "original_position" : 235,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 235,
      "pull_request_review_id" : 1606655503,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313012119/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-01T16:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313012119",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313028412"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313028412"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Here we assume that a public key will never start with magic+\"version\". Can it? If the pubkey is completely random bytes, then the chance of that happening is 1 in 256<sup>12</sup> = 2<sup>96</sup>.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-09-01T13:26:49Z",
      "diff_hunk" : "@@ -910,24 +912,632 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // Initial state, cannot be transitioned into.\n+        assert(false);\n+        break;\n+    case RecvState::KEY:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        assert(m_recv_state == RecvState::KEY);\n+        break;\n+    case RecvState::GARBAUTH:\n+        assert(m_recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::VERSION:\n+        assert(m_recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::APP:\n+        assert(m_recv_state == RecvState::VERSION || m_recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        assert(m_recv_state == RecvState::APP);\n+        break;\n+    case RecvState::V1:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (send_state) {\n+    case SendState::KEY_GARB_MAYBE_V1:\n+        // Initial state, cannot be transitioned into.\n+        assert(false);\n+        break;\n+    case SendState::KEY_GARB:\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1);\n+        break;\n+    case SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION:\n+        assert(m_send_state == SendState::KEY_GARB);\n+        break;\n+    case SendState::APP_READY:\n+        assert(m_send_state == SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION ||\n+               m_send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        assert(m_send_state == SendState::APP_READY);\n+        break;\n+    case SendState::V1:\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // During the KEY_MAYBE_V1 state we do not allow more than the length of v1 prefix into the\n+        // receive buffer.\n+        Assume(m_recv_buffer.size() <= m_v1_prefix.size());\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY_MAYBE_V1);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313028412",
      "id" : 1313028412,
      "line" : 1145,
      "node_id" : "PRRC_kwDOABII585OQzk8",
      "original_commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "original_line" : 1145,
      "original_position" : 262,
      "original_start_line" : 1142,
      "path" : "src/net.cpp",
      "position" : 262,
      "pull_request_review_id" : 1606655503,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313028412/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 1142,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-09-01T16:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313028412",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313034598"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313034598"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Is that allowed only for `KEY_GARB` -> `KEY_GARB` for sender? And no `X` -> `X` for the receive state?",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-09-01T13:31:50Z",
      "diff_hunk" : "@@ -910,24 +912,632 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // Initial state, cannot be transitioned into.\n+        assert(false);\n+        break;\n+    case RecvState::KEY:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        assert(m_recv_state == RecvState::KEY);\n+        break;\n+    case RecvState::GARBAUTH:\n+        assert(m_recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::VERSION:\n+        assert(m_recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::APP:\n+        assert(m_recv_state == RecvState::VERSION || m_recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        assert(m_recv_state == RecvState::APP);\n+        break;\n+    case RecvState::V1:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313034598",
      "id" : 1313034598,
      "line" : 1051,
      "node_id" : "PRRC_kwDOABII585OQ1Fm",
      "original_commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "original_line" : 1051,
      "original_position" : 168,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 168,
      "pull_request_review_id" : 1606655503,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313034598/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-01T16:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313034598",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313037669"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313037669"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "```suggestion\r\n        // Full match with the v1 prefix, so fall back to v1 behavior.\r\n```",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-09-01T13:34:33Z",
      "diff_hunk" : "@@ -910,24 +912,632 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // Initial state, cannot be transitioned into.\n+        assert(false);\n+        break;\n+    case RecvState::KEY:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        assert(m_recv_state == RecvState::KEY);\n+        break;\n+    case RecvState::GARBAUTH:\n+        assert(m_recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::VERSION:\n+        assert(m_recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::APP:\n+        assert(m_recv_state == RecvState::VERSION || m_recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        assert(m_recv_state == RecvState::APP);\n+        break;\n+    case RecvState::V1:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (send_state) {\n+    case SendState::KEY_GARB_MAYBE_V1:\n+        // Initial state, cannot be transitioned into.\n+        assert(false);\n+        break;\n+    case SendState::KEY_GARB:\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1);\n+        break;\n+    case SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION:\n+        assert(m_send_state == SendState::KEY_GARB);\n+        break;\n+    case SendState::APP_READY:\n+        assert(m_send_state == SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION ||\n+               m_send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        assert(m_send_state == SendState::APP_READY);\n+        break;\n+    case SendState::V1:\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // During the KEY_MAYBE_V1 state we do not allow more than the length of v1 prefix into the\n+        // receive buffer.\n+        Assume(m_recv_buffer.size() <= m_v1_prefix.size());\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY_MAYBE_V1);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        SetReceiveState(RecvState::KEY); // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        SetSendState(SendState::KEY_GARB);\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313037669",
      "id" : 1313037669,
      "line" : 1152,
      "node_id" : "PRRC_kwDOABII585OQ11l",
      "original_commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "original_line" : 1152,
      "original_position" : 269,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 269,
      "pull_request_review_id" : 1606655503,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313037669/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-01T16:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313037669",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313079175"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313079175"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This looks too dangerous/fragile to me. `feedback` is constructed from `m_recv_buffer` which is provided by the peer and if `ReceivedBytes()` does not like it, then we will crash. Earlier we have checked that its size equals `m_v1_prefix.size()` and even earlier we have checked that the first bytes of `m_recv_buffer` and `m_v1_prefix` equal. Or if `m_v1_fallback` has been used before, it may dislike a legit magic+\"version\".\r\n\r\nMaybe construct `feedback` from `m_v1_prefix` which has been constructed by us? I know they are equal, but still...\r\n\r\n@sdaftuar had some concerns elsewhere about asserts in the networking code: https://github.com/bitcoin/bitcoin/pull/27374#discussion_r1154508362. Following that should all asserts in this PR be replaced by dropping the connection? If there is a rare bug in e.g. `V2Transport` is it better to crash the node or close the connection and continue operation?",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-09-01T14:09:58Z",
      "diff_hunk" : "@@ -910,24 +912,632 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // Initial state, cannot be transitioned into.\n+        assert(false);\n+        break;\n+    case RecvState::KEY:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        assert(m_recv_state == RecvState::KEY);\n+        break;\n+    case RecvState::GARBAUTH:\n+        assert(m_recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::VERSION:\n+        assert(m_recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::APP:\n+        assert(m_recv_state == RecvState::VERSION || m_recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        assert(m_recv_state == RecvState::APP);\n+        break;\n+    case RecvState::V1:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (send_state) {\n+    case SendState::KEY_GARB_MAYBE_V1:\n+        // Initial state, cannot be transitioned into.\n+        assert(false);\n+        break;\n+    case SendState::KEY_GARB:\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1);\n+        break;\n+    case SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION:\n+        assert(m_send_state == SendState::KEY_GARB);\n+        break;\n+    case SendState::APP_READY:\n+        assert(m_send_state == SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION ||\n+               m_send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        assert(m_send_state == SendState::APP_READY);\n+        break;\n+    case SendState::V1:\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // During the KEY_MAYBE_V1 state we do not allow more than the length of v1 prefix into the\n+        // receive buffer.\n+        Assume(m_recv_buffer.size() <= m_v1_prefix.size());\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY_MAYBE_V1);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        SetReceiveState(RecvState::KEY); // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        SetSendState(SendState::KEY_GARB);\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313079175",
      "id" : 1313079175,
      "line" : 1157,
      "node_id" : "PRRC_kwDOABII585OQ_-H",
      "original_commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "original_line" : 1157,
      "original_position" : 274,
      "original_start_line" : 1155,
      "path" : "src/net.cpp",
      "position" : 274,
      "pull_request_review_id" : 1606655503,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313079175/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 1155,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-09-01T16:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313079175",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313194800"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313194800"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "```suggestion\r\n    size_t garb_len = provider.ConsumeIntegralInRange<size_t>(0, V2Transport::MAX_GARBAGE_LEN);\r\n```",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-09-01T15:39:57Z",
      "diff_hunk" : "@@ -320,6 +335,43 @@ std::unique_ptr<Transport> MakeV1Transport(NodeId nodeid) noexcept\n     return std::make_unique<V1Transport>(nodeid, SER_NETWORK, INIT_PROTO_VERSION);\n }\n \n+template<typename RNG>\n+std::unique_ptr<Transport> MakeV2Transport(NodeId nodeid, bool initiator, RNG& rng, FuzzedDataProvider& provider)\n+{\n+    // Retrieve key\n+    auto key_data = provider.ConsumeBytes<unsigned char>(32);\n+    key_data.resize(32);\n+    CKey key;\n+    key.Set(key_data.begin(), key_data.end(), true);\n+    if (!key.IsValid()) return {};\n+    // Construct garbage\n+    size_t garb_len = provider.ConsumeIntegralInRange<size_t>(0, 4095);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313194800",
      "id" : 1313194800,
      "line" : 348,
      "node_id" : "PRRC_kwDOABII585ORcMw",
      "original_commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "original_line" : 348,
      "original_position" : 107,
      "original_start_line" : null,
      "path" : "src/test/fuzz/p2p_transport_serialization.cpp",
      "position" : 107,
      "pull_request_review_id" : 1606655503,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313194800/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-01T16:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313194800",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313198040"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313198040"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "```suggestion\r\n    // This is extremely unlikely (~2^-116) with random keys/garbage, but the fuzzer can choose\r\n```",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-09-01T15:43:09Z",
      "diff_hunk" : "@@ -320,6 +335,43 @@ std::unique_ptr<Transport> MakeV1Transport(NodeId nodeid) noexcept\n     return std::make_unique<V1Transport>(nodeid, SER_NETWORK, INIT_PROTO_VERSION);\n }\n \n+template<typename RNG>\n+std::unique_ptr<Transport> MakeV2Transport(NodeId nodeid, bool initiator, RNG& rng, FuzzedDataProvider& provider)\n+{\n+    // Retrieve key\n+    auto key_data = provider.ConsumeBytes<unsigned char>(32);\n+    key_data.resize(32);\n+    CKey key;\n+    key.Set(key_data.begin(), key_data.end(), true);\n+    if (!key.IsValid()) return {};\n+    // Construct garbage\n+    size_t garb_len = provider.ConsumeIntegralInRange<size_t>(0, 4095);\n+    std::vector<uint8_t> garb;\n+    if (garb_len <= 64) {\n+        // When the garbage length is up to 64 bytes, read it directly from the fuzzer input.\n+        garb = provider.ConsumeBytes<uint8_t>(garb_len);\n+        garb.resize(garb_len);\n+    } else {\n+        // If it's longer, generate it from the RNG. This avoids having large amounts of\n+        // (hopefully) irrelevant data needing to be stored in the fuzzer data.\n+        for (auto& v : garb) v = uint8_t(rng());\n+    }\n+    // Retrieve entropy\n+    auto ent = provider.ConsumeBytes<std::byte>(32);\n+    ent.resize(32);\n+    // Use as entropy SHA256(ent || garbage). This prevents a situation where the fuzzer manages to\n+    // include the garbage terminator (which is a function of both ellswift keys) in the garbage.\n+    // This is entremely unlikely (~2^-116) with random keys/garbage, but the fuzzer can choose",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313198040",
      "id" : 1313198040,
      "line" : 364,
      "node_id" : "PRRC_kwDOABII585ORc_Y",
      "original_commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "original_line" : 364,
      "original_position" : 123,
      "original_start_line" : null,
      "path" : "src/test/fuzz/p2p_transport_serialization.cpp",
      "position" : 123,
      "pull_request_review_id" : 1606655503,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313198040/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-01T16:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313198040",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313209038"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313209038"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Why do this? To reduce the amount of `m_recv_buffer` resizes?\r\n\r\nHow did you choose `250000`?\r\n\r\nWhen would `max_read` be larger than `msg_bytes.size() + MAX_RESERVE_AHEAD`?",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-09-01T15:53:43Z",
      "diff_hunk" : "@@ -910,24 +912,632 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // Initial state, cannot be transitioned into.\n+        assert(false);\n+        break;\n+    case RecvState::KEY:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        assert(m_recv_state == RecvState::KEY);\n+        break;\n+    case RecvState::GARBAUTH:\n+        assert(m_recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::VERSION:\n+        assert(m_recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::APP:\n+        assert(m_recv_state == RecvState::VERSION || m_recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        assert(m_recv_state == RecvState::APP);\n+        break;\n+    case RecvState::V1:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (send_state) {\n+    case SendState::KEY_GARB_MAYBE_V1:\n+        // Initial state, cannot be transitioned into.\n+        assert(false);\n+        break;\n+    case SendState::KEY_GARB:\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1);\n+        break;\n+    case SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION:\n+        assert(m_send_state == SendState::KEY_GARB);\n+        break;\n+    case SendState::APP_READY:\n+        assert(m_send_state == SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION ||\n+               m_send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        assert(m_send_state == SendState::APP_READY);\n+        break;\n+    case SendState::V1:\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // During the KEY_MAYBE_V1 state we do not allow more than the length of v1 prefix into the\n+        // receive buffer.\n+        Assume(m_recv_buffer.size() <= m_v1_prefix.size());\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY_MAYBE_V1);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        SetReceiveState(RecvState::KEY); // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        SetSendState(SendState::KEY_GARB);\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        SetReceiveState(RecvState::V1);\n+        SetSendState(SendState::V1);\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        EllSwiftPubKey ellswift(MakeByteSpan(m_recv_buffer).first(EllSwiftPubKey::size()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(ellswift, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        SetReceiveState(RecvState::GARB_GARBTERM);\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARB_GARBTERM_GARBAUTH_VERSION.\n+        SetSendState(SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION);\n+        // Append the garbage terminator to the send buffer.\n+        size_t garbage_len = m_send_buffer.size() - EllSwiftPubKey::size();\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer (using the garbage data which\n+        // already there).\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            MakeByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size(), garbage_len),\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+    Assume(m_recv_buffer.size() <= MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            SetReceiveState(RecvState::GARBAUTH);\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARBAUTH || m_recv_state == RecvState::VERSION ||\n+           m_recv_state == RecvState::APP);\n+\n+    // The maximum permitted contents length for a packet.\n+    static constexpr size_t MAX_CONTENTS_LEN =\n+        1 + CMessageHeader::COMMAND_SIZE + // The maximum length for encoding the message type.\n+        std::min<size_t>(MAX_SIZE, MAX_PROTOCOL_MESSAGE_LENGTH); // The maximum payload.\n+\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_CONTENTS_LEN) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        // Note that it is impossible to reach this branch without hitting the branch above first,\n+        // as GetMaxBytesToProcess only allows up to LENGTH_LEN into the buffer before that point.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packet decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            SetReceiveState(RecvState::VERSION);\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is\n+                // ignored, but can be used for future extensions.\n+                SetReceiveState(RecvState::APP);\n+            }\n+            break;\n+        case RecvState::APP:\n+            if (!ignore) {\n+                // Application message decrypted correctly. It can be extracted using GetMessage().\n+                SetReceiveState(RecvState::APP_READY);\n+            }\n+            break;\n+        default:\n+            // Any other state is invalid (this function should not have been called).\n+            assert(false);\n+        }\n+        // Wipe the receive buffer where the next packet will be received into.\n+        m_recv_buffer = {};\n+        // In all but APP_READY state, we can wipe the decoded contents.\n+        if (m_recv_state != RecvState::APP_READY) m_recv_decode_buffer = {};\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ReceivedBytes(Span<const uint8_t>& msg_bytes) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    /** How many bytes to allocate in the receive buffer at most above what is received so far. */\n+    static constexpr size_t MAX_RESERVE_AHEAD = 250000;\n+\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedBytes(msg_bytes);\n+\n+    while (!msg_bytes.empty()) {\n+        // Decide how many bytes to copy from msg_bytes to m_recv_buffer.\n+        size_t max_read = GetMaxBytesToProcess();\n+        // Reserve space in the buffer.\n+        if (m_recv_state == RecvState::KEY_MAYBE_V1 || m_recv_state == RecvState::KEY ||\n+            m_recv_state == RecvState::GARB_GARBTERM) {\n+            // During the initial states (key/garbage), allocate once to fit the maximum (4111\n+            // bytes).\n+            m_recv_buffer.reserve(MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        } else if (m_recv_state == RecvState::GARBAUTH || m_recv_state == RecvState::VERSION ||\n+            m_recv_state == RecvState::APP) {\n+            // During states where a packet is being received, as much as is expected but never\n+            // more than MAX_RESERVE_AHEAD bytes in addition to what is received so far.\n+            size_t alloc_add = std::min(max_read, msg_bytes.size() + MAX_RESERVE_AHEAD);\n+            m_recv_buffer.reserve(m_recv_buffer.size() + alloc_add);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313209038",
      "id" : 1313209038,
      "line" : 1326,
      "node_id" : "PRRC_kwDOABII585ORfrO",
      "original_commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "original_line" : 1326,
      "original_position" : 443,
      "original_start_line" : 1307,
      "path" : "src/net.cpp",
      "position" : 443,
      "pull_request_review_id" : 1606655503,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313209038/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 1307,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-09-01T16:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313209038",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313242620"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313242620"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Would be nice to avoid the magic numbers 12 and 13.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-09-01T16:16:24Z",
      "diff_hunk" : "@@ -1008,4 +1009,496 @@ BOOST_AUTO_TEST_CASE(advertise_local_address)\n     RemoveLocal(addr_cjdns);\n }\n \n+namespace {\n+\n+/** A class for scenario-based tests of V2Transport\n+ *\n+ * Each V2TransportTester encapsulates a V2Transport (the one being tested), and can be told to\n+ * interact with it. To do so, it also encapsulates a BIP324Cipher to act as the other side. A\n+ * second V2Transport is not used, as doing so would prevent scenarios that are permitted by BIP324\n+ * but not implemented (such as the sending of decoy packets).\n+ */\n+class V2TransportTester\n+{\n+    V2Transport m_transport; //!< V2Transport being tested\n+    BIP324Cipher m_cipher; //!< Cipher to help with the other side\n+    bool m_test_initiator; //!< Whether m_transport is the initiator (true) or responder (false)\n+\n+    std::vector<uint8_t> m_sent_garbage; //!< The garbage we've sent to m_transport.\n+    std::vector<uint8_t> m_to_send; //!< Bytes we have queued up to send to m_transport.\n+    std::vector<uint8_t> m_received; //!< Bytes we have received from m_transport.\n+    std::deque<CSerializedNetMsg> m_msg_to_send; //!< Messages to be sent *by* m_transport to us.\n+\n+public:\n+    /** Construct a tester object. test_initiator: whether the tested transport is initiator. */\n+    V2TransportTester(bool test_initiator) :\n+        m_transport(0, test_initiator, SER_NETWORK, INIT_PROTO_VERSION),\n+        m_test_initiator(test_initiator) {}\n+\n+    /** Data type returned by Interact:\n+     *\n+     * - std::nullopt: transport error occurred\n+     * - otherwise: a vector of\n+     *   - std::nullopt: invalid message received\n+     *   - otherwise: a CNetMessage retrieved\n+     */\n+    using InteractResult = std::optional<std::vector<std::optional<CNetMessage>>>;\n+\n+    /** Send/receive scheduled/available bytes and messages.\n+     *\n+     * This is the only function that interacts with the transport being tested; everything else is\n+     * scheduling things done by Interact(), or processing things learned by it.\n+     */\n+    InteractResult Interact()\n+    {\n+        std::vector<std::optional<CNetMessage>> ret;\n+        while (true) {\n+            bool progress{false};\n+            // Send bytes from m_to_send to the transport.\n+            if (!m_to_send.empty()) {\n+                Span<const uint8_t> to_send = Span{m_to_send}.first(1 + InsecureRandRange(m_to_send.size()));\n+                size_t old_len = to_send.size();\n+                if (!m_transport.ReceivedBytes(to_send)) {\n+                    return std::nullopt; // transport error occurred\n+                }\n+                if (old_len != to_send.size()) {\n+                    progress = true;\n+                    m_to_send.erase(m_to_send.begin(), m_to_send.begin() + (old_len - to_send.size()));\n+                }\n+            }\n+            // Retrieve messages received by the transport.\n+            if (m_transport.ReceivedMessageComplete() && (!progress || InsecureRandBool())) {\n+                bool reject{false};\n+                auto msg = m_transport.GetReceivedMessage({}, reject);\n+                if (reject) {\n+                    ret.push_back(std::nullopt);\n+                } else {\n+                    ret.push_back(std::move(msg));\n+                }\n+                progress = true;\n+            }\n+            // Enqueue a message to be sent by the transport to us.\n+            if (!m_msg_to_send.empty() && (!progress || InsecureRandBool())) {\n+                if (m_transport.SetMessageToSend(m_msg_to_send.front())) {\n+                    m_msg_to_send.pop_front();\n+                    progress = true;\n+                }\n+            }\n+            // Receive bytes from the transport.\n+            const auto& [recv_bytes, _more, _msg_type] = m_transport.GetBytesToSend(!m_msg_to_send.empty());\n+            if (!recv_bytes.empty() && (!progress || InsecureRandBool())) {\n+                size_t to_receive = 1 + InsecureRandRange(recv_bytes.size());\n+                m_received.insert(m_received.end(), recv_bytes.begin(), recv_bytes.begin() + to_receive);\n+                progress = true;\n+                m_transport.MarkBytesSent(to_receive);\n+            }\n+            if (!progress) break;\n+        }\n+        return ret;\n+    }\n+\n+    /** Expose the cipher. */\n+    BIP324Cipher& GetCipher() { return m_cipher; }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const uint8_t> data)\n+    {\n+        m_to_send.insert(m_to_send.end(), data.begin(), data.end());\n+    }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const std::byte> data) { Send(MakeUCharSpan(data)); }\n+\n+    /** Schedule our ellswift key to be sent to the transport. */\n+    void SendKey() { Send(m_cipher.GetOurPubKey()); }\n+\n+    /** Schedule specified garbage to be sent to the transport. */\n+    void SendGarbage(Span<const uint8_t> garbage)\n+    {\n+        // Remember the specified garbage (so we can use it for constructing the garbage\n+        // authentication packet).\n+        m_sent_garbage.assign(garbage.begin(), garbage.end());\n+        // Schedule it for sending.\n+        Send(m_sent_garbage);\n+    }\n+\n+    /** Schedule garbage (of specified length) to be sent to the transport. */\n+    void SendGarbage(size_t garbage_len)\n+    {\n+        // Generate random garbage and send it.\n+        SendGarbage(g_insecure_rand_ctx.randbytes<uint8_t>(garbage_len));\n+    }\n+\n+    /** Schedule garbage (with valid random length) to be sent to the transport. */\n+    void SendGarbage()\n+    {\n+         SendGarbage(InsecureRandRange(V2Transport::MAX_GARBAGE_LEN + 1));\n+    }\n+\n+    /** Schedule a message to be sent to us by the transport. */\n+    void AddMessage(std::string m_type, std::vector<uint8_t> payload)\n+    {\n+        CSerializedNetMsg msg;\n+        msg.m_type = std::move(m_type);\n+        msg.data = std::move(payload);\n+        m_msg_to_send.push_back(std::move(msg));\n+    }\n+\n+    /** Expect ellswift key to have been received from transport and process it.\n+     *\n+     * Many other V2TransportTester functions cannot be called until after ReceiveKey() has been\n+     * called, as no encryption keys are set up before that point.\n+     */\n+    void ReceiveKey()\n+    {\n+        // When processing a key, enough bytes need to have been received already.\n+        BOOST_CHECK(m_received.size() >= EllSwiftPubKey::size());\n+        // Initialize the cipher using it (acting as the opposite side of the tested transport).\n+        m_cipher.Initialize(MakeByteSpan(m_received).first(EllSwiftPubKey::size()), !m_test_initiator);\n+        // Strip the processed bytes off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + EllSwiftPubKey::size());\n+    }\n+\n+    /** Schedule an encrypted packet with specified content/aad/ignore to be sent to transport\n+     *  (only after ReceiveKey). */\n+    void SendPacket(Span<const uint8_t> content, Span<const uint8_t> aad = {}, bool ignore = false)\n+    {\n+        // Use cipher to construct ciphertext.\n+        std::vector<std::byte> ciphertext;\n+        ciphertext.resize(content.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(MakeByteSpan(content), MakeByteSpan(aad), ignore, ciphertext);\n+        // Schedule it for sending.\n+        Send(ciphertext);\n+    }\n+\n+    /** Schedule garbage terminator and authentication packet to be sent to the transport (only\n+     *  after ReceiveKey). */\n+    void SendGarbageTermAuth(size_t garb_auth_data_len = 0, bool garb_auth_ignore = false)\n+    {\n+        // Generate random data to include in the garbage authentication packet (ignored by peer).\n+        auto garb_auth_data = g_insecure_rand_ctx.randbytes<uint8_t>(garb_auth_data_len);\n+        // Schedule the garbage terminator to be sent.\n+        Send(m_cipher.GetSendGarbageTerminator());\n+        // Schedule the garbage authentication packet to be sent.\n+        SendPacket(/*content=*/garb_auth_data, /*aad=*/m_sent_garbage, /*ignore=*/garb_auth_ignore);\n+    }\n+\n+    /** Schedule version packet to be sent to the transport (only after ReceiveKey). */\n+    void SendVersion(Span<const uint8_t> version_data = {}, bool vers_ignore = false)\n+    {\n+        SendPacket(/*content=*/version_data, /*aad=*/{}, /*ignore=*/vers_ignore);\n+    }\n+\n+    /** Expect a packet to have been received from transport, process it, and return its contents\n+     *  (only after ReceiveKey). By default, decoys are skipped. */\n+    std::vector<uint8_t> ReceivePacket(Span<const std::byte> aad = {}, bool skip_decoy = true)\n+    {\n+        std::vector<uint8_t> contents;\n+        // Loop as long as there are ignored packets that are to be skipped.\n+        while (true) {\n+            // When processing a packet, at least enough bytes for its length descriptor must be received.\n+            BOOST_CHECK(m_received.size() >= BIP324Cipher::LENGTH_LEN);\n+            // Decrypt the content length.\n+            size_t size = m_cipher.DecryptLength(MakeByteSpan(Span{m_received}.first(BIP324Cipher::LENGTH_LEN)));\n+            // Check that the full packet is in the receive buffer.\n+            BOOST_CHECK(m_received.size() >= size + BIP324Cipher::EXPANSION);\n+            // Decrypt the packet contents.\n+            contents.resize(size);\n+            bool ignore{false};\n+            bool ret = m_cipher.Decrypt(\n+                MakeByteSpan(Span{m_received}.first(size + BIP324Cipher::EXPANSION).subspan(BIP324Cipher::LENGTH_LEN)),\n+                aad, ignore, MakeWritableByteSpan(contents));\n+            BOOST_CHECK(ret);\n+            // Strip the processed packet's bytes off the front of the receive buffer.\n+            m_received.erase(m_received.begin(), m_received.begin() + size + BIP324Cipher::EXPANSION);\n+            // Stop if the ignore bit is not set on this packet, or if we choose to not honor it.\n+            if (!ignore || !skip_decoy) break;\n+        }\n+        return contents;\n+    }\n+\n+    /** Expect garbage, garbage terminator, and garbage auth packet to have been received, and\n+     *  process them (only after ReceiveKey). */\n+    void ReceiveGarbage()\n+    {\n+        // Figure out the garbage length.\n+        size_t garblen;\n+        for (garblen = 0; garblen <= V2Transport::MAX_GARBAGE_LEN; ++garblen) {\n+            assert(m_received.size() >= garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            auto term_span = MakeByteSpan(Span{m_received}.subspan(garblen, BIP324Cipher::GARBAGE_TERMINATOR_LEN));\n+            if (term_span == m_cipher.GetReceiveGarbageTerminator()) break;\n+        }\n+        // Copy the garbage to a buffer.\n+        std::vector<uint8_t> garbage(m_received.begin(), m_received.begin() + garblen);\n+        // Strip garbage + garbage terminator off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        // Process the expected garbage authentication packet. Such a packet still functions as one\n+        // even when its ignore bit is set to true, so we do not skip decoy packets here.\n+        ReceivePacket(/*aad=*/MakeByteSpan(garbage), /*skip_decoy=*/false);\n+    }\n+\n+    /** Expect version packet to have been received, and process it (only after ReceiveKey). */\n+    void ReceiveVersion()\n+    {\n+        auto contents = ReceivePacket();\n+        // Version packets from real BIP324 peers are expected to be empty, despite the fact that\n+        // this class supports *sending* non-empty version packets (to test that BIP324 peers\n+        // correctly ignore version packet contents).\n+        BOOST_CHECK(contents.empty());\n+    }\n+\n+    /** Expect application packet to have been received, with specified short id and payload.\n+     *  (only after ReceiveKey). */\n+    void ReceiveMessage(uint8_t short_id, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_CHECK(ret.size() == payload.size() + 1);\n+        BOOST_CHECK(ret[0] == short_id);\n+        BOOST_CHECK(Span{ret}.subspan(1) == payload);\n+    }\n+\n+    /** Expect application packet to have been received, with specified 12-char message type and\n+     *  payload (only after ReceiveKey). */\n+    void ReceiveMessage(const std::string& m_type, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_CHECK(ret.size() == payload.size() + 13);\n+        BOOST_CHECK(ret[0] == 0);\n+        for (unsigned i = 0; i < 12; ++i) {\n+            if (i < m_type.size()) {\n+                BOOST_CHECK(ret[1 + i] == m_type[i]);\n+            } else {\n+                BOOST_CHECK(ret[1 + i] == 0);\n+            }\n+        }\n+        BOOST_CHECK(Span{ret}.subspan(13) == payload);\n+    }\n+\n+    /** Schedule an encrypted packet with specified message type and payload to be sent to\n+     *  transport (only after ReceiveKey). */\n+    void SendMessage(std::string mtype, Span<const uint8_t> payload)\n+    {\n+        // Construct contents consisting of 0x00 + 12-byte message type + payload.\n+        std::vector<uint8_t> contents(13 + payload.size());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313242620",
      "id" : 1313242620,
      "line" : 1282,
      "node_id" : "PRRC_kwDOABII585ORn38",
      "original_commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "original_line" : 1282,
      "original_position" : 282,
      "original_start_line" : 1265,
      "path" : "src/test/net_tests.cpp",
      "position" : 282,
      "pull_request_review_id" : 1606655503,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313242620/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 1265,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-09-01T16:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313242620",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313245167"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313245167"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Since this unit test uses random numbers, it may happen that if it fails/crashes, then it does not do that if run again. How would one go to reproduce a test failure?",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-09-01T16:19:22Z",
      "diff_hunk" : "@@ -1008,4 +1009,496 @@ BOOST_AUTO_TEST_CASE(advertise_local_address)\n     RemoveLocal(addr_cjdns);\n }\n \n+namespace {\n+\n+/** A class for scenario-based tests of V2Transport\n+ *\n+ * Each V2TransportTester encapsulates a V2Transport (the one being tested), and can be told to\n+ * interact with it. To do so, it also encapsulates a BIP324Cipher to act as the other side. A\n+ * second V2Transport is not used, as doing so would prevent scenarios that are permitted by BIP324\n+ * but not implemented (such as the sending of decoy packets).\n+ */\n+class V2TransportTester\n+{\n+    V2Transport m_transport; //!< V2Transport being tested\n+    BIP324Cipher m_cipher; //!< Cipher to help with the other side\n+    bool m_test_initiator; //!< Whether m_transport is the initiator (true) or responder (false)\n+\n+    std::vector<uint8_t> m_sent_garbage; //!< The garbage we've sent to m_transport.\n+    std::vector<uint8_t> m_to_send; //!< Bytes we have queued up to send to m_transport.\n+    std::vector<uint8_t> m_received; //!< Bytes we have received from m_transport.\n+    std::deque<CSerializedNetMsg> m_msg_to_send; //!< Messages to be sent *by* m_transport to us.\n+\n+public:\n+    /** Construct a tester object. test_initiator: whether the tested transport is initiator. */\n+    V2TransportTester(bool test_initiator) :\n+        m_transport(0, test_initiator, SER_NETWORK, INIT_PROTO_VERSION),\n+        m_test_initiator(test_initiator) {}\n+\n+    /** Data type returned by Interact:\n+     *\n+     * - std::nullopt: transport error occurred\n+     * - otherwise: a vector of\n+     *   - std::nullopt: invalid message received\n+     *   - otherwise: a CNetMessage retrieved\n+     */\n+    using InteractResult = std::optional<std::vector<std::optional<CNetMessage>>>;\n+\n+    /** Send/receive scheduled/available bytes and messages.\n+     *\n+     * This is the only function that interacts with the transport being tested; everything else is\n+     * scheduling things done by Interact(), or processing things learned by it.\n+     */\n+    InteractResult Interact()\n+    {\n+        std::vector<std::optional<CNetMessage>> ret;\n+        while (true) {\n+            bool progress{false};\n+            // Send bytes from m_to_send to the transport.\n+            if (!m_to_send.empty()) {\n+                Span<const uint8_t> to_send = Span{m_to_send}.first(1 + InsecureRandRange(m_to_send.size()));\n+                size_t old_len = to_send.size();\n+                if (!m_transport.ReceivedBytes(to_send)) {\n+                    return std::nullopt; // transport error occurred\n+                }\n+                if (old_len != to_send.size()) {\n+                    progress = true;\n+                    m_to_send.erase(m_to_send.begin(), m_to_send.begin() + (old_len - to_send.size()));\n+                }\n+            }\n+            // Retrieve messages received by the transport.\n+            if (m_transport.ReceivedMessageComplete() && (!progress || InsecureRandBool())) {\n+                bool reject{false};\n+                auto msg = m_transport.GetReceivedMessage({}, reject);\n+                if (reject) {\n+                    ret.push_back(std::nullopt);\n+                } else {\n+                    ret.push_back(std::move(msg));\n+                }\n+                progress = true;\n+            }\n+            // Enqueue a message to be sent by the transport to us.\n+            if (!m_msg_to_send.empty() && (!progress || InsecureRandBool())) {\n+                if (m_transport.SetMessageToSend(m_msg_to_send.front())) {\n+                    m_msg_to_send.pop_front();\n+                    progress = true;\n+                }\n+            }\n+            // Receive bytes from the transport.\n+            const auto& [recv_bytes, _more, _msg_type] = m_transport.GetBytesToSend(!m_msg_to_send.empty());\n+            if (!recv_bytes.empty() && (!progress || InsecureRandBool())) {\n+                size_t to_receive = 1 + InsecureRandRange(recv_bytes.size());\n+                m_received.insert(m_received.end(), recv_bytes.begin(), recv_bytes.begin() + to_receive);\n+                progress = true;\n+                m_transport.MarkBytesSent(to_receive);\n+            }\n+            if (!progress) break;\n+        }\n+        return ret;\n+    }\n+\n+    /** Expose the cipher. */\n+    BIP324Cipher& GetCipher() { return m_cipher; }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const uint8_t> data)\n+    {\n+        m_to_send.insert(m_to_send.end(), data.begin(), data.end());\n+    }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const std::byte> data) { Send(MakeUCharSpan(data)); }\n+\n+    /** Schedule our ellswift key to be sent to the transport. */\n+    void SendKey() { Send(m_cipher.GetOurPubKey()); }\n+\n+    /** Schedule specified garbage to be sent to the transport. */\n+    void SendGarbage(Span<const uint8_t> garbage)\n+    {\n+        // Remember the specified garbage (so we can use it for constructing the garbage\n+        // authentication packet).\n+        m_sent_garbage.assign(garbage.begin(), garbage.end());\n+        // Schedule it for sending.\n+        Send(m_sent_garbage);\n+    }\n+\n+    /** Schedule garbage (of specified length) to be sent to the transport. */\n+    void SendGarbage(size_t garbage_len)\n+    {\n+        // Generate random garbage and send it.\n+        SendGarbage(g_insecure_rand_ctx.randbytes<uint8_t>(garbage_len));\n+    }\n+\n+    /** Schedule garbage (with valid random length) to be sent to the transport. */\n+    void SendGarbage()\n+    {\n+         SendGarbage(InsecureRandRange(V2Transport::MAX_GARBAGE_LEN + 1));\n+    }\n+\n+    /** Schedule a message to be sent to us by the transport. */\n+    void AddMessage(std::string m_type, std::vector<uint8_t> payload)\n+    {\n+        CSerializedNetMsg msg;\n+        msg.m_type = std::move(m_type);\n+        msg.data = std::move(payload);\n+        m_msg_to_send.push_back(std::move(msg));\n+    }\n+\n+    /** Expect ellswift key to have been received from transport and process it.\n+     *\n+     * Many other V2TransportTester functions cannot be called until after ReceiveKey() has been\n+     * called, as no encryption keys are set up before that point.\n+     */\n+    void ReceiveKey()\n+    {\n+        // When processing a key, enough bytes need to have been received already.\n+        BOOST_CHECK(m_received.size() >= EllSwiftPubKey::size());\n+        // Initialize the cipher using it (acting as the opposite side of the tested transport).\n+        m_cipher.Initialize(MakeByteSpan(m_received).first(EllSwiftPubKey::size()), !m_test_initiator);\n+        // Strip the processed bytes off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + EllSwiftPubKey::size());\n+    }\n+\n+    /** Schedule an encrypted packet with specified content/aad/ignore to be sent to transport\n+     *  (only after ReceiveKey). */\n+    void SendPacket(Span<const uint8_t> content, Span<const uint8_t> aad = {}, bool ignore = false)\n+    {\n+        // Use cipher to construct ciphertext.\n+        std::vector<std::byte> ciphertext;\n+        ciphertext.resize(content.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(MakeByteSpan(content), MakeByteSpan(aad), ignore, ciphertext);\n+        // Schedule it for sending.\n+        Send(ciphertext);\n+    }\n+\n+    /** Schedule garbage terminator and authentication packet to be sent to the transport (only\n+     *  after ReceiveKey). */\n+    void SendGarbageTermAuth(size_t garb_auth_data_len = 0, bool garb_auth_ignore = false)\n+    {\n+        // Generate random data to include in the garbage authentication packet (ignored by peer).\n+        auto garb_auth_data = g_insecure_rand_ctx.randbytes<uint8_t>(garb_auth_data_len);\n+        // Schedule the garbage terminator to be sent.\n+        Send(m_cipher.GetSendGarbageTerminator());\n+        // Schedule the garbage authentication packet to be sent.\n+        SendPacket(/*content=*/garb_auth_data, /*aad=*/m_sent_garbage, /*ignore=*/garb_auth_ignore);\n+    }\n+\n+    /** Schedule version packet to be sent to the transport (only after ReceiveKey). */\n+    void SendVersion(Span<const uint8_t> version_data = {}, bool vers_ignore = false)\n+    {\n+        SendPacket(/*content=*/version_data, /*aad=*/{}, /*ignore=*/vers_ignore);\n+    }\n+\n+    /** Expect a packet to have been received from transport, process it, and return its contents\n+     *  (only after ReceiveKey). By default, decoys are skipped. */\n+    std::vector<uint8_t> ReceivePacket(Span<const std::byte> aad = {}, bool skip_decoy = true)\n+    {\n+        std::vector<uint8_t> contents;\n+        // Loop as long as there are ignored packets that are to be skipped.\n+        while (true) {\n+            // When processing a packet, at least enough bytes for its length descriptor must be received.\n+            BOOST_CHECK(m_received.size() >= BIP324Cipher::LENGTH_LEN);\n+            // Decrypt the content length.\n+            size_t size = m_cipher.DecryptLength(MakeByteSpan(Span{m_received}.first(BIP324Cipher::LENGTH_LEN)));\n+            // Check that the full packet is in the receive buffer.\n+            BOOST_CHECK(m_received.size() >= size + BIP324Cipher::EXPANSION);\n+            // Decrypt the packet contents.\n+            contents.resize(size);\n+            bool ignore{false};\n+            bool ret = m_cipher.Decrypt(\n+                MakeByteSpan(Span{m_received}.first(size + BIP324Cipher::EXPANSION).subspan(BIP324Cipher::LENGTH_LEN)),\n+                aad, ignore, MakeWritableByteSpan(contents));\n+            BOOST_CHECK(ret);\n+            // Strip the processed packet's bytes off the front of the receive buffer.\n+            m_received.erase(m_received.begin(), m_received.begin() + size + BIP324Cipher::EXPANSION);\n+            // Stop if the ignore bit is not set on this packet, or if we choose to not honor it.\n+            if (!ignore || !skip_decoy) break;\n+        }\n+        return contents;\n+    }\n+\n+    /** Expect garbage, garbage terminator, and garbage auth packet to have been received, and\n+     *  process them (only after ReceiveKey). */\n+    void ReceiveGarbage()\n+    {\n+        // Figure out the garbage length.\n+        size_t garblen;\n+        for (garblen = 0; garblen <= V2Transport::MAX_GARBAGE_LEN; ++garblen) {\n+            assert(m_received.size() >= garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            auto term_span = MakeByteSpan(Span{m_received}.subspan(garblen, BIP324Cipher::GARBAGE_TERMINATOR_LEN));\n+            if (term_span == m_cipher.GetReceiveGarbageTerminator()) break;\n+        }\n+        // Copy the garbage to a buffer.\n+        std::vector<uint8_t> garbage(m_received.begin(), m_received.begin() + garblen);\n+        // Strip garbage + garbage terminator off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        // Process the expected garbage authentication packet. Such a packet still functions as one\n+        // even when its ignore bit is set to true, so we do not skip decoy packets here.\n+        ReceivePacket(/*aad=*/MakeByteSpan(garbage), /*skip_decoy=*/false);\n+    }\n+\n+    /** Expect version packet to have been received, and process it (only after ReceiveKey). */\n+    void ReceiveVersion()\n+    {\n+        auto contents = ReceivePacket();\n+        // Version packets from real BIP324 peers are expected to be empty, despite the fact that\n+        // this class supports *sending* non-empty version packets (to test that BIP324 peers\n+        // correctly ignore version packet contents).\n+        BOOST_CHECK(contents.empty());\n+    }\n+\n+    /** Expect application packet to have been received, with specified short id and payload.\n+     *  (only after ReceiveKey). */\n+    void ReceiveMessage(uint8_t short_id, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_CHECK(ret.size() == payload.size() + 1);\n+        BOOST_CHECK(ret[0] == short_id);\n+        BOOST_CHECK(Span{ret}.subspan(1) == payload);\n+    }\n+\n+    /** Expect application packet to have been received, with specified 12-char message type and\n+     *  payload (only after ReceiveKey). */\n+    void ReceiveMessage(const std::string& m_type, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_CHECK(ret.size() == payload.size() + 13);\n+        BOOST_CHECK(ret[0] == 0);\n+        for (unsigned i = 0; i < 12; ++i) {\n+            if (i < m_type.size()) {\n+                BOOST_CHECK(ret[1 + i] == m_type[i]);\n+            } else {\n+                BOOST_CHECK(ret[1 + i] == 0);\n+            }\n+        }\n+        BOOST_CHECK(Span{ret}.subspan(13) == payload);\n+    }\n+\n+    /** Schedule an encrypted packet with specified message type and payload to be sent to\n+     *  transport (only after ReceiveKey). */\n+    void SendMessage(std::string mtype, Span<const uint8_t> payload)\n+    {\n+        // Construct contents consisting of 0x00 + 12-byte message type + payload.\n+        std::vector<uint8_t> contents(13 + payload.size());\n+        std::copy(mtype.begin(), mtype.end(), reinterpret_cast<char*>(contents.data() + 1));\n+        std::copy(payload.begin(), payload.end(), contents.begin() + 13);\n+        // Send a packet with that as contents.\n+        SendPacket(contents);\n+    }\n+\n+    /** Schedule an encrypted packet with specified short message id and payload to be sent to\n+     *  transport (only after ReceiveKey). */\n+    void SendMessage(uint8_t short_id, Span<const uint8_t> payload)\n+    {\n+        // Construct contents consisting of short_id + payload.\n+        std::vector<uint8_t> contents(1 + payload.size());\n+        contents[0] = short_id;\n+        std::copy(payload.begin(), payload.end(), contents.begin() + 1);\n+        // Send a packet with that as contents.\n+        SendPacket(contents);\n+    }\n+\n+    /** Introduce a bit error in the data scheduled to be sent. */\n+    void Damage()\n+    {\n+        m_to_send[InsecureRandRange(m_to_send.size())] ^= (uint8_t{1} << InsecureRandRange(8));\n+    }\n+};\n+\n+} // namespace\n+\n+BOOST_AUTO_TEST_CASE(v2transport_test)\n+{\n+    // A mostly normal scenario, testing a transport in initiator mode.\n+    for (int i = 0; i < 10; ++i) {\n+        V2TransportTester tester(true);\n+        auto ret = tester.Interact();\n+        BOOST_CHECK(ret && ret->empty());\n+        tester.SendKey();\n+        tester.SendGarbage();\n+        tester.ReceiveKey();\n+        tester.SendGarbageTermAuth();\n+        tester.SendVersion();\n+        ret = tester.Interact();\n+        BOOST_CHECK(ret && ret->empty());\n+        tester.ReceiveGarbage();\n+        tester.ReceiveVersion();\n+        auto msg_data_1 = g_insecure_rand_ctx.randbytes<uint8_t>(InsecureRandRange(100000));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313245167",
      "id" : 1313245167,
      "line" : 1326,
      "node_id" : "PRRC_kwDOABII585ORofv",
      "original_commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "original_line" : 1326,
      "original_position" : 326,
      "original_start_line" : null,
      "path" : "src/test/net_tests.cpp",
      "position" : 326,
      "pull_request_review_id" : 1606655503,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313245167/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-01T16:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313245167",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313307383"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313307383"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It's possible to outlaw those `X` -> `X` transitions, but I don't think that accomplishes much. Conceptually, staying in the same state is always allowed; it just so happens that in many cases the current code never invokes this function in cases where no state change is needed.",
      "commit_id" : "75b91740fdeb9ad14cc6cb073e75867b49875a00",
      "created_at" : "2023-09-01T17:13:58Z",
      "diff_hunk" : "@@ -910,24 +912,632 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // Initial state, cannot be transitioned into.\n+        assert(false);\n+        break;\n+    case RecvState::KEY:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        assert(m_recv_state == RecvState::KEY);\n+        break;\n+    case RecvState::GARBAUTH:\n+        assert(m_recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::VERSION:\n+        assert(m_recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::APP:\n+        assert(m_recv_state == RecvState::VERSION || m_recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        assert(m_recv_state == RecvState::APP);\n+        break;\n+    case RecvState::V1:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313307383",
      "id" : 1313307383,
      "in_reply_to_id" : 1313034598,
      "line" : 1051,
      "node_id" : "PRRC_kwDOABII585OR3r3",
      "original_commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "original_line" : 1051,
      "original_position" : 168,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 168,
      "pull_request_review_id" : 1607368990,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313307383/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-01T19:53:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313307383",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313308489"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313308489"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Indeed, exactly. See also [footnote 9 in BIP324](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#cite_ref-why_no_prefix_check_9-0).",
      "commit_id" : "75b91740fdeb9ad14cc6cb073e75867b49875a00",
      "created_at" : "2023-09-01T17:15:03Z",
      "diff_hunk" : "@@ -910,24 +912,632 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // Initial state, cannot be transitioned into.\n+        assert(false);\n+        break;\n+    case RecvState::KEY:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        assert(m_recv_state == RecvState::KEY);\n+        break;\n+    case RecvState::GARBAUTH:\n+        assert(m_recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::VERSION:\n+        assert(m_recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::APP:\n+        assert(m_recv_state == RecvState::VERSION || m_recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        assert(m_recv_state == RecvState::APP);\n+        break;\n+    case RecvState::V1:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (send_state) {\n+    case SendState::KEY_GARB_MAYBE_V1:\n+        // Initial state, cannot be transitioned into.\n+        assert(false);\n+        break;\n+    case SendState::KEY_GARB:\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1);\n+        break;\n+    case SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION:\n+        assert(m_send_state == SendState::KEY_GARB);\n+        break;\n+    case SendState::APP_READY:\n+        assert(m_send_state == SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION ||\n+               m_send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        assert(m_send_state == SendState::APP_READY);\n+        break;\n+    case SendState::V1:\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // During the KEY_MAYBE_V1 state we do not allow more than the length of v1 prefix into the\n+        // receive buffer.\n+        Assume(m_recv_buffer.size() <= m_v1_prefix.size());\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY_MAYBE_V1);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313308489",
      "id" : 1313308489,
      "in_reply_to_id" : 1313028412,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OR39J",
      "original_commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "original_line" : 1145,
      "original_position" : 262,
      "original_start_line" : 1142,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1607368990,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313308489/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-09-01T19:53:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313308489",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313337429"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313337429"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> Why do this? To reduce the amount of `m_recv_buffer` resizes?\r\n\r\nMost `std::vector` implementations will double their memory when they resize beyond their bounds. That's a problem, because without explicitly controlling the preallocation to prevent that it means peers can trivially cause multiple megabytes of allocated but unused memory, without even needing to send bytes to fill them.\r\n\r\nI've added some extra comments to the code.\r\n\r\n> How did you choose `250000`?\r\n\r\nSame as `V1Transport` (see `V1Transport::readData`). I just realized it's `256 * 1024` there, I'll use the same here.\r\n\r\n> When would `max_read` be larger than `msg_bytes.size() + MAX_RESERVE_AHEAD`?\r\n\r\nFor example, when after receiving the first 1000 bytes of a 2 MB packet. `max_read` will be ~2000000, but `msg_bytes.size() + MAX_RESERVE_AHEAD` will be 251000.",
      "commit_id" : "75b91740fdeb9ad14cc6cb073e75867b49875a00",
      "created_at" : "2023-09-01T17:39:59Z",
      "diff_hunk" : "@@ -910,24 +912,632 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // Initial state, cannot be transitioned into.\n+        assert(false);\n+        break;\n+    case RecvState::KEY:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        assert(m_recv_state == RecvState::KEY);\n+        break;\n+    case RecvState::GARBAUTH:\n+        assert(m_recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::VERSION:\n+        assert(m_recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::APP:\n+        assert(m_recv_state == RecvState::VERSION || m_recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        assert(m_recv_state == RecvState::APP);\n+        break;\n+    case RecvState::V1:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (send_state) {\n+    case SendState::KEY_GARB_MAYBE_V1:\n+        // Initial state, cannot be transitioned into.\n+        assert(false);\n+        break;\n+    case SendState::KEY_GARB:\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1);\n+        break;\n+    case SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION:\n+        assert(m_send_state == SendState::KEY_GARB);\n+        break;\n+    case SendState::APP_READY:\n+        assert(m_send_state == SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION ||\n+               m_send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        assert(m_send_state == SendState::APP_READY);\n+        break;\n+    case SendState::V1:\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // During the KEY_MAYBE_V1 state we do not allow more than the length of v1 prefix into the\n+        // receive buffer.\n+        Assume(m_recv_buffer.size() <= m_v1_prefix.size());\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY_MAYBE_V1);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        SetReceiveState(RecvState::KEY); // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        SetSendState(SendState::KEY_GARB);\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        SetReceiveState(RecvState::V1);\n+        SetSendState(SendState::V1);\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        EllSwiftPubKey ellswift(MakeByteSpan(m_recv_buffer).first(EllSwiftPubKey::size()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(ellswift, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        SetReceiveState(RecvState::GARB_GARBTERM);\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARB_GARBTERM_GARBAUTH_VERSION.\n+        SetSendState(SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION);\n+        // Append the garbage terminator to the send buffer.\n+        size_t garbage_len = m_send_buffer.size() - EllSwiftPubKey::size();\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer (using the garbage data which\n+        // already there).\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            MakeByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size(), garbage_len),\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+    Assume(m_recv_buffer.size() <= MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            SetReceiveState(RecvState::GARBAUTH);\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARBAUTH || m_recv_state == RecvState::VERSION ||\n+           m_recv_state == RecvState::APP);\n+\n+    // The maximum permitted contents length for a packet.\n+    static constexpr size_t MAX_CONTENTS_LEN =\n+        1 + CMessageHeader::COMMAND_SIZE + // The maximum length for encoding the message type.\n+        std::min<size_t>(MAX_SIZE, MAX_PROTOCOL_MESSAGE_LENGTH); // The maximum payload.\n+\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_CONTENTS_LEN) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        // Note that it is impossible to reach this branch without hitting the branch above first,\n+        // as GetMaxBytesToProcess only allows up to LENGTH_LEN into the buffer before that point.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packet decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            SetReceiveState(RecvState::VERSION);\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is\n+                // ignored, but can be used for future extensions.\n+                SetReceiveState(RecvState::APP);\n+            }\n+            break;\n+        case RecvState::APP:\n+            if (!ignore) {\n+                // Application message decrypted correctly. It can be extracted using GetMessage().\n+                SetReceiveState(RecvState::APP_READY);\n+            }\n+            break;\n+        default:\n+            // Any other state is invalid (this function should not have been called).\n+            assert(false);\n+        }\n+        // Wipe the receive buffer where the next packet will be received into.\n+        m_recv_buffer = {};\n+        // In all but APP_READY state, we can wipe the decoded contents.\n+        if (m_recv_state != RecvState::APP_READY) m_recv_decode_buffer = {};\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ReceivedBytes(Span<const uint8_t>& msg_bytes) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    /** How many bytes to allocate in the receive buffer at most above what is received so far. */\n+    static constexpr size_t MAX_RESERVE_AHEAD = 250000;\n+\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedBytes(msg_bytes);\n+\n+    while (!msg_bytes.empty()) {\n+        // Decide how many bytes to copy from msg_bytes to m_recv_buffer.\n+        size_t max_read = GetMaxBytesToProcess();\n+        // Reserve space in the buffer.\n+        if (m_recv_state == RecvState::KEY_MAYBE_V1 || m_recv_state == RecvState::KEY ||\n+            m_recv_state == RecvState::GARB_GARBTERM) {\n+            // During the initial states (key/garbage), allocate once to fit the maximum (4111\n+            // bytes).\n+            m_recv_buffer.reserve(MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        } else if (m_recv_state == RecvState::GARBAUTH || m_recv_state == RecvState::VERSION ||\n+            m_recv_state == RecvState::APP) {\n+            // During states where a packet is being received, as much as is expected but never\n+            // more than MAX_RESERVE_AHEAD bytes in addition to what is received so far.\n+            size_t alloc_add = std::min(max_read, msg_bytes.size() + MAX_RESERVE_AHEAD);\n+            m_recv_buffer.reserve(m_recv_buffer.size() + alloc_add);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313337429",
      "id" : 1313337429,
      "in_reply_to_id" : 1313209038,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OR_BV",
      "original_commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "original_line" : 1331,
      "original_position" : 443,
      "original_start_line" : 1307,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1607368990,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313337429/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-09-01T19:53:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313337429",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313344260"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313344260"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "75b91740fdeb9ad14cc6cb073e75867b49875a00",
      "created_at" : "2023-09-01T17:45:55Z",
      "diff_hunk" : "@@ -416,7 +414,226 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    // The sender side and receiver side of V2Transport are largely independent state machines that\n+    // are transitioned through, where each state corresponds to the meaning of the data in (or to\n+    // be received to) the respective (send/receive) buffer. The sender side is primarily\n+    // controlled by send-side functions (SetMessageToSend, MarkBytesSent), while the received side\n+    // is primarily controlled by receiver-side functions (ReceivedBytes, GetReceivedMessage),\n+    // though in some cases the sender state can also change as a result of receiving bytes.\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted.\n+     *\n+     * Diagram:\n+     *\n+     *   start(responder)\n+     *        |\n+     *        |  start(initiator)                                       /---------\\\n+     *        |          |                                              |         |\n+     *        v          v                                              v         |\n+     *  KEY_MAYBE_V1 -> KEY -> GARB_GARBTERM -> GARBAUTH -> VERSION -> APP -> APP_READY\n+     *        |\n+     *        \\-> V1\n+     */\n+    enum class RecvState : uint8_t {\n+        /** (Responder only) either v2 public key or v1 header.\n+         *\n+         * This is the initial state for responders, before data has been received to distinguish\n+         * v1 from v2 connections. When that happens, the state becomes either KEY (for v2) or V1\n+         * (for v1). */\n+        KEY_MAYBE_V1,\n+\n+        /** Public key.\n+         *\n+         * This is the initial state for initiators, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes APP,\n+         * and the decrypted contents is interpreted as version negotiation (currently, that means\n+         * ignoring it, but it can be used for negotiating future extensions). If it fails, the\n+         * connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All receive operations are redirected to m_v1_fallback. */\n+        V1,\n+    };\n+\n+    /** State type that defines the contents of the send buffer.\n+     *\n+     * Diagram:\n+     *\n+     *  start(responder)  start(initiator)                                        /----------\\\n+     *        |                  |                                                |          |\n+     *        v                  v                                                v          |\n+     *  KEY_GARB_MAYBE_V1 -> KEY_GARB -> KEY_GARB_GARBTERM_GARBAUTH_VERSION -> APP_READY -> APP\n+     *        |\n+     *        \\-> V1\n+     */\n+    enum class SendState : uint8_t {\n+        /** (Responder only) Public key and garbage.\n+         *\n+         * This is the initial state for responders. The send buffer contains the public key and\n+         * garbage to send, but nothing is sent in this state yet. When the receiver determines\n+         * whether this is a V1 or V2 connection, the sender state becomes KEY_GARB (for v2) or V1\n+         * (for v1) as well.\n+         */\n+        KEY_GARB_MAYBE_V1,\n+\n+        /** Public key and garbage.\n+         *\n+         * This is the initial state for initiators. The public key plus garbage are sent out. When\n+         * the receiver receives the other side's public key and transitions to GARB_GARBTERM, the\n+         * sender state becomes KEY_GARB_GARBTERM_GARBAUTH_VERSION. The key and garbage are left in\n+         * the send buffer when this happens, because they may not have been fully sent out yet. */\n+        KEY_GARB,\n+\n+        /** Public key + garbage + garbage terminator + garbage authenticator + version packet.\n+         *\n+         * This is the state the sender is in after the other side's public key has been received.\n+         * Whatever remains of the public key and garbage are sent, plus garbage terminator,\n+         * authentication packet, and version packet. When all of that is sent, the sender state\n+         * becomes APP_READY. */\n+        KEY_GARB_GARBTERM_GARBAUTH_VERSION,\n+\n+        /** Nothing (an application message to send can be provided).\n+         *\n+         * We're ready to start sending an application message at this point, but none are\n+         * currently provided. Upon SetMessageToSend() the sender state becomes APP. */\n+        APP_READY,\n+\n+        /** Application packet.\n+         *\n+         * There is an encrypted packet encoding an application message in the send buffer right now.\n+         * When it is fully sent, the sender state becomes APP_READY. */\n+        APP,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All send operations are redirected to m_v1_fallback. */\n+        V1,\n+    };\n+\n+    /** Cipher state. */\n+    BIP324Cipher m_cipher;\n+    /** Whether we are the initiator side. */\n+    const bool m_initiating;\n+    /** NodeId (for debug logging). */\n+    const NodeId m_nodeid;\n+    /** Encapsulate a V1Transport to fall back to. */\n+    V1Transport m_v1_fallback;\n+    /** V1 prefix to look for (4-byte network magic + \"version\\x00\"; magic will be filled in). */\n+    std::array<uint8_t, 12> m_v1_prefix = {0, 0, 0, 0, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313344260",
      "id" : 1313344260,
      "in_reply_to_id" : 1313012119,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OSAsE",
      "original_commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "original_line" : 572,
      "original_position" : 235,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1607368990,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313344260/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-01T19:53:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313344260",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313367688"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313367688"
         }
      },
      "author_association" : "MEMBER",
      "body" : "fb3ec8fd9e96f6c2d16db02fd2d683ea097a90ff: Maybe repeat here, in the public interface, that `initiating` means `Whether we are the initiator side.`.\r\n\r\nI'm a bit confused about the other two arguments. These refer to our internal `DataStream` types and versions? Not something related to the v2 protocol?",
      "commit_id" : "75b91740fdeb9ad14cc6cb073e75867b49875a00",
      "created_at" : "2023-09-01T18:10:36Z",
      "diff_hunk" : "@@ -417,6 +419,187 @@ class V1Transport final : public Transport\n     size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n };\n \n+class V2Transport final : public Transport\n+{\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    // The sender side and receiver side of V2Transport are largely independent state machines that\n+    // are transitioned through, where each state corresponds to the meaning of the data in (or to\n+    // be received to) the respective (send/receive) buffer. The sender side is primarily\n+    // controlled by send-side functions (SetMessageToSend, MarkBytesSent), while the received side\n+    // is primarily controlled by receiver-side functions (ReceivedBytes, GetReceivedMessage),\n+    // though in some cases the sender state can also change as a result of receiving bytes.\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted.\n+     *\n+     * Diagram:\n+     *\n+     *   start                                            /---------\\\n+     *     |                                              |         |\n+     *     v                                              v         |\n+     *    KEY -> GARB_GARBTERM -> GARBAUTH -> VERSION -> APP -> APP_READY\n+     */\n+    enum class RecvState : uint8_t {\n+        /** Public key.\n+         *\n+         * This is the initial state, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes APP,\n+         * and the decrypted contents is interpreted as version negotiation (currently, that means\n+         * ignoring it, but it can be used for negotiating future extensions). If it fails, the\n+         * connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+    };\n+\n+    /** State type that defines the contents of the send buffer.\n+     *\n+     * Diagram:\n+     *\n+     *   start                                       /----------\\\n+     *     |                                         |          |\n+     *     v                                         v          |\n+     *    KEY -> KEY_GARBTERM_GARBAUTH_VERSION -> APP_READY -> APP\n+     */\n+    enum class SendState : uint8_t {\n+        /** Public key.\n+         *\n+         * This is the initial state. The public key is sent out. When the receiver\n+         * receives the other side's public key and transitions to GARB_GARBTERM, the sender state\n+         * becomes KEY_GARBTERM_GARBAUTH_VERSION. The key is left in the send buffer when this\n+         * happens, because it may not have been fully sent out yet. */\n+        KEY,\n+\n+        /** Public key + garbage terminator + garbage authenticator + version packet.\n+         *\n+         * This is the state the sender is in after the other side's public key has been received.\n+         * Whatever remains of the public key is sent, plus garbage terminator, authentication\n+         * packet, and version packet. When all of that is sent, the sender state becomes\n+         * APP_READY. */\n+        KEY_GARBTERM_GARBAUTH_VERSION,\n+\n+        /** Nothing (an application message to send can be provided).\n+         *\n+         * We're ready to start sending an application message at this point, but none are\n+         * currently provided. Upon SetMessageToSend() the sender state becomes APP. */\n+        APP_READY,\n+\n+        /** Application packet.\n+         *\n+         * There is an encrypted packet encoding an application message in the send buffer right now.\n+         * When it is fully sent, the sender state becomes APP_READY. */\n+        APP,\n+    };\n+\n+    /** Cipher state. */\n+    BIP324Cipher m_cipher;\n+    /** Whether we are the initiator side. */\n+    const bool m_initiating;\n+    /** NodeId (for debug logging). */\n+    const NodeId m_nodeid;\n+\n+    /** Lock for receiver-side fields. */\n+    mutable Mutex m_recv_mutex ACQUIRED_BEFORE(m_send_mutex);\n+    /** In {GARBAUTH, VERSION, APP}, the decrypted packet length, if m_recv_buffer.size() >=\n+     *  BIP324Cipher::LENGTH_LEN. Unspecified otherwise. */\n+    uint32_t m_recv_len GUARDED_BY(m_recv_mutex) {0};\n+    /** Receive buffer; meaning is determined by m_recv_state. */\n+    std::vector<uint8_t> m_recv_buffer GUARDED_BY(m_recv_mutex);\n+    /** During GARBAUTH, the garbage received during GARB_GARBTERM. */\n+    std::vector<uint8_t> m_recv_garbage GUARDED_BY(m_recv_mutex);\n+    /** Buffer to put decrypted contents in, for converting to CNetMessage. */\n+    std::vector<uint8_t> m_recv_decode_buffer GUARDED_BY(m_recv_mutex);\n+    /** Deserialization type. */\n+    const int m_recv_type;\n+    /** Deserialization version number. */\n+    const int m_recv_version;\n+    /** Current receiver state. */\n+    RecvState m_recv_state GUARDED_BY(m_recv_mutex);\n+\n+    /** Lock for sending-side fields. If both sending and receiving fields are accessed,\n+     *  m_recv_mutex must be acquired before m_send_mutex. */\n+    mutable Mutex m_send_mutex ACQUIRED_AFTER(m_recv_mutex);\n+    /** The send buffer; meaning is determined by m_send_state. */\n+    std::vector<uint8_t> m_send_buffer GUARDED_BY(m_send_mutex);\n+    /** How many bytes from the send buffer have been sent so far. */\n+    uint32_t m_send_pos GUARDED_BY(m_send_mutex) {0};\n+    /** Type of the message being sent. */\n+    std::string m_send_type GUARDED_BY(m_send_mutex);\n+    /** Current sender state. */\n+    SendState m_send_state GUARDED_BY(m_send_mutex);\n+\n+    /** Change the receive state. */\n+    void SetReceiveState(RecvState recv_state) noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex);\n+    /** Change the send state. */\n+    void SetSendState(SendState send_state) noexcept EXCLUSIVE_LOCKS_REQUIRED(m_send_mutex);\n+    /** Given a packet's contents, find the message type (if valid), and strip it from contents. */\n+    static std::optional<std::string> GetMessageType(Span<const uint8_t>& contents) noexcept;\n+    /** Determine how many received bytes can be processed in one go (not allowed in V1 state). */\n+    size_t GetMaxBytesToProcess() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex);\n+    /** Process m_recv_buffer in KEY state. */\n+    void ProcessReceivedKey() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex, !m_send_mutex);\n+    /** Process m_recv_buffer in GARB_GARBTERM state. */\n+    bool ProcessReceivedGarbage() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex);\n+    /** Process m_recv_buffer in GARBAUTH/VERSION/APP state. */\n+    bool ProcessReceivedPacket() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex);\n+\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+    /** Construct a V2 transport with securely generated random keys. */\n+    V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313367688",
      "id" : 1313367688,
      "line" : 631,
      "node_id" : "PRRC_kwDOABII585OSGaI",
      "original_commit_id" : "fb3ec8fd9e96f6c2d16db02fd2d683ea097a90ff",
      "original_line" : 631,
      "original_position" : 187,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 294,
      "pull_request_review_id" : 1602833673,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313367688/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-01T19:06:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313367688",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313369431"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313369431"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "75b91740fdeb9ad14cc6cb073e75867b49875a00",
      "created_at" : "2023-09-01T18:12:54Z",
      "diff_hunk" : "@@ -320,6 +335,43 @@ std::unique_ptr<Transport> MakeV1Transport(NodeId nodeid) noexcept\n     return std::make_unique<V1Transport>(nodeid, SER_NETWORK, INIT_PROTO_VERSION);\n }\n \n+template<typename RNG>\n+std::unique_ptr<Transport> MakeV2Transport(NodeId nodeid, bool initiator, RNG& rng, FuzzedDataProvider& provider)\n+{\n+    // Retrieve key\n+    auto key_data = provider.ConsumeBytes<unsigned char>(32);\n+    key_data.resize(32);\n+    CKey key;\n+    key.Set(key_data.begin(), key_data.end(), true);\n+    if (!key.IsValid()) return {};\n+    // Construct garbage\n+    size_t garb_len = provider.ConsumeIntegralInRange<size_t>(0, 4095);\n+    std::vector<uint8_t> garb;\n+    if (garb_len <= 64) {\n+        // When the garbage length is up to 64 bytes, read it directly from the fuzzer input.\n+        garb = provider.ConsumeBytes<uint8_t>(garb_len);\n+        garb.resize(garb_len);\n+    } else {\n+        // If it's longer, generate it from the RNG. This avoids having large amounts of\n+        // (hopefully) irrelevant data needing to be stored in the fuzzer data.\n+        for (auto& v : garb) v = uint8_t(rng());\n+    }\n+    // Retrieve entropy\n+    auto ent = provider.ConsumeBytes<std::byte>(32);\n+    ent.resize(32);\n+    // Use as entropy SHA256(ent || garbage). This prevents a situation where the fuzzer manages to\n+    // include the garbage terminator (which is a function of both ellswift keys) in the garbage.\n+    // This is entremely unlikely (~2^-116) with random keys/garbage, but the fuzzer can choose",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313369431",
      "id" : 1313369431,
      "in_reply_to_id" : 1313198040,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OSG1X",
      "original_commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "original_line" : 364,
      "original_position" : 123,
      "original_start_line" : null,
      "path" : "src/test/fuzz/p2p_transport_serialization.cpp",
      "position" : null,
      "pull_request_review_id" : 1607368990,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313369431/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-01T19:53:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313369431",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313369484"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313369484"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "75b91740fdeb9ad14cc6cb073e75867b49875a00",
      "created_at" : "2023-09-01T18:12:59Z",
      "diff_hunk" : "@@ -320,6 +335,43 @@ std::unique_ptr<Transport> MakeV1Transport(NodeId nodeid) noexcept\n     return std::make_unique<V1Transport>(nodeid, SER_NETWORK, INIT_PROTO_VERSION);\n }\n \n+template<typename RNG>\n+std::unique_ptr<Transport> MakeV2Transport(NodeId nodeid, bool initiator, RNG& rng, FuzzedDataProvider& provider)\n+{\n+    // Retrieve key\n+    auto key_data = provider.ConsumeBytes<unsigned char>(32);\n+    key_data.resize(32);\n+    CKey key;\n+    key.Set(key_data.begin(), key_data.end(), true);\n+    if (!key.IsValid()) return {};\n+    // Construct garbage\n+    size_t garb_len = provider.ConsumeIntegralInRange<size_t>(0, 4095);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313369484",
      "id" : 1313369484,
      "in_reply_to_id" : 1313194800,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OSG2M",
      "original_commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "original_line" : 348,
      "original_position" : 107,
      "original_start_line" : null,
      "path" : "src/test/fuzz/p2p_transport_serialization.cpp",
      "position" : null,
      "pull_request_review_id" : 1607368990,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313369484/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-01T19:53:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313369484",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313370086"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313370086"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "75b91740fdeb9ad14cc6cb073e75867b49875a00",
      "created_at" : "2023-09-01T18:13:46Z",
      "diff_hunk" : "@@ -910,24 +912,632 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // Initial state, cannot be transitioned into.\n+        assert(false);\n+        break;\n+    case RecvState::KEY:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        assert(m_recv_state == RecvState::KEY);\n+        break;\n+    case RecvState::GARBAUTH:\n+        assert(m_recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::VERSION:\n+        assert(m_recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::APP:\n+        assert(m_recv_state == RecvState::VERSION || m_recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        assert(m_recv_state == RecvState::APP);\n+        break;\n+    case RecvState::V1:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (send_state) {\n+    case SendState::KEY_GARB_MAYBE_V1:\n+        // Initial state, cannot be transitioned into.\n+        assert(false);\n+        break;\n+    case SendState::KEY_GARB:\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1);\n+        break;\n+    case SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION:\n+        assert(m_send_state == SendState::KEY_GARB);\n+        break;\n+    case SendState::APP_READY:\n+        assert(m_send_state == SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION ||\n+               m_send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        assert(m_send_state == SendState::APP_READY);\n+        break;\n+    case SendState::V1:\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // During the KEY_MAYBE_V1 state we do not allow more than the length of v1 prefix into the\n+        // receive buffer.\n+        Assume(m_recv_buffer.size() <= m_v1_prefix.size());\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY_MAYBE_V1);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        SetReceiveState(RecvState::KEY); // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        SetSendState(SendState::KEY_GARB);\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313370086",
      "id" : 1313370086,
      "in_reply_to_id" : 1313037669,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OSG_m",
      "original_commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "original_line" : 1152,
      "original_position" : 269,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1607368990,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313370086/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-01T19:53:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313370086",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313380691"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313380691"
         }
      },
      "author_association" : "MEMBER",
      "body" : "fb3ec8fd9e96f6c2d16db02fd2d683ea097a90ff: `stipulates that senders should leave this empty, and receivers should ignore it`.",
      "commit_id" : "75b91740fdeb9ad14cc6cb073e75867b49875a00",
      "created_at" : "2023-09-01T18:27:57Z",
      "diff_hunk" : "@@ -417,6 +419,187 @@ class V1Transport final : public Transport\n     size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n };\n \n+class V2Transport final : public Transport\n+{\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313380691",
      "id" : 1313380691,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OSJlT",
      "original_commit_id" : "fb3ec8fd9e96f6c2d16db02fd2d683ea097a90ff",
      "original_line" : 425,
      "original_position" : 25,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1602833673,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313380691/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-01T19:06:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313380691",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313385211"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313385211"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed (in the code; I've left them in the comments as I think making the actual values known is also useful for the reader).",
      "commit_id" : "75b91740fdeb9ad14cc6cb073e75867b49875a00",
      "created_at" : "2023-09-01T18:34:25Z",
      "diff_hunk" : "@@ -1008,4 +1009,496 @@ BOOST_AUTO_TEST_CASE(advertise_local_address)\n     RemoveLocal(addr_cjdns);\n }\n \n+namespace {\n+\n+/** A class for scenario-based tests of V2Transport\n+ *\n+ * Each V2TransportTester encapsulates a V2Transport (the one being tested), and can be told to\n+ * interact with it. To do so, it also encapsulates a BIP324Cipher to act as the other side. A\n+ * second V2Transport is not used, as doing so would prevent scenarios that are permitted by BIP324\n+ * but not implemented (such as the sending of decoy packets).\n+ */\n+class V2TransportTester\n+{\n+    V2Transport m_transport; //!< V2Transport being tested\n+    BIP324Cipher m_cipher; //!< Cipher to help with the other side\n+    bool m_test_initiator; //!< Whether m_transport is the initiator (true) or responder (false)\n+\n+    std::vector<uint8_t> m_sent_garbage; //!< The garbage we've sent to m_transport.\n+    std::vector<uint8_t> m_to_send; //!< Bytes we have queued up to send to m_transport.\n+    std::vector<uint8_t> m_received; //!< Bytes we have received from m_transport.\n+    std::deque<CSerializedNetMsg> m_msg_to_send; //!< Messages to be sent *by* m_transport to us.\n+\n+public:\n+    /** Construct a tester object. test_initiator: whether the tested transport is initiator. */\n+    V2TransportTester(bool test_initiator) :\n+        m_transport(0, test_initiator, SER_NETWORK, INIT_PROTO_VERSION),\n+        m_test_initiator(test_initiator) {}\n+\n+    /** Data type returned by Interact:\n+     *\n+     * - std::nullopt: transport error occurred\n+     * - otherwise: a vector of\n+     *   - std::nullopt: invalid message received\n+     *   - otherwise: a CNetMessage retrieved\n+     */\n+    using InteractResult = std::optional<std::vector<std::optional<CNetMessage>>>;\n+\n+    /** Send/receive scheduled/available bytes and messages.\n+     *\n+     * This is the only function that interacts with the transport being tested; everything else is\n+     * scheduling things done by Interact(), or processing things learned by it.\n+     */\n+    InteractResult Interact()\n+    {\n+        std::vector<std::optional<CNetMessage>> ret;\n+        while (true) {\n+            bool progress{false};\n+            // Send bytes from m_to_send to the transport.\n+            if (!m_to_send.empty()) {\n+                Span<const uint8_t> to_send = Span{m_to_send}.first(1 + InsecureRandRange(m_to_send.size()));\n+                size_t old_len = to_send.size();\n+                if (!m_transport.ReceivedBytes(to_send)) {\n+                    return std::nullopt; // transport error occurred\n+                }\n+                if (old_len != to_send.size()) {\n+                    progress = true;\n+                    m_to_send.erase(m_to_send.begin(), m_to_send.begin() + (old_len - to_send.size()));\n+                }\n+            }\n+            // Retrieve messages received by the transport.\n+            if (m_transport.ReceivedMessageComplete() && (!progress || InsecureRandBool())) {\n+                bool reject{false};\n+                auto msg = m_transport.GetReceivedMessage({}, reject);\n+                if (reject) {\n+                    ret.push_back(std::nullopt);\n+                } else {\n+                    ret.push_back(std::move(msg));\n+                }\n+                progress = true;\n+            }\n+            // Enqueue a message to be sent by the transport to us.\n+            if (!m_msg_to_send.empty() && (!progress || InsecureRandBool())) {\n+                if (m_transport.SetMessageToSend(m_msg_to_send.front())) {\n+                    m_msg_to_send.pop_front();\n+                    progress = true;\n+                }\n+            }\n+            // Receive bytes from the transport.\n+            const auto& [recv_bytes, _more, _msg_type] = m_transport.GetBytesToSend(!m_msg_to_send.empty());\n+            if (!recv_bytes.empty() && (!progress || InsecureRandBool())) {\n+                size_t to_receive = 1 + InsecureRandRange(recv_bytes.size());\n+                m_received.insert(m_received.end(), recv_bytes.begin(), recv_bytes.begin() + to_receive);\n+                progress = true;\n+                m_transport.MarkBytesSent(to_receive);\n+            }\n+            if (!progress) break;\n+        }\n+        return ret;\n+    }\n+\n+    /** Expose the cipher. */\n+    BIP324Cipher& GetCipher() { return m_cipher; }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const uint8_t> data)\n+    {\n+        m_to_send.insert(m_to_send.end(), data.begin(), data.end());\n+    }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const std::byte> data) { Send(MakeUCharSpan(data)); }\n+\n+    /** Schedule our ellswift key to be sent to the transport. */\n+    void SendKey() { Send(m_cipher.GetOurPubKey()); }\n+\n+    /** Schedule specified garbage to be sent to the transport. */\n+    void SendGarbage(Span<const uint8_t> garbage)\n+    {\n+        // Remember the specified garbage (so we can use it for constructing the garbage\n+        // authentication packet).\n+        m_sent_garbage.assign(garbage.begin(), garbage.end());\n+        // Schedule it for sending.\n+        Send(m_sent_garbage);\n+    }\n+\n+    /** Schedule garbage (of specified length) to be sent to the transport. */\n+    void SendGarbage(size_t garbage_len)\n+    {\n+        // Generate random garbage and send it.\n+        SendGarbage(g_insecure_rand_ctx.randbytes<uint8_t>(garbage_len));\n+    }\n+\n+    /** Schedule garbage (with valid random length) to be sent to the transport. */\n+    void SendGarbage()\n+    {\n+         SendGarbage(InsecureRandRange(V2Transport::MAX_GARBAGE_LEN + 1));\n+    }\n+\n+    /** Schedule a message to be sent to us by the transport. */\n+    void AddMessage(std::string m_type, std::vector<uint8_t> payload)\n+    {\n+        CSerializedNetMsg msg;\n+        msg.m_type = std::move(m_type);\n+        msg.data = std::move(payload);\n+        m_msg_to_send.push_back(std::move(msg));\n+    }\n+\n+    /** Expect ellswift key to have been received from transport and process it.\n+     *\n+     * Many other V2TransportTester functions cannot be called until after ReceiveKey() has been\n+     * called, as no encryption keys are set up before that point.\n+     */\n+    void ReceiveKey()\n+    {\n+        // When processing a key, enough bytes need to have been received already.\n+        BOOST_CHECK(m_received.size() >= EllSwiftPubKey::size());\n+        // Initialize the cipher using it (acting as the opposite side of the tested transport).\n+        m_cipher.Initialize(MakeByteSpan(m_received).first(EllSwiftPubKey::size()), !m_test_initiator);\n+        // Strip the processed bytes off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + EllSwiftPubKey::size());\n+    }\n+\n+    /** Schedule an encrypted packet with specified content/aad/ignore to be sent to transport\n+     *  (only after ReceiveKey). */\n+    void SendPacket(Span<const uint8_t> content, Span<const uint8_t> aad = {}, bool ignore = false)\n+    {\n+        // Use cipher to construct ciphertext.\n+        std::vector<std::byte> ciphertext;\n+        ciphertext.resize(content.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(MakeByteSpan(content), MakeByteSpan(aad), ignore, ciphertext);\n+        // Schedule it for sending.\n+        Send(ciphertext);\n+    }\n+\n+    /** Schedule garbage terminator and authentication packet to be sent to the transport (only\n+     *  after ReceiveKey). */\n+    void SendGarbageTermAuth(size_t garb_auth_data_len = 0, bool garb_auth_ignore = false)\n+    {\n+        // Generate random data to include in the garbage authentication packet (ignored by peer).\n+        auto garb_auth_data = g_insecure_rand_ctx.randbytes<uint8_t>(garb_auth_data_len);\n+        // Schedule the garbage terminator to be sent.\n+        Send(m_cipher.GetSendGarbageTerminator());\n+        // Schedule the garbage authentication packet to be sent.\n+        SendPacket(/*content=*/garb_auth_data, /*aad=*/m_sent_garbage, /*ignore=*/garb_auth_ignore);\n+    }\n+\n+    /** Schedule version packet to be sent to the transport (only after ReceiveKey). */\n+    void SendVersion(Span<const uint8_t> version_data = {}, bool vers_ignore = false)\n+    {\n+        SendPacket(/*content=*/version_data, /*aad=*/{}, /*ignore=*/vers_ignore);\n+    }\n+\n+    /** Expect a packet to have been received from transport, process it, and return its contents\n+     *  (only after ReceiveKey). By default, decoys are skipped. */\n+    std::vector<uint8_t> ReceivePacket(Span<const std::byte> aad = {}, bool skip_decoy = true)\n+    {\n+        std::vector<uint8_t> contents;\n+        // Loop as long as there are ignored packets that are to be skipped.\n+        while (true) {\n+            // When processing a packet, at least enough bytes for its length descriptor must be received.\n+            BOOST_CHECK(m_received.size() >= BIP324Cipher::LENGTH_LEN);\n+            // Decrypt the content length.\n+            size_t size = m_cipher.DecryptLength(MakeByteSpan(Span{m_received}.first(BIP324Cipher::LENGTH_LEN)));\n+            // Check that the full packet is in the receive buffer.\n+            BOOST_CHECK(m_received.size() >= size + BIP324Cipher::EXPANSION);\n+            // Decrypt the packet contents.\n+            contents.resize(size);\n+            bool ignore{false};\n+            bool ret = m_cipher.Decrypt(\n+                MakeByteSpan(Span{m_received}.first(size + BIP324Cipher::EXPANSION).subspan(BIP324Cipher::LENGTH_LEN)),\n+                aad, ignore, MakeWritableByteSpan(contents));\n+            BOOST_CHECK(ret);\n+            // Strip the processed packet's bytes off the front of the receive buffer.\n+            m_received.erase(m_received.begin(), m_received.begin() + size + BIP324Cipher::EXPANSION);\n+            // Stop if the ignore bit is not set on this packet, or if we choose to not honor it.\n+            if (!ignore || !skip_decoy) break;\n+        }\n+        return contents;\n+    }\n+\n+    /** Expect garbage, garbage terminator, and garbage auth packet to have been received, and\n+     *  process them (only after ReceiveKey). */\n+    void ReceiveGarbage()\n+    {\n+        // Figure out the garbage length.\n+        size_t garblen;\n+        for (garblen = 0; garblen <= V2Transport::MAX_GARBAGE_LEN; ++garblen) {\n+            assert(m_received.size() >= garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            auto term_span = MakeByteSpan(Span{m_received}.subspan(garblen, BIP324Cipher::GARBAGE_TERMINATOR_LEN));\n+            if (term_span == m_cipher.GetReceiveGarbageTerminator()) break;\n+        }\n+        // Copy the garbage to a buffer.\n+        std::vector<uint8_t> garbage(m_received.begin(), m_received.begin() + garblen);\n+        // Strip garbage + garbage terminator off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        // Process the expected garbage authentication packet. Such a packet still functions as one\n+        // even when its ignore bit is set to true, so we do not skip decoy packets here.\n+        ReceivePacket(/*aad=*/MakeByteSpan(garbage), /*skip_decoy=*/false);\n+    }\n+\n+    /** Expect version packet to have been received, and process it (only after ReceiveKey). */\n+    void ReceiveVersion()\n+    {\n+        auto contents = ReceivePacket();\n+        // Version packets from real BIP324 peers are expected to be empty, despite the fact that\n+        // this class supports *sending* non-empty version packets (to test that BIP324 peers\n+        // correctly ignore version packet contents).\n+        BOOST_CHECK(contents.empty());\n+    }\n+\n+    /** Expect application packet to have been received, with specified short id and payload.\n+     *  (only after ReceiveKey). */\n+    void ReceiveMessage(uint8_t short_id, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_CHECK(ret.size() == payload.size() + 1);\n+        BOOST_CHECK(ret[0] == short_id);\n+        BOOST_CHECK(Span{ret}.subspan(1) == payload);\n+    }\n+\n+    /** Expect application packet to have been received, with specified 12-char message type and\n+     *  payload (only after ReceiveKey). */\n+    void ReceiveMessage(const std::string& m_type, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_CHECK(ret.size() == payload.size() + 13);\n+        BOOST_CHECK(ret[0] == 0);\n+        for (unsigned i = 0; i < 12; ++i) {\n+            if (i < m_type.size()) {\n+                BOOST_CHECK(ret[1 + i] == m_type[i]);\n+            } else {\n+                BOOST_CHECK(ret[1 + i] == 0);\n+            }\n+        }\n+        BOOST_CHECK(Span{ret}.subspan(13) == payload);\n+    }\n+\n+    /** Schedule an encrypted packet with specified message type and payload to be sent to\n+     *  transport (only after ReceiveKey). */\n+    void SendMessage(std::string mtype, Span<const uint8_t> payload)\n+    {\n+        // Construct contents consisting of 0x00 + 12-byte message type + payload.\n+        std::vector<uint8_t> contents(13 + payload.size());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313385211",
      "id" : 1313385211,
      "in_reply_to_id" : 1313242620,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OSKr7",
      "original_commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "original_line" : 1282,
      "original_position" : 282,
      "original_start_line" : 1265,
      "path" : "src/test/net_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1607368990,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313385211/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-09-01T19:53:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313385211",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313408730"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313408730"
         }
      },
      "author_association" : "MEMBER",
      "body" : "fb3ec8fd9e96f6c2d16db02fd2d683ea097a90ff: why not remain in the `KEY` state until we've completely sent out the public key? And only then transition to `GARBTERM_GARBAUTH_VERSION`?",
      "commit_id" : "75b91740fdeb9ad14cc6cb073e75867b49875a00",
      "created_at" : "2023-09-01T19:02:32Z",
      "diff_hunk" : "@@ -417,6 +419,187 @@ class V1Transport final : public Transport\n     size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n };\n \n+class V2Transport final : public Transport\n+{\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    // The sender side and receiver side of V2Transport are largely independent state machines that\n+    // are transitioned through, where each state corresponds to the meaning of the data in (or to\n+    // be received to) the respective (send/receive) buffer. The sender side is primarily\n+    // controlled by send-side functions (SetMessageToSend, MarkBytesSent), while the received side\n+    // is primarily controlled by receiver-side functions (ReceivedBytes, GetReceivedMessage),\n+    // though in some cases the sender state can also change as a result of receiving bytes.\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted.\n+     *\n+     * Diagram:\n+     *\n+     *   start                                            /---------\\\n+     *     |                                              |         |\n+     *     v                                              v         |\n+     *    KEY -> GARB_GARBTERM -> GARBAUTH -> VERSION -> APP -> APP_READY\n+     */\n+    enum class RecvState : uint8_t {\n+        /** Public key.\n+         *\n+         * This is the initial state, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes APP,\n+         * and the decrypted contents is interpreted as version negotiation (currently, that means\n+         * ignoring it, but it can be used for negotiating future extensions). If it fails, the\n+         * connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+    };\n+\n+    /** State type that defines the contents of the send buffer.\n+     *\n+     * Diagram:\n+     *\n+     *   start                                       /----------\\\n+     *     |                                         |          |\n+     *     v                                         v          |\n+     *    KEY -> KEY_GARBTERM_GARBAUTH_VERSION -> APP_READY -> APP\n+     */\n+    enum class SendState : uint8_t {\n+        /** Public key.\n+         *\n+         * This is the initial state. The public key is sent out. When the receiver\n+         * receives the other side's public key and transitions to GARB_GARBTERM, the sender state\n+         * becomes KEY_GARBTERM_GARBAUTH_VERSION. The key is left in the send buffer when this\n+         * happens, because it may not have been fully sent out yet. */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313408730",
      "id" : 1313408730,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OSQba",
      "original_commit_id" : "fb3ec8fd9e96f6c2d16db02fd2d683ea097a90ff",
      "original_line" : 507,
      "original_position" : 107,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1602833673,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313408730/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-01T19:06:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313408730",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313431150"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313431150"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed (you're not the first one to notice).",
      "commit_id" : "75b91740fdeb9ad14cc6cb073e75867b49875a00",
      "created_at" : "2023-09-01T19:30:27Z",
      "diff_hunk" : "@@ -973,11 +987,44 @@ size_t V2Transport::GetMaxBytesToProcess() noexcept\n     case RecvState::APP_READY:\n         // No bytes can be processed until GetMessage() is called.\n         return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n     }\n     assert(false); // unreachable\n     return 0;\n }\n \n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_MAYBE_V1 || m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313431150",
      "id" : 1313431150,
      "in_reply_to_id" : 1310367236,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OSV5u",
      "original_commit_id" : "faf5af3f6b96488ebf9585c1558710545cde05a6",
      "original_line" : 1152,
      "original_position" : 93,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1607368990,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313431150/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-01T19:53:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313431150",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313432012"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313432012"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've added doxygen comments about the parameters.\r\n\r\nThe type/version thing will hopefully go away everywhere soon (see #25284).",
      "commit_id" : "75b91740fdeb9ad14cc6cb073e75867b49875a00",
      "created_at" : "2023-09-01T19:31:15Z",
      "diff_hunk" : "@@ -417,6 +419,187 @@ class V1Transport final : public Transport\n     size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n };\n \n+class V2Transport final : public Transport\n+{\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    // The sender side and receiver side of V2Transport are largely independent state machines that\n+    // are transitioned through, where each state corresponds to the meaning of the data in (or to\n+    // be received to) the respective (send/receive) buffer. The sender side is primarily\n+    // controlled by send-side functions (SetMessageToSend, MarkBytesSent), while the received side\n+    // is primarily controlled by receiver-side functions (ReceivedBytes, GetReceivedMessage),\n+    // though in some cases the sender state can also change as a result of receiving bytes.\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted.\n+     *\n+     * Diagram:\n+     *\n+     *   start                                            /---------\\\n+     *     |                                              |         |\n+     *     v                                              v         |\n+     *    KEY -> GARB_GARBTERM -> GARBAUTH -> VERSION -> APP -> APP_READY\n+     */\n+    enum class RecvState : uint8_t {\n+        /** Public key.\n+         *\n+         * This is the initial state, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes APP,\n+         * and the decrypted contents is interpreted as version negotiation (currently, that means\n+         * ignoring it, but it can be used for negotiating future extensions). If it fails, the\n+         * connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+    };\n+\n+    /** State type that defines the contents of the send buffer.\n+     *\n+     * Diagram:\n+     *\n+     *   start                                       /----------\\\n+     *     |                                         |          |\n+     *     v                                         v          |\n+     *    KEY -> KEY_GARBTERM_GARBAUTH_VERSION -> APP_READY -> APP\n+     */\n+    enum class SendState : uint8_t {\n+        /** Public key.\n+         *\n+         * This is the initial state. The public key is sent out. When the receiver\n+         * receives the other side's public key and transitions to GARB_GARBTERM, the sender state\n+         * becomes KEY_GARBTERM_GARBAUTH_VERSION. The key is left in the send buffer when this\n+         * happens, because it may not have been fully sent out yet. */\n+        KEY,\n+\n+        /** Public key + garbage terminator + garbage authenticator + version packet.\n+         *\n+         * This is the state the sender is in after the other side's public key has been received.\n+         * Whatever remains of the public key is sent, plus garbage terminator, authentication\n+         * packet, and version packet. When all of that is sent, the sender state becomes\n+         * APP_READY. */\n+        KEY_GARBTERM_GARBAUTH_VERSION,\n+\n+        /** Nothing (an application message to send can be provided).\n+         *\n+         * We're ready to start sending an application message at this point, but none are\n+         * currently provided. Upon SetMessageToSend() the sender state becomes APP. */\n+        APP_READY,\n+\n+        /** Application packet.\n+         *\n+         * There is an encrypted packet encoding an application message in the send buffer right now.\n+         * When it is fully sent, the sender state becomes APP_READY. */\n+        APP,\n+    };\n+\n+    /** Cipher state. */\n+    BIP324Cipher m_cipher;\n+    /** Whether we are the initiator side. */\n+    const bool m_initiating;\n+    /** NodeId (for debug logging). */\n+    const NodeId m_nodeid;\n+\n+    /** Lock for receiver-side fields. */\n+    mutable Mutex m_recv_mutex ACQUIRED_BEFORE(m_send_mutex);\n+    /** In {GARBAUTH, VERSION, APP}, the decrypted packet length, if m_recv_buffer.size() >=\n+     *  BIP324Cipher::LENGTH_LEN. Unspecified otherwise. */\n+    uint32_t m_recv_len GUARDED_BY(m_recv_mutex) {0};\n+    /** Receive buffer; meaning is determined by m_recv_state. */\n+    std::vector<uint8_t> m_recv_buffer GUARDED_BY(m_recv_mutex);\n+    /** During GARBAUTH, the garbage received during GARB_GARBTERM. */\n+    std::vector<uint8_t> m_recv_garbage GUARDED_BY(m_recv_mutex);\n+    /** Buffer to put decrypted contents in, for converting to CNetMessage. */\n+    std::vector<uint8_t> m_recv_decode_buffer GUARDED_BY(m_recv_mutex);\n+    /** Deserialization type. */\n+    const int m_recv_type;\n+    /** Deserialization version number. */\n+    const int m_recv_version;\n+    /** Current receiver state. */\n+    RecvState m_recv_state GUARDED_BY(m_recv_mutex);\n+\n+    /** Lock for sending-side fields. If both sending and receiving fields are accessed,\n+     *  m_recv_mutex must be acquired before m_send_mutex. */\n+    mutable Mutex m_send_mutex ACQUIRED_AFTER(m_recv_mutex);\n+    /** The send buffer; meaning is determined by m_send_state. */\n+    std::vector<uint8_t> m_send_buffer GUARDED_BY(m_send_mutex);\n+    /** How many bytes from the send buffer have been sent so far. */\n+    uint32_t m_send_pos GUARDED_BY(m_send_mutex) {0};\n+    /** Type of the message being sent. */\n+    std::string m_send_type GUARDED_BY(m_send_mutex);\n+    /** Current sender state. */\n+    SendState m_send_state GUARDED_BY(m_send_mutex);\n+\n+    /** Change the receive state. */\n+    void SetReceiveState(RecvState recv_state) noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex);\n+    /** Change the send state. */\n+    void SetSendState(SendState send_state) noexcept EXCLUSIVE_LOCKS_REQUIRED(m_send_mutex);\n+    /** Given a packet's contents, find the message type (if valid), and strip it from contents. */\n+    static std::optional<std::string> GetMessageType(Span<const uint8_t>& contents) noexcept;\n+    /** Determine how many received bytes can be processed in one go (not allowed in V1 state). */\n+    size_t GetMaxBytesToProcess() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex);\n+    /** Process m_recv_buffer in KEY state. */\n+    void ProcessReceivedKey() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex, !m_send_mutex);\n+    /** Process m_recv_buffer in GARB_GARBTERM state. */\n+    bool ProcessReceivedGarbage() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex);\n+    /** Process m_recv_buffer in GARBAUTH/VERSION/APP state. */\n+    bool ProcessReceivedPacket() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex);\n+\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+    /** Construct a V2 transport with securely generated random keys. */\n+    V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313432012",
      "id" : 1313432012,
      "in_reply_to_id" : 1313367688,
      "line" : 631,
      "node_id" : "PRRC_kwDOABII585OSWHM",
      "original_commit_id" : "fb3ec8fd9e96f6c2d16db02fd2d683ea097a90ff",
      "original_line" : 631,
      "original_position" : 187,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 294,
      "pull_request_review_id" : 1607368990,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313432012/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-01T19:53:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313432012",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313437343"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313437343"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done; that's more concise.",
      "commit_id" : "75b91740fdeb9ad14cc6cb073e75867b49875a00",
      "created_at" : "2023-09-01T19:36:39Z",
      "diff_hunk" : "@@ -417,6 +419,187 @@ class V1Transport final : public Transport\n     size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n };\n \n+class V2Transport final : public Transport\n+{\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313437343",
      "id" : 1313437343,
      "in_reply_to_id" : 1313380691,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OSXaf",
      "original_commit_id" : "fb3ec8fd9e96f6c2d16db02fd2d683ea097a90ff",
      "original_line" : 425,
      "original_position" : 25,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1607368990,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313437343/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-01T19:53:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313437343",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313439087"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313439087"
         }
      },
      "author_association" : "MEMBER",
      "body" : "There's nothing wrong with that approach, but it's a bit more complex I think. Because it'd mean the transition can happen under two possible events (the last bytes of the peer's key are received while our key is sent already, and the last bytes of our key get sent while all bytes of the peer's key are received already).",
      "commit_id" : "75b91740fdeb9ad14cc6cb073e75867b49875a00",
      "created_at" : "2023-09-01T19:38:26Z",
      "diff_hunk" : "@@ -417,6 +419,187 @@ class V1Transport final : public Transport\n     size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n };\n \n+class V2Transport final : public Transport\n+{\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    // The sender side and receiver side of V2Transport are largely independent state machines that\n+    // are transitioned through, where each state corresponds to the meaning of the data in (or to\n+    // be received to) the respective (send/receive) buffer. The sender side is primarily\n+    // controlled by send-side functions (SetMessageToSend, MarkBytesSent), while the received side\n+    // is primarily controlled by receiver-side functions (ReceivedBytes, GetReceivedMessage),\n+    // though in some cases the sender state can also change as a result of receiving bytes.\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted.\n+     *\n+     * Diagram:\n+     *\n+     *   start                                            /---------\\\n+     *     |                                              |         |\n+     *     v                                              v         |\n+     *    KEY -> GARB_GARBTERM -> GARBAUTH -> VERSION -> APP -> APP_READY\n+     */\n+    enum class RecvState : uint8_t {\n+        /** Public key.\n+         *\n+         * This is the initial state, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes APP,\n+         * and the decrypted contents is interpreted as version negotiation (currently, that means\n+         * ignoring it, but it can be used for negotiating future extensions). If it fails, the\n+         * connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+    };\n+\n+    /** State type that defines the contents of the send buffer.\n+     *\n+     * Diagram:\n+     *\n+     *   start                                       /----------\\\n+     *     |                                         |          |\n+     *     v                                         v          |\n+     *    KEY -> KEY_GARBTERM_GARBAUTH_VERSION -> APP_READY -> APP\n+     */\n+    enum class SendState : uint8_t {\n+        /** Public key.\n+         *\n+         * This is the initial state. The public key is sent out. When the receiver\n+         * receives the other side's public key and transitions to GARB_GARBTERM, the sender state\n+         * becomes KEY_GARBTERM_GARBAUTH_VERSION. The key is left in the send buffer when this\n+         * happens, because it may not have been fully sent out yet. */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313439087",
      "id" : 1313439087,
      "in_reply_to_id" : 1313408730,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OSX1v",
      "original_commit_id" : "fb3ec8fd9e96f6c2d16db02fd2d683ea097a90ff",
      "original_line" : 507,
      "original_position" : 107,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1607368990,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313439087/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-01T19:53:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313439087",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313441493"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313441493"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've toyed with this idea already actually, and think it's quite doable. We could instead of just looking at the first 12 bytes, wait until we have the first 16, and if the 12 bytes after the first 4 match \"version\\x00\\x00\\x00\\x00\\x00\" but the magic doesn't match, disconnect instead of treating it as V2.\r\n\r\nI don't think it's strictly needed, as the 64+ bytes sent by the initiator should cause instant disconnection anyway by any v1 receiver, even ones of the wrong network.\r\n\r\nWDYT? This PR, or for a follow-up?",
      "commit_id" : "75b91740fdeb9ad14cc6cb073e75867b49875a00",
      "created_at" : "2023-09-01T19:40:46Z",
      "diff_hunk" : "@@ -973,11 +987,44 @@ size_t V2Transport::GetMaxBytesToProcess() noexcept\n     case RecvState::APP_READY:\n         // No bytes can be processed until GetMessage() is called.\n         return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n     }\n     assert(false); // unreachable\n     return 0;\n }\n \n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313441493",
      "id" : 1313441493,
      "in_reply_to_id" : 1310362246,
      "line" : 1146,
      "node_id" : "PRRC_kwDOABII585OSYbV",
      "original_commit_id" : "faf5af3f6b96488ebf9585c1558710545cde05a6",
      "original_line" : 1146,
      "original_position" : 86,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 263,
      "pull_request_review_id" : 1607368990,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313441493/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-01T19:53:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313441493",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313444923"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313444923"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The test RNG seed is printed out, and can be provided back using the `RANDOM_CTX_SEED` env variable. The ellswift keys used in the unit test come from the high-quality RNG and not the test RNG though, but I don't expect those to actually influence the kind of failures this type of test would trigger.",
      "commit_id" : "75b91740fdeb9ad14cc6cb073e75867b49875a00",
      "created_at" : "2023-09-01T19:44:17Z",
      "diff_hunk" : "@@ -1008,4 +1009,496 @@ BOOST_AUTO_TEST_CASE(advertise_local_address)\n     RemoveLocal(addr_cjdns);\n }\n \n+namespace {\n+\n+/** A class for scenario-based tests of V2Transport\n+ *\n+ * Each V2TransportTester encapsulates a V2Transport (the one being tested), and can be told to\n+ * interact with it. To do so, it also encapsulates a BIP324Cipher to act as the other side. A\n+ * second V2Transport is not used, as doing so would prevent scenarios that are permitted by BIP324\n+ * but not implemented (such as the sending of decoy packets).\n+ */\n+class V2TransportTester\n+{\n+    V2Transport m_transport; //!< V2Transport being tested\n+    BIP324Cipher m_cipher; //!< Cipher to help with the other side\n+    bool m_test_initiator; //!< Whether m_transport is the initiator (true) or responder (false)\n+\n+    std::vector<uint8_t> m_sent_garbage; //!< The garbage we've sent to m_transport.\n+    std::vector<uint8_t> m_to_send; //!< Bytes we have queued up to send to m_transport.\n+    std::vector<uint8_t> m_received; //!< Bytes we have received from m_transport.\n+    std::deque<CSerializedNetMsg> m_msg_to_send; //!< Messages to be sent *by* m_transport to us.\n+\n+public:\n+    /** Construct a tester object. test_initiator: whether the tested transport is initiator. */\n+    V2TransportTester(bool test_initiator) :\n+        m_transport(0, test_initiator, SER_NETWORK, INIT_PROTO_VERSION),\n+        m_test_initiator(test_initiator) {}\n+\n+    /** Data type returned by Interact:\n+     *\n+     * - std::nullopt: transport error occurred\n+     * - otherwise: a vector of\n+     *   - std::nullopt: invalid message received\n+     *   - otherwise: a CNetMessage retrieved\n+     */\n+    using InteractResult = std::optional<std::vector<std::optional<CNetMessage>>>;\n+\n+    /** Send/receive scheduled/available bytes and messages.\n+     *\n+     * This is the only function that interacts with the transport being tested; everything else is\n+     * scheduling things done by Interact(), or processing things learned by it.\n+     */\n+    InteractResult Interact()\n+    {\n+        std::vector<std::optional<CNetMessage>> ret;\n+        while (true) {\n+            bool progress{false};\n+            // Send bytes from m_to_send to the transport.\n+            if (!m_to_send.empty()) {\n+                Span<const uint8_t> to_send = Span{m_to_send}.first(1 + InsecureRandRange(m_to_send.size()));\n+                size_t old_len = to_send.size();\n+                if (!m_transport.ReceivedBytes(to_send)) {\n+                    return std::nullopt; // transport error occurred\n+                }\n+                if (old_len != to_send.size()) {\n+                    progress = true;\n+                    m_to_send.erase(m_to_send.begin(), m_to_send.begin() + (old_len - to_send.size()));\n+                }\n+            }\n+            // Retrieve messages received by the transport.\n+            if (m_transport.ReceivedMessageComplete() && (!progress || InsecureRandBool())) {\n+                bool reject{false};\n+                auto msg = m_transport.GetReceivedMessage({}, reject);\n+                if (reject) {\n+                    ret.push_back(std::nullopt);\n+                } else {\n+                    ret.push_back(std::move(msg));\n+                }\n+                progress = true;\n+            }\n+            // Enqueue a message to be sent by the transport to us.\n+            if (!m_msg_to_send.empty() && (!progress || InsecureRandBool())) {\n+                if (m_transport.SetMessageToSend(m_msg_to_send.front())) {\n+                    m_msg_to_send.pop_front();\n+                    progress = true;\n+                }\n+            }\n+            // Receive bytes from the transport.\n+            const auto& [recv_bytes, _more, _msg_type] = m_transport.GetBytesToSend(!m_msg_to_send.empty());\n+            if (!recv_bytes.empty() && (!progress || InsecureRandBool())) {\n+                size_t to_receive = 1 + InsecureRandRange(recv_bytes.size());\n+                m_received.insert(m_received.end(), recv_bytes.begin(), recv_bytes.begin() + to_receive);\n+                progress = true;\n+                m_transport.MarkBytesSent(to_receive);\n+            }\n+            if (!progress) break;\n+        }\n+        return ret;\n+    }\n+\n+    /** Expose the cipher. */\n+    BIP324Cipher& GetCipher() { return m_cipher; }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const uint8_t> data)\n+    {\n+        m_to_send.insert(m_to_send.end(), data.begin(), data.end());\n+    }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const std::byte> data) { Send(MakeUCharSpan(data)); }\n+\n+    /** Schedule our ellswift key to be sent to the transport. */\n+    void SendKey() { Send(m_cipher.GetOurPubKey()); }\n+\n+    /** Schedule specified garbage to be sent to the transport. */\n+    void SendGarbage(Span<const uint8_t> garbage)\n+    {\n+        // Remember the specified garbage (so we can use it for constructing the garbage\n+        // authentication packet).\n+        m_sent_garbage.assign(garbage.begin(), garbage.end());\n+        // Schedule it for sending.\n+        Send(m_sent_garbage);\n+    }\n+\n+    /** Schedule garbage (of specified length) to be sent to the transport. */\n+    void SendGarbage(size_t garbage_len)\n+    {\n+        // Generate random garbage and send it.\n+        SendGarbage(g_insecure_rand_ctx.randbytes<uint8_t>(garbage_len));\n+    }\n+\n+    /** Schedule garbage (with valid random length) to be sent to the transport. */\n+    void SendGarbage()\n+    {\n+         SendGarbage(InsecureRandRange(V2Transport::MAX_GARBAGE_LEN + 1));\n+    }\n+\n+    /** Schedule a message to be sent to us by the transport. */\n+    void AddMessage(std::string m_type, std::vector<uint8_t> payload)\n+    {\n+        CSerializedNetMsg msg;\n+        msg.m_type = std::move(m_type);\n+        msg.data = std::move(payload);\n+        m_msg_to_send.push_back(std::move(msg));\n+    }\n+\n+    /** Expect ellswift key to have been received from transport and process it.\n+     *\n+     * Many other V2TransportTester functions cannot be called until after ReceiveKey() has been\n+     * called, as no encryption keys are set up before that point.\n+     */\n+    void ReceiveKey()\n+    {\n+        // When processing a key, enough bytes need to have been received already.\n+        BOOST_CHECK(m_received.size() >= EllSwiftPubKey::size());\n+        // Initialize the cipher using it (acting as the opposite side of the tested transport).\n+        m_cipher.Initialize(MakeByteSpan(m_received).first(EllSwiftPubKey::size()), !m_test_initiator);\n+        // Strip the processed bytes off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + EllSwiftPubKey::size());\n+    }\n+\n+    /** Schedule an encrypted packet with specified content/aad/ignore to be sent to transport\n+     *  (only after ReceiveKey). */\n+    void SendPacket(Span<const uint8_t> content, Span<const uint8_t> aad = {}, bool ignore = false)\n+    {\n+        // Use cipher to construct ciphertext.\n+        std::vector<std::byte> ciphertext;\n+        ciphertext.resize(content.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(MakeByteSpan(content), MakeByteSpan(aad), ignore, ciphertext);\n+        // Schedule it for sending.\n+        Send(ciphertext);\n+    }\n+\n+    /** Schedule garbage terminator and authentication packet to be sent to the transport (only\n+     *  after ReceiveKey). */\n+    void SendGarbageTermAuth(size_t garb_auth_data_len = 0, bool garb_auth_ignore = false)\n+    {\n+        // Generate random data to include in the garbage authentication packet (ignored by peer).\n+        auto garb_auth_data = g_insecure_rand_ctx.randbytes<uint8_t>(garb_auth_data_len);\n+        // Schedule the garbage terminator to be sent.\n+        Send(m_cipher.GetSendGarbageTerminator());\n+        // Schedule the garbage authentication packet to be sent.\n+        SendPacket(/*content=*/garb_auth_data, /*aad=*/m_sent_garbage, /*ignore=*/garb_auth_ignore);\n+    }\n+\n+    /** Schedule version packet to be sent to the transport (only after ReceiveKey). */\n+    void SendVersion(Span<const uint8_t> version_data = {}, bool vers_ignore = false)\n+    {\n+        SendPacket(/*content=*/version_data, /*aad=*/{}, /*ignore=*/vers_ignore);\n+    }\n+\n+    /** Expect a packet to have been received from transport, process it, and return its contents\n+     *  (only after ReceiveKey). By default, decoys are skipped. */\n+    std::vector<uint8_t> ReceivePacket(Span<const std::byte> aad = {}, bool skip_decoy = true)\n+    {\n+        std::vector<uint8_t> contents;\n+        // Loop as long as there are ignored packets that are to be skipped.\n+        while (true) {\n+            // When processing a packet, at least enough bytes for its length descriptor must be received.\n+            BOOST_CHECK(m_received.size() >= BIP324Cipher::LENGTH_LEN);\n+            // Decrypt the content length.\n+            size_t size = m_cipher.DecryptLength(MakeByteSpan(Span{m_received}.first(BIP324Cipher::LENGTH_LEN)));\n+            // Check that the full packet is in the receive buffer.\n+            BOOST_CHECK(m_received.size() >= size + BIP324Cipher::EXPANSION);\n+            // Decrypt the packet contents.\n+            contents.resize(size);\n+            bool ignore{false};\n+            bool ret = m_cipher.Decrypt(\n+                MakeByteSpan(Span{m_received}.first(size + BIP324Cipher::EXPANSION).subspan(BIP324Cipher::LENGTH_LEN)),\n+                aad, ignore, MakeWritableByteSpan(contents));\n+            BOOST_CHECK(ret);\n+            // Strip the processed packet's bytes off the front of the receive buffer.\n+            m_received.erase(m_received.begin(), m_received.begin() + size + BIP324Cipher::EXPANSION);\n+            // Stop if the ignore bit is not set on this packet, or if we choose to not honor it.\n+            if (!ignore || !skip_decoy) break;\n+        }\n+        return contents;\n+    }\n+\n+    /** Expect garbage, garbage terminator, and garbage auth packet to have been received, and\n+     *  process them (only after ReceiveKey). */\n+    void ReceiveGarbage()\n+    {\n+        // Figure out the garbage length.\n+        size_t garblen;\n+        for (garblen = 0; garblen <= V2Transport::MAX_GARBAGE_LEN; ++garblen) {\n+            assert(m_received.size() >= garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            auto term_span = MakeByteSpan(Span{m_received}.subspan(garblen, BIP324Cipher::GARBAGE_TERMINATOR_LEN));\n+            if (term_span == m_cipher.GetReceiveGarbageTerminator()) break;\n+        }\n+        // Copy the garbage to a buffer.\n+        std::vector<uint8_t> garbage(m_received.begin(), m_received.begin() + garblen);\n+        // Strip garbage + garbage terminator off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        // Process the expected garbage authentication packet. Such a packet still functions as one\n+        // even when its ignore bit is set to true, so we do not skip decoy packets here.\n+        ReceivePacket(/*aad=*/MakeByteSpan(garbage), /*skip_decoy=*/false);\n+    }\n+\n+    /** Expect version packet to have been received, and process it (only after ReceiveKey). */\n+    void ReceiveVersion()\n+    {\n+        auto contents = ReceivePacket();\n+        // Version packets from real BIP324 peers are expected to be empty, despite the fact that\n+        // this class supports *sending* non-empty version packets (to test that BIP324 peers\n+        // correctly ignore version packet contents).\n+        BOOST_CHECK(contents.empty());\n+    }\n+\n+    /** Expect application packet to have been received, with specified short id and payload.\n+     *  (only after ReceiveKey). */\n+    void ReceiveMessage(uint8_t short_id, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_CHECK(ret.size() == payload.size() + 1);\n+        BOOST_CHECK(ret[0] == short_id);\n+        BOOST_CHECK(Span{ret}.subspan(1) == payload);\n+    }\n+\n+    /** Expect application packet to have been received, with specified 12-char message type and\n+     *  payload (only after ReceiveKey). */\n+    void ReceiveMessage(const std::string& m_type, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_CHECK(ret.size() == payload.size() + 13);\n+        BOOST_CHECK(ret[0] == 0);\n+        for (unsigned i = 0; i < 12; ++i) {\n+            if (i < m_type.size()) {\n+                BOOST_CHECK(ret[1 + i] == m_type[i]);\n+            } else {\n+                BOOST_CHECK(ret[1 + i] == 0);\n+            }\n+        }\n+        BOOST_CHECK(Span{ret}.subspan(13) == payload);\n+    }\n+\n+    /** Schedule an encrypted packet with specified message type and payload to be sent to\n+     *  transport (only after ReceiveKey). */\n+    void SendMessage(std::string mtype, Span<const uint8_t> payload)\n+    {\n+        // Construct contents consisting of 0x00 + 12-byte message type + payload.\n+        std::vector<uint8_t> contents(13 + payload.size());\n+        std::copy(mtype.begin(), mtype.end(), reinterpret_cast<char*>(contents.data() + 1));\n+        std::copy(payload.begin(), payload.end(), contents.begin() + 13);\n+        // Send a packet with that as contents.\n+        SendPacket(contents);\n+    }\n+\n+    /** Schedule an encrypted packet with specified short message id and payload to be sent to\n+     *  transport (only after ReceiveKey). */\n+    void SendMessage(uint8_t short_id, Span<const uint8_t> payload)\n+    {\n+        // Construct contents consisting of short_id + payload.\n+        std::vector<uint8_t> contents(1 + payload.size());\n+        contents[0] = short_id;\n+        std::copy(payload.begin(), payload.end(), contents.begin() + 1);\n+        // Send a packet with that as contents.\n+        SendPacket(contents);\n+    }\n+\n+    /** Introduce a bit error in the data scheduled to be sent. */\n+    void Damage()\n+    {\n+        m_to_send[InsecureRandRange(m_to_send.size())] ^= (uint8_t{1} << InsecureRandRange(8));\n+    }\n+};\n+\n+} // namespace\n+\n+BOOST_AUTO_TEST_CASE(v2transport_test)\n+{\n+    // A mostly normal scenario, testing a transport in initiator mode.\n+    for (int i = 0; i < 10; ++i) {\n+        V2TransportTester tester(true);\n+        auto ret = tester.Interact();\n+        BOOST_CHECK(ret && ret->empty());\n+        tester.SendKey();\n+        tester.SendGarbage();\n+        tester.ReceiveKey();\n+        tester.SendGarbageTermAuth();\n+        tester.SendVersion();\n+        ret = tester.Interact();\n+        BOOST_CHECK(ret && ret->empty());\n+        tester.ReceiveGarbage();\n+        tester.ReceiveVersion();\n+        auto msg_data_1 = g_insecure_rand_ctx.randbytes<uint8_t>(InsecureRandRange(100000));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313444923",
      "id" : 1313444923,
      "in_reply_to_id" : 1313245167,
      "line" : 1326,
      "node_id" : "PRRC_kwDOABII585OSZQ7",
      "original_commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "original_line" : 1326,
      "original_position" : 326,
      "original_start_line" : null,
      "path" : "src/test/net_tests.cpp",
      "position" : 326,
      "pull_request_review_id" : 1607368990,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313444923/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-01T19:53:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313444923",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313449447"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313449447"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> Maybe construct feedback from m_v1_prefix which has been constructed by us? I know they are equal, but still...\r\n\r\nI think that's overkill. I've added some comments explaining why the v1 fallback should always accept this prefix.\r\n\r\n> ... concerns elsewhere about asserts in the networking code ...\r\n\r\nI have changed all the `assert`s to `Assume`s. I didn't do so initially, because I wasn't aware that `Assume`s are treated like assertions in fuzz tests, and wanted to make sure the fuzz tests actually had a chance of triggering them. As that doesn't seem to be the case, there is little reason to keep asserts.\r\n\r\nI've also gone over the code added in this PR, trying to find possible places where actually dangerous (e.g. out of bounds access) behavior is guarded by assertions (as those are worthwhile to keep as assertions in production, crashing is better than possibly remotely-triggerable OOB-based UB), but I can't actually find any. Nearly code I can find that accesses buffers is in conditional branches that test actually the right buffer sizes beforehand.\r\n\r\nChanging some/all of them to instead disconnect would require a bunch of code changes, and because of the above, I don't think it's worth it. Keeping a connection open in a weird state, where it'll very likely not do anything and time out isn't all that bad compared to disconnecting in case of a bug (and may actually be easier to notice).",
      "commit_id" : "75b91740fdeb9ad14cc6cb073e75867b49875a00",
      "created_at" : "2023-09-01T19:48:52Z",
      "diff_hunk" : "@@ -910,24 +912,632 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // Initial state, cannot be transitioned into.\n+        assert(false);\n+        break;\n+    case RecvState::KEY:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        assert(m_recv_state == RecvState::KEY);\n+        break;\n+    case RecvState::GARBAUTH:\n+        assert(m_recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::VERSION:\n+        assert(m_recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::APP:\n+        assert(m_recv_state == RecvState::VERSION || m_recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        assert(m_recv_state == RecvState::APP);\n+        break;\n+    case RecvState::V1:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (send_state) {\n+    case SendState::KEY_GARB_MAYBE_V1:\n+        // Initial state, cannot be transitioned into.\n+        assert(false);\n+        break;\n+    case SendState::KEY_GARB:\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1);\n+        break;\n+    case SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION:\n+        assert(m_send_state == SendState::KEY_GARB);\n+        break;\n+    case SendState::APP_READY:\n+        assert(m_send_state == SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION ||\n+               m_send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        assert(m_send_state == SendState::APP_READY);\n+        break;\n+    case SendState::V1:\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // During the KEY_MAYBE_V1 state we do not allow more than the length of v1 prefix into the\n+        // receive buffer.\n+        Assume(m_recv_buffer.size() <= m_v1_prefix.size());\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY_MAYBE_V1);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        SetReceiveState(RecvState::KEY); // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        SetSendState(SendState::KEY_GARB);\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313449447",
      "id" : 1313449447,
      "in_reply_to_id" : 1313079175,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OSaXn",
      "original_commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "original_line" : 1157,
      "original_position" : 274,
      "original_start_line" : 1155,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1607368990,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313449447/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-09-01T19:53:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313449447",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313686515"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313686515"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: as `m_recv_buffer` has exactly the size of an ellswift pubkey at this point (ensured by the if a few lines above), the `.first` call isn't needed:\r\n```suggestion\r\n        EllSwiftPubKey ellswift(MakeByteSpan(m_recv_buffer));\r\n```\r\n",
      "commit_id" : "59f1dd13958ab76ff9ea34a47b60bb73f336c81e",
      "created_at" : "2023-09-02T02:05:55Z",
      "diff_hunk" : "@@ -912,6 +912,420 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (recv_state) {\n+    case RecvState::KEY:\n+        // Initial state, cannot be transitioned into.\n+        Assume(false);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(m_recv_state == RecvState::KEY);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(m_recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::APP:\n+        Assume(m_recv_state == RecvState::VERSION || m_recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(m_recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (send_state) {\n+    case SendState::KEY:\n+        // Initial state, cannot be transitioned into.\n+        Assume(false);\n+        break;\n+    case SendState::KEY_GARBTERM_GARBAUTH_VERSION:\n+        Assume(m_send_state == SendState::KEY);\n+        break;\n+    case SendState::APP_READY:\n+        Assume(m_send_state == SendState::KEY_GARBTERM_GARBAUTH_VERSION ||\n+               m_send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        Assume(m_send_state == SendState::APP_READY);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    Assume(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        EllSwiftPubKey ellswift(MakeByteSpan(m_recv_buffer).first(EllSwiftPubKey::size()));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313686515",
      "id" : 1313686515,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OTUPz",
      "original_commit_id" : "ab9d292e3fa61824870bfcd31b0fb6f649eafa2d",
      "original_line" : 1046,
      "original_position" : 135,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1607831626,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313686515/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-02T02:41:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313686515",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313686655"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313686655"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "~nit:~\r\n```suggestion\r\n        RandAddEvent(ReadLE32(m_recv_buffer.end() - 4));\r\n```\r\n(EDIT: oh nevermind, end() returns an iterator, not a pointer, so this won't work.)",
      "commit_id" : "59f1dd13958ab76ff9ea34a47b60bb73f336c81e",
      "created_at" : "2023-09-02T02:06:48Z",
      "diff_hunk" : "@@ -912,6 +912,420 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (recv_state) {\n+    case RecvState::KEY:\n+        // Initial state, cannot be transitioned into.\n+        Assume(false);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(m_recv_state == RecvState::KEY);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(m_recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::APP:\n+        Assume(m_recv_state == RecvState::VERSION || m_recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(m_recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (send_state) {\n+    case SendState::KEY:\n+        // Initial state, cannot be transitioned into.\n+        Assume(false);\n+        break;\n+    case SendState::KEY_GARBTERM_GARBAUTH_VERSION:\n+        Assume(m_send_state == SendState::KEY);\n+        break;\n+    case SendState::APP_READY:\n+        Assume(m_send_state == SendState::KEY_GARBTERM_GARBAUTH_VERSION ||\n+               m_send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        Assume(m_send_state == SendState::APP_READY);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    Assume(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        EllSwiftPubKey ellswift(MakeByteSpan(m_recv_buffer).first(EllSwiftPubKey::size()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(ellswift, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        SetReceiveState(RecvState::GARB_GARBTERM);\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        SetSendState(SendState::KEY_GARBTERM_GARBAUTH_VERSION);\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+    Assume(m_recv_buffer.size() <= MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            SetReceiveState(RecvState::GARBAUTH);\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARBAUTH || m_recv_state == RecvState::VERSION ||\n+           m_recv_state == RecvState::APP);\n+\n+    // The maximum permitted contents length for a packet.\n+    static constexpr size_t MAX_CONTENTS_LEN =\n+        1 + CMessageHeader::COMMAND_SIZE + // The maximum length for encoding the message type.\n+        std::min<size_t>(MAX_SIZE, MAX_PROTOCOL_MESSAGE_LENGTH); // The maximum payload.\n+\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_CONTENTS_LEN) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        // Note that it is impossible to reach this branch without hitting the branch above first,\n+        // as GetMaxBytesToProcess only allows up to LENGTH_LEN into the buffer before that point.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313686655",
      "id" : 1313686655,
      "line" : 1266,
      "node_id" : "PRRC_kwDOABII585OTUR_",
      "original_commit_id" : "ab9d292e3fa61824870bfcd31b0fb6f649eafa2d",
      "original_line" : 1266,
      "original_position" : 225,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 383,
      "pull_request_review_id" : 1607831626,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313686655/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-02T03:02:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313686655",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313692208"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313692208"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Should the size of the 3-byte length descriptor also be added here? (at least that would come close to what happens for v1, where HEADER_SIZE is accounted for).",
      "commit_id" : "59f1dd13958ab76ff9ea34a47b60bb73f336c81e",
      "created_at" : "2023-09-02T02:19:55Z",
      "diff_hunk" : "@@ -912,6 +912,420 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (recv_state) {\n+    case RecvState::KEY:\n+        // Initial state, cannot be transitioned into.\n+        Assume(false);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(m_recv_state == RecvState::KEY);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(m_recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::APP:\n+        Assume(m_recv_state == RecvState::VERSION || m_recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(m_recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (send_state) {\n+    case SendState::KEY:\n+        // Initial state, cannot be transitioned into.\n+        Assume(false);\n+        break;\n+    case SendState::KEY_GARBTERM_GARBAUTH_VERSION:\n+        Assume(m_send_state == SendState::KEY);\n+        break;\n+    case SendState::APP_READY:\n+        Assume(m_send_state == SendState::KEY_GARBTERM_GARBAUTH_VERSION ||\n+               m_send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        Assume(m_send_state == SendState::APP_READY);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    Assume(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        EllSwiftPubKey ellswift(MakeByteSpan(m_recv_buffer).first(EllSwiftPubKey::size()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(ellswift, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        SetReceiveState(RecvState::GARB_GARBTERM);\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        SetSendState(SendState::KEY_GARBTERM_GARBAUTH_VERSION);\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+    Assume(m_recv_buffer.size() <= MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            SetReceiveState(RecvState::GARBAUTH);\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARBAUTH || m_recv_state == RecvState::VERSION ||\n+           m_recv_state == RecvState::APP);\n+\n+    // The maximum permitted contents length for a packet.\n+    static constexpr size_t MAX_CONTENTS_LEN =\n+        1 + CMessageHeader::COMMAND_SIZE + // The maximum length for encoding the message type.\n+        std::min<size_t>(MAX_SIZE, MAX_PROTOCOL_MESSAGE_LENGTH); // The maximum payload.\n+\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_CONTENTS_LEN) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        // Note that it is impossible to reach this branch without hitting the branch above first,\n+        // as GetMaxBytesToProcess only allows up to LENGTH_LEN into the buffer before that point.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packet decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            SetReceiveState(RecvState::VERSION);\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is\n+                // ignored, but can be used for future extensions.\n+                SetReceiveState(RecvState::APP);\n+            }\n+            break;\n+        case RecvState::APP:\n+            if (!ignore) {\n+                // Application message decrypted correctly. It can be extracted using GetMessage().\n+                SetReceiveState(RecvState::APP_READY);\n+            }\n+            break;\n+        default:\n+            // Any other state is invalid (this function should not have been called).\n+            Assume(false);\n+        }\n+        // Wipe the receive buffer where the next packet will be received into.\n+        m_recv_buffer = {};\n+        // In all but APP_READY state, we can wipe the decoded contents.\n+        if (m_recv_state != RecvState::APP_READY) m_recv_decode_buffer = {};\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ReceivedBytes(Span<const uint8_t>& msg_bytes) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    while (!msg_bytes.empty()) {\n+        // Decide how many bytes to copy from msg_bytes to m_recv_buffer.\n+        size_t max_read = GetMaxBytesToProcess();\n+        // Can't read more than provided input.\n+        max_read = std::min(msg_bytes.size(), max_read);\n+        // Copy data to buffer.\n+        m_recv_buffer.insert(m_recv_buffer.end(), UCharCast(msg_bytes.data()), UCharCast(msg_bytes.data() + max_read));\n+        msg_bytes = msg_bytes.subspan(max_read);\n+\n+        // Process data in the buffer.\n+        switch (m_recv_state) {\n+        case RecvState::KEY:\n+            ProcessReceivedKey();\n+            break;\n+\n+        case RecvState::GARB_GARBTERM:\n+            if (!ProcessReceivedGarbage()) return false;\n+            break;\n+\n+        case RecvState::GARBAUTH:\n+        case RecvState::VERSION:\n+        case RecvState::APP:\n+            if (!ProcessReceivedPacket()) return false;\n+            break;\n+\n+        case RecvState::APP_READY:\n+            return true;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+std::optional<std::string> V2Transport::GetMessageType(Span<const uint8_t>& contents) noexcept\n+{\n+    if (contents.size() == 0) return std::nullopt; // Empty contents\n+    uint8_t first_byte = contents[0];\n+    contents = contents.subspan(1); // Strip first byte.\n+\n+    if (first_byte != 0) return std::nullopt; // TODO: implement short encoding\n+\n+    if (contents.size() < CMessageHeader::COMMAND_SIZE) {\n+        return std::nullopt; // Long encoding needs 12 message type bytes.\n+    }\n+\n+    size_t msg_type_len{0};\n+    while (msg_type_len < CMessageHeader::COMMAND_SIZE && contents[msg_type_len] != 0) {\n+        // Verify that message type bytes before the first 0x00 are in range.\n+        if (contents[msg_type_len] < ' ' || contents[msg_type_len] > 0x7F) {\n+            return {};\n+        }\n+        ++msg_type_len;\n+    }\n+    std::string ret{reinterpret_cast<const char*>(contents.data()), msg_type_len};\n+    while (msg_type_len < CMessageHeader::COMMAND_SIZE) {\n+        // Verify that message type bytes after the first 0x00 are also 0x00.\n+        if (contents[msg_type_len] != 0) return {};\n+        ++msg_type_len;\n+    }\n+    // Strip message type bytes of contents.\n+    contents = contents.subspan(CMessageHeader::COMMAND_SIZE);\n+    return {std::move(ret)};\n+}\n+\n+CNetMessage V2Transport::GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::APP_READY);\n+    Span<const uint8_t> contents{m_recv_decode_buffer};\n+    auto msg_type = GetMessageType(contents);\n+    CDataStream ret(m_recv_type, m_recv_version);\n+    CNetMessage msg{std::move(ret)};\n+    msg.m_raw_message_size = m_recv_decode_buffer.size() + BIP324Cipher::EXPANSION;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313692208",
      "id" : 1313692208,
      "line" : 1422,
      "node_id" : "PRRC_kwDOABII585OTVow",
      "original_commit_id" : "ab9d292e3fa61824870bfcd31b0fb6f649eafa2d",
      "original_line" : 1422,
      "original_position" : 338,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 539,
      "pull_request_review_id" : 1607831626,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313692208/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-02T02:41:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313692208",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313692979"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313692979"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "missing verb after \"BIP324\":\r\n```suggestion\r\n    /** Contents of the version packet to send. BIP324 stipulates that senders should leave this empty, and\r\n```",
      "commit_id" : "59f1dd13958ab76ff9ea34a47b60bb73f336c81e",
      "created_at" : "2023-09-02T02:24:59Z",
      "diff_hunk" : "@@ -417,6 +419,194 @@ class V1Transport final : public Transport\n     size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n };\n \n+class V2Transport final : public Transport\n+{\n+private:\n+    /** Contents of the version packet to send. BIP324 that senders should leave this empty, and",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313692979",
      "id" : 1313692979,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OTV0z",
      "original_commit_id" : "ab9d292e3fa61824870bfcd31b0fb6f649eafa2d",
      "original_line" : 425,
      "original_position" : 25,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1607831626,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313692979/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-02T02:41:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313692979",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313695214"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313695214"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: in `Set{Send,Receive}State`, at least for my brain the state transition checks would be slightly easier to grasp if the current state is switch/case-d and the allowed next state(s) are `Assume`d (i.e. asserting \"where can I go to?\" rather than \"where could I have come from?\").",
      "commit_id" : "59f1dd13958ab76ff9ea34a47b60bb73f336c81e",
      "created_at" : "2023-09-02T02:31:56Z",
      "diff_hunk" : "@@ -912,6 +912,420 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (recv_state) {\n+    case RecvState::KEY:\n+        // Initial state, cannot be transitioned into.\n+        Assume(false);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(m_recv_state == RecvState::KEY);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(m_recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::APP:\n+        Assume(m_recv_state == RecvState::VERSION || m_recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(m_recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (send_state) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313695214",
      "id" : 1313695214,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OTWXu",
      "original_commit_id" : "ab9d292e3fa61824870bfcd31b0fb6f649eafa2d",
      "original_line" : 974,
      "original_position" : 63,
      "original_start_line" : 973,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1607831626,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313695214/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-09-02T02:41:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313695214",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313708390"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313708390"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nice, done.",
      "commit_id" : "59f1dd13958ab76ff9ea34a47b60bb73f336c81e",
      "created_at" : "2023-09-02T03:39:01Z",
      "diff_hunk" : "@@ -912,6 +912,420 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (recv_state) {\n+    case RecvState::KEY:\n+        // Initial state, cannot be transitioned into.\n+        Assume(false);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(m_recv_state == RecvState::KEY);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(m_recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::APP:\n+        Assume(m_recv_state == RecvState::VERSION || m_recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(m_recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (send_state) {\n+    case SendState::KEY:\n+        // Initial state, cannot be transitioned into.\n+        Assume(false);\n+        break;\n+    case SendState::KEY_GARBTERM_GARBAUTH_VERSION:\n+        Assume(m_send_state == SendState::KEY);\n+        break;\n+    case SendState::APP_READY:\n+        Assume(m_send_state == SendState::KEY_GARBTERM_GARBAUTH_VERSION ||\n+               m_send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        Assume(m_send_state == SendState::APP_READY);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    Assume(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        EllSwiftPubKey ellswift(MakeByteSpan(m_recv_buffer).first(EllSwiftPubKey::size()));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313708390",
      "id" : 1313708390,
      "in_reply_to_id" : 1313686515,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OTZlm",
      "original_commit_id" : "ab9d292e3fa61824870bfcd31b0fb6f649eafa2d",
      "original_line" : 1046,
      "original_position" : 135,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1607869598,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313708390/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-02T03:39:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313708390",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313708398"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313708398"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Sadly, indeed.",
      "commit_id" : "59f1dd13958ab76ff9ea34a47b60bb73f336c81e",
      "created_at" : "2023-09-02T03:39:10Z",
      "diff_hunk" : "@@ -912,6 +912,420 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (recv_state) {\n+    case RecvState::KEY:\n+        // Initial state, cannot be transitioned into.\n+        Assume(false);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(m_recv_state == RecvState::KEY);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(m_recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::APP:\n+        Assume(m_recv_state == RecvState::VERSION || m_recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(m_recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (send_state) {\n+    case SendState::KEY:\n+        // Initial state, cannot be transitioned into.\n+        Assume(false);\n+        break;\n+    case SendState::KEY_GARBTERM_GARBAUTH_VERSION:\n+        Assume(m_send_state == SendState::KEY);\n+        break;\n+    case SendState::APP_READY:\n+        Assume(m_send_state == SendState::KEY_GARBTERM_GARBAUTH_VERSION ||\n+               m_send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        Assume(m_send_state == SendState::APP_READY);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    Assume(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        EllSwiftPubKey ellswift(MakeByteSpan(m_recv_buffer).first(EllSwiftPubKey::size()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(ellswift, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        SetReceiveState(RecvState::GARB_GARBTERM);\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        SetSendState(SendState::KEY_GARBTERM_GARBAUTH_VERSION);\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+    Assume(m_recv_buffer.size() <= MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            SetReceiveState(RecvState::GARBAUTH);\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARBAUTH || m_recv_state == RecvState::VERSION ||\n+           m_recv_state == RecvState::APP);\n+\n+    // The maximum permitted contents length for a packet.\n+    static constexpr size_t MAX_CONTENTS_LEN =\n+        1 + CMessageHeader::COMMAND_SIZE + // The maximum length for encoding the message type.\n+        std::min<size_t>(MAX_SIZE, MAX_PROTOCOL_MESSAGE_LENGTH); // The maximum payload.\n+\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_CONTENTS_LEN) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        // Note that it is impossible to reach this branch without hitting the branch above first,\n+        // as GetMaxBytesToProcess only allows up to LENGTH_LEN into the buffer before that point.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313708398",
      "id" : 1313708398,
      "in_reply_to_id" : 1313686655,
      "line" : 1266,
      "node_id" : "PRRC_kwDOABII585OTZlu",
      "original_commit_id" : "ab9d292e3fa61824870bfcd31b0fb6f649eafa2d",
      "original_line" : 1266,
      "original_position" : 225,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 383,
      "pull_request_review_id" : 1607869614,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313708398/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-02T03:39:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313708398",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313708417"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313708417"
         }
      },
      "author_association" : "MEMBER",
      "body" : "That's included in EXPANSION. I've added a comment to clarify that.",
      "commit_id" : "59f1dd13958ab76ff9ea34a47b60bb73f336c81e",
      "created_at" : "2023-09-02T03:39:30Z",
      "diff_hunk" : "@@ -912,6 +912,420 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (recv_state) {\n+    case RecvState::KEY:\n+        // Initial state, cannot be transitioned into.\n+        Assume(false);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(m_recv_state == RecvState::KEY);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(m_recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::APP:\n+        Assume(m_recv_state == RecvState::VERSION || m_recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(m_recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (send_state) {\n+    case SendState::KEY:\n+        // Initial state, cannot be transitioned into.\n+        Assume(false);\n+        break;\n+    case SendState::KEY_GARBTERM_GARBAUTH_VERSION:\n+        Assume(m_send_state == SendState::KEY);\n+        break;\n+    case SendState::APP_READY:\n+        Assume(m_send_state == SendState::KEY_GARBTERM_GARBAUTH_VERSION ||\n+               m_send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        Assume(m_send_state == SendState::APP_READY);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    Assume(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        EllSwiftPubKey ellswift(MakeByteSpan(m_recv_buffer).first(EllSwiftPubKey::size()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(ellswift, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        SetReceiveState(RecvState::GARB_GARBTERM);\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        SetSendState(SendState::KEY_GARBTERM_GARBAUTH_VERSION);\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+    Assume(m_recv_buffer.size() <= MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            SetReceiveState(RecvState::GARBAUTH);\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARBAUTH || m_recv_state == RecvState::VERSION ||\n+           m_recv_state == RecvState::APP);\n+\n+    // The maximum permitted contents length for a packet.\n+    static constexpr size_t MAX_CONTENTS_LEN =\n+        1 + CMessageHeader::COMMAND_SIZE + // The maximum length for encoding the message type.\n+        std::min<size_t>(MAX_SIZE, MAX_PROTOCOL_MESSAGE_LENGTH); // The maximum payload.\n+\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_CONTENTS_LEN) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        // Note that it is impossible to reach this branch without hitting the branch above first,\n+        // as GetMaxBytesToProcess only allows up to LENGTH_LEN into the buffer before that point.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packet decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            SetReceiveState(RecvState::VERSION);\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is\n+                // ignored, but can be used for future extensions.\n+                SetReceiveState(RecvState::APP);\n+            }\n+            break;\n+        case RecvState::APP:\n+            if (!ignore) {\n+                // Application message decrypted correctly. It can be extracted using GetMessage().\n+                SetReceiveState(RecvState::APP_READY);\n+            }\n+            break;\n+        default:\n+            // Any other state is invalid (this function should not have been called).\n+            Assume(false);\n+        }\n+        // Wipe the receive buffer where the next packet will be received into.\n+        m_recv_buffer = {};\n+        // In all but APP_READY state, we can wipe the decoded contents.\n+        if (m_recv_state != RecvState::APP_READY) m_recv_decode_buffer = {};\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ReceivedBytes(Span<const uint8_t>& msg_bytes) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    while (!msg_bytes.empty()) {\n+        // Decide how many bytes to copy from msg_bytes to m_recv_buffer.\n+        size_t max_read = GetMaxBytesToProcess();\n+        // Can't read more than provided input.\n+        max_read = std::min(msg_bytes.size(), max_read);\n+        // Copy data to buffer.\n+        m_recv_buffer.insert(m_recv_buffer.end(), UCharCast(msg_bytes.data()), UCharCast(msg_bytes.data() + max_read));\n+        msg_bytes = msg_bytes.subspan(max_read);\n+\n+        // Process data in the buffer.\n+        switch (m_recv_state) {\n+        case RecvState::KEY:\n+            ProcessReceivedKey();\n+            break;\n+\n+        case RecvState::GARB_GARBTERM:\n+            if (!ProcessReceivedGarbage()) return false;\n+            break;\n+\n+        case RecvState::GARBAUTH:\n+        case RecvState::VERSION:\n+        case RecvState::APP:\n+            if (!ProcessReceivedPacket()) return false;\n+            break;\n+\n+        case RecvState::APP_READY:\n+            return true;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+std::optional<std::string> V2Transport::GetMessageType(Span<const uint8_t>& contents) noexcept\n+{\n+    if (contents.size() == 0) return std::nullopt; // Empty contents\n+    uint8_t first_byte = contents[0];\n+    contents = contents.subspan(1); // Strip first byte.\n+\n+    if (first_byte != 0) return std::nullopt; // TODO: implement short encoding\n+\n+    if (contents.size() < CMessageHeader::COMMAND_SIZE) {\n+        return std::nullopt; // Long encoding needs 12 message type bytes.\n+    }\n+\n+    size_t msg_type_len{0};\n+    while (msg_type_len < CMessageHeader::COMMAND_SIZE && contents[msg_type_len] != 0) {\n+        // Verify that message type bytes before the first 0x00 are in range.\n+        if (contents[msg_type_len] < ' ' || contents[msg_type_len] > 0x7F) {\n+            return {};\n+        }\n+        ++msg_type_len;\n+    }\n+    std::string ret{reinterpret_cast<const char*>(contents.data()), msg_type_len};\n+    while (msg_type_len < CMessageHeader::COMMAND_SIZE) {\n+        // Verify that message type bytes after the first 0x00 are also 0x00.\n+        if (contents[msg_type_len] != 0) return {};\n+        ++msg_type_len;\n+    }\n+    // Strip message type bytes of contents.\n+    contents = contents.subspan(CMessageHeader::COMMAND_SIZE);\n+    return {std::move(ret)};\n+}\n+\n+CNetMessage V2Transport::GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::APP_READY);\n+    Span<const uint8_t> contents{m_recv_decode_buffer};\n+    auto msg_type = GetMessageType(contents);\n+    CDataStream ret(m_recv_type, m_recv_version);\n+    CNetMessage msg{std::move(ret)};\n+    msg.m_raw_message_size = m_recv_decode_buffer.size() + BIP324Cipher::EXPANSION;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313708417",
      "id" : 1313708417,
      "in_reply_to_id" : 1313692208,
      "line" : 1422,
      "node_id" : "PRRC_kwDOABII585OTZmB",
      "original_commit_id" : "ab9d292e3fa61824870bfcd31b0fb6f649eafa2d",
      "original_line" : 1422,
      "original_position" : 338,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 539,
      "pull_request_review_id" : 1607869649,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313708417/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-02T03:39:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313708417",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313708498"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313708498"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "59f1dd13958ab76ff9ea34a47b60bb73f336c81e",
      "created_at" : "2023-09-02T03:39:39Z",
      "diff_hunk" : "@@ -417,6 +419,194 @@ class V1Transport final : public Transport\n     size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n };\n \n+class V2Transport final : public Transport\n+{\n+private:\n+    /** Contents of the version packet to send. BIP324 that senders should leave this empty, and",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313708498",
      "id" : 1313708498,
      "in_reply_to_id" : 1313692979,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OTZnS",
      "original_commit_id" : "ab9d292e3fa61824870bfcd31b0fb6f649eafa2d",
      "original_line" : 425,
      "original_position" : 25,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1607869703,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313708498/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-02T03:39:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313708498",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313708718"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313708718"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Agreed, changed. It's also a bit simpler now actually.",
      "commit_id" : "59f1dd13958ab76ff9ea34a47b60bb73f336c81e",
      "created_at" : "2023-09-02T03:40:26Z",
      "diff_hunk" : "@@ -912,6 +912,420 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (recv_state) {\n+    case RecvState::KEY:\n+        // Initial state, cannot be transitioned into.\n+        Assume(false);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(m_recv_state == RecvState::KEY);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(m_recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::APP:\n+        Assume(m_recv_state == RecvState::VERSION || m_recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(m_recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (send_state) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313708718",
      "id" : 1313708718,
      "in_reply_to_id" : 1313695214,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OTZqu",
      "original_commit_id" : "ab9d292e3fa61824870bfcd31b0fb6f649eafa2d",
      "original_line" : 974,
      "original_position" : 63,
      "original_start_line" : 973,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1607870108,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313708718/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-09-02T03:40:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313708718",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315025895"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315025895"
         }
      },
      "author_association" : "MEMBER",
      "body" : "No strong preference here, but I imagine it's useful early on for debugging to tell the difference between a truly failed v2 connection and some other network failing to make a v1 connection. Though I have no idea how often the latter actually happens these days.",
      "commit_id" : "59f1dd13958ab76ff9ea34a47b60bb73f336c81e",
      "created_at" : "2023-09-04T14:43:12Z",
      "diff_hunk" : "@@ -973,11 +987,44 @@ size_t V2Transport::GetMaxBytesToProcess() noexcept\n     case RecvState::APP_READY:\n         // No bytes can be processed until GetMessage() is called.\n         return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n     }\n     assert(false); // unreachable\n     return 0;\n }\n \n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315025895",
      "id" : 1315025895,
      "in_reply_to_id" : 1310362246,
      "line" : 1143,
      "node_id" : "PRRC_kwDOABII585OYbPn",
      "original_commit_id" : "faf5af3f6b96488ebf9585c1558710545cde05a6",
      "original_line" : 1143,
      "original_position" : 86,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 260,
      "pull_request_review_id" : 1609674963,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315025895/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-04T14:43:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315025895",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315028241"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315028241"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Right, I see now. To print the seed one has to use `-printtoconsole=1`:\r\n\r\n```sh\r\n$ ./src/test/test_bitcoin --run_test=net_tests/v2transport_test -- -printtoconsole=1\r\nRunning 1 test case...\r\n2023-09-04T13:44:27Z Seed: Setting random seed for current tests to RANDOM_CTX_SEED=e99d422b1c8107ef36cbf5bdb18326ebfbe0e3d311d31f0b5a74fb50ada6d18e\r\n...\r\n```\r\n\r\n`-printtoconsole=1` seems to not be used on CI: https://cirrus-ci.com/task/5714938337951744?logs=ci#L3390\r\n\r\nWhat about non-deterministic failure that happens on CI?",
      "commit_id" : "59f1dd13958ab76ff9ea34a47b60bb73f336c81e",
      "created_at" : "2023-09-04T14:45:40Z",
      "diff_hunk" : "@@ -1008,4 +1009,496 @@ BOOST_AUTO_TEST_CASE(advertise_local_address)\n     RemoveLocal(addr_cjdns);\n }\n \n+namespace {\n+\n+/** A class for scenario-based tests of V2Transport\n+ *\n+ * Each V2TransportTester encapsulates a V2Transport (the one being tested), and can be told to\n+ * interact with it. To do so, it also encapsulates a BIP324Cipher to act as the other side. A\n+ * second V2Transport is not used, as doing so would prevent scenarios that are permitted by BIP324\n+ * but not implemented (such as the sending of decoy packets).\n+ */\n+class V2TransportTester\n+{\n+    V2Transport m_transport; //!< V2Transport being tested\n+    BIP324Cipher m_cipher; //!< Cipher to help with the other side\n+    bool m_test_initiator; //!< Whether m_transport is the initiator (true) or responder (false)\n+\n+    std::vector<uint8_t> m_sent_garbage; //!< The garbage we've sent to m_transport.\n+    std::vector<uint8_t> m_to_send; //!< Bytes we have queued up to send to m_transport.\n+    std::vector<uint8_t> m_received; //!< Bytes we have received from m_transport.\n+    std::deque<CSerializedNetMsg> m_msg_to_send; //!< Messages to be sent *by* m_transport to us.\n+\n+public:\n+    /** Construct a tester object. test_initiator: whether the tested transport is initiator. */\n+    V2TransportTester(bool test_initiator) :\n+        m_transport(0, test_initiator, SER_NETWORK, INIT_PROTO_VERSION),\n+        m_test_initiator(test_initiator) {}\n+\n+    /** Data type returned by Interact:\n+     *\n+     * - std::nullopt: transport error occurred\n+     * - otherwise: a vector of\n+     *   - std::nullopt: invalid message received\n+     *   - otherwise: a CNetMessage retrieved\n+     */\n+    using InteractResult = std::optional<std::vector<std::optional<CNetMessage>>>;\n+\n+    /** Send/receive scheduled/available bytes and messages.\n+     *\n+     * This is the only function that interacts with the transport being tested; everything else is\n+     * scheduling things done by Interact(), or processing things learned by it.\n+     */\n+    InteractResult Interact()\n+    {\n+        std::vector<std::optional<CNetMessage>> ret;\n+        while (true) {\n+            bool progress{false};\n+            // Send bytes from m_to_send to the transport.\n+            if (!m_to_send.empty()) {\n+                Span<const uint8_t> to_send = Span{m_to_send}.first(1 + InsecureRandRange(m_to_send.size()));\n+                size_t old_len = to_send.size();\n+                if (!m_transport.ReceivedBytes(to_send)) {\n+                    return std::nullopt; // transport error occurred\n+                }\n+                if (old_len != to_send.size()) {\n+                    progress = true;\n+                    m_to_send.erase(m_to_send.begin(), m_to_send.begin() + (old_len - to_send.size()));\n+                }\n+            }\n+            // Retrieve messages received by the transport.\n+            if (m_transport.ReceivedMessageComplete() && (!progress || InsecureRandBool())) {\n+                bool reject{false};\n+                auto msg = m_transport.GetReceivedMessage({}, reject);\n+                if (reject) {\n+                    ret.push_back(std::nullopt);\n+                } else {\n+                    ret.push_back(std::move(msg));\n+                }\n+                progress = true;\n+            }\n+            // Enqueue a message to be sent by the transport to us.\n+            if (!m_msg_to_send.empty() && (!progress || InsecureRandBool())) {\n+                if (m_transport.SetMessageToSend(m_msg_to_send.front())) {\n+                    m_msg_to_send.pop_front();\n+                    progress = true;\n+                }\n+            }\n+            // Receive bytes from the transport.\n+            const auto& [recv_bytes, _more, _msg_type] = m_transport.GetBytesToSend(!m_msg_to_send.empty());\n+            if (!recv_bytes.empty() && (!progress || InsecureRandBool())) {\n+                size_t to_receive = 1 + InsecureRandRange(recv_bytes.size());\n+                m_received.insert(m_received.end(), recv_bytes.begin(), recv_bytes.begin() + to_receive);\n+                progress = true;\n+                m_transport.MarkBytesSent(to_receive);\n+            }\n+            if (!progress) break;\n+        }\n+        return ret;\n+    }\n+\n+    /** Expose the cipher. */\n+    BIP324Cipher& GetCipher() { return m_cipher; }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const uint8_t> data)\n+    {\n+        m_to_send.insert(m_to_send.end(), data.begin(), data.end());\n+    }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const std::byte> data) { Send(MakeUCharSpan(data)); }\n+\n+    /** Schedule our ellswift key to be sent to the transport. */\n+    void SendKey() { Send(m_cipher.GetOurPubKey()); }\n+\n+    /** Schedule specified garbage to be sent to the transport. */\n+    void SendGarbage(Span<const uint8_t> garbage)\n+    {\n+        // Remember the specified garbage (so we can use it for constructing the garbage\n+        // authentication packet).\n+        m_sent_garbage.assign(garbage.begin(), garbage.end());\n+        // Schedule it for sending.\n+        Send(m_sent_garbage);\n+    }\n+\n+    /** Schedule garbage (of specified length) to be sent to the transport. */\n+    void SendGarbage(size_t garbage_len)\n+    {\n+        // Generate random garbage and send it.\n+        SendGarbage(g_insecure_rand_ctx.randbytes<uint8_t>(garbage_len));\n+    }\n+\n+    /** Schedule garbage (with valid random length) to be sent to the transport. */\n+    void SendGarbage()\n+    {\n+         SendGarbage(InsecureRandRange(V2Transport::MAX_GARBAGE_LEN + 1));\n+    }\n+\n+    /** Schedule a message to be sent to us by the transport. */\n+    void AddMessage(std::string m_type, std::vector<uint8_t> payload)\n+    {\n+        CSerializedNetMsg msg;\n+        msg.m_type = std::move(m_type);\n+        msg.data = std::move(payload);\n+        m_msg_to_send.push_back(std::move(msg));\n+    }\n+\n+    /** Expect ellswift key to have been received from transport and process it.\n+     *\n+     * Many other V2TransportTester functions cannot be called until after ReceiveKey() has been\n+     * called, as no encryption keys are set up before that point.\n+     */\n+    void ReceiveKey()\n+    {\n+        // When processing a key, enough bytes need to have been received already.\n+        BOOST_CHECK(m_received.size() >= EllSwiftPubKey::size());\n+        // Initialize the cipher using it (acting as the opposite side of the tested transport).\n+        m_cipher.Initialize(MakeByteSpan(m_received).first(EllSwiftPubKey::size()), !m_test_initiator);\n+        // Strip the processed bytes off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + EllSwiftPubKey::size());\n+    }\n+\n+    /** Schedule an encrypted packet with specified content/aad/ignore to be sent to transport\n+     *  (only after ReceiveKey). */\n+    void SendPacket(Span<const uint8_t> content, Span<const uint8_t> aad = {}, bool ignore = false)\n+    {\n+        // Use cipher to construct ciphertext.\n+        std::vector<std::byte> ciphertext;\n+        ciphertext.resize(content.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(MakeByteSpan(content), MakeByteSpan(aad), ignore, ciphertext);\n+        // Schedule it for sending.\n+        Send(ciphertext);\n+    }\n+\n+    /** Schedule garbage terminator and authentication packet to be sent to the transport (only\n+     *  after ReceiveKey). */\n+    void SendGarbageTermAuth(size_t garb_auth_data_len = 0, bool garb_auth_ignore = false)\n+    {\n+        // Generate random data to include in the garbage authentication packet (ignored by peer).\n+        auto garb_auth_data = g_insecure_rand_ctx.randbytes<uint8_t>(garb_auth_data_len);\n+        // Schedule the garbage terminator to be sent.\n+        Send(m_cipher.GetSendGarbageTerminator());\n+        // Schedule the garbage authentication packet to be sent.\n+        SendPacket(/*content=*/garb_auth_data, /*aad=*/m_sent_garbage, /*ignore=*/garb_auth_ignore);\n+    }\n+\n+    /** Schedule version packet to be sent to the transport (only after ReceiveKey). */\n+    void SendVersion(Span<const uint8_t> version_data = {}, bool vers_ignore = false)\n+    {\n+        SendPacket(/*content=*/version_data, /*aad=*/{}, /*ignore=*/vers_ignore);\n+    }\n+\n+    /** Expect a packet to have been received from transport, process it, and return its contents\n+     *  (only after ReceiveKey). By default, decoys are skipped. */\n+    std::vector<uint8_t> ReceivePacket(Span<const std::byte> aad = {}, bool skip_decoy = true)\n+    {\n+        std::vector<uint8_t> contents;\n+        // Loop as long as there are ignored packets that are to be skipped.\n+        while (true) {\n+            // When processing a packet, at least enough bytes for its length descriptor must be received.\n+            BOOST_CHECK(m_received.size() >= BIP324Cipher::LENGTH_LEN);\n+            // Decrypt the content length.\n+            size_t size = m_cipher.DecryptLength(MakeByteSpan(Span{m_received}.first(BIP324Cipher::LENGTH_LEN)));\n+            // Check that the full packet is in the receive buffer.\n+            BOOST_CHECK(m_received.size() >= size + BIP324Cipher::EXPANSION);\n+            // Decrypt the packet contents.\n+            contents.resize(size);\n+            bool ignore{false};\n+            bool ret = m_cipher.Decrypt(\n+                MakeByteSpan(Span{m_received}.first(size + BIP324Cipher::EXPANSION).subspan(BIP324Cipher::LENGTH_LEN)),\n+                aad, ignore, MakeWritableByteSpan(contents));\n+            BOOST_CHECK(ret);\n+            // Strip the processed packet's bytes off the front of the receive buffer.\n+            m_received.erase(m_received.begin(), m_received.begin() + size + BIP324Cipher::EXPANSION);\n+            // Stop if the ignore bit is not set on this packet, or if we choose to not honor it.\n+            if (!ignore || !skip_decoy) break;\n+        }\n+        return contents;\n+    }\n+\n+    /** Expect garbage, garbage terminator, and garbage auth packet to have been received, and\n+     *  process them (only after ReceiveKey). */\n+    void ReceiveGarbage()\n+    {\n+        // Figure out the garbage length.\n+        size_t garblen;\n+        for (garblen = 0; garblen <= V2Transport::MAX_GARBAGE_LEN; ++garblen) {\n+            assert(m_received.size() >= garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            auto term_span = MakeByteSpan(Span{m_received}.subspan(garblen, BIP324Cipher::GARBAGE_TERMINATOR_LEN));\n+            if (term_span == m_cipher.GetReceiveGarbageTerminator()) break;\n+        }\n+        // Copy the garbage to a buffer.\n+        std::vector<uint8_t> garbage(m_received.begin(), m_received.begin() + garblen);\n+        // Strip garbage + garbage terminator off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        // Process the expected garbage authentication packet. Such a packet still functions as one\n+        // even when its ignore bit is set to true, so we do not skip decoy packets here.\n+        ReceivePacket(/*aad=*/MakeByteSpan(garbage), /*skip_decoy=*/false);\n+    }\n+\n+    /** Expect version packet to have been received, and process it (only after ReceiveKey). */\n+    void ReceiveVersion()\n+    {\n+        auto contents = ReceivePacket();\n+        // Version packets from real BIP324 peers are expected to be empty, despite the fact that\n+        // this class supports *sending* non-empty version packets (to test that BIP324 peers\n+        // correctly ignore version packet contents).\n+        BOOST_CHECK(contents.empty());\n+    }\n+\n+    /** Expect application packet to have been received, with specified short id and payload.\n+     *  (only after ReceiveKey). */\n+    void ReceiveMessage(uint8_t short_id, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_CHECK(ret.size() == payload.size() + 1);\n+        BOOST_CHECK(ret[0] == short_id);\n+        BOOST_CHECK(Span{ret}.subspan(1) == payload);\n+    }\n+\n+    /** Expect application packet to have been received, with specified 12-char message type and\n+     *  payload (only after ReceiveKey). */\n+    void ReceiveMessage(const std::string& m_type, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_CHECK(ret.size() == payload.size() + 13);\n+        BOOST_CHECK(ret[0] == 0);\n+        for (unsigned i = 0; i < 12; ++i) {\n+            if (i < m_type.size()) {\n+                BOOST_CHECK(ret[1 + i] == m_type[i]);\n+            } else {\n+                BOOST_CHECK(ret[1 + i] == 0);\n+            }\n+        }\n+        BOOST_CHECK(Span{ret}.subspan(13) == payload);\n+    }\n+\n+    /** Schedule an encrypted packet with specified message type and payload to be sent to\n+     *  transport (only after ReceiveKey). */\n+    void SendMessage(std::string mtype, Span<const uint8_t> payload)\n+    {\n+        // Construct contents consisting of 0x00 + 12-byte message type + payload.\n+        std::vector<uint8_t> contents(13 + payload.size());\n+        std::copy(mtype.begin(), mtype.end(), reinterpret_cast<char*>(contents.data() + 1));\n+        std::copy(payload.begin(), payload.end(), contents.begin() + 13);\n+        // Send a packet with that as contents.\n+        SendPacket(contents);\n+    }\n+\n+    /** Schedule an encrypted packet with specified short message id and payload to be sent to\n+     *  transport (only after ReceiveKey). */\n+    void SendMessage(uint8_t short_id, Span<const uint8_t> payload)\n+    {\n+        // Construct contents consisting of short_id + payload.\n+        std::vector<uint8_t> contents(1 + payload.size());\n+        contents[0] = short_id;\n+        std::copy(payload.begin(), payload.end(), contents.begin() + 1);\n+        // Send a packet with that as contents.\n+        SendPacket(contents);\n+    }\n+\n+    /** Introduce a bit error in the data scheduled to be sent. */\n+    void Damage()\n+    {\n+        m_to_send[InsecureRandRange(m_to_send.size())] ^= (uint8_t{1} << InsecureRandRange(8));\n+    }\n+};\n+\n+} // namespace\n+\n+BOOST_AUTO_TEST_CASE(v2transport_test)\n+{\n+    // A mostly normal scenario, testing a transport in initiator mode.\n+    for (int i = 0; i < 10; ++i) {\n+        V2TransportTester tester(true);\n+        auto ret = tester.Interact();\n+        BOOST_CHECK(ret && ret->empty());\n+        tester.SendKey();\n+        tester.SendGarbage();\n+        tester.ReceiveKey();\n+        tester.SendGarbageTermAuth();\n+        tester.SendVersion();\n+        ret = tester.Interact();\n+        BOOST_CHECK(ret && ret->empty());\n+        tester.ReceiveGarbage();\n+        tester.ReceiveVersion();\n+        auto msg_data_1 = g_insecure_rand_ctx.randbytes<uint8_t>(InsecureRandRange(100000));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315028241",
      "id" : 1315028241,
      "in_reply_to_id" : 1313245167,
      "line" : 1327,
      "node_id" : "PRRC_kwDOABII585OYb0R",
      "original_commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "original_line" : 1327,
      "original_position" : 326,
      "original_start_line" : null,
      "path" : "src/test/net_tests.cpp",
      "position" : 327,
      "pull_request_review_id" : 1609678498,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315028241/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-04T14:45:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315028241",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315042194"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315042194"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I found the description quite hard to understand. Conceptually it seems easier to understand \"We sent our key AND we have their key\", i.e. it's waiting for both to finish.\r\n\r\nThough I might be understanding that wrong, given https://github.com/bitcoin/bitcoin/pull/28196#issuecomment-1703257925",
      "commit_id" : "59f1dd13958ab76ff9ea34a47b60bb73f336c81e",
      "created_at" : "2023-09-04T15:00:54Z",
      "diff_hunk" : "@@ -417,6 +419,187 @@ class V1Transport final : public Transport\n     size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n };\n \n+class V2Transport final : public Transport\n+{\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    // The sender side and receiver side of V2Transport are largely independent state machines that\n+    // are transitioned through, where each state corresponds to the meaning of the data in (or to\n+    // be received to) the respective (send/receive) buffer. The sender side is primarily\n+    // controlled by send-side functions (SetMessageToSend, MarkBytesSent), while the received side\n+    // is primarily controlled by receiver-side functions (ReceivedBytes, GetReceivedMessage),\n+    // though in some cases the sender state can also change as a result of receiving bytes.\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted.\n+     *\n+     * Diagram:\n+     *\n+     *   start                                            /---------\\\n+     *     |                                              |         |\n+     *     v                                              v         |\n+     *    KEY -> GARB_GARBTERM -> GARBAUTH -> VERSION -> APP -> APP_READY\n+     */\n+    enum class RecvState : uint8_t {\n+        /** Public key.\n+         *\n+         * This is the initial state, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes APP,\n+         * and the decrypted contents is interpreted as version negotiation (currently, that means\n+         * ignoring it, but it can be used for negotiating future extensions). If it fails, the\n+         * connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+    };\n+\n+    /** State type that defines the contents of the send buffer.\n+     *\n+     * Diagram:\n+     *\n+     *   start                                       /----------\\\n+     *     |                                         |          |\n+     *     v                                         v          |\n+     *    KEY -> KEY_GARBTERM_GARBAUTH_VERSION -> APP_READY -> APP\n+     */\n+    enum class SendState : uint8_t {\n+        /** Public key.\n+         *\n+         * This is the initial state. The public key is sent out. When the receiver\n+         * receives the other side's public key and transitions to GARB_GARBTERM, the sender state\n+         * becomes KEY_GARBTERM_GARBAUTH_VERSION. The key is left in the send buffer when this\n+         * happens, because it may not have been fully sent out yet. */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315042194",
      "id" : 1315042194,
      "in_reply_to_id" : 1313408730,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OYfOS",
      "original_commit_id" : "fb3ec8fd9e96f6c2d16db02fd2d683ea097a90ff",
      "original_line" : 507,
      "original_position" : 107,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1609699967,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315042194/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-04T15:03:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315042194",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   }
]
