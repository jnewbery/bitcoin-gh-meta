[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\nA summary of reviews will appear here.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#27114](https://github.com/bitcoin/bitcoin/pull/27114) (p2p: Allow whitelisting outgoing connections by brunoerg)\n* [#26938](https://github.com/bitcoin/bitcoin/pull/26938) ([WIP] p2p: asmap, avoid inbound connections from a specific AS by brunoerg)\n* [#26114](https://github.com/bitcoin/bitcoin/pull/26114) (net: Make AddrFetch connections to fixed seeds by mzumsande)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "created_at" : "2023-08-01T17:57:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#issuecomment-1660822807",
      "id" : 1660822807,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28196",
      "node_id" : "IC_kwDOABII585i_iUX",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1660822807/reactions"
      },
      "updated_at" : "2023-08-22T09:59:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1660822807",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1303013011"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303013011"
         }
      },
      "author_association" : "MEMBER",
      "body" : "163d93304dea08bf8f2ea79d79cabceec1a13d96: I assume this is because of the short message ID's? Can you mention that in the commit message, so it's easy to find with `git blame`?",
      "commit_id" : "ec39432a674ef012e24391f2daa9480c2a14075a",
      "created_at" : "2023-08-23T13:21:16Z",
      "diff_hunk" : "@@ -595,12 +595,12 @@ def connect_nodes(self, a, b):\n         # * Must have a verack message before anything else\n         self.wait_until(lambda: sum(peer['version'] != 0 for peer in from_connection.getpeerinfo()) == from_num_peers)\n         self.wait_until(lambda: sum(peer['version'] != 0 for peer in to_connection.getpeerinfo()) == to_num_peers)\n-        self.wait_until(lambda: sum(peer['bytesrecv_per_msg'].pop('verack', 0) == 24 for peer in from_connection.getpeerinfo()) == from_num_peers)\n-        self.wait_until(lambda: sum(peer['bytesrecv_per_msg'].pop('verack', 0) == 24 for peer in to_connection.getpeerinfo()) == to_num_peers)\n+        self.wait_until(lambda: sum(peer['bytesrecv_per_msg'].pop('verack', 0) >= 21 for peer in from_connection.getpeerinfo()) == from_num_peers)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1303013011",
      "id" : 1303013011,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NqmaT",
      "original_commit_id" : "163d93304dea08bf8f2ea79d79cabceec1a13d96",
      "original_line" : 598,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/test_framework.py",
      "position" : null,
      "pull_request_review_id" : 1591588401,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303013011/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-23T13:43:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303013011",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1303026846"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303026846"
         }
      },
      "author_association" : "MEMBER",
      "body" : "9c3159378658c4b1535ab6c546512f7d1b2b3979: what's the difference between these two scenarios? `m_use_v1` vs `m_recv_state == RecvState::V1`?\r\n\r\nWhy not return `{}`? Unsafe / bad / not great?",
      "commit_id" : "ec39432a674ef012e24391f2daa9480c2a14075a",
      "created_at" : "2023-08-23T13:30:52Z",
      "diff_hunk" : "@@ -1434,6 +1435,20 @@ size_t V2Transport::GetSendMemoryUsage() const noexcept\n     return sizeof(m_send_buffer) + memusage::DynamicUsage(m_send_buffer);\n }\n \n+Span<const std::byte> V2Transport::GetSessionID() const noexcept\n+{\n+    if (m_use_v1) return m_v1_fallback.GetSessionID();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.GetSessionID();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1303026846",
      "id" : 1303026846,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Nqpye",
      "original_commit_id" : "9c3159378658c4b1535ab6c546512f7d1b2b3979",
      "original_line" : 1442,
      "original_position" : 16,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1591588401,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303026846/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-23T13:43:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303026846",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Started doing review, out of order. Some quick initial questions and remarks...\r\n\r\nI tend to get spontaneous v2 connections eventually, both inbound and outbound. But are there any known reachable mainnet nodes folks can test against? (testnet and signet is fine too I suppose)\r\n\r\nI would be useful to have at least one log message in the lifetime of a peer to indicate it's a v2. E.g. `[net] Added v2 connection peer=â¦` (haven't checked if we already know it's v2 at that point)\r\n\r\nDo I assume correctly that `0` refers to size of the message payload, i.e. ignoring the (short) message id (what was a header in v1)? `[net] sending verack (0 bytes)`",
      "created_at" : "2023-08-23T13:36:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#issuecomment-1689980940",
      "id" : 1689980940,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28196",
      "node_id" : "IC_kwDOABII585kuxAM",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1689980940/reactions"
      },
      "updated_at" : "2023-08-23T13:43:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1689980940",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1303059175"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303059175"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This commit will disappear eventually, when integration is done more properly.\n\nBut in short, yes, this is because when short IDs are in use, messages have a 21 byte overhead (on top of the payload) in V2 vs. 24 bytes in V1.",
      "commit_id" : "ec39432a674ef012e24391f2daa9480c2a14075a",
      "created_at" : "2023-08-23T13:52:50Z",
      "diff_hunk" : "@@ -595,12 +595,12 @@ def connect_nodes(self, a, b):\n         # * Must have a verack message before anything else\n         self.wait_until(lambda: sum(peer['version'] != 0 for peer in from_connection.getpeerinfo()) == from_num_peers)\n         self.wait_until(lambda: sum(peer['version'] != 0 for peer in to_connection.getpeerinfo()) == to_num_peers)\n-        self.wait_until(lambda: sum(peer['bytesrecv_per_msg'].pop('verack', 0) == 24 for peer in from_connection.getpeerinfo()) == from_num_peers)\n-        self.wait_until(lambda: sum(peer['bytesrecv_per_msg'].pop('verack', 0) == 24 for peer in to_connection.getpeerinfo()) == to_num_peers)\n+        self.wait_until(lambda: sum(peer['bytesrecv_per_msg'].pop('verack', 0) >= 21 for peer in from_connection.getpeerinfo()) == from_num_peers)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1303059175",
      "id" : 1303059175,
      "in_reply_to_id" : 1303013011,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Nqxrn",
      "original_commit_id" : "163d93304dea08bf8f2ea79d79cabceec1a13d96",
      "original_line" : 598,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/test_framework.py",
      "position" : null,
      "pull_request_review_id" : 1591662321,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303059175/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-23T13:52:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303059175",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1303071712"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303071712"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The difference between these scenarios: nothing, but it's possible that the m_use_v1 atomic gets set in between it being checked here and the lock being grabbed. So the m_use_v1 is there as an optimization that almost always works, but the RecvState::V1 check is necessary to make it always work. For other Transport member functions the m_use_v1 is introduced in a separate commit, which hopefully explains it.\n\nThere's also nothing wrong with `return {};` here, but I thought it'd be more obviously correct to explicitly call the V1Transport function.",
      "commit_id" : "ec39432a674ef012e24391f2daa9480c2a14075a",
      "created_at" : "2023-08-23T14:01:35Z",
      "diff_hunk" : "@@ -1434,6 +1435,20 @@ size_t V2Transport::GetSendMemoryUsage() const noexcept\n     return sizeof(m_send_buffer) + memusage::DynamicUsage(m_send_buffer);\n }\n \n+Span<const std::byte> V2Transport::GetSessionID() const noexcept\n+{\n+    if (m_use_v1) return m_v1_fallback.GetSessionID();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.GetSessionID();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1303071712",
      "id" : 1303071712,
      "in_reply_to_id" : 1303026846,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Nq0vg",
      "original_commit_id" : "9c3159378658c4b1535ab6c546512f7d1b2b3979",
      "original_line" : 1442,
      "original_position" : 16,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1591682059,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303071712/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-23T14:01:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303071712",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1308061759"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308061759"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In `V1Transport::GetReceivedMessage`, we call `RandAddEvent()` to harvest entropy from the time and checksum of the received messages. Should something similar be done for V2?",
      "commit_id" : "ec39432a674ef012e24391f2daa9480c2a14075a",
      "created_at" : "2023-08-28T23:53:59Z",
      "diff_hunk" : "@@ -912,6 +912,351 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::WAITING:\n+        // One byte is enough to transition to KEY.\n+        return 1;\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+\n+        // At this point we have a valid packed decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            m_recv_state = RecvState::VERSION;\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is\n+                // ignored, but can be used for future extensions.\n+                m_recv_state = RecvState::APP;\n+            }\n+            break;\n+        case RecvState::APP:\n+            if (!ignore) {\n+                // Application message decrypted correctly. It can be extracted using GetMessage().\n+                m_recv_state = RecvState::APP_READY;\n+            }\n+            break;\n+        default:\n+            // Any other state is invalid (this function should not have been called).\n+            assert(false);\n+        }\n+        // Wipe the receive buffer where the next packet will be received into.\n+        m_recv_buffer = {};\n+        // In all but APP_READY state, we can wipe the decoded contents.\n+        if (m_recv_state != RecvState::APP_READY) m_recv_decode_buffer = {};\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ReceivedBytes(Span<const uint8_t>& msg_bytes) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    while (!msg_bytes.empty()) {\n+        // Decide how many bytes to copy from msg_bytes to m_recv_buffer.\n+        size_t max_read = GetMaxBytesToProcess();\n+        // Can't read more than provided input.\n+        max_read = std::min<uint32_t>(msg_bytes.size(), max_read);\n+        // Copy data to buffer.\n+        m_recv_buffer.insert(m_recv_buffer.end(), UCharCast(msg_bytes.data()), UCharCast(msg_bytes.data() + max_read));\n+        msg_bytes = msg_bytes.subspan(max_read);\n+\n+        // Process data in the buffer.\n+        switch (m_recv_state) {\n+        case RecvState::WAITING:\n+            if (!m_recv_buffer.empty()) {\n+                m_recv_state = RecvState::KEY;\n+                LOCK(m_send_mutex);\n+                assert(m_send_state == SendState::KEY_WAITING);\n+                m_send_state = SendState::KEY;\n+            }\n+            break;\n+\n+        case RecvState::KEY:\n+            ProcessReceivedKey();\n+            break;\n+\n+        case RecvState::GARB_GARBTERM:\n+            if (!ProcessReceivedGarbage()) return false;\n+            break;\n+\n+        case RecvState::GARBAUTH:\n+        case RecvState::VERSION:\n+        case RecvState::APP:\n+            if (!ProcessReceivedPacket()) return false;\n+            break;\n+\n+        case RecvState::APP_READY:\n+            return true;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+std::optional<std::string> V2Transport::GetMessageType(Span<const uint8_t>& contents) noexcept\n+{\n+    if (contents.size() < 13 || contents[0] != 0) return std::nullopt; // Short encoding not yet supported\n+\n+    size_t msg_type_len{0};\n+    while (msg_type_len < 12 && contents[1 + msg_type_len] != 0) {\n+        if (contents[1 + msg_type_len] < ' ' || contents[1 + msg_type_len] > 0x7F) {\n+            return {};\n+        }\n+        ++msg_type_len;\n+    }\n+    std::string ret{reinterpret_cast<const char*>(contents.data() + 1), msg_type_len};\n+    while (msg_type_len < 12) {\n+        if (contents[1 + msg_type_len] != 0) return {};\n+        ++msg_type_len;\n+    }\n+    contents = contents.subspan(13);\n+    return {std::move(ret)};\n+}\n+\n+CNetMessage V2Transport::GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    assert(m_recv_state == RecvState::APP_READY);\n+    Span<const uint8_t> contents{m_recv_decode_buffer};\n+    auto msg_type = GetMessageType(contents);\n+    CDataStream ret(m_recv_type, m_recv_version);\n+    CNetMessage msg{std::move(ret)};\n+    msg.m_raw_message_size = m_recv_decode_buffer.size() + BIP324Cipher::EXPANSION;\n+    if (msg_type) {\n+        reject_message = false;\n+        msg.m_type = std::move(*msg_type);\n+        msg.m_time = time;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1308061759",
      "id" : 1308061759,
      "line" : 1342,
      "node_id" : "PRRC_kwDOABII585N93A_",
      "original_commit_id" : "f41a1a0ae49c3ada8073edb3c051deaa7534d494",
      "original_line" : 1185,
      "original_position" : 274,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 459,
      "pull_request_review_id" : 1599275947,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308061759/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-28T23:53:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308061759",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1308143623"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308143623"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Good idea. Done (in `V2Transport::ProcessReceivedPacket`, which sees the authentication tags).",
      "commit_id" : "d9344fd5c77e69a544c2d80aa6cbd20827f2e169",
      "created_at" : "2023-08-29T03:02:00Z",
      "diff_hunk" : "@@ -912,6 +912,351 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::WAITING:\n+        // One byte is enough to transition to KEY.\n+        return 1;\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+\n+        // At this point we have a valid packed decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            m_recv_state = RecvState::VERSION;\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is\n+                // ignored, but can be used for future extensions.\n+                m_recv_state = RecvState::APP;\n+            }\n+            break;\n+        case RecvState::APP:\n+            if (!ignore) {\n+                // Application message decrypted correctly. It can be extracted using GetMessage().\n+                m_recv_state = RecvState::APP_READY;\n+            }\n+            break;\n+        default:\n+            // Any other state is invalid (this function should not have been called).\n+            assert(false);\n+        }\n+        // Wipe the receive buffer where the next packet will be received into.\n+        m_recv_buffer = {};\n+        // In all but APP_READY state, we can wipe the decoded contents.\n+        if (m_recv_state != RecvState::APP_READY) m_recv_decode_buffer = {};\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ReceivedBytes(Span<const uint8_t>& msg_bytes) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    while (!msg_bytes.empty()) {\n+        // Decide how many bytes to copy from msg_bytes to m_recv_buffer.\n+        size_t max_read = GetMaxBytesToProcess();\n+        // Can't read more than provided input.\n+        max_read = std::min<uint32_t>(msg_bytes.size(), max_read);\n+        // Copy data to buffer.\n+        m_recv_buffer.insert(m_recv_buffer.end(), UCharCast(msg_bytes.data()), UCharCast(msg_bytes.data() + max_read));\n+        msg_bytes = msg_bytes.subspan(max_read);\n+\n+        // Process data in the buffer.\n+        switch (m_recv_state) {\n+        case RecvState::WAITING:\n+            if (!m_recv_buffer.empty()) {\n+                m_recv_state = RecvState::KEY;\n+                LOCK(m_send_mutex);\n+                assert(m_send_state == SendState::KEY_WAITING);\n+                m_send_state = SendState::KEY;\n+            }\n+            break;\n+\n+        case RecvState::KEY:\n+            ProcessReceivedKey();\n+            break;\n+\n+        case RecvState::GARB_GARBTERM:\n+            if (!ProcessReceivedGarbage()) return false;\n+            break;\n+\n+        case RecvState::GARBAUTH:\n+        case RecvState::VERSION:\n+        case RecvState::APP:\n+            if (!ProcessReceivedPacket()) return false;\n+            break;\n+\n+        case RecvState::APP_READY:\n+            return true;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+std::optional<std::string> V2Transport::GetMessageType(Span<const uint8_t>& contents) noexcept\n+{\n+    if (contents.size() < 13 || contents[0] != 0) return std::nullopt; // Short encoding not yet supported\n+\n+    size_t msg_type_len{0};\n+    while (msg_type_len < 12 && contents[1 + msg_type_len] != 0) {\n+        if (contents[1 + msg_type_len] < ' ' || contents[1 + msg_type_len] > 0x7F) {\n+            return {};\n+        }\n+        ++msg_type_len;\n+    }\n+    std::string ret{reinterpret_cast<const char*>(contents.data() + 1), msg_type_len};\n+    while (msg_type_len < 12) {\n+        if (contents[1 + msg_type_len] != 0) return {};\n+        ++msg_type_len;\n+    }\n+    contents = contents.subspan(13);\n+    return {std::move(ret)};\n+}\n+\n+CNetMessage V2Transport::GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    assert(m_recv_state == RecvState::APP_READY);\n+    Span<const uint8_t> contents{m_recv_decode_buffer};\n+    auto msg_type = GetMessageType(contents);\n+    CDataStream ret(m_recv_type, m_recv_version);\n+    CNetMessage msg{std::move(ret)};\n+    msg.m_raw_message_size = m_recv_decode_buffer.size() + BIP324Cipher::EXPANSION;\n+    if (msg_type) {\n+        reject_message = false;\n+        msg.m_type = std::move(*msg_type);\n+        msg.m_time = time;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1308143623",
      "id" : 1308143623,
      "in_reply_to_id" : 1308061759,
      "line" : 1344,
      "node_id" : "PRRC_kwDOABII585N-LAH",
      "original_commit_id" : "f41a1a0ae49c3ada8073edb3c051deaa7534d494",
      "original_line" : 1344,
      "original_position" : 274,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 461,
      "pull_request_review_id" : 1599399238,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308143623/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-29T03:02:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308143623",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1308716718"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308716718"
         }
      },
      "author_association" : "NONE",
      "body" : "maybe this is for a followup PR, but I think here it is better to print the status of the state, this makes trivial to debug the problem if happens.",
      "commit_id" : "d9344fd5c77e69a544c2d80aa6cbd20827f2e169",
      "created_at" : "2023-08-29T12:08:21Z",
      "diff_hunk" : "@@ -912,6 +912,353 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::WAITING:\n+        // One byte is enough to transition to KEY.\n+        return 1;\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packed decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            m_recv_state = RecvState::VERSION;\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is\n+                // ignored, but can be used for future extensions.\n+                m_recv_state = RecvState::APP;\n+            }\n+            break;\n+        case RecvState::APP:\n+            if (!ignore) {\n+                // Application message decrypted correctly. It can be extracted using GetMessage().\n+                m_recv_state = RecvState::APP_READY;\n+            }\n+            break;\n+        default:\n+            // Any other state is invalid (this function should not have been called).\n+            assert(false);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1308716718",
      "id" : 1308716718,
      "line" : 1217,
      "node_id" : "PRRC_kwDOABII585OAW6u",
      "original_commit_id" : "aa1da1a0ef0504d4f30ab3b101b334e11b8868ac",
      "original_line" : 1098,
      "original_position" : 187,
      "original_start_line" : 1097,
      "path" : "src/net.cpp",
      "position" : 334,
      "pull_request_review_id" : 1600253188,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308716718/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 1216,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-29T12:08:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308716718",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/17150045?v=4",
         "events_url" : "https://api.github.com/users/vincenzopalazzo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vincenzopalazzo/followers",
         "following_url" : "https://api.github.com/users/vincenzopalazzo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vincenzopalazzo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vincenzopalazzo",
         "id" : 17150045,
         "login" : "vincenzopalazzo",
         "node_id" : "MDQ6VXNlcjE3MTUwMDQ1",
         "organizations_url" : "https://api.github.com/users/vincenzopalazzo/orgs",
         "received_events_url" : "https://api.github.com/users/vincenzopalazzo/received_events",
         "repos_url" : "https://api.github.com/users/vincenzopalazzo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vincenzopalazzo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vincenzopalazzo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vincenzopalazzo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1308718127"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308718127"
         }
      },
      "author_association" : "MEMBER",
      "body" : "No, this code is unreachable. If it gets hit, it would be obvious what is wrong.",
      "commit_id" : "d9344fd5c77e69a544c2d80aa6cbd20827f2e169",
      "created_at" : "2023-08-29T12:09:37Z",
      "diff_hunk" : "@@ -912,6 +912,353 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::WAITING:\n+        // One byte is enough to transition to KEY.\n+        return 1;\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packed decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            m_recv_state = RecvState::VERSION;\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is\n+                // ignored, but can be used for future extensions.\n+                m_recv_state = RecvState::APP;\n+            }\n+            break;\n+        case RecvState::APP:\n+            if (!ignore) {\n+                // Application message decrypted correctly. It can be extracted using GetMessage().\n+                m_recv_state = RecvState::APP_READY;\n+            }\n+            break;\n+        default:\n+            // Any other state is invalid (this function should not have been called).\n+            assert(false);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1308718127",
      "id" : 1308718127,
      "in_reply_to_id" : 1308716718,
      "line" : 1217,
      "node_id" : "PRRC_kwDOABII585OAXQv",
      "original_commit_id" : "aa1da1a0ef0504d4f30ab3b101b334e11b8868ac",
      "original_line" : 1098,
      "original_position" : 187,
      "original_start_line" : 1097,
      "path" : "src/net.cpp",
      "position" : 334,
      "pull_request_review_id" : 1600255297,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308718127/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 1216,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-29T12:09:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308718127",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1308731485"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308731485"
         }
      },
      "author_association" : "NONE",
      "body" : "I see now your point, ok make sense",
      "commit_id" : "d9344fd5c77e69a544c2d80aa6cbd20827f2e169",
      "created_at" : "2023-08-29T12:20:02Z",
      "diff_hunk" : "@@ -912,6 +912,353 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::WAITING:\n+        // One byte is enough to transition to KEY.\n+        return 1;\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packed decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            m_recv_state = RecvState::VERSION;\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is\n+                // ignored, but can be used for future extensions.\n+                m_recv_state = RecvState::APP;\n+            }\n+            break;\n+        case RecvState::APP:\n+            if (!ignore) {\n+                // Application message decrypted correctly. It can be extracted using GetMessage().\n+                m_recv_state = RecvState::APP_READY;\n+            }\n+            break;\n+        default:\n+            // Any other state is invalid (this function should not have been called).\n+            assert(false);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1308731485",
      "id" : 1308731485,
      "in_reply_to_id" : 1308716718,
      "line" : 1217,
      "node_id" : "PRRC_kwDOABII585OAahd",
      "original_commit_id" : "aa1da1a0ef0504d4f30ab3b101b334e11b8868ac",
      "original_line" : 1098,
      "original_position" : 187,
      "original_start_line" : 1097,
      "path" : "src/net.cpp",
      "position" : 334,
      "pull_request_review_id" : 1600275509,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308731485/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 1216,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-29T12:20:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308731485",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/17150045?v=4",
         "events_url" : "https://api.github.com/users/vincenzopalazzo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vincenzopalazzo/followers",
         "following_url" : "https://api.github.com/users/vincenzopalazzo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vincenzopalazzo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vincenzopalazzo",
         "id" : 17150045,
         "login" : "vincenzopalazzo",
         "node_id" : "MDQ6VXNlcjE3MTUwMDQ1",
         "organizations_url" : "https://api.github.com/users/vincenzopalazzo/orgs",
         "received_events_url" : "https://api.github.com/users/vincenzopalazzo/received_events",
         "repos_url" : "https://api.github.com/users/vincenzopalazzo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vincenzopalazzo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vincenzopalazzo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vincenzopalazzo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1309329927"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1309329927"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Looks like `SetReceiveVersion` is never used anywhere, neither for V1 nor V2, because the version is set in the respective constructors. Should we just remove it from the `Transport` interface?",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-29T20:38:08Z",
      "diff_hunk" : "@@ -912,6 +912,353 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1309329927",
      "id" : 1309329927,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OCsoH",
      "original_commit_id" : "f7c0be500adeeddba1671b6f4478ce369fc0c6b3",
      "original_line" : 1020,
      "original_position" : 33,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1601240500,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1309329927/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-30T20:03:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1309329927",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1309344192"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1309344192"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "could put some of the magic numbers (13 here and in a few other places like `SetMessageToSend`, 12 in `GetMessageType()`) into  constants or maybe use `CMessageHeader::COMMAND_SIZE`.",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-29T20:53:44Z",
      "diff_hunk" : "@@ -912,6 +912,353 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::WAITING:\n+        // One byte is enough to transition to KEY.\n+        return 1;\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1309344192",
      "id" : 1309344192,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OCwHA",
      "original_commit_id" : "f7c0be500adeeddba1671b6f4478ce369fc0c6b3",
      "original_line" : 1171,
      "original_position" : 141,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1601240500,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1309344192/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-30T20:03:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1309344192",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1309532823"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1309532823"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit-like: For the long encoding processing, it might be worthwhile to advance for one byte in the contents span first, to work with the remaining 12 bytes and avoid the plus ones everywhere below (especially for the array indices in the while loops)?\r\n```suggestion\r\n    contents = contents.subspan(1);\r\n    if (contents.size() < 12) return std::nullopt; // Long encoding needs at least 12 bytes (after the short message id)\r\n```\r\n",
      "commit_id" : "040ea05dae05ef513ac79306dd560c8c1f228942",
      "created_at" : "2023-08-30T02:06:04Z",
      "diff_hunk" : "@@ -1213,7 +1276,22 @@ bool V2Transport::ReceivedBytes(Span<const uint8_t>& msg_bytes) noexcept\n \n std::optional<std::string> V2Transport::GetMessageType(Span<const uint8_t>& contents) noexcept\n {\n-    if (contents.size() < 13 || contents[0] != 0) return std::nullopt; // Short encoding not yet supported\n+    if (contents.size() == 0) return std::nullopt; // Empty contents\n+    uint8_t first_byte = contents[0];\n+\n+    if (first_byte != 0) {\n+        // Short (1 byte) encoding.\n+        if (first_byte < std::size(V2_MESSAGE_IDS)) {\n+            // Valid short message id.\n+            contents = contents.subspan(1);\n+            return V2_MESSAGE_IDS[first_byte];\n+        } else {\n+            // Unknown short message id.\n+            return std::nullopt;\n+        }\n+    }\n+\n+    if (contents.size() < 13) return std::nullopt; // Long encoding needs at least 13 bytes",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1309532823",
      "id" : 1309532823,
      "line" : 1310,
      "node_id" : "PRRC_kwDOABII585ODeKX",
      "original_commit_id" : "8a2e9f6fb909436f3c849c1088a3b79b2cfba119",
      "original_line" : 1310,
      "original_position" : 90,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 427,
      "pull_request_review_id" : 1601752363,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1309532823/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-30T02:28:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1309532823",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1309537403"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1309537403"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: though logically identical with the current code, could be explicit about the fill value of the resize (in contrast to the short message case above, not all of the new elments after the resize are overwritten):\r\n```suggestion\r\n        contents.resize(13 + msg.data.size(), 0);\r\n```",
      "commit_id" : "040ea05dae05ef513ac79306dd560c8c1f228942",
      "created_at" : "2023-08-30T02:12:58Z",
      "diff_hunk" : "@@ -1270,9 +1348,17 @@ bool V2Transport::SetMessageToSend(CSerializedNetMsg& msg) noexcept\n \n     if (m_send_state != SendState::APP_READY) return false;\n     // Construct contents (encoding message type + payload).\n-    std::vector<uint8_t> contents(13 + msg.data.size(), 0);\n-    std::copy(msg.m_type.begin(), msg.m_type.end(), reinterpret_cast<char*>(contents.data() + 1));\n-    std::copy(msg.data.begin(), msg.data.end(), contents.begin() + 13);\n+    std::vector<uint8_t> contents;\n+    auto short_message_id = V2_MESSAGE_MAP(msg.m_type);\n+    if (short_message_id) {\n+        contents.resize(1 + msg.data.size());\n+        contents[0] = *short_message_id;\n+        std::copy(msg.data.begin(), msg.data.end(), contents.begin() + 1);\n+    } else {\n+        contents.resize(13 + msg.data.size());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1309537403",
      "id" : 1309537403,
      "line" : 1374,
      "node_id" : "PRRC_kwDOABII585ODfR7",
      "original_commit_id" : "8a2e9f6fb909436f3c849c1088a3b79b2cfba119",
      "original_line" : 1374,
      "original_position" : 108,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 491,
      "pull_request_review_id" : 1601752363,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1309537403/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-30T02:28:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1309537403",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310237002"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310237002"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: tell doxygen about the parameter (and maybe about the return value):\r\n\r\n```cpp\r\n/**\r\n * Title sentence up to first dot.\r\n * Further elaborate description. Many sentences whatever.\r\n * @param[in] have_next_message Controls whether the \"more\"...\r\n * @return The bytes returned by this function...\r\n */",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-30T12:58:56Z",
      "diff_hunk" : "@@ -320,7 +328,7 @@ class Transport {\n      * Note that m_type and to_send refer to data that is internal to the transport, and calling\n      * any non-const function on this object may invalidate them.\n      */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310237002",
      "id" : 1310237002,
      "line" : 328,
      "node_id" : "PRRC_kwDOABII585OGKFK",
      "original_commit_id" : "040ea05dae05ef513ac79306dd560c8c1f228942",
      "original_line" : 328,
      "original_position" : 34,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 43,
      "pull_request_review_id" : 1602648914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310237002/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T13:28:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310237002",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310277982"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310277982"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "```suggestion\r\n         * A packet is received, and decrypted/verified. If that succeeds, the state becomes APP and the decrypted contents is\r\n```",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-30T13:24:38Z",
      "diff_hunk" : "@@ -416,7 +424,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the contents of the receive buffer. */\n+    enum class RecvState {\n+        /** (Responder only) either v2 public key or v1 header.\n+         *\n+         * This is the initial state for responders, before data has been received to distinguish\n+         * v1 from v2 connections. When that happens, the state becomes either KEY (for v2) or V1\n+         * (for v1). */\n+        KEY_MAYBE_V1,\n+\n+        /** Public key.\n+         *\n+         * This is the initial state for initiators, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, its contents is",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310277982",
      "id" : 1310277982,
      "line" : 467,
      "node_id" : "PRRC_kwDOABII585OGUFe",
      "original_commit_id" : "040ea05dae05ef513ac79306dd560c8c1f228942",
      "original_line" : 467,
      "original_position" : 94,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 119,
      "pull_request_review_id" : 1602648914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310277982/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T13:28:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310277982",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310288598"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310288598"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "```\r\nEnum 'RecvState' uses a larger base type ('int', size: 4 bytes) than necessary for its value set, consider using 'std::uint8_t' (1 byte) as the base type to reduce its size [performance-enum-size]\r\n```\r\n(same for `SendState`)",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-30T13:31:33Z",
      "diff_hunk" : "@@ -416,7 +424,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the contents of the receive buffer. */\n+    enum class RecvState {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310288598",
      "id" : 1310288598,
      "line" : 435,
      "node_id" : "PRRC_kwDOABII585OGWrW",
      "original_commit_id" : "040ea05dae05ef513ac79306dd560c8c1f228942",
      "original_line" : 435,
      "original_position" : 62,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 87,
      "pull_request_review_id" : 1602648914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310288598/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T13:28:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310288598",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310305445"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310305445"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "It would be useful to have a diagram describing the possible state transitions of this state machine:\r\n\r\n```cpp\r\n    /** State type that defines the contents of the receive buffer. Possible transitions:\r\n     * KEY_MAYBE_V1 --> V1                                                   *--------<---------*\r\n     *            |                                                          v                  |\r\n     *            *---> KEY --> GARB_GARBTERM --> GARBAUTH --> VERSION --> APP --> APP_READY -->*\r\n     */\r\n```\r\n\r\n(same for `SendState`)",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-30T13:42:58Z",
      "diff_hunk" : "@@ -416,7 +424,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the contents of the receive buffer. */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310305445",
      "id" : 1310305445,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OGayl",
      "original_commit_id" : "040ea05dae05ef513ac79306dd560c8c1f228942",
      "original_line" : 443,
      "original_position" : 61,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1602648914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310305445/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T13:28:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310305445",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310446507"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310446507"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Good idea, I've rewritten some part of the code here using that approach. Also added more comments.",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-30T15:20:02Z",
      "diff_hunk" : "@@ -1213,7 +1276,22 @@ bool V2Transport::ReceivedBytes(Span<const uint8_t>& msg_bytes) noexcept\n \n std::optional<std::string> V2Transport::GetMessageType(Span<const uint8_t>& contents) noexcept\n {\n-    if (contents.size() < 13 || contents[0] != 0) return std::nullopt; // Short encoding not yet supported\n+    if (contents.size() == 0) return std::nullopt; // Empty contents\n+    uint8_t first_byte = contents[0];\n+\n+    if (first_byte != 0) {\n+        // Short (1 byte) encoding.\n+        if (first_byte < std::size(V2_MESSAGE_IDS)) {\n+            // Valid short message id.\n+            contents = contents.subspan(1);\n+            return V2_MESSAGE_IDS[first_byte];\n+        } else {\n+            // Unknown short message id.\n+            return std::nullopt;\n+        }\n+    }\n+\n+    if (contents.size() < 13) return std::nullopt; // Long encoding needs at least 13 bytes",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310446507",
      "id" : 1310446507,
      "in_reply_to_id" : 1309532823,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OG9Or",
      "original_commit_id" : "8a2e9f6fb909436f3c849c1088a3b79b2cfba119",
      "original_line" : 1310,
      "original_position" : 90,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1602960483,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310446507/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-30T15:20:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310446507",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310446699"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310446699"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done, and added a comment.",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-30T15:20:10Z",
      "diff_hunk" : "@@ -1270,9 +1348,17 @@ bool V2Transport::SetMessageToSend(CSerializedNetMsg& msg) noexcept\n \n     if (m_send_state != SendState::APP_READY) return false;\n     // Construct contents (encoding message type + payload).\n-    std::vector<uint8_t> contents(13 + msg.data.size(), 0);\n-    std::copy(msg.m_type.begin(), msg.m_type.end(), reinterpret_cast<char*>(contents.data() + 1));\n-    std::copy(msg.data.begin(), msg.data.end(), contents.begin() + 13);\n+    std::vector<uint8_t> contents;\n+    auto short_message_id = V2_MESSAGE_MAP(msg.m_type);\n+    if (short_message_id) {\n+        contents.resize(1 + msg.data.size());\n+        contents[0] = *short_message_id;\n+        std::copy(msg.data.begin(), msg.data.end(), contents.begin() + 1);\n+    } else {\n+        contents.resize(13 + msg.data.size());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310446699",
      "id" : 1310446699,
      "in_reply_to_id" : 1309537403,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OG9Rr",
      "original_commit_id" : "8a2e9f6fb909436f3c849c1088a3b79b2cfba119",
      "original_line" : 1374,
      "original_position" : 108,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1602960755,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310446699/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-30T15:20:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310446699",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310647503"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310647503"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: this initially confused me a little; maybe stress that it defines what we are _expecting_ to retrieve from the receive buffer but not necessarily the current content of the receive buffer (which may be empty if we haven't received anything yet, or contain other data if the peer didn't follow the protocol) - this seems like a small difference to the send buffer, where it actually contains the given info when it's in the status.",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-30T18:08:54Z",
      "diff_hunk" : "@@ -427,6 +429,160 @@ class V1Transport final : public Transport\n     size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n };\n \n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the contents of the receive buffer. */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310647503",
      "id" : 1310647503,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OHuTP",
      "original_commit_id" : "de705988c330fc5b3c006337bd72ca0f0c8e2750",
      "original_line" : 443,
      "original_position" : 33,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1601240500,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310647503/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-30T20:03:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310647503",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310685384"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310685384"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "maybe add a comment that `BIP324Cipher::EXPANSION` includes `BIP324Cipher::LENGTH_LEN` - I was wondering at first whether that needed to be accounted for too here until I looked it up.",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-30T18:46:29Z",
      "diff_hunk" : "@@ -912,6 +912,347 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310685384",
      "id" : 1310685384,
      "line" : 1050,
      "node_id" : "PRRC_kwDOABII585OH3jI",
      "original_commit_id" : "de705988c330fc5b3c006337bd72ca0f0c8e2750",
      "original_line" : 1050,
      "original_position" : 60,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 167,
      "pull_request_review_id" : 1601240500,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310685384/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-30T20:03:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310685384",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310694585"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310694585"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "typo: packet",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-30T18:55:41Z",
      "diff_hunk" : "@@ -912,6 +912,347 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packed decrypted into m_recv_decode_buffer. Depending on",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310694585",
      "id" : 1310694585,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OH5y5",
      "original_commit_id" : "de705988c330fc5b3c006337bd72ca0f0c8e2750",
      "original_line" : 1071,
      "original_position" : 160,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1601240500,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310694585/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-30T20:03:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310694585",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310695744"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310695744"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "typo: content",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-30T18:56:47Z",
      "diff_hunk" : "@@ -912,6 +912,347 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packed decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            m_recv_state = RecvState::VERSION;\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310695744",
      "id" : 1310695744,
      "line" : 1199,
      "node_id" : "PRRC_kwDOABII585OH6FA",
      "original_commit_id" : "de705988c330fc5b3c006337bd72ca0f0c8e2750",
      "original_line" : 1199,
      "original_position" : 171,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 316,
      "pull_request_review_id" : 1601240500,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310695744/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-30T20:03:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310695744",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310794366"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310794366"
         }
      },
      "author_association" : "MEMBER",
      "body" : "BIP324 calls it `contents`.",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-30T20:38:05Z",
      "diff_hunk" : "@@ -912,6 +912,347 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packed decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            m_recv_state = RecvState::VERSION;\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310794366",
      "id" : 1310794366,
      "in_reply_to_id" : 1310695744,
      "line" : 1199,
      "node_id" : "PRRC_kwDOABII585OISJ-",
      "original_commit_id" : "de705988c330fc5b3c006337bd72ca0f0c8e2750",
      "original_line" : 1199,
      "original_position" : 171,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 316,
      "pull_request_review_id" : 1603457794,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310794366/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-30T20:38:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310794366",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310794510"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310794510"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-30T20:38:12Z",
      "diff_hunk" : "@@ -912,6 +912,347 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packed decrypted into m_recv_decode_buffer. Depending on",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310794510",
      "id" : 1310794510,
      "in_reply_to_id" : 1310694585,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OISMO",
      "original_commit_id" : "de705988c330fc5b3c006337bd72ca0f0c8e2750",
      "original_line" : 1071,
      "original_position" : 160,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1603457938,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310794510/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-30T20:38:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310794510",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310794587"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310794587"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-30T20:38:18Z",
      "diff_hunk" : "@@ -912,6 +912,347 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310794587",
      "id" : 1310794587,
      "in_reply_to_id" : 1310685384,
      "line" : 1050,
      "node_id" : "PRRC_kwDOABII585OISNb",
      "original_commit_id" : "de705988c330fc5b3c006337bd72ca0f0c8e2750",
      "original_line" : 1050,
      "original_position" : 60,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 167,
      "pull_request_review_id" : 1603458045,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310794587/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-30T20:38:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310794587",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310794782"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310794782"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Expanded the comment a bit.",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-30T20:38:31Z",
      "diff_hunk" : "@@ -427,6 +429,160 @@ class V1Transport final : public Transport\n     size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n };\n \n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the contents of the receive buffer. */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310794782",
      "id" : 1310794782,
      "in_reply_to_id" : 1310647503,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OISQe",
      "original_commit_id" : "de705988c330fc5b3c006337bd72ca0f0c8e2750",
      "original_line" : 443,
      "original_position" : 33,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1603458343,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310794782/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-30T20:38:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310794782",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310795003"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310795003"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've added `CMessageHeader::COMMAND_SIZE` in a bunch of places.",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-30T20:38:45Z",
      "diff_hunk" : "@@ -912,6 +912,353 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::WAITING:\n+        // One byte is enough to transition to KEY.\n+        return 1;\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310795003",
      "id" : 1310795003,
      "in_reply_to_id" : 1309344192,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OIST7",
      "original_commit_id" : "f7c0be500adeeddba1671b6f4478ce369fc0c6b3",
      "original_line" : 1171,
      "original_position" : 141,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1603458652,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310795003/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-30T20:38:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310795003",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310795146"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310795146"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Added a commit to remove it.",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-30T20:38:55Z",
      "diff_hunk" : "@@ -912,6 +912,353 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310795146",
      "id" : 1310795146,
      "in_reply_to_id" : 1309329927,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OISWK",
      "original_commit_id" : "f7c0be500adeeddba1671b6f4478ce369fc0c6b3",
      "original_line" : 1020,
      "original_position" : 33,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1603458871,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310795146/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-30T20:38:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310795146",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311222591"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311222591"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "From your comment https://github.com/bitcoin/bitcoin/pull/28196#issuecomment-1699574611\r\n\r\n> ... both the sender side and receiver side of V2Transport are state machines that are transitioned through, with each state corresponding to the meaning of what is in the respective send/receive buffers. The receive state is changed by receiving bytes, or extracting completed messages. The send state is changed by receiving bytes, sending bytes, or being given a message to send.\r\n\r\nThat would be useful to have as a comment in the source code, somewhere around `RecvState` or `SendState`.",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-31T07:40:17Z",
      "diff_hunk" : "@@ -416,7 +414,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted. */\n+    enum class RecvState {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311222591",
      "id" : 1311222591,
      "line" : 435,
      "node_id" : "PRRC_kwDOABII585OJ6s_",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 435,
      "original_position" : 87,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 87,
      "pull_request_review_id" : 1602648914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311222591/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T13:28:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311222591",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311249370"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311249370"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "What about using `std::optional` to represent \"not on behalf of any message\" instead of `\"\"`?\r\n\r\n```cpp\r\n    using BytesToSend = std::tuple<\r\n        Span<const uint8_t> /*to_send*/,\r\n        bool /*more*/,\r\n        const std::optional<std::string>& /*m_type*/\r\n    >;\r\n...\r\n    /** Type of the message being sent. */\r\n    std::optional<std::string> m_send_type GUARDED_BY(m_send_mutex);\r\n```",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-31T08:02:43Z",
      "diff_hunk" : "@@ -300,7 +299,8 @@ class Transport {\n      *  - Span<const uint8_t> to_send: span of bytes to be sent over the wire (possibly empty).\n      *  - bool more: whether there will be more bytes to be sent after the ones in to_send are\n      *    all sent (as signaled by MarkBytesSent()).\n-     *  - const std::string& m_type: message type on behalf of which this is being sent.\n+     *  - const std::string& m_type: message type on behalf of which this is being sent\n+     *    (\"\" for bytes that are not on behalf of any message).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311249370",
      "id" : 1311249370,
      "line" : 303,
      "node_id" : "PRRC_kwDOABII585OKBPa",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 303,
      "original_position" : 23,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 23,
      "pull_request_review_id" : 1602648914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311249370/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T13:28:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311249370",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311376345"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311376345"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Consider this: https://google.github.io/styleguide/cppguide#Declaration_Order, personally I find it easier to read the interface if that order is followed. Or at least I would avoid two `public:` sections.",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-31T09:43:29Z",
      "diff_hunk" : "@@ -416,7 +414,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311376345",
      "id" : 1311376345,
      "line" : 427,
      "node_id" : "PRRC_kwDOABII585OKgPZ",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 427,
      "original_position" : 79,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 79,
      "pull_request_review_id" : 1602648914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311376345/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T13:28:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311376345",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311381100"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311381100"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "typo and an extra `)`: \r\n```suggestion\r\n     *  m_recv_buffer.size() >= BIP324Cipher::LENGTH_LEN. Unspecified otherwise. */\r\n```",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-31T09:47:43Z",
      "diff_hunk" : "@@ -416,7 +414,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted. */\n+    enum class RecvState {\n+        /** (Responder only) either v2 public key or v1 header.\n+         *\n+         * This is the initial state for responders, before data has been received to distinguish\n+         * v1 from v2 connections. When that happens, the state becomes either KEY (for v2) or V1\n+         * (for v1). */\n+        KEY_MAYBE_V1,\n+\n+        /** Public key.\n+         *\n+         * This is the initial state for initiators, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, its contents is\n+         * interpreted as version negotiation (currently, that means ignoring it, but it can be\n+         * used for negotiating future extensions). If it fails, the connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All receive operations are redirected to m_v1_fallback. m_use_v1 is also set in this\n+         * state, so this redirection can usually happen without needing the m_cs_recv lock. */\n+        V1,\n+    };\n+\n+    /** State type that defines the contents of the send buffer. */\n+    enum class SendState {\n+        /** (Responder only) Public key and garbage.\n+         *\n+         * This is the initial state for responders. The send buffer contains the public key and\n+         * garbage to send, but nothing is sent in this state yet. When the receiver determines\n+         * whether this is a V1 or V2 connection, the sender state becomes KEY_GARB (for v2) or V1\n+         * (for v1) as well.\n+         */\n+        KEY_GARB_MAYBE_V1,\n+\n+        /** Public key and garbage.\n+         *\n+         * This is the initial state for initiators. The public key plus garbage are sent out. When\n+         * the receiver receives the other side's public key and transitions to GARB_GARBTERM, the\n+         * sender state becomes KEY_GARB_GARBTERM_GARBAUTH_VERSION. The key and garbage are left in\n+         * the send buffer when this happens, because they may not have been fully sent out yet. */\n+        KEY_GARB,\n+\n+        /** Public key + garbage + garbage terminator + garbage authenticator + version packet.\n+         *\n+         * This is the state the sender is in after the other side's public key has been received.\n+         * Whatever remains of the public key and garbage are sent, plus garbage terminator,\n+         * authentication packet, and version packet. When all of that is sent, the sender state\n+         * becomes APP_READY. */\n+        KEY_GARB_GARBTERM_GARBAUTH_VERSION,\n+\n+        /** Nothing (an application message to send can be provided).\n+         *\n+         * We're ready to start sending an application message at this point, but none are\n+         * currently provided. Upon SetMessageToSend() the sender state becomes APP. */\n+        APP_READY,\n+\n+        /** Application packet.\n+         *\n+         * There is an encrypted packet encoding an application message in the send buffer right now.\n+         * When it is fully sent, the sender state becomes APP_READY. */\n+        APP,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All send operations are redirected to m_v1_fallback. m_use_v1 is also set in this state,\n+         * so this redirection can usually happen without needing the m_cs_send lock. */\n+        V1,\n+    };\n+\n+    /** Cipher state. */\n+    BIP324Cipher m_cipher;\n+    /** Whether we are the initiator side. */\n+    const bool m_initiating;\n+    /** NodeId (for debug logging). */\n+    const NodeId m_nodeid;\n+    /** Whether the send/receive states are V1. This is an optimization allowing fallback to\n+     *  (typically) work without the m_cs_send or m_cs_recv locks. */\n+    std::atomic<bool> m_use_v1{false};\n+    /** Encapsulate a V1Transport to fall back to. */\n+    V1Transport m_v1_fallback;\n+    /** V1 prefix to look for (4-byte network magic + \"version\\x00\"; magic will be filled in). */\n+    std::array<uint8_t, 12> m_v1_prefix = {0, 0, 0, 0, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00};\n+\n+    /** Lock for receiver-side fields. */\n+    mutable Mutex m_recv_mutex;\n+    /** In {GARBAUTH, VERSION, APP}, the decrypted packet length, if\n+     *  m_recv_buffer.size() >= BIP324::LENGTH_LEN). Unspecified otherwise. */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311381100",
      "id" : 1311381100,
      "line" : 555,
      "node_id" : "PRRC_kwDOABII585OKhZs",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 555,
      "original_position" : 207,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 207,
      "pull_request_review_id" : 1602648914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311381100/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T13:28:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311381100",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311393641"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311393641"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Can be `const`?\r\n```suggestion\r\n    const int m_recv_type GUARDED_BY(m_recv_mutex);\r\n```\r\n\r\nSame for `m_recv_version`.",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-31T09:58:06Z",
      "diff_hunk" : "@@ -416,7 +414,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted. */\n+    enum class RecvState {\n+        /** (Responder only) either v2 public key or v1 header.\n+         *\n+         * This is the initial state for responders, before data has been received to distinguish\n+         * v1 from v2 connections. When that happens, the state becomes either KEY (for v2) or V1\n+         * (for v1). */\n+        KEY_MAYBE_V1,\n+\n+        /** Public key.\n+         *\n+         * This is the initial state for initiators, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, its contents is\n+         * interpreted as version negotiation (currently, that means ignoring it, but it can be\n+         * used for negotiating future extensions). If it fails, the connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All receive operations are redirected to m_v1_fallback. m_use_v1 is also set in this\n+         * state, so this redirection can usually happen without needing the m_cs_recv lock. */\n+        V1,\n+    };\n+\n+    /** State type that defines the contents of the send buffer. */\n+    enum class SendState {\n+        /** (Responder only) Public key and garbage.\n+         *\n+         * This is the initial state for responders. The send buffer contains the public key and\n+         * garbage to send, but nothing is sent in this state yet. When the receiver determines\n+         * whether this is a V1 or V2 connection, the sender state becomes KEY_GARB (for v2) or V1\n+         * (for v1) as well.\n+         */\n+        KEY_GARB_MAYBE_V1,\n+\n+        /** Public key and garbage.\n+         *\n+         * This is the initial state for initiators. The public key plus garbage are sent out. When\n+         * the receiver receives the other side's public key and transitions to GARB_GARBTERM, the\n+         * sender state becomes KEY_GARB_GARBTERM_GARBAUTH_VERSION. The key and garbage are left in\n+         * the send buffer when this happens, because they may not have been fully sent out yet. */\n+        KEY_GARB,\n+\n+        /** Public key + garbage + garbage terminator + garbage authenticator + version packet.\n+         *\n+         * This is the state the sender is in after the other side's public key has been received.\n+         * Whatever remains of the public key and garbage are sent, plus garbage terminator,\n+         * authentication packet, and version packet. When all of that is sent, the sender state\n+         * becomes APP_READY. */\n+        KEY_GARB_GARBTERM_GARBAUTH_VERSION,\n+\n+        /** Nothing (an application message to send can be provided).\n+         *\n+         * We're ready to start sending an application message at this point, but none are\n+         * currently provided. Upon SetMessageToSend() the sender state becomes APP. */\n+        APP_READY,\n+\n+        /** Application packet.\n+         *\n+         * There is an encrypted packet encoding an application message in the send buffer right now.\n+         * When it is fully sent, the sender state becomes APP_READY. */\n+        APP,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All send operations are redirected to m_v1_fallback. m_use_v1 is also set in this state,\n+         * so this redirection can usually happen without needing the m_cs_send lock. */\n+        V1,\n+    };\n+\n+    /** Cipher state. */\n+    BIP324Cipher m_cipher;\n+    /** Whether we are the initiator side. */\n+    const bool m_initiating;\n+    /** NodeId (for debug logging). */\n+    const NodeId m_nodeid;\n+    /** Whether the send/receive states are V1. This is an optimization allowing fallback to\n+     *  (typically) work without the m_cs_send or m_cs_recv locks. */\n+    std::atomic<bool> m_use_v1{false};\n+    /** Encapsulate a V1Transport to fall back to. */\n+    V1Transport m_v1_fallback;\n+    /** V1 prefix to look for (4-byte network magic + \"version\\x00\"; magic will be filled in). */\n+    std::array<uint8_t, 12> m_v1_prefix = {0, 0, 0, 0, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00};\n+\n+    /** Lock for receiver-side fields. */\n+    mutable Mutex m_recv_mutex;\n+    /** In {GARBAUTH, VERSION, APP}, the decrypted packet length, if\n+     *  m_recv_buffer.size() >= BIP324::LENGTH_LEN). Unspecified otherwise. */\n+    uint32_t m_recv_len GUARDED_BY(m_recv_mutex) {0};\n+    /** Receive buffer; meaning is determined by m_recv_state. */\n+    std::vector<uint8_t> m_recv_buffer GUARDED_BY(m_recv_mutex);\n+    /** During GARBAUTH, the garbage received during GARB_GARBTERM. */\n+    std::vector<uint8_t> m_recv_garbage GUARDED_BY(m_recv_mutex);\n+    /** Buffer to put decrypted contents in, for converting to CNetMessage. */\n+    std::vector<uint8_t> m_recv_decode_buffer GUARDED_BY(m_recv_mutex);\n+    /** Deserialization type. */\n+    int m_recv_type GUARDED_BY(m_recv_mutex);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311393641",
      "id" : 1311393641,
      "line" : 564,
      "node_id" : "PRRC_kwDOABII585OKkdp",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 564,
      "original_position" : 216,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 216,
      "pull_request_review_id" : 1602648914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311393641/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T13:28:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311393641",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311402373"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311402373"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In some places `uint8_t` is used and in some other `std::byte`. I guess they are used interchangeably? Maybe for consistency use just one of them everywhere.",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-31T10:05:18Z",
      "diff_hunk" : "@@ -416,7 +414,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted. */\n+    enum class RecvState {\n+        /** (Responder only) either v2 public key or v1 header.\n+         *\n+         * This is the initial state for responders, before data has been received to distinguish\n+         * v1 from v2 connections. When that happens, the state becomes either KEY (for v2) or V1\n+         * (for v1). */\n+        KEY_MAYBE_V1,\n+\n+        /** Public key.\n+         *\n+         * This is the initial state for initiators, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, its contents is\n+         * interpreted as version negotiation (currently, that means ignoring it, but it can be\n+         * used for negotiating future extensions). If it fails, the connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All receive operations are redirected to m_v1_fallback. m_use_v1 is also set in this\n+         * state, so this redirection can usually happen without needing the m_cs_recv lock. */\n+        V1,\n+    };\n+\n+    /** State type that defines the contents of the send buffer. */\n+    enum class SendState {\n+        /** (Responder only) Public key and garbage.\n+         *\n+         * This is the initial state for responders. The send buffer contains the public key and\n+         * garbage to send, but nothing is sent in this state yet. When the receiver determines\n+         * whether this is a V1 or V2 connection, the sender state becomes KEY_GARB (for v2) or V1\n+         * (for v1) as well.\n+         */\n+        KEY_GARB_MAYBE_V1,\n+\n+        /** Public key and garbage.\n+         *\n+         * This is the initial state for initiators. The public key plus garbage are sent out. When\n+         * the receiver receives the other side's public key and transitions to GARB_GARBTERM, the\n+         * sender state becomes KEY_GARB_GARBTERM_GARBAUTH_VERSION. The key and garbage are left in\n+         * the send buffer when this happens, because they may not have been fully sent out yet. */\n+        KEY_GARB,\n+\n+        /** Public key + garbage + garbage terminator + garbage authenticator + version packet.\n+         *\n+         * This is the state the sender is in after the other side's public key has been received.\n+         * Whatever remains of the public key and garbage are sent, plus garbage terminator,\n+         * authentication packet, and version packet. When all of that is sent, the sender state\n+         * becomes APP_READY. */\n+        KEY_GARB_GARBTERM_GARBAUTH_VERSION,\n+\n+        /** Nothing (an application message to send can be provided).\n+         *\n+         * We're ready to start sending an application message at this point, but none are\n+         * currently provided. Upon SetMessageToSend() the sender state becomes APP. */\n+        APP_READY,\n+\n+        /** Application packet.\n+         *\n+         * There is an encrypted packet encoding an application message in the send buffer right now.\n+         * When it is fully sent, the sender state becomes APP_READY. */\n+        APP,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All send operations are redirected to m_v1_fallback. m_use_v1 is also set in this state,\n+         * so this redirection can usually happen without needing the m_cs_send lock. */\n+        V1,\n+    };\n+\n+    /** Cipher state. */\n+    BIP324Cipher m_cipher;\n+    /** Whether we are the initiator side. */\n+    const bool m_initiating;\n+    /** NodeId (for debug logging). */\n+    const NodeId m_nodeid;\n+    /** Whether the send/receive states are V1. This is an optimization allowing fallback to\n+     *  (typically) work without the m_cs_send or m_cs_recv locks. */\n+    std::atomic<bool> m_use_v1{false};\n+    /** Encapsulate a V1Transport to fall back to. */\n+    V1Transport m_v1_fallback;\n+    /** V1 prefix to look for (4-byte network magic + \"version\\x00\"; magic will be filled in). */\n+    std::array<uint8_t, 12> m_v1_prefix = {0, 0, 0, 0, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00};\n+\n+    /** Lock for receiver-side fields. */\n+    mutable Mutex m_recv_mutex;\n+    /** In {GARBAUTH, VERSION, APP}, the decrypted packet length, if\n+     *  m_recv_buffer.size() >= BIP324::LENGTH_LEN). Unspecified otherwise. */\n+    uint32_t m_recv_len GUARDED_BY(m_recv_mutex) {0};\n+    /** Receive buffer; meaning is determined by m_recv_state. */\n+    std::vector<uint8_t> m_recv_buffer GUARDED_BY(m_recv_mutex);\n+    /** During GARBAUTH, the garbage received during GARB_GARBTERM. */\n+    std::vector<uint8_t> m_recv_garbage GUARDED_BY(m_recv_mutex);\n+    /** Buffer to put decrypted contents in, for converting to CNetMessage. */\n+    std::vector<uint8_t> m_recv_decode_buffer GUARDED_BY(m_recv_mutex);\n+    /** Deserialization type. */\n+    int m_recv_type GUARDED_BY(m_recv_mutex);\n+    /** Deserialization version number. */\n+    int m_recv_version GUARDED_BY(m_recv_mutex);\n+    /** Current receiver state. */\n+    RecvState m_recv_state GUARDED_BY(m_recv_mutex);\n+\n+    /** Lock for sending-side fields. */\n+    mutable Mutex m_send_mutex;\n+    /** The send buffer; meaning is determined by m_send_state. */\n+    std::vector<uint8_t> m_send_buffer GUARDED_BY(m_send_mutex);\n+    /** How many bytes from the send buffer have been sent so far. */\n+    uint32_t m_send_pos GUARDED_BY(m_send_mutex) {0};\n+    /** Type of the message being sent. */\n+    std::string m_send_type GUARDED_BY(m_send_mutex);\n+    /** Current sender state. */\n+    SendState m_send_state GUARDED_BY(m_send_mutex);\n+\n+    /** Given a packet's contents, find the message type (if valid), and strip it from contents. */\n+    static std::optional<std::string> GetMessageType(Span<const uint8_t>& contents) noexcept;\n+    /** Determine how many received bytes can be processed in one go (not allowed in V1 state). */\n+    size_t GetMaxBytesToProcess() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex);\n+    /** Process m_recv_buffer in KEY_MAYBE_V1 state. */\n+    void ProcessReceivedMaybeV1() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex, !m_send_mutex);\n+    /** Process m_recv_buffer in KEY state. */\n+    void ProcessReceivedKey() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex, !m_send_mutex);\n+    /** Process m_recv_buffer in GARB_GARBTERM state. */\n+    bool ProcessReceivedGarbage() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex);\n+    /** Process m_recv_buffer in GARBAUTH/VERSION/APP state. */\n+    bool ProcessReceivedPacket() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex);\n+\n+public:\n+\n+    /** Construct a V2 transport with securely generated random keys. */\n+    V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept;\n+    /** Construct a V2 transport with specified keys and garbage (test use only). */\n+    V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311402373",
      "id" : 1311402373,
      "line" : 599,
      "node_id" : "PRRC_kwDOABII585OKmmF",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 599,
      "original_position" : 251,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 251,
      "pull_request_review_id" : 1602648914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311402373/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T13:28:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311402373",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311460423"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311460423"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "It is not immediately obvious whether these subtractions can go negative. Should this be handled? Or if it cannot happen, then an assert/assume?",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-31T10:59:13Z",
      "diff_hunk" : "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311460423",
      "id" : 1311460423,
      "line" : 1034,
      "node_id" : "PRRC_kwDOABII585OK0xH",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 1034,
      "original_position" : 151,
      "original_start_line" : 1029,
      "path" : "src/net.cpp",
      "position" : 151,
      "pull_request_review_id" : 1602648914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311460423/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 1029,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-31T13:28:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311460423",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311500825"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311500825"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Maybe expand the comments with something like this:\r\n\r\nTo avoid deadlocks, if both `m_recv_mutex` and `m_send_mutex` have to be locked at the same time, always lock `m_recv_mutex` first. I.e. when locking `m_recv_mutex`, make sure that `m_send_mutex` is not already locked by the calling thread.",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-31T11:39:13Z",
      "diff_hunk" : "@@ -416,7 +414,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted. */\n+    enum class RecvState {\n+        /** (Responder only) either v2 public key or v1 header.\n+         *\n+         * This is the initial state for responders, before data has been received to distinguish\n+         * v1 from v2 connections. When that happens, the state becomes either KEY (for v2) or V1\n+         * (for v1). */\n+        KEY_MAYBE_V1,\n+\n+        /** Public key.\n+         *\n+         * This is the initial state for initiators, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, its contents is\n+         * interpreted as version negotiation (currently, that means ignoring it, but it can be\n+         * used for negotiating future extensions). If it fails, the connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All receive operations are redirected to m_v1_fallback. m_use_v1 is also set in this\n+         * state, so this redirection can usually happen without needing the m_cs_recv lock. */\n+        V1,\n+    };\n+\n+    /** State type that defines the contents of the send buffer. */\n+    enum class SendState {\n+        /** (Responder only) Public key and garbage.\n+         *\n+         * This is the initial state for responders. The send buffer contains the public key and\n+         * garbage to send, but nothing is sent in this state yet. When the receiver determines\n+         * whether this is a V1 or V2 connection, the sender state becomes KEY_GARB (for v2) or V1\n+         * (for v1) as well.\n+         */\n+        KEY_GARB_MAYBE_V1,\n+\n+        /** Public key and garbage.\n+         *\n+         * This is the initial state for initiators. The public key plus garbage are sent out. When\n+         * the receiver receives the other side's public key and transitions to GARB_GARBTERM, the\n+         * sender state becomes KEY_GARB_GARBTERM_GARBAUTH_VERSION. The key and garbage are left in\n+         * the send buffer when this happens, because they may not have been fully sent out yet. */\n+        KEY_GARB,\n+\n+        /** Public key + garbage + garbage terminator + garbage authenticator + version packet.\n+         *\n+         * This is the state the sender is in after the other side's public key has been received.\n+         * Whatever remains of the public key and garbage are sent, plus garbage terminator,\n+         * authentication packet, and version packet. When all of that is sent, the sender state\n+         * becomes APP_READY. */\n+        KEY_GARB_GARBTERM_GARBAUTH_VERSION,\n+\n+        /** Nothing (an application message to send can be provided).\n+         *\n+         * We're ready to start sending an application message at this point, but none are\n+         * currently provided. Upon SetMessageToSend() the sender state becomes APP. */\n+        APP_READY,\n+\n+        /** Application packet.\n+         *\n+         * There is an encrypted packet encoding an application message in the send buffer right now.\n+         * When it is fully sent, the sender state becomes APP_READY. */\n+        APP,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All send operations are redirected to m_v1_fallback. m_use_v1 is also set in this state,\n+         * so this redirection can usually happen without needing the m_cs_send lock. */\n+        V1,\n+    };\n+\n+    /** Cipher state. */\n+    BIP324Cipher m_cipher;\n+    /** Whether we are the initiator side. */\n+    const bool m_initiating;\n+    /** NodeId (for debug logging). */\n+    const NodeId m_nodeid;\n+    /** Whether the send/receive states are V1. This is an optimization allowing fallback to\n+     *  (typically) work without the m_cs_send or m_cs_recv locks. */\n+    std::atomic<bool> m_use_v1{false};\n+    /** Encapsulate a V1Transport to fall back to. */\n+    V1Transport m_v1_fallback;\n+    /** V1 prefix to look for (4-byte network magic + \"version\\x00\"; magic will be filled in). */\n+    std::array<uint8_t, 12> m_v1_prefix = {0, 0, 0, 0, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00};\n+\n+    /** Lock for receiver-side fields. */\n+    mutable Mutex m_recv_mutex;\n+    /** In {GARBAUTH, VERSION, APP}, the decrypted packet length, if\n+     *  m_recv_buffer.size() >= BIP324::LENGTH_LEN). Unspecified otherwise. */\n+    uint32_t m_recv_len GUARDED_BY(m_recv_mutex) {0};\n+    /** Receive buffer; meaning is determined by m_recv_state. */\n+    std::vector<uint8_t> m_recv_buffer GUARDED_BY(m_recv_mutex);\n+    /** During GARBAUTH, the garbage received during GARB_GARBTERM. */\n+    std::vector<uint8_t> m_recv_garbage GUARDED_BY(m_recv_mutex);\n+    /** Buffer to put decrypted contents in, for converting to CNetMessage. */\n+    std::vector<uint8_t> m_recv_decode_buffer GUARDED_BY(m_recv_mutex);\n+    /** Deserialization type. */\n+    int m_recv_type GUARDED_BY(m_recv_mutex);\n+    /** Deserialization version number. */\n+    int m_recv_version GUARDED_BY(m_recv_mutex);\n+    /** Current receiver state. */\n+    RecvState m_recv_state GUARDED_BY(m_recv_mutex);\n+\n+    /** Lock for sending-side fields. */\n+    mutable Mutex m_send_mutex;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311500825",
      "id" : 1311500825,
      "line" : 571,
      "node_id" : "PRRC_kwDOABII585OK-oZ",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 571,
      "original_position" : 223,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 223,
      "pull_request_review_id" : 1602648914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311500825/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T13:28:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311500825",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311508831"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311508831"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This is doing an extra copy of the key - first from the buffer to the array and then from the array to `m_cipher.m_pubkey`. Is it possible to avoid that? Is it possible to initialize `m_cipher.m_pubkey` directly from the buffer? I think it is ok to take vector in `EllSwiftPubKey` and document that its size must be `EllSwiftPubKey::size()` and assert that it is indeed.",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-31T11:47:02Z",
      "diff_hunk" : "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311508831",
      "id" : 1311508831,
      "line" : 1106,
      "node_id" : "PRRC_kwDOABII585OLAlf",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 1106,
      "original_position" : 223,
      "original_start_line" : 1103,
      "path" : "src/net.cpp",
      "position" : 223,
      "pull_request_review_id" : 1602648914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311508831/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 1103,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-31T13:28:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311508831",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311514245"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311514245"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "It would be good to enforce the state machine allowed transitions - in all places that change the state, assert that such transition is allowed. In this case: `assert(m_recv_state == RecvState::KEY)`. Or maybe have `m_recv_state` be a class that enforces correctness internally and is then called like:\r\n\r\n```cpp\r\nm_recv_state.ChangeTo(RecvState::GARB_GARBTERM);\r\n```",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-31T11:52:16Z",
      "diff_hunk" : "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311514245",
      "id" : 1311514245,
      "line" : 1109,
      "node_id" : "PRRC_kwDOABII585OLB6F",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 1109,
      "original_position" : 226,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 226,
      "pull_request_review_id" : 1602648914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311514245/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T13:28:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311514245",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311548994"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311548994"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "What about changing that `==` to `>=`? Otherwise, if it somehow happens that the buffer is larger, then this safety check will never catch it and it will keep receiving \"forever\".",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-31T12:24:14Z",
      "diff_hunk" : "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARB_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        size_t garbage_len = m_send_buffer.size() - EllSwiftPubKey::size();\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer (using the garbage data which\n+        // already there).\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            MakeByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size(), garbage_len),\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311548994",
      "id" : 1311548994,
      "line" : 1149,
      "node_id" : "PRRC_kwDOABII585OLKZC",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 1149,
      "original_position" : 266,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 266,
      "pull_request_review_id" : 1602648914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311548994/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T13:28:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311548994",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311553670"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311553670"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Would be nice if at the start of the function, or just before `m_recv_state = ...` there is something like `assert(current state is xyz);`",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-31T12:28:18Z",
      "diff_hunk" : "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARB_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        size_t garbage_len = m_send_buffer.size() - EllSwiftPubKey::size();\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer (using the garbage data which\n+        // already there).\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            MakeByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size(), garbage_len),\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311553670",
      "id" : 1311553670,
      "line" : 1148,
      "node_id" : "PRRC_kwDOABII585OLLiG",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 1148,
      "original_position" : 265,
      "original_start_line" : 1139,
      "path" : "src/net.cpp",
      "position" : 265,
      "pull_request_review_id" : 1602648914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311553670/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 1139,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-31T13:28:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311553670",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311560086"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311560086"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "```suggestion\r\n        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\r\n        const auto max = std::min(MAX_SIZE, MAX_PROTOCOL_MESSAGE_LENGTH) + 1 /* what is this? */ + CMessageHeader::COMMAND_SIZE;\r\n        if (m_recv_len > max) {\r\n            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes > %u), peer=%d\\n\", m_recv_len, max, m_nodeid);\r\n```",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-31T12:33:51Z",
      "diff_hunk" : "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARB_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        size_t garbage_len = m_send_buffer.size() - EllSwiftPubKey::size();\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer (using the garbage data which\n+        // already there).\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            MakeByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size(), garbage_len),\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 1 + CMessageHeader::COMMAND_SIZE ||\n+            m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 1 + CMessageHeader::COMMAND_SIZE) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311560086",
      "id" : 1311560086,
      "line" : 1167,
      "node_id" : "PRRC_kwDOABII585OLNGW",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 1167,
      "original_position" : 284,
      "original_start_line" : 1164,
      "path" : "src/net.cpp",
      "position" : 284,
      "pull_request_review_id" : 1602648914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311560086/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 1164,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-31T13:28:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311560086",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311568129"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311568129"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Is it possible that this branch executes before the one above? If the buffer is less than `LENGTH_LEN` (3) and then on the next invocation of this method, it is greater than `LENGTH_LEN` (3), equal to `EXPANSION` (20)?\r\n\r\nEdit: that's not possible currently. It relies on\r\n1. this method being called only if `m_recv_state` is one of `GARBAUTH`, `VERSION`, `APP` and\r\n2. `GetMaxBytesToProcess()` working correctly\r\n\r\nthat's a bit remote from the point of view inside this function. Maybe add assert or assume to ensure that?",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-31T12:40:31Z",
      "diff_hunk" : "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARB_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        size_t garbage_len = m_send_buffer.size() - EllSwiftPubKey::size();\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer (using the garbage data which\n+        // already there).\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            MakeByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size(), garbage_len),\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 1 + CMessageHeader::COMMAND_SIZE ||\n+            m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 1 + CMessageHeader::COMMAND_SIZE) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311568129",
      "id" : 1311568129,
      "line" : 1170,
      "node_id" : "PRRC_kwDOABII585OLPEB",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 1170,
      "original_position" : 287,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 287,
      "pull_request_review_id" : 1602648914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311568129/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T13:36:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311568129",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311613938"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311613938"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "The cast seems unnecessary?\r\n```suggestion\r\n        std::copy(msg.m_type.begin(), msg.m_type.end(), contents.data() + 1);\r\n        std::copy(msg.data.begin(), msg.data.end(), contents.begin() + 1 + CMessageHeader::COMMAND_SIZE);\r\n```",
      "commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "created_at" : "2023-08-31T13:16:22Z",
      "diff_hunk" : "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARB_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        size_t garbage_len = m_send_buffer.size() - EllSwiftPubKey::size();\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer (using the garbage data which\n+        // already there).\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            MakeByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size(), garbage_len),\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 1 + CMessageHeader::COMMAND_SIZE ||\n+            m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 1 + CMessageHeader::COMMAND_SIZE) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packet decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            m_recv_state = RecvState::VERSION;\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is\n+                // ignored, but can be used for future extensions.\n+                m_recv_state = RecvState::APP;\n+            }\n+            break;\n+        case RecvState::APP:\n+            if (!ignore) {\n+                // Application message decrypted correctly. It can be extracted using GetMessage().\n+                m_recv_state = RecvState::APP_READY;\n+            }\n+            break;\n+        default:\n+            // Any other state is invalid (this function should not have been called).\n+            assert(false);\n+        }\n+        // Wipe the receive buffer where the next packet will be received into.\n+        m_recv_buffer = {};\n+        // In all but APP_READY state, we can wipe the decoded contents.\n+        if (m_recv_state != RecvState::APP_READY) m_recv_decode_buffer = {};\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ReceivedBytes(Span<const uint8_t>& msg_bytes) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    /** How many bytes to allocate in the receive buffer at most above what is received so far. */\n+    static constexpr size_t MAX_RESERVE_AHEAD = 250000;\n+\n+    if (m_use_v1) return m_v1_fallback.ReceivedBytes(msg_bytes);\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedBytes(msg_bytes);\n+\n+    while (!msg_bytes.empty()) {\n+        // Decide how many bytes to copy from msg_bytes to m_recv_buffer.\n+        size_t max_read = GetMaxBytesToProcess();\n+        // Reserve space in the buffer.\n+        if (m_recv_state == RecvState::KEY_MAYBE_V1 || m_recv_state == RecvState::KEY ||\n+            m_recv_state == RecvState::GARB_GARBTERM) {\n+            // During the initial states (key/garbage), allocate once to fit the maximum (4111\n+            // bytes).\n+            m_recv_buffer.reserve(MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        } else if (m_recv_state == RecvState::GARBAUTH || m_recv_state == RecvState::VERSION ||\n+            m_recv_state == RecvState::APP) {\n+            // During states where a packet is being received, as much as is expected but never\n+            // more than MAX_RESERVE_AHEAD bytes in addition to what is received so far.\n+            size_t alloc_add = std::min(max_read, msg_bytes.size() + MAX_RESERVE_AHEAD);\n+            m_recv_buffer.reserve(m_recv_buffer.size() + alloc_add);\n+        }\n+        // Can't read more than provided input.\n+        max_read = std::min<uint32_t>(msg_bytes.size(), max_read);\n+        // Copy data to buffer.\n+        m_recv_buffer.insert(m_recv_buffer.end(), UCharCast(msg_bytes.data()), UCharCast(msg_bytes.data() + max_read));\n+        msg_bytes = msg_bytes.subspan(max_read);\n+\n+        // Process data in the buffer.\n+        switch (m_recv_state) {\n+        case RecvState::KEY_MAYBE_V1:\n+            ProcessReceivedMaybeV1();\n+            if (m_recv_state == RecvState::V1) return true;\n+            break;\n+\n+        case RecvState::KEY:\n+            ProcessReceivedKey();\n+            break;\n+\n+        case RecvState::GARB_GARBTERM:\n+            if (!ProcessReceivedGarbage()) return false;\n+            break;\n+\n+        case RecvState::GARBAUTH:\n+        case RecvState::VERSION:\n+        case RecvState::APP:\n+            if (!ProcessReceivedPacket()) return false;\n+            break;\n+\n+        case RecvState::APP_READY:\n+            return true;\n+\n+        case RecvState::V1:\n+            // We should have bailed out before.\n+            assert(false);\n+            break;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+std::optional<std::string> V2Transport::GetMessageType(Span<const uint8_t>& contents) noexcept\n+{\n+    if (contents.size() == 0) return std::nullopt; // Empty contents\n+    uint8_t first_byte = contents[0];\n+    contents = contents.subspan(1); // Strip first byte.\n+\n+    if (first_byte != 0) {\n+        // Short (1 byte) encoding.\n+        if (first_byte < std::size(V2_MESSAGE_IDS)) {\n+            // Valid short message id.\n+            return V2_MESSAGE_IDS[first_byte];\n+        } else {\n+            // Unknown short message id.\n+            return std::nullopt;\n+        }\n+    }\n+\n+    if (contents.size() < CMessageHeader::COMMAND_SIZE) {\n+        return std::nullopt; // Long encoding needs 12 message type bytes.\n+    }\n+\n+    size_t msg_type_len{0};\n+    while (msg_type_len < CMessageHeader::COMMAND_SIZE && contents[msg_type_len] != 0) {\n+        // Verify that message type bytes before the first 0x00 are in range.\n+        if (contents[msg_type_len] < ' ' || contents[msg_type_len] > 0x7F) {\n+            return {};\n+        }\n+        ++msg_type_len;\n+    }\n+    std::string ret{reinterpret_cast<const char*>(contents.data()), msg_type_len};\n+    while (msg_type_len < CMessageHeader::COMMAND_SIZE) {\n+        // Verify that message type bytes after the first 0x00 are also 0x00.\n+        if (contents[msg_type_len] != 0) return {};\n+        ++msg_type_len;\n+    }\n+    // Strip message type bytes of contents.\n+    contents = contents.subspan(CMessageHeader::COMMAND_SIZE);\n+    return {std::move(ret)};\n+}\n+\n+CNetMessage V2Transport::GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.GetReceivedMessage(time, reject_message);\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.GetReceivedMessage(time, reject_message);\n+\n+    assert(m_recv_state == RecvState::APP_READY);\n+    Span<const uint8_t> contents{m_recv_decode_buffer};\n+    auto msg_type = GetMessageType(contents);\n+    CDataStream ret(m_recv_type, m_recv_version);\n+    CNetMessage msg{std::move(ret)};\n+    msg.m_raw_message_size = m_recv_decode_buffer.size() + BIP324Cipher::EXPANSION;\n+    if (msg_type) {\n+        reject_message = false;\n+        msg.m_type = std::move(*msg_type);\n+        msg.m_time = time;\n+        msg.m_message_size = contents.size();\n+        msg.m_recv.resize(contents.size());\n+        std::copy(contents.begin(), contents.end(), UCharCast(msg.m_recv.data()));\n+    } else {\n+        LogPrint(BCLog::NET, \"V2 transport error: invalid message type (%u bytes contents), peer=%d\\n\", m_recv_decode_buffer.size(), m_nodeid);\n+        reject_message = true;\n+    }\n+    m_recv_decode_buffer = {};\n+    m_recv_state = RecvState::APP;\n+\n+    return msg;\n+}\n+\n+bool V2Transport::SetMessageToSend(CSerializedNetMsg& msg) noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_use_v1) return m_v1_fallback.SetMessageToSend(msg);\n+    LOCK(m_send_mutex);\n+    if (m_send_state == SendState::V1) return m_v1_fallback.SetMessageToSend(msg);\n+\n+    if (m_send_state != SendState::APP_READY) return false;\n+    // Construct contents (encoding message type + payload).\n+    std::vector<uint8_t> contents;\n+    auto short_message_id = V2_MESSAGE_MAP(msg.m_type);\n+    if (short_message_id) {\n+        contents.resize(1 + msg.data.size());\n+        contents[0] = *short_message_id;\n+        std::copy(msg.data.begin(), msg.data.end(), contents.begin() + 1);\n+    } else {\n+        // Initialize with zeroes, and then write the message type string starting at offset 0.\n+        // This means contents[0] and the unused positions in contents[1..13] remain 0x00.\n+        contents.resize(1 + CMessageHeader::COMMAND_SIZE + msg.data.size(), 0);\n+        std::copy(msg.m_type.begin(), msg.m_type.end(), reinterpret_cast<char*>(contents.data() + 1));\n+        std::copy(msg.data.begin(), msg.data.end(), contents.begin() + 1 + CMessageHeader::COMMAND_SIZE);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311613938",
      "id" : 1311613938,
      "line" : 1378,
      "node_id" : "PRRC_kwDOABII585OLaPy",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 1378,
      "original_position" : 495,
      "original_start_line" : 1377,
      "path" : "src/net.cpp",
      "position" : 495,
      "pull_request_review_id" : 1602648914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311613938/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 1377,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-31T13:28:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311613938",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311986162"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311986162"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The `m_type` value is really only used to control the breakdown statistics of bytes sent/received per message type in the `getpeerinfo` RPC. We need string categories there, so it seems to me really the question is what category name to use for bytes not assignable to a specific message type. `\"\"` seems to be as good as any, so all this suggestion would entail is having a more complex `m_type` in `BytesToSend`, and logic in the RPC code to turn `std::nullopt` into `\"\"`. I don't think that improves much.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T17:45:22Z",
      "diff_hunk" : "@@ -300,7 +299,8 @@ class Transport {\n      *  - Span<const uint8_t> to_send: span of bytes to be sent over the wire (possibly empty).\n      *  - bool more: whether there will be more bytes to be sent after the ones in to_send are\n      *    all sent (as signaled by MarkBytesSent()).\n-     *  - const std::string& m_type: message type on behalf of which this is being sent.\n+     *  - const std::string& m_type: message type on behalf of which this is being sent\n+     *    (\"\" for bytes that are not on behalf of any message).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311986162",
      "id" : 1311986162,
      "in_reply_to_id" : 1311249370,
      "line" : 303,
      "node_id" : "PRRC_kwDOABII585OM1Hy",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 303,
      "original_position" : 23,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 23,
      "pull_request_review_id" : 1605335997,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311986162/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T17:45:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311986162",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312001695"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312001695"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The conflict is due to the fact that most of the cryptography code (at least the part used by V2Transport, directly and indirectly) has been converted to be entirely `Span<std::byte>`-based, while the network/serialization code is still mostly (`Span<uint8_t>` and `(uint8_t* data, size_t size)`-based). In `V2Transport` we interact with both, which means some silly conversions.\r\n\r\nI've opted not to try to convert the network/serialize code here to `Span<std::byte>` (as that's a bigger, and probably longer-term effort, though I do expect that to happen eventually), and as a result the internal `V2Transport` variables that are closer to that side also use `uint8_t*`. They're indeed interchangeable (even by the C++ spec: specifically only `char`, `unsigned char`, and `std::byte` pointers are allowed to be used to access data of any data type), but until the whole codebase this interacts with is `std::byte`-based, there will be some conversions.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T17:57:59Z",
      "diff_hunk" : "@@ -416,7 +414,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted. */\n+    enum class RecvState {\n+        /** (Responder only) either v2 public key or v1 header.\n+         *\n+         * This is the initial state for responders, before data has been received to distinguish\n+         * v1 from v2 connections. When that happens, the state becomes either KEY (for v2) or V1\n+         * (for v1). */\n+        KEY_MAYBE_V1,\n+\n+        /** Public key.\n+         *\n+         * This is the initial state for initiators, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, its contents is\n+         * interpreted as version negotiation (currently, that means ignoring it, but it can be\n+         * used for negotiating future extensions). If it fails, the connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All receive operations are redirected to m_v1_fallback. m_use_v1 is also set in this\n+         * state, so this redirection can usually happen without needing the m_cs_recv lock. */\n+        V1,\n+    };\n+\n+    /** State type that defines the contents of the send buffer. */\n+    enum class SendState {\n+        /** (Responder only) Public key and garbage.\n+         *\n+         * This is the initial state for responders. The send buffer contains the public key and\n+         * garbage to send, but nothing is sent in this state yet. When the receiver determines\n+         * whether this is a V1 or V2 connection, the sender state becomes KEY_GARB (for v2) or V1\n+         * (for v1) as well.\n+         */\n+        KEY_GARB_MAYBE_V1,\n+\n+        /** Public key and garbage.\n+         *\n+         * This is the initial state for initiators. The public key plus garbage are sent out. When\n+         * the receiver receives the other side's public key and transitions to GARB_GARBTERM, the\n+         * sender state becomes KEY_GARB_GARBTERM_GARBAUTH_VERSION. The key and garbage are left in\n+         * the send buffer when this happens, because they may not have been fully sent out yet. */\n+        KEY_GARB,\n+\n+        /** Public key + garbage + garbage terminator + garbage authenticator + version packet.\n+         *\n+         * This is the state the sender is in after the other side's public key has been received.\n+         * Whatever remains of the public key and garbage are sent, plus garbage terminator,\n+         * authentication packet, and version packet. When all of that is sent, the sender state\n+         * becomes APP_READY. */\n+        KEY_GARB_GARBTERM_GARBAUTH_VERSION,\n+\n+        /** Nothing (an application message to send can be provided).\n+         *\n+         * We're ready to start sending an application message at this point, but none are\n+         * currently provided. Upon SetMessageToSend() the sender state becomes APP. */\n+        APP_READY,\n+\n+        /** Application packet.\n+         *\n+         * There is an encrypted packet encoding an application message in the send buffer right now.\n+         * When it is fully sent, the sender state becomes APP_READY. */\n+        APP,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All send operations are redirected to m_v1_fallback. m_use_v1 is also set in this state,\n+         * so this redirection can usually happen without needing the m_cs_send lock. */\n+        V1,\n+    };\n+\n+    /** Cipher state. */\n+    BIP324Cipher m_cipher;\n+    /** Whether we are the initiator side. */\n+    const bool m_initiating;\n+    /** NodeId (for debug logging). */\n+    const NodeId m_nodeid;\n+    /** Whether the send/receive states are V1. This is an optimization allowing fallback to\n+     *  (typically) work without the m_cs_send or m_cs_recv locks. */\n+    std::atomic<bool> m_use_v1{false};\n+    /** Encapsulate a V1Transport to fall back to. */\n+    V1Transport m_v1_fallback;\n+    /** V1 prefix to look for (4-byte network magic + \"version\\x00\"; magic will be filled in). */\n+    std::array<uint8_t, 12> m_v1_prefix = {0, 0, 0, 0, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00};\n+\n+    /** Lock for receiver-side fields. */\n+    mutable Mutex m_recv_mutex;\n+    /** In {GARBAUTH, VERSION, APP}, the decrypted packet length, if\n+     *  m_recv_buffer.size() >= BIP324::LENGTH_LEN). Unspecified otherwise. */\n+    uint32_t m_recv_len GUARDED_BY(m_recv_mutex) {0};\n+    /** Receive buffer; meaning is determined by m_recv_state. */\n+    std::vector<uint8_t> m_recv_buffer GUARDED_BY(m_recv_mutex);\n+    /** During GARBAUTH, the garbage received during GARB_GARBTERM. */\n+    std::vector<uint8_t> m_recv_garbage GUARDED_BY(m_recv_mutex);\n+    /** Buffer to put decrypted contents in, for converting to CNetMessage. */\n+    std::vector<uint8_t> m_recv_decode_buffer GUARDED_BY(m_recv_mutex);\n+    /** Deserialization type. */\n+    int m_recv_type GUARDED_BY(m_recv_mutex);\n+    /** Deserialization version number. */\n+    int m_recv_version GUARDED_BY(m_recv_mutex);\n+    /** Current receiver state. */\n+    RecvState m_recv_state GUARDED_BY(m_recv_mutex);\n+\n+    /** Lock for sending-side fields. */\n+    mutable Mutex m_send_mutex;\n+    /** The send buffer; meaning is determined by m_send_state. */\n+    std::vector<uint8_t> m_send_buffer GUARDED_BY(m_send_mutex);\n+    /** How many bytes from the send buffer have been sent so far. */\n+    uint32_t m_send_pos GUARDED_BY(m_send_mutex) {0};\n+    /** Type of the message being sent. */\n+    std::string m_send_type GUARDED_BY(m_send_mutex);\n+    /** Current sender state. */\n+    SendState m_send_state GUARDED_BY(m_send_mutex);\n+\n+    /** Given a packet's contents, find the message type (if valid), and strip it from contents. */\n+    static std::optional<std::string> GetMessageType(Span<const uint8_t>& contents) noexcept;\n+    /** Determine how many received bytes can be processed in one go (not allowed in V1 state). */\n+    size_t GetMaxBytesToProcess() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex);\n+    /** Process m_recv_buffer in KEY_MAYBE_V1 state. */\n+    void ProcessReceivedMaybeV1() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex, !m_send_mutex);\n+    /** Process m_recv_buffer in KEY state. */\n+    void ProcessReceivedKey() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex, !m_send_mutex);\n+    /** Process m_recv_buffer in GARB_GARBTERM state. */\n+    bool ProcessReceivedGarbage() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex);\n+    /** Process m_recv_buffer in GARBAUTH/VERSION/APP state. */\n+    bool ProcessReceivedPacket() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex);\n+\n+public:\n+\n+    /** Construct a V2 transport with securely generated random keys. */\n+    V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept;\n+    /** Construct a V2 transport with specified keys and garbage (test use only). */\n+    V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312001695",
      "id" : 1312001695,
      "in_reply_to_id" : 1311402373,
      "line" : 627,
      "node_id" : "PRRC_kwDOABII585OM46f",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 627,
      "original_position" : 251,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 290,
      "pull_request_review_id" : 1605369802,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312001695/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T17:57:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312001695",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312003077"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312003077"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "name changed: m_recv_mutex / m_send_mutex - same a few lines above for the V1 states.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T17:58:30Z",
      "diff_hunk" : "@@ -538,6 +540,9 @@ class V2Transport final : public Transport\n     const bool m_initiating;\n     /** NodeId (for debug logging). */\n     const NodeId m_nodeid;\n+    /** Whether the send/receive states are V1. This is an optimization allowing fallback to\n+     *  (typically) work without the m_cs_send or m_cs_recv locks. */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312003077",
      "id" : 1312003077,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585OM5QF",
      "original_commit_id" : "c3902f3f1dec2368b7e7b6ec77019324ae915b31",
      "original_line" : 572,
      "original_position" : 25,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1605372003,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312003077/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T20:32:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312003077",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312036062"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312036062"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Does the `m_use_v1` optimization result in a meaningful speedup? \r\nMy first thought was that the V1 functions are so similar to the respective V2 functions in terms of locking (have analogous `m_recv_mutex`/`m_send_mutex` locks for  analogous functions) so if there would be lock contention at the V2 level that `m_use_v1` avoids, we'd now just have the same contention for the analogous locks one level below at V1Transport instead, resulting in no real performance improvement.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T18:18:06Z",
      "diff_hunk" : "@@ -538,6 +540,9 @@ class V2Transport final : public Transport\n     const bool m_initiating;\n     /** NodeId (for debug logging). */\n     const NodeId m_nodeid;\n+    /** Whether the send/receive states are V1. This is an optimization allowing fallback to\n+     *  (typically) work without the m_cs_send or m_cs_recv locks. */\n+    std::atomic<bool> m_use_v1{false};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312036062",
      "id" : 1312036062,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585ONBTe",
      "original_commit_id" : "c3902f3f1dec2368b7e7b6ec77019324ae915b31",
      "original_line" : 573,
      "original_position" : 26,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1605372003,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312036062/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T20:32:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312036062",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312092279"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312092279"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T19:07:23Z",
      "diff_hunk" : "@@ -320,7 +328,7 @@ class Transport {\n      * Note that m_type and to_send refer to data that is internal to the transport, and calling\n      * any non-const function on this object may invalidate them.\n      */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312092279",
      "id" : 1312092279,
      "in_reply_to_id" : 1310237002,
      "line" : 328,
      "node_id" : "PRRC_kwDOABII585ONPB3",
      "original_commit_id" : "040ea05dae05ef513ac79306dd560c8c1f228942",
      "original_line" : 328,
      "original_position" : 34,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 54,
      "pull_request_review_id" : 1605515528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312092279/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T19:18:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312092279",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312092953"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312092953"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've merged the two `public:` sections.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T19:07:52Z",
      "diff_hunk" : "@@ -416,7 +414,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312092953",
      "id" : 1312092953,
      "in_reply_to_id" : 1311376345,
      "line" : 424,
      "node_id" : "PRRC_kwDOABII585ONPMZ",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 424,
      "original_position" : 79,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 87,
      "pull_request_review_id" : 1605515528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312092953/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T19:18:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312092953",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312106070"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312106070"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This is something I learned in college, though I've never seen it repeated elsewhere: when you have conditional code, make the conditional as narrow as necessary. The reason is that in general, if you let conditionals apply to states that shouldn't be hit at all, they'll hide the issue; the alternative generally leads to more obvious failures.\r\n\r\nI think it applies here: if we'd use `>=`, and we ever ended up in a `>` state, that would imply we're not actually testing for the garbage terminator after every byte, possibly leading to hard-to-discover connection failures. With just `==`, it'll keep receiving forever, likely stalling, or crashing, with an obvious too-large receive buffer.\r\n\r\nOf course, we can do even better: add an Assume that the receive buffer size never exceeds `MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN` in this state, which is what I've added here.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T19:12:17Z",
      "diff_hunk" : "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARB_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        size_t garbage_len = m_send_buffer.size() - EllSwiftPubKey::size();\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer (using the garbage data which\n+        // already there).\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            MakeByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size(), garbage_len),\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312106070",
      "id" : 1312106070,
      "in_reply_to_id" : 1311548994,
      "line" : 1221,
      "node_id" : "PRRC_kwDOABII585ONSZW",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 1221,
      "original_position" : 266,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 338,
      "pull_request_review_id" : 1605515528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312106070/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T19:18:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312106070",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312108759"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312108759"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'm not sure how I'd assert for it, but I've added a comment.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T19:12:57Z",
      "diff_hunk" : "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARB_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        size_t garbage_len = m_send_buffer.size() - EllSwiftPubKey::size();\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer (using the garbage data which\n+        // already there).\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            MakeByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size(), garbage_len),\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 1 + CMessageHeader::COMMAND_SIZE ||\n+            m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 1 + CMessageHeader::COMMAND_SIZE) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312108759",
      "id" : 1312108759,
      "in_reply_to_id" : 1311568129,
      "line" : 1249,
      "node_id" : "PRRC_kwDOABII585ONTDX",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 1249,
      "original_position" : 287,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 366,
      "pull_request_review_id" : 1605515528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312108759/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T19:18:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312108759",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312111598"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312111598"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T19:13:37Z",
      "diff_hunk" : "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARB_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        size_t garbage_len = m_send_buffer.size() - EllSwiftPubKey::size();\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer (using the garbage data which\n+        // already there).\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            MakeByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size(), garbage_len),\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 1 + CMessageHeader::COMMAND_SIZE ||\n+            m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 1 + CMessageHeader::COMMAND_SIZE) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packet decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            m_recv_state = RecvState::VERSION;\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is\n+                // ignored, but can be used for future extensions.\n+                m_recv_state = RecvState::APP;\n+            }\n+            break;\n+        case RecvState::APP:\n+            if (!ignore) {\n+                // Application message decrypted correctly. It can be extracted using GetMessage().\n+                m_recv_state = RecvState::APP_READY;\n+            }\n+            break;\n+        default:\n+            // Any other state is invalid (this function should not have been called).\n+            assert(false);\n+        }\n+        // Wipe the receive buffer where the next packet will be received into.\n+        m_recv_buffer = {};\n+        // In all but APP_READY state, we can wipe the decoded contents.\n+        if (m_recv_state != RecvState::APP_READY) m_recv_decode_buffer = {};\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ReceivedBytes(Span<const uint8_t>& msg_bytes) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    /** How many bytes to allocate in the receive buffer at most above what is received so far. */\n+    static constexpr size_t MAX_RESERVE_AHEAD = 250000;\n+\n+    if (m_use_v1) return m_v1_fallback.ReceivedBytes(msg_bytes);\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedBytes(msg_bytes);\n+\n+    while (!msg_bytes.empty()) {\n+        // Decide how many bytes to copy from msg_bytes to m_recv_buffer.\n+        size_t max_read = GetMaxBytesToProcess();\n+        // Reserve space in the buffer.\n+        if (m_recv_state == RecvState::KEY_MAYBE_V1 || m_recv_state == RecvState::KEY ||\n+            m_recv_state == RecvState::GARB_GARBTERM) {\n+            // During the initial states (key/garbage), allocate once to fit the maximum (4111\n+            // bytes).\n+            m_recv_buffer.reserve(MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        } else if (m_recv_state == RecvState::GARBAUTH || m_recv_state == RecvState::VERSION ||\n+            m_recv_state == RecvState::APP) {\n+            // During states where a packet is being received, as much as is expected but never\n+            // more than MAX_RESERVE_AHEAD bytes in addition to what is received so far.\n+            size_t alloc_add = std::min(max_read, msg_bytes.size() + MAX_RESERVE_AHEAD);\n+            m_recv_buffer.reserve(m_recv_buffer.size() + alloc_add);\n+        }\n+        // Can't read more than provided input.\n+        max_read = std::min<uint32_t>(msg_bytes.size(), max_read);\n+        // Copy data to buffer.\n+        m_recv_buffer.insert(m_recv_buffer.end(), UCharCast(msg_bytes.data()), UCharCast(msg_bytes.data() + max_read));\n+        msg_bytes = msg_bytes.subspan(max_read);\n+\n+        // Process data in the buffer.\n+        switch (m_recv_state) {\n+        case RecvState::KEY_MAYBE_V1:\n+            ProcessReceivedMaybeV1();\n+            if (m_recv_state == RecvState::V1) return true;\n+            break;\n+\n+        case RecvState::KEY:\n+            ProcessReceivedKey();\n+            break;\n+\n+        case RecvState::GARB_GARBTERM:\n+            if (!ProcessReceivedGarbage()) return false;\n+            break;\n+\n+        case RecvState::GARBAUTH:\n+        case RecvState::VERSION:\n+        case RecvState::APP:\n+            if (!ProcessReceivedPacket()) return false;\n+            break;\n+\n+        case RecvState::APP_READY:\n+            return true;\n+\n+        case RecvState::V1:\n+            // We should have bailed out before.\n+            assert(false);\n+            break;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+std::optional<std::string> V2Transport::GetMessageType(Span<const uint8_t>& contents) noexcept\n+{\n+    if (contents.size() == 0) return std::nullopt; // Empty contents\n+    uint8_t first_byte = contents[0];\n+    contents = contents.subspan(1); // Strip first byte.\n+\n+    if (first_byte != 0) {\n+        // Short (1 byte) encoding.\n+        if (first_byte < std::size(V2_MESSAGE_IDS)) {\n+            // Valid short message id.\n+            return V2_MESSAGE_IDS[first_byte];\n+        } else {\n+            // Unknown short message id.\n+            return std::nullopt;\n+        }\n+    }\n+\n+    if (contents.size() < CMessageHeader::COMMAND_SIZE) {\n+        return std::nullopt; // Long encoding needs 12 message type bytes.\n+    }\n+\n+    size_t msg_type_len{0};\n+    while (msg_type_len < CMessageHeader::COMMAND_SIZE && contents[msg_type_len] != 0) {\n+        // Verify that message type bytes before the first 0x00 are in range.\n+        if (contents[msg_type_len] < ' ' || contents[msg_type_len] > 0x7F) {\n+            return {};\n+        }\n+        ++msg_type_len;\n+    }\n+    std::string ret{reinterpret_cast<const char*>(contents.data()), msg_type_len};\n+    while (msg_type_len < CMessageHeader::COMMAND_SIZE) {\n+        // Verify that message type bytes after the first 0x00 are also 0x00.\n+        if (contents[msg_type_len] != 0) return {};\n+        ++msg_type_len;\n+    }\n+    // Strip message type bytes of contents.\n+    contents = contents.subspan(CMessageHeader::COMMAND_SIZE);\n+    return {std::move(ret)};\n+}\n+\n+CNetMessage V2Transport::GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.GetReceivedMessage(time, reject_message);\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.GetReceivedMessage(time, reject_message);\n+\n+    assert(m_recv_state == RecvState::APP_READY);\n+    Span<const uint8_t> contents{m_recv_decode_buffer};\n+    auto msg_type = GetMessageType(contents);\n+    CDataStream ret(m_recv_type, m_recv_version);\n+    CNetMessage msg{std::move(ret)};\n+    msg.m_raw_message_size = m_recv_decode_buffer.size() + BIP324Cipher::EXPANSION;\n+    if (msg_type) {\n+        reject_message = false;\n+        msg.m_type = std::move(*msg_type);\n+        msg.m_time = time;\n+        msg.m_message_size = contents.size();\n+        msg.m_recv.resize(contents.size());\n+        std::copy(contents.begin(), contents.end(), UCharCast(msg.m_recv.data()));\n+    } else {\n+        LogPrint(BCLog::NET, \"V2 transport error: invalid message type (%u bytes contents), peer=%d\\n\", m_recv_decode_buffer.size(), m_nodeid);\n+        reject_message = true;\n+    }\n+    m_recv_decode_buffer = {};\n+    m_recv_state = RecvState::APP;\n+\n+    return msg;\n+}\n+\n+bool V2Transport::SetMessageToSend(CSerializedNetMsg& msg) noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_use_v1) return m_v1_fallback.SetMessageToSend(msg);\n+    LOCK(m_send_mutex);\n+    if (m_send_state == SendState::V1) return m_v1_fallback.SetMessageToSend(msg);\n+\n+    if (m_send_state != SendState::APP_READY) return false;\n+    // Construct contents (encoding message type + payload).\n+    std::vector<uint8_t> contents;\n+    auto short_message_id = V2_MESSAGE_MAP(msg.m_type);\n+    if (short_message_id) {\n+        contents.resize(1 + msg.data.size());\n+        contents[0] = *short_message_id;\n+        std::copy(msg.data.begin(), msg.data.end(), contents.begin() + 1);\n+    } else {\n+        // Initialize with zeroes, and then write the message type string starting at offset 0.\n+        // This means contents[0] and the unused positions in contents[1..13] remain 0x00.\n+        contents.resize(1 + CMessageHeader::COMMAND_SIZE + msg.data.size(), 0);\n+        std::copy(msg.m_type.begin(), msg.m_type.end(), reinterpret_cast<char*>(contents.data() + 1));\n+        std::copy(msg.data.begin(), msg.data.end(), contents.begin() + 1 + CMessageHeader::COMMAND_SIZE);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312111598",
      "id" : 1312111598,
      "in_reply_to_id" : 1311613938,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585ONTvu",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 1456,
      "original_position" : 495,
      "original_start_line" : 1377,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1605515528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312111598/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-31T19:18:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312111598",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312112870"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312112870"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done (using a `static constexpr size_t` constant with comments higher up).",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T19:14:05Z",
      "diff_hunk" : "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARB_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        size_t garbage_len = m_send_buffer.size() - EllSwiftPubKey::size();\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer (using the garbage data which\n+        // already there).\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            MakeByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size(), garbage_len),\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 1 + CMessageHeader::COMMAND_SIZE ||\n+            m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 1 + CMessageHeader::COMMAND_SIZE) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312112870",
      "id" : 1312112870,
      "in_reply_to_id" : 1311560086,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585ONUDm",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 1246,
      "original_position" : 284,
      "original_start_line" : 1164,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1605515528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312112870/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-31T19:18:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312112870",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312113220"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312113220"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done, at the beginning of all `ProcessReceived*` functions.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T19:14:25Z",
      "diff_hunk" : "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARB_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        size_t garbage_len = m_send_buffer.size() - EllSwiftPubKey::size();\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer (using the garbage data which\n+        // already there).\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            MakeByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size(), garbage_len),\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312113220",
      "id" : 1312113220,
      "in_reply_to_id" : 1311553670,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585ONUJE",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 1148,
      "original_position" : 265,
      "original_start_line" : 1139,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1605515528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312113220/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-31T19:18:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312113220",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312113425"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312113425"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T19:14:40Z",
      "diff_hunk" : "@@ -416,7 +424,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the contents of the receive buffer. */\n+    enum class RecvState {\n+        /** (Responder only) either v2 public key or v1 header.\n+         *\n+         * This is the initial state for responders, before data has been received to distinguish\n+         * v1 from v2 connections. When that happens, the state becomes either KEY (for v2) or V1\n+         * (for v1). */\n+        KEY_MAYBE_V1,\n+\n+        /** Public key.\n+         *\n+         * This is the initial state for initiators, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, its contents is",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312113425",
      "id" : 1312113425,
      "in_reply_to_id" : 1310277982,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585ONUMR",
      "original_commit_id" : "040ea05dae05ef513ac79306dd560c8c1f228942",
      "original_line" : 467,
      "original_position" : 94,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1605515528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312113425/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T19:18:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312113425",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312113516"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312113516"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T19:14:46Z",
      "diff_hunk" : "@@ -416,7 +424,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the contents of the receive buffer. */\n+    enum class RecvState {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312113516",
      "id" : 1312113516,
      "in_reply_to_id" : 1310288598,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585ONUNs",
      "original_commit_id" : "040ea05dae05ef513ac79306dd560c8c1f228942",
      "original_line" : 435,
      "original_position" : 62,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1605515528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312113516/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T19:18:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312113516",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312113605"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312113605"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T19:14:50Z",
      "diff_hunk" : "@@ -416,7 +424,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the contents of the receive buffer. */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312113605",
      "id" : 1312113605,
      "in_reply_to_id" : 1310305445,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585ONUPF",
      "original_commit_id" : "040ea05dae05ef513ac79306dd560c8c1f228942",
      "original_line" : 443,
      "original_position" : 61,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1605515528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312113605/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T19:18:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312113605",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312113901"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312113901"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've added an overall comment above `enum class RecvState`.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T19:15:09Z",
      "diff_hunk" : "@@ -416,7 +414,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted. */\n+    enum class RecvState {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312113901",
      "id" : 1312113901,
      "in_reply_to_id" : 1311222591,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585ONUTt",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 435,
      "original_position" : 87,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1605515528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312113901/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T19:18:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312113901",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312114126"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312114126"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T19:15:16Z",
      "diff_hunk" : "@@ -416,7 +414,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted. */\n+    enum class RecvState {\n+        /** (Responder only) either v2 public key or v1 header.\n+         *\n+         * This is the initial state for responders, before data has been received to distinguish\n+         * v1 from v2 connections. When that happens, the state becomes either KEY (for v2) or V1\n+         * (for v1). */\n+        KEY_MAYBE_V1,\n+\n+        /** Public key.\n+         *\n+         * This is the initial state for initiators, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, its contents is\n+         * interpreted as version negotiation (currently, that means ignoring it, but it can be\n+         * used for negotiating future extensions). If it fails, the connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All receive operations are redirected to m_v1_fallback. m_use_v1 is also set in this\n+         * state, so this redirection can usually happen without needing the m_cs_recv lock. */\n+        V1,\n+    };\n+\n+    /** State type that defines the contents of the send buffer. */\n+    enum class SendState {\n+        /** (Responder only) Public key and garbage.\n+         *\n+         * This is the initial state for responders. The send buffer contains the public key and\n+         * garbage to send, but nothing is sent in this state yet. When the receiver determines\n+         * whether this is a V1 or V2 connection, the sender state becomes KEY_GARB (for v2) or V1\n+         * (for v1) as well.\n+         */\n+        KEY_GARB_MAYBE_V1,\n+\n+        /** Public key and garbage.\n+         *\n+         * This is the initial state for initiators. The public key plus garbage are sent out. When\n+         * the receiver receives the other side's public key and transitions to GARB_GARBTERM, the\n+         * sender state becomes KEY_GARB_GARBTERM_GARBAUTH_VERSION. The key and garbage are left in\n+         * the send buffer when this happens, because they may not have been fully sent out yet. */\n+        KEY_GARB,\n+\n+        /** Public key + garbage + garbage terminator + garbage authenticator + version packet.\n+         *\n+         * This is the state the sender is in after the other side's public key has been received.\n+         * Whatever remains of the public key and garbage are sent, plus garbage terminator,\n+         * authentication packet, and version packet. When all of that is sent, the sender state\n+         * becomes APP_READY. */\n+        KEY_GARB_GARBTERM_GARBAUTH_VERSION,\n+\n+        /** Nothing (an application message to send can be provided).\n+         *\n+         * We're ready to start sending an application message at this point, but none are\n+         * currently provided. Upon SetMessageToSend() the sender state becomes APP. */\n+        APP_READY,\n+\n+        /** Application packet.\n+         *\n+         * There is an encrypted packet encoding an application message in the send buffer right now.\n+         * When it is fully sent, the sender state becomes APP_READY. */\n+        APP,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All send operations are redirected to m_v1_fallback. m_use_v1 is also set in this state,\n+         * so this redirection can usually happen without needing the m_cs_send lock. */\n+        V1,\n+    };\n+\n+    /** Cipher state. */\n+    BIP324Cipher m_cipher;\n+    /** Whether we are the initiator side. */\n+    const bool m_initiating;\n+    /** NodeId (for debug logging). */\n+    const NodeId m_nodeid;\n+    /** Whether the send/receive states are V1. This is an optimization allowing fallback to\n+     *  (typically) work without the m_cs_send or m_cs_recv locks. */\n+    std::atomic<bool> m_use_v1{false};\n+    /** Encapsulate a V1Transport to fall back to. */\n+    V1Transport m_v1_fallback;\n+    /** V1 prefix to look for (4-byte network magic + \"version\\x00\"; magic will be filled in). */\n+    std::array<uint8_t, 12> m_v1_prefix = {0, 0, 0, 0, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00};\n+\n+    /** Lock for receiver-side fields. */\n+    mutable Mutex m_recv_mutex;\n+    /** In {GARBAUTH, VERSION, APP}, the decrypted packet length, if\n+     *  m_recv_buffer.size() >= BIP324::LENGTH_LEN). Unspecified otherwise. */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312114126",
      "id" : 1312114126,
      "in_reply_to_id" : 1311381100,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585ONUXO",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 555,
      "original_position" : 207,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1605515528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312114126/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T19:18:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312114126",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312114721"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312114721"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done. Also dropped the `GUARDED_BY(m_recv_mutex)` which is not needed for immutable variables.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T19:15:45Z",
      "diff_hunk" : "@@ -416,7 +414,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted. */\n+    enum class RecvState {\n+        /** (Responder only) either v2 public key or v1 header.\n+         *\n+         * This is the initial state for responders, before data has been received to distinguish\n+         * v1 from v2 connections. When that happens, the state becomes either KEY (for v2) or V1\n+         * (for v1). */\n+        KEY_MAYBE_V1,\n+\n+        /** Public key.\n+         *\n+         * This is the initial state for initiators, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, its contents is\n+         * interpreted as version negotiation (currently, that means ignoring it, but it can be\n+         * used for negotiating future extensions). If it fails, the connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All receive operations are redirected to m_v1_fallback. m_use_v1 is also set in this\n+         * state, so this redirection can usually happen without needing the m_cs_recv lock. */\n+        V1,\n+    };\n+\n+    /** State type that defines the contents of the send buffer. */\n+    enum class SendState {\n+        /** (Responder only) Public key and garbage.\n+         *\n+         * This is the initial state for responders. The send buffer contains the public key and\n+         * garbage to send, but nothing is sent in this state yet. When the receiver determines\n+         * whether this is a V1 or V2 connection, the sender state becomes KEY_GARB (for v2) or V1\n+         * (for v1) as well.\n+         */\n+        KEY_GARB_MAYBE_V1,\n+\n+        /** Public key and garbage.\n+         *\n+         * This is the initial state for initiators. The public key plus garbage are sent out. When\n+         * the receiver receives the other side's public key and transitions to GARB_GARBTERM, the\n+         * sender state becomes KEY_GARB_GARBTERM_GARBAUTH_VERSION. The key and garbage are left in\n+         * the send buffer when this happens, because they may not have been fully sent out yet. */\n+        KEY_GARB,\n+\n+        /** Public key + garbage + garbage terminator + garbage authenticator + version packet.\n+         *\n+         * This is the state the sender is in after the other side's public key has been received.\n+         * Whatever remains of the public key and garbage are sent, plus garbage terminator,\n+         * authentication packet, and version packet. When all of that is sent, the sender state\n+         * becomes APP_READY. */\n+        KEY_GARB_GARBTERM_GARBAUTH_VERSION,\n+\n+        /** Nothing (an application message to send can be provided).\n+         *\n+         * We're ready to start sending an application message at this point, but none are\n+         * currently provided. Upon SetMessageToSend() the sender state becomes APP. */\n+        APP_READY,\n+\n+        /** Application packet.\n+         *\n+         * There is an encrypted packet encoding an application message in the send buffer right now.\n+         * When it is fully sent, the sender state becomes APP_READY. */\n+        APP,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All send operations are redirected to m_v1_fallback. m_use_v1 is also set in this state,\n+         * so this redirection can usually happen without needing the m_cs_send lock. */\n+        V1,\n+    };\n+\n+    /** Cipher state. */\n+    BIP324Cipher m_cipher;\n+    /** Whether we are the initiator side. */\n+    const bool m_initiating;\n+    /** NodeId (for debug logging). */\n+    const NodeId m_nodeid;\n+    /** Whether the send/receive states are V1. This is an optimization allowing fallback to\n+     *  (typically) work without the m_cs_send or m_cs_recv locks. */\n+    std::atomic<bool> m_use_v1{false};\n+    /** Encapsulate a V1Transport to fall back to. */\n+    V1Transport m_v1_fallback;\n+    /** V1 prefix to look for (4-byte network magic + \"version\\x00\"; magic will be filled in). */\n+    std::array<uint8_t, 12> m_v1_prefix = {0, 0, 0, 0, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00};\n+\n+    /** Lock for receiver-side fields. */\n+    mutable Mutex m_recv_mutex;\n+    /** In {GARBAUTH, VERSION, APP}, the decrypted packet length, if\n+     *  m_recv_buffer.size() >= BIP324::LENGTH_LEN). Unspecified otherwise. */\n+    uint32_t m_recv_len GUARDED_BY(m_recv_mutex) {0};\n+    /** Receive buffer; meaning is determined by m_recv_state. */\n+    std::vector<uint8_t> m_recv_buffer GUARDED_BY(m_recv_mutex);\n+    /** During GARBAUTH, the garbage received during GARB_GARBTERM. */\n+    std::vector<uint8_t> m_recv_garbage GUARDED_BY(m_recv_mutex);\n+    /** Buffer to put decrypted contents in, for converting to CNetMessage. */\n+    std::vector<uint8_t> m_recv_decode_buffer GUARDED_BY(m_recv_mutex);\n+    /** Deserialization type. */\n+    int m_recv_type GUARDED_BY(m_recv_mutex);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312114721",
      "id" : 1312114721,
      "in_reply_to_id" : 1311393641,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585ONUgh",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 564,
      "original_position" : 216,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1605515528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312114721/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T19:18:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312114721",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312115309"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312115309"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It's impossible to hit, because `GetMaxBytesToProcess` only lets in as much as needed to reach the end of the buffer. I've added comments and Assumes.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T19:16:27Z",
      "diff_hunk" : "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312115309",
      "id" : 1312115309,
      "in_reply_to_id" : 1311460423,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585ONUpt",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 1107,
      "original_position" : 151,
      "original_start_line" : 1029,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1605515528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312115309/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-31T19:18:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312115309",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312116243"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312116243"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It turns out that we actually have locking annotations for that. I've added `ACQUIRED_BEFORE(m_send_mutex)` to `m_recv_mutex`, and `ACQUIRED_AFTER(m_recv_mutex)` to `m_send_mutex`, together with a shortened version of your suggested comment.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T19:17:21Z",
      "diff_hunk" : "@@ -416,7 +414,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted. */\n+    enum class RecvState {\n+        /** (Responder only) either v2 public key or v1 header.\n+         *\n+         * This is the initial state for responders, before data has been received to distinguish\n+         * v1 from v2 connections. When that happens, the state becomes either KEY (for v2) or V1\n+         * (for v1). */\n+        KEY_MAYBE_V1,\n+\n+        /** Public key.\n+         *\n+         * This is the initial state for initiators, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, its contents is\n+         * interpreted as version negotiation (currently, that means ignoring it, but it can be\n+         * used for negotiating future extensions). If it fails, the connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All receive operations are redirected to m_v1_fallback. m_use_v1 is also set in this\n+         * state, so this redirection can usually happen without needing the m_cs_recv lock. */\n+        V1,\n+    };\n+\n+    /** State type that defines the contents of the send buffer. */\n+    enum class SendState {\n+        /** (Responder only) Public key and garbage.\n+         *\n+         * This is the initial state for responders. The send buffer contains the public key and\n+         * garbage to send, but nothing is sent in this state yet. When the receiver determines\n+         * whether this is a V1 or V2 connection, the sender state becomes KEY_GARB (for v2) or V1\n+         * (for v1) as well.\n+         */\n+        KEY_GARB_MAYBE_V1,\n+\n+        /** Public key and garbage.\n+         *\n+         * This is the initial state for initiators. The public key plus garbage are sent out. When\n+         * the receiver receives the other side's public key and transitions to GARB_GARBTERM, the\n+         * sender state becomes KEY_GARB_GARBTERM_GARBAUTH_VERSION. The key and garbage are left in\n+         * the send buffer when this happens, because they may not have been fully sent out yet. */\n+        KEY_GARB,\n+\n+        /** Public key + garbage + garbage terminator + garbage authenticator + version packet.\n+         *\n+         * This is the state the sender is in after the other side's public key has been received.\n+         * Whatever remains of the public key and garbage are sent, plus garbage terminator,\n+         * authentication packet, and version packet. When all of that is sent, the sender state\n+         * becomes APP_READY. */\n+        KEY_GARB_GARBTERM_GARBAUTH_VERSION,\n+\n+        /** Nothing (an application message to send can be provided).\n+         *\n+         * We're ready to start sending an application message at this point, but none are\n+         * currently provided. Upon SetMessageToSend() the sender state becomes APP. */\n+        APP_READY,\n+\n+        /** Application packet.\n+         *\n+         * There is an encrypted packet encoding an application message in the send buffer right now.\n+         * When it is fully sent, the sender state becomes APP_READY. */\n+        APP,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All send operations are redirected to m_v1_fallback. m_use_v1 is also set in this state,\n+         * so this redirection can usually happen without needing the m_cs_send lock. */\n+        V1,\n+    };\n+\n+    /** Cipher state. */\n+    BIP324Cipher m_cipher;\n+    /** Whether we are the initiator side. */\n+    const bool m_initiating;\n+    /** NodeId (for debug logging). */\n+    const NodeId m_nodeid;\n+    /** Whether the send/receive states are V1. This is an optimization allowing fallback to\n+     *  (typically) work without the m_cs_send or m_cs_recv locks. */\n+    std::atomic<bool> m_use_v1{false};\n+    /** Encapsulate a V1Transport to fall back to. */\n+    V1Transport m_v1_fallback;\n+    /** V1 prefix to look for (4-byte network magic + \"version\\x00\"; magic will be filled in). */\n+    std::array<uint8_t, 12> m_v1_prefix = {0, 0, 0, 0, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00};\n+\n+    /** Lock for receiver-side fields. */\n+    mutable Mutex m_recv_mutex;\n+    /** In {GARBAUTH, VERSION, APP}, the decrypted packet length, if\n+     *  m_recv_buffer.size() >= BIP324::LENGTH_LEN). Unspecified otherwise. */\n+    uint32_t m_recv_len GUARDED_BY(m_recv_mutex) {0};\n+    /** Receive buffer; meaning is determined by m_recv_state. */\n+    std::vector<uint8_t> m_recv_buffer GUARDED_BY(m_recv_mutex);\n+    /** During GARBAUTH, the garbage received during GARB_GARBTERM. */\n+    std::vector<uint8_t> m_recv_garbage GUARDED_BY(m_recv_mutex);\n+    /** Buffer to put decrypted contents in, for converting to CNetMessage. */\n+    std::vector<uint8_t> m_recv_decode_buffer GUARDED_BY(m_recv_mutex);\n+    /** Deserialization type. */\n+    int m_recv_type GUARDED_BY(m_recv_mutex);\n+    /** Deserialization version number. */\n+    int m_recv_version GUARDED_BY(m_recv_mutex);\n+    /** Current receiver state. */\n+    RecvState m_recv_state GUARDED_BY(m_recv_mutex);\n+\n+    /** Lock for sending-side fields. */\n+    mutable Mutex m_send_mutex;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312116243",
      "id" : 1312116243,
      "in_reply_to_id" : 1311500825,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585ONU4T",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 571,
      "original_position" : 223,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1605515528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312116243/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T19:18:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312116243",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312116773"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312116773"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed in an extra preparatory commit (allowing `Span<const std::byte>` argument for `EllSwiftPubKey` constructor.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T19:17:54Z",
      "diff_hunk" : "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312116773",
      "id" : 1312116773,
      "in_reply_to_id" : 1311508831,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585ONVAl",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 1106,
      "original_position" : 223,
      "original_start_line" : 1103,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1605515528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312116773/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-31T19:18:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312116773",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312117427"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312117427"
         }
      },
      "author_association" : "MEMBER",
      "body" : "A wrapper felt like overkill to me, but I've added `SetReceiveState` and `SetSendState` functions for effecting state transitions, which enforce the allowed ones.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T19:18:34Z",
      "diff_hunk" : "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312117427",
      "id" : 1312117427,
      "in_reply_to_id" : 1311514245,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585ONVKz",
      "original_commit_id" : "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "original_line" : 1109,
      "original_position" : 226,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1605515528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312117427/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T19:18:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312117427",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312201855"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312201855"
         }
      },
      "author_association" : "MEMBER",
      "body" : "That sounds right; there will really only be contention on one of the two levels, and uncontended mutex grabs are in the 10s of nanonseconds I believe. I'll just drop this commit.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T20:37:21Z",
      "diff_hunk" : "@@ -538,6 +540,9 @@ class V2Transport final : public Transport\n     const bool m_initiating;\n     /** NodeId (for debug logging). */\n     const NodeId m_nodeid;\n+    /** Whether the send/receive states are V1. This is an optimization allowing fallback to\n+     *  (typically) work without the m_cs_send or m_cs_recv locks. */\n+    std::atomic<bool> m_use_v1{false};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312201855",
      "id" : 1312201855,
      "in_reply_to_id" : 1312036062,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585ONpx_",
      "original_commit_id" : "c3902f3f1dec2368b7e7b6ec77019324ae915b31",
      "original_line" : 573,
      "original_position" : 26,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1605676924,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312201855/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T20:37:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312201855",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312212320"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312212320"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "okay then, can be resolved.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T20:48:31Z",
      "diff_hunk" : "@@ -912,6 +912,347 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packed decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            m_recv_state = RecvState::VERSION;\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312212320",
      "id" : 1312212320,
      "in_reply_to_id" : 1310695744,
      "line" : 1280,
      "node_id" : "PRRC_kwDOABII585ONsVg",
      "original_commit_id" : "de705988c330fc5b3c006337bd72ca0f0c8e2750",
      "original_line" : 1280,
      "original_position" : 171,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 397,
      "pull_request_review_id" : 1605693293,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312212320/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T20:48:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312212320",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312213945"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312213945"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Resolved by dropping the commit.",
      "commit_id" : "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "created_at" : "2023-08-31T20:50:00Z",
      "diff_hunk" : "@@ -538,6 +540,9 @@ class V2Transport final : public Transport\n     const bool m_initiating;\n     /** NodeId (for debug logging). */\n     const NodeId m_nodeid;\n+    /** Whether the send/receive states are V1. This is an optimization allowing fallback to\n+     *  (typically) work without the m_cs_send or m_cs_recv locks. */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312213945",
      "id" : 1312213945,
      "in_reply_to_id" : 1312003077,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585ONsu5",
      "original_commit_id" : "c3902f3f1dec2368b7e7b6ec77019324ae915b31",
      "original_line" : 572,
      "original_position" : 25,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1605695923,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312213945/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-31T20:50:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312213945",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   }
]
