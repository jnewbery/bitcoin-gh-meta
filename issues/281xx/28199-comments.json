[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [instagibbs](https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1669753053) |\n| Concept ACK | [dergoegge](https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1662073675), [jamesob](https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1662122993), [brunoerg](https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1662147529), [jonatack](https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1662205614), [Empact](https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1664679951) |\n\nIf your review is incorrectly listed, please react with ð to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#20892](https://github.com/bitcoin/bitcoin/pull/20892) (tests: Run both descriptor and legacy tests within a single test invocation by achow101)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "created_at" : "2023-08-02T11:14:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1662019735",
      "id" : 1662019735,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28199",
      "node_id" : "IC_kwDOABII585jEGiX",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1662019735/reactions"
      },
      "updated_at" : "2023-08-08T14:39:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1662019735",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK\r\n\r\nGood to have these tests prior to refactoring",
      "created_at" : "2023-08-02T11:54:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1662073675",
      "id" : 1662073675,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28199",
      "node_id" : "IC_kwDOABII585jETtL",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1662073675/reactions"
      },
      "updated_at" : "2023-08-02T11:54:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1662073675",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK, looks like some great additional coverage.",
      "created_at" : "2023-08-02T12:29:21Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1662122993",
      "id" : 1662122993,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28199",
      "node_id" : "IC_kwDOABII585jEfvx",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1662122993/reactions"
      },
      "updated_at" : "2023-08-02T12:29:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1662122993",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Concept ACK ",
      "created_at" : "2023-08-02T12:46:32Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1662147529",
      "id" : 1662147529,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28199",
      "node_id" : "IC_kwDOABII585jElvJ",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1662147529/reactions"
      },
      "updated_at" : "2023-08-02T12:46:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1662147529",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19480819?v=4",
         "events_url" : "https://api.github.com/users/brunoerg/events{/privacy}",
         "followers_url" : "https://api.github.com/users/brunoerg/followers",
         "following_url" : "https://api.github.com/users/brunoerg/following{/other_user}",
         "gists_url" : "https://api.github.com/users/brunoerg/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/brunoerg",
         "id" : 19480819,
         "login" : "brunoerg",
         "node_id" : "MDQ6VXNlcjE5NDgwODE5",
         "organizations_url" : "https://api.github.com/users/brunoerg/orgs",
         "received_events_url" : "https://api.github.com/users/brunoerg/received_events",
         "repos_url" : "https://api.github.com/users/brunoerg/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/brunoerg/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/brunoerg/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/brunoerg"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Concept ACK",
      "created_at" : "2023-08-02T13:22:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1662205614",
      "id" : 1662205614,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28199",
      "node_id" : "IC_kwDOABII585jEz6u",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1662205614/reactions"
      },
      "updated_at" : "2023-08-02T13:22:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1662205614",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282131242"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282131242"
         }
      },
      "author_association" : "MEMBER",
      "body" : "comment block seems extraneous if there's logging for each test",
      "commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "created_at" : "2023-08-02T16:14:00Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282131242",
      "id" : 1282131242,
      "line" : 6,
      "node_id" : "PRRC_kwDOABII585Ma8Uq",
      "original_commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_line" : 6,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : 6,
      "pull_request_review_id" : 1559366940,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282131242/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-02T18:24:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282131242",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282208201"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282208201"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Stick the constant inside `cleanup` and move the comment for `cleanup`, since it explains what the whole thing is doing.",
      "commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "created_at" : "2023-08-02T17:17:38Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282208201",
      "id" : 1282208201,
      "line" : 57,
      "node_id" : "PRRC_kwDOABII585MbPHJ",
      "original_commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_line" : 57,
      "original_position" : 57,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : 57,
      "pull_request_review_id" : 1559366940,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282208201/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-02T18:24:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282208201",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282234657"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282234657"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n        # The parent should be requested since the unstripped wtxid would differ. Delayed because it's by txid and this is not a preferred relay peer.\r\n```",
      "commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "created_at" : "2023-08-02T17:44:18Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282234657",
      "id" : 1282234657,
      "line" : 258,
      "node_id" : "PRRC_kwDOABII585MbVkh",
      "original_commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_line" : 258,
      "original_position" : 258,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : 258,
      "pull_request_review_id" : 1559366940,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282234657/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-02T18:24:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282234657",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282243358"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282243358"
         }
      },
      "author_association" : "MEMBER",
      "body" : "can't we just reconsider it again?",
      "commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "created_at" : "2023-08-02T17:53:41Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282243358",
      "id" : 1282243358,
      "line" : 280,
      "node_id" : "PRRC_kwDOABII585MbXse",
      "original_commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_line" : 280,
      "original_position" : 280,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : 280,
      "pull_request_review_id" : 1559366940,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282243358/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-02T18:24:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282243358",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282251680"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282251680"
         }
      },
      "author_association" : "MEMBER",
      "body" : "took me a second, just assert it's not in mempool for those quickly reading ",
      "commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "created_at" : "2023-08-02T18:02:11Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)\n+        self.generate(node, 1)\n+        node.syncwithvalidationinterfacequeue()\n+\n+        # This UTXO confirmed recently.\n+        utxo_conf_recent = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        self.generate(node, 1)\n+\n+        # This UTXO is unconfirmed and in the mempool.\n+        assert_equal(len(node.getrawmempool()), 0)\n+        mempool_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_unconf_mempool = mempool_tx[\"new_utxo\"]\n+\n+        # This UTXO is unconfirmed and missing.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282251680",
      "id" : 1282251680,
      "line" : 293,
      "node_id" : "PRRC_kwDOABII585MbZug",
      "original_commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_line" : 293,
      "original_position" : 293,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : 293,
      "pull_request_review_id" : 1559366940,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282251680/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-02T18:24:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282251680",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282257631"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282257631"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n        \"\"\"Check that the node does not immediately respond to this message with any of\r\n```",
      "commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "created_at" : "2023-08-02T18:06:00Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282257631",
      "id" : 1282257631,
      "line" : 109,
      "node_id" : "PRRC_kwDOABII585MbbLf",
      "original_commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_line" : 109,
      "original_position" : 109,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : 109,
      "pull_request_review_id" : 1559366940,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282257631/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-02T18:24:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282257631",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282258402"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282258402"
         }
      },
      "author_association" : "MEMBER",
      "body" : "can we assert that peer_spy hasn't received the INV, just to be sure?",
      "commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "created_at" : "2023-08-02T18:06:57Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282258402",
      "id" : 1282258402,
      "line" : 180,
      "node_id" : "PRRC_kwDOABII585MbbXi",
      "original_commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_line" : 180,
      "original_position" : 180,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : 180,
      "pull_request_review_id" : 1559366940,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282258402/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-02T18:24:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282258402",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282259677"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282259677"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't get this case. Why wouldn't you request a \"fake\" parent if you don't know it's fake already?",
      "commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "created_at" : "2023-08-02T18:08:27Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282259677",
      "id" : 1282259677,
      "line" : 191,
      "node_id" : "PRRC_kwDOABII585Mbbrd",
      "original_commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_line" : 191,
      "original_position" : 191,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : 191,
      "pull_request_review_id" : 1559366940,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282259677/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-02T18:24:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282259677",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282261573"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282261573"
         }
      },
      "author_association" : "MEMBER",
      "body" : "does this wallet never use 0-conf change? would be nice to assert to make it clear the lack of utxo connection",
      "commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "created_at" : "2023-08-02T18:09:53Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)\n+        self.generate(node, 1)\n+        node.syncwithvalidationinterfacequeue()\n+\n+        # This UTXO confirmed recently.\n+        utxo_conf_recent = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        self.generate(node, 1)\n+\n+        # This UTXO is unconfirmed and in the mempool.\n+        assert_equal(len(node.getrawmempool()), 0)\n+        mempool_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_unconf_mempool = mempool_tx[\"new_utxo\"]\n+\n+        # This UTXO is unconfirmed and missing.\n+        missing_tx = self.wallet.create_self_transfer()\n+        utxo_unconf_missing = missing_tx[\"new_utxo\"]\n+\n+        orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[utxo_conf_old,\n+            utxo_conf_recent, utxo_unconf_mempool, utxo_unconf_missing])\n+\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.sync_with_ping()\n+        assert_equal(len(peer.last_message[\"getdata\"].inv), 2)\n+        peer.wait_for_parent_requests([int(txid_conf_old, 16), int(missing_tx[\"txid\"], 16)])\n+\n+        # Even though the peer would send a notfound for the \"old\" confirmed transaction, the node\n+        # doesn't give up on the orphan. Once all of the missing parents are received, it should be\n+        # submitted to mempool.\n+        peer.send_message(msg_notfound(vec=[CInv(MSG_WITNESS_TX, int(txid_conf_old, 16))]))\n+        peer.send_and_ping(msg_tx(missing_tx[\"tx\"]))\n+        peer.sync_with_ping()\n+        assert_equal(node.getmempoolentry(orphan[\"txid\"])[\"ancestorcount\"], 3)\n+\n+    @cleanup\n+    def test_orphans_overlapping_parents(self):\n+        node = self.nodes[0]\n+        # In the process of relaying inflight_parent_AB\n+        peer_txrequest = node.add_p2p_connection(PeerTxRelayer())\n+        # Sends the orphans\n+        peer_orphans = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test handling of multiple orphans with missing parents that are already being requested\")\n+        # Parent of child_A only\n+        missing_parent_A = self.wallet_nonsegwit.create_self_transfer()\n+        # Parents of child_A and child_B\n+        missing_parent_AB = self.wallet_nonsegwit.create_self_transfer()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282261573",
      "id" : 1282261573,
      "line" : 326,
      "node_id" : "PRRC_kwDOABII585MbcJF",
      "original_commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_line" : 326,
      "original_position" : 326,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : 326,
      "pull_request_review_id" : 1559366940,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282261573/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-02T18:24:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282261573",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282268679"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282268679"
         }
      },
      "author_association" : "MEMBER",
      "body" : "\"The node should not request a parent if it has an in-flight txrequest\" ? Seems like parents are being reqiested. Maybe a typo or I can't tell what scenario it's covering.",
      "commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "created_at" : "2023-08-02T18:17:38Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)\n+        self.generate(node, 1)\n+        node.syncwithvalidationinterfacequeue()\n+\n+        # This UTXO confirmed recently.\n+        utxo_conf_recent = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        self.generate(node, 1)\n+\n+        # This UTXO is unconfirmed and in the mempool.\n+        assert_equal(len(node.getrawmempool()), 0)\n+        mempool_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_unconf_mempool = mempool_tx[\"new_utxo\"]\n+\n+        # This UTXO is unconfirmed and missing.\n+        missing_tx = self.wallet.create_self_transfer()\n+        utxo_unconf_missing = missing_tx[\"new_utxo\"]\n+\n+        orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[utxo_conf_old,\n+            utxo_conf_recent, utxo_unconf_mempool, utxo_unconf_missing])\n+\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.sync_with_ping()\n+        assert_equal(len(peer.last_message[\"getdata\"].inv), 2)\n+        peer.wait_for_parent_requests([int(txid_conf_old, 16), int(missing_tx[\"txid\"], 16)])\n+\n+        # Even though the peer would send a notfound for the \"old\" confirmed transaction, the node\n+        # doesn't give up on the orphan. Once all of the missing parents are received, it should be\n+        # submitted to mempool.\n+        peer.send_message(msg_notfound(vec=[CInv(MSG_WITNESS_TX, int(txid_conf_old, 16))]))\n+        peer.send_and_ping(msg_tx(missing_tx[\"tx\"]))\n+        peer.sync_with_ping()\n+        assert_equal(node.getmempoolentry(orphan[\"txid\"])[\"ancestorcount\"], 3)\n+\n+    @cleanup\n+    def test_orphans_overlapping_parents(self):\n+        node = self.nodes[0]\n+        # In the process of relaying inflight_parent_AB\n+        peer_txrequest = node.add_p2p_connection(PeerTxRelayer())\n+        # Sends the orphans\n+        peer_orphans = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test handling of multiple orphans with missing parents that are already being requested\")\n+        # Parent of child_A only\n+        missing_parent_A = self.wallet_nonsegwit.create_self_transfer()\n+        # Parents of child_A and child_B\n+        missing_parent_AB = self.wallet_nonsegwit.create_self_transfer()\n+        inflight_parent_AB = self.wallet_nonsegwit.create_self_transfer()\n+        # Parent of child_B only\n+        missing_parent_B = self.wallet_nonsegwit.create_self_transfer()\n+        child_A = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_A[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+        child_B = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_B[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+\n+        # The wtxid and txid need to be the same for the node to recognize that the missing input\n+        # and in-flight request for inflight_parent_AB are the same transaction.\n+        assert_equal(inflight_parent_AB[\"txid\"], inflight_parent_AB[\"tx\"].getwtxid())\n+\n+        # Announce inflight_parent_AB and wait for getdata\n+        peer_txrequest.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=int(inflight_parent_AB[\"tx\"].getwtxid(), 16))]))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_txrequest.wait_for_getdata([int(inflight_parent_AB[\"tx\"].getwtxid(), 16)])\n+\n+        self.log.info(\"The node should not request a parent if it has an in-flight txrequest\")\n+        # Relay orphan child_A\n+        self.relay_transaction(peer_orphans, child_A[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        # Both missing parents should be requested.\n+        peer_orphans.wait_for_parent_requests([int(missing_parent_A[\"txid\"], 16), int(missing_parent_AB[\"txid\"], 16)])",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282268679",
      "id" : 1282268679,
      "line" : 351,
      "node_id" : "PRRC_kwDOABII585Mbd4H",
      "original_commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_line" : 351,
      "original_position" : 351,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : 351,
      "pull_request_review_id" : 1559366940,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282268679/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-02T18:24:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282268679",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282274277"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282274277"
         }
      },
      "author_association" : "MEMBER",
      "body" : "bit of a repeat with test_orphan_rejected_parents_exceptions ?",
      "commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "created_at" : "2023-08-02T18:23:51Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)\n+        self.generate(node, 1)\n+        node.syncwithvalidationinterfacequeue()\n+\n+        # This UTXO confirmed recently.\n+        utxo_conf_recent = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        self.generate(node, 1)\n+\n+        # This UTXO is unconfirmed and in the mempool.\n+        assert_equal(len(node.getrawmempool()), 0)\n+        mempool_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_unconf_mempool = mempool_tx[\"new_utxo\"]\n+\n+        # This UTXO is unconfirmed and missing.\n+        missing_tx = self.wallet.create_self_transfer()\n+        utxo_unconf_missing = missing_tx[\"new_utxo\"]\n+\n+        orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[utxo_conf_old,\n+            utxo_conf_recent, utxo_unconf_mempool, utxo_unconf_missing])\n+\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.sync_with_ping()\n+        assert_equal(len(peer.last_message[\"getdata\"].inv), 2)\n+        peer.wait_for_parent_requests([int(txid_conf_old, 16), int(missing_tx[\"txid\"], 16)])\n+\n+        # Even though the peer would send a notfound for the \"old\" confirmed transaction, the node\n+        # doesn't give up on the orphan. Once all of the missing parents are received, it should be\n+        # submitted to mempool.\n+        peer.send_message(msg_notfound(vec=[CInv(MSG_WITNESS_TX, int(txid_conf_old, 16))]))\n+        peer.send_and_ping(msg_tx(missing_tx[\"tx\"]))\n+        peer.sync_with_ping()\n+        assert_equal(node.getmempoolentry(orphan[\"txid\"])[\"ancestorcount\"], 3)\n+\n+    @cleanup\n+    def test_orphans_overlapping_parents(self):\n+        node = self.nodes[0]\n+        # In the process of relaying inflight_parent_AB\n+        peer_txrequest = node.add_p2p_connection(PeerTxRelayer())\n+        # Sends the orphans\n+        peer_orphans = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test handling of multiple orphans with missing parents that are already being requested\")\n+        # Parent of child_A only\n+        missing_parent_A = self.wallet_nonsegwit.create_self_transfer()\n+        # Parents of child_A and child_B\n+        missing_parent_AB = self.wallet_nonsegwit.create_self_transfer()\n+        inflight_parent_AB = self.wallet_nonsegwit.create_self_transfer()\n+        # Parent of child_B only\n+        missing_parent_B = self.wallet_nonsegwit.create_self_transfer()\n+        child_A = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_A[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+        child_B = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_B[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+\n+        # The wtxid and txid need to be the same for the node to recognize that the missing input\n+        # and in-flight request for inflight_parent_AB are the same transaction.\n+        assert_equal(inflight_parent_AB[\"txid\"], inflight_parent_AB[\"tx\"].getwtxid())\n+\n+        # Announce inflight_parent_AB and wait for getdata\n+        peer_txrequest.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=int(inflight_parent_AB[\"tx\"].getwtxid(), 16))]))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_txrequest.wait_for_getdata([int(inflight_parent_AB[\"tx\"].getwtxid(), 16)])\n+\n+        self.log.info(\"The node should not request a parent if it has an in-flight txrequest\")\n+        # Relay orphan child_A\n+        self.relay_transaction(peer_orphans, child_A[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        # Both missing parents should be requested.\n+        peer_orphans.wait_for_parent_requests([int(missing_parent_A[\"txid\"], 16), int(missing_parent_AB[\"txid\"], 16)])\n+\n+        self.log.info(\"The node should not request a parent if it has an in-flight orphan parent request\")\n+        # Relay orphan child_B\n+        self.relay_transaction(peer_orphans, child_B[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        # Only missing_parent_B should be requested. Not inflight_parent_AB or missing_parent_AB\n+        # because they are already being requested from peer_orphans.\n+        peer_orphans.wait_for_parent_requests([int(missing_parent_B[\"txid\"], 16)])\n+        peer_orphans.assert_never_requested(int(inflight_parent_AB[\"txid\"], 16))\n+\n+    @cleanup\n+    def test_orphan_of_orphan(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test handling of an orphan with a parent who is another orphan\")\n+        missing_grandparent = self.wallet_nonsegwit.create_self_transfer()\n+        missing_parent_orphan = self.wallet_nonsegwit.create_self_transfer(utxo_to_spend=missing_grandparent[\"new_utxo\"])\n+        missing_parent = self.wallet_nonsegwit.create_self_transfer()\n+        orphan = self.wallet_nonsegwit.create_self_transfer_multi(utxos_to_spend=[missing_parent[\"new_utxo\"], missing_parent_orphan[\"new_utxo\"]])\n+\n+        # The node should put missing_parent_orphan into the orphanage and request missing_grandparent\n+        self.relay_transaction(peer, missing_parent_orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.wait_for_parent_requests([int(missing_grandparent[\"txid\"], 16)])\n+\n+        # The node should put the orphan into the orphanage and request missing_parent, skipping\n+        # missing_parent_orphan because it already has it in the orphanage.\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.wait_for_parent_requests([int(missing_parent[\"txid\"], 16)])\n+\n+    @cleanup\n+    def test_orphan_inherit_rejection(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+        peer3 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282274277",
      "id" : 1282274277,
      "line" : 391,
      "node_id" : "PRRC_kwDOABII585MbfPl",
      "original_commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_line" : 391,
      "original_position" : 391,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : 391,
      "pull_request_review_id" : 1559366940,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282274277/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-02T18:24:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282274277",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282831868"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282831868"
         }
      },
      "author_association" : "MEMBER",
      "body" : "removed comment block",
      "commit_id" : "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "created_at" : "2023-08-03T08:23:55Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282831868",
      "id" : 1282831868,
      "in_reply_to_id" : 1282131242,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585MdnX8",
      "original_commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_line" : 6,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : null,
      "pull_request_review_id" : 1560507719,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282831868/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-03T10:13:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282831868",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282832651"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282832651"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "created_at" : "2023-08-03T08:24:31Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282832651",
      "id" : 1282832651,
      "in_reply_to_id" : 1282208201,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585MdnkL",
      "original_commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_line" : 57,
      "original_position" : 57,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : null,
      "pull_request_review_id" : 1560507719,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282832651/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-03T10:13:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282832651",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282834565"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282834565"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done, and renamed to `assert_no_immediate_response`",
      "commit_id" : "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "created_at" : "2023-08-03T08:26:00Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282834565",
      "id" : 1282834565,
      "in_reply_to_id" : 1282257631,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585MdoCF",
      "original_commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_line" : 109,
      "original_position" : 109,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : null,
      "pull_request_review_id" : 1560507719,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282834565/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-03T10:13:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282834565",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282837698"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282837698"
         }
      },
      "author_association" : "MEMBER",
      "body" : "added",
      "commit_id" : "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "created_at" : "2023-08-03T08:28:28Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282837698",
      "id" : 1282837698,
      "in_reply_to_id" : 1282258402,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585MdozC",
      "original_commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_line" : 180,
      "original_position" : 180,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : null,
      "pull_request_review_id" : 1560507719,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282837698/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-03T10:13:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282837698",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282850596"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282850596"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Edited the comments.\r\n\r\nWithout delays and filtering right before sending, I figured you could query whether `tx_real` has arrived in the node's mempool yet by sending a fake orphan that spends from it (if the node requests `tx_real` they don't have it yet, if they don't request it then it's already in mempool/seen). Hence \"reveal.\" But you can only know whether `tx_real` arrived in the last ~2-4 seconds.",
      "commit_id" : "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "created_at" : "2023-08-03T08:39:22Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282850596",
      "id" : 1282850596,
      "in_reply_to_id" : 1282259677,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Mdr8k",
      "original_commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_line" : 191,
      "original_position" : 191,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : null,
      "pull_request_review_id" : 1560507719,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282850596/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-03T10:13:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282850596",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282853373"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282853373"
         }
      },
      "author_association" : "MEMBER",
      "body" : "added",
      "commit_id" : "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "created_at" : "2023-08-03T08:41:00Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)\n+        self.generate(node, 1)\n+        node.syncwithvalidationinterfacequeue()\n+\n+        # This UTXO confirmed recently.\n+        utxo_conf_recent = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        self.generate(node, 1)\n+\n+        # This UTXO is unconfirmed and in the mempool.\n+        assert_equal(len(node.getrawmempool()), 0)\n+        mempool_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_unconf_mempool = mempool_tx[\"new_utxo\"]\n+\n+        # This UTXO is unconfirmed and missing.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282853373",
      "id" : 1282853373,
      "in_reply_to_id" : 1282251680,
      "line" : 274,
      "node_id" : "PRRC_kwDOABII585Mdsn9",
      "original_commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_line" : 274,
      "original_position" : 293,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : 274,
      "pull_request_review_id" : 1560507719,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282853373/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-03T10:13:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282853373",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282857628"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282857628"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It should not request `inflight_parent_AB` even though it's one of the missing parents. I'll add a comment to explain this.",
      "commit_id" : "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "created_at" : "2023-08-03T08:44:06Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)\n+        self.generate(node, 1)\n+        node.syncwithvalidationinterfacequeue()\n+\n+        # This UTXO confirmed recently.\n+        utxo_conf_recent = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        self.generate(node, 1)\n+\n+        # This UTXO is unconfirmed and in the mempool.\n+        assert_equal(len(node.getrawmempool()), 0)\n+        mempool_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_unconf_mempool = mempool_tx[\"new_utxo\"]\n+\n+        # This UTXO is unconfirmed and missing.\n+        missing_tx = self.wallet.create_self_transfer()\n+        utxo_unconf_missing = missing_tx[\"new_utxo\"]\n+\n+        orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[utxo_conf_old,\n+            utxo_conf_recent, utxo_unconf_mempool, utxo_unconf_missing])\n+\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.sync_with_ping()\n+        assert_equal(len(peer.last_message[\"getdata\"].inv), 2)\n+        peer.wait_for_parent_requests([int(txid_conf_old, 16), int(missing_tx[\"txid\"], 16)])\n+\n+        # Even though the peer would send a notfound for the \"old\" confirmed transaction, the node\n+        # doesn't give up on the orphan. Once all of the missing parents are received, it should be\n+        # submitted to mempool.\n+        peer.send_message(msg_notfound(vec=[CInv(MSG_WITNESS_TX, int(txid_conf_old, 16))]))\n+        peer.send_and_ping(msg_tx(missing_tx[\"tx\"]))\n+        peer.sync_with_ping()\n+        assert_equal(node.getmempoolentry(orphan[\"txid\"])[\"ancestorcount\"], 3)\n+\n+    @cleanup\n+    def test_orphans_overlapping_parents(self):\n+        node = self.nodes[0]\n+        # In the process of relaying inflight_parent_AB\n+        peer_txrequest = node.add_p2p_connection(PeerTxRelayer())\n+        # Sends the orphans\n+        peer_orphans = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test handling of multiple orphans with missing parents that are already being requested\")\n+        # Parent of child_A only\n+        missing_parent_A = self.wallet_nonsegwit.create_self_transfer()\n+        # Parents of child_A and child_B\n+        missing_parent_AB = self.wallet_nonsegwit.create_self_transfer()\n+        inflight_parent_AB = self.wallet_nonsegwit.create_self_transfer()\n+        # Parent of child_B only\n+        missing_parent_B = self.wallet_nonsegwit.create_self_transfer()\n+        child_A = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_A[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+        child_B = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_B[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+\n+        # The wtxid and txid need to be the same for the node to recognize that the missing input\n+        # and in-flight request for inflight_parent_AB are the same transaction.\n+        assert_equal(inflight_parent_AB[\"txid\"], inflight_parent_AB[\"tx\"].getwtxid())\n+\n+        # Announce inflight_parent_AB and wait for getdata\n+        peer_txrequest.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=int(inflight_parent_AB[\"tx\"].getwtxid(), 16))]))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_txrequest.wait_for_getdata([int(inflight_parent_AB[\"tx\"].getwtxid(), 16)])\n+\n+        self.log.info(\"The node should not request a parent if it has an in-flight txrequest\")\n+        # Relay orphan child_A\n+        self.relay_transaction(peer_orphans, child_A[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        # Both missing parents should be requested.\n+        peer_orphans.wait_for_parent_requests([int(missing_parent_A[\"txid\"], 16), int(missing_parent_AB[\"txid\"], 16)])",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282857628",
      "id" : 1282857628,
      "in_reply_to_id" : 1282268679,
      "line" : 336,
      "node_id" : "PRRC_kwDOABII585Mdtqc",
      "original_commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_line" : 336,
      "original_position" : 351,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : 336,
      "pull_request_review_id" : 1560507719,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282857628/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-03T10:13:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282857628",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282862310"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282862310"
         }
      },
      "author_association" : "MEMBER",
      "body" : "True this could be combined. The main idea for this test is that this transaction's failure propagates all the way to the grandchild.",
      "commit_id" : "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "created_at" : "2023-08-03T08:47:14Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)\n+        self.generate(node, 1)\n+        node.syncwithvalidationinterfacequeue()\n+\n+        # This UTXO confirmed recently.\n+        utxo_conf_recent = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        self.generate(node, 1)\n+\n+        # This UTXO is unconfirmed and in the mempool.\n+        assert_equal(len(node.getrawmempool()), 0)\n+        mempool_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_unconf_mempool = mempool_tx[\"new_utxo\"]\n+\n+        # This UTXO is unconfirmed and missing.\n+        missing_tx = self.wallet.create_self_transfer()\n+        utxo_unconf_missing = missing_tx[\"new_utxo\"]\n+\n+        orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[utxo_conf_old,\n+            utxo_conf_recent, utxo_unconf_mempool, utxo_unconf_missing])\n+\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.sync_with_ping()\n+        assert_equal(len(peer.last_message[\"getdata\"].inv), 2)\n+        peer.wait_for_parent_requests([int(txid_conf_old, 16), int(missing_tx[\"txid\"], 16)])\n+\n+        # Even though the peer would send a notfound for the \"old\" confirmed transaction, the node\n+        # doesn't give up on the orphan. Once all of the missing parents are received, it should be\n+        # submitted to mempool.\n+        peer.send_message(msg_notfound(vec=[CInv(MSG_WITNESS_TX, int(txid_conf_old, 16))]))\n+        peer.send_and_ping(msg_tx(missing_tx[\"tx\"]))\n+        peer.sync_with_ping()\n+        assert_equal(node.getmempoolentry(orphan[\"txid\"])[\"ancestorcount\"], 3)\n+\n+    @cleanup\n+    def test_orphans_overlapping_parents(self):\n+        node = self.nodes[0]\n+        # In the process of relaying inflight_parent_AB\n+        peer_txrequest = node.add_p2p_connection(PeerTxRelayer())\n+        # Sends the orphans\n+        peer_orphans = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test handling of multiple orphans with missing parents that are already being requested\")\n+        # Parent of child_A only\n+        missing_parent_A = self.wallet_nonsegwit.create_self_transfer()\n+        # Parents of child_A and child_B\n+        missing_parent_AB = self.wallet_nonsegwit.create_self_transfer()\n+        inflight_parent_AB = self.wallet_nonsegwit.create_self_transfer()\n+        # Parent of child_B only\n+        missing_parent_B = self.wallet_nonsegwit.create_self_transfer()\n+        child_A = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_A[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+        child_B = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_B[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+\n+        # The wtxid and txid need to be the same for the node to recognize that the missing input\n+        # and in-flight request for inflight_parent_AB are the same transaction.\n+        assert_equal(inflight_parent_AB[\"txid\"], inflight_parent_AB[\"tx\"].getwtxid())\n+\n+        # Announce inflight_parent_AB and wait for getdata\n+        peer_txrequest.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=int(inflight_parent_AB[\"tx\"].getwtxid(), 16))]))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_txrequest.wait_for_getdata([int(inflight_parent_AB[\"tx\"].getwtxid(), 16)])\n+\n+        self.log.info(\"The node should not request a parent if it has an in-flight txrequest\")\n+        # Relay orphan child_A\n+        self.relay_transaction(peer_orphans, child_A[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        # Both missing parents should be requested.\n+        peer_orphans.wait_for_parent_requests([int(missing_parent_A[\"txid\"], 16), int(missing_parent_AB[\"txid\"], 16)])\n+\n+        self.log.info(\"The node should not request a parent if it has an in-flight orphan parent request\")\n+        # Relay orphan child_B\n+        self.relay_transaction(peer_orphans, child_B[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        # Only missing_parent_B should be requested. Not inflight_parent_AB or missing_parent_AB\n+        # because they are already being requested from peer_orphans.\n+        peer_orphans.wait_for_parent_requests([int(missing_parent_B[\"txid\"], 16)])\n+        peer_orphans.assert_never_requested(int(inflight_parent_AB[\"txid\"], 16))\n+\n+    @cleanup\n+    def test_orphan_of_orphan(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test handling of an orphan with a parent who is another orphan\")\n+        missing_grandparent = self.wallet_nonsegwit.create_self_transfer()\n+        missing_parent_orphan = self.wallet_nonsegwit.create_self_transfer(utxo_to_spend=missing_grandparent[\"new_utxo\"])\n+        missing_parent = self.wallet_nonsegwit.create_self_transfer()\n+        orphan = self.wallet_nonsegwit.create_self_transfer_multi(utxos_to_spend=[missing_parent[\"new_utxo\"], missing_parent_orphan[\"new_utxo\"]])\n+\n+        # The node should put missing_parent_orphan into the orphanage and request missing_grandparent\n+        self.relay_transaction(peer, missing_parent_orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.wait_for_parent_requests([int(missing_grandparent[\"txid\"], 16)])\n+\n+        # The node should put the orphan into the orphanage and request missing_parent, skipping\n+        # missing_parent_orphan because it already has it in the orphanage.\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.wait_for_parent_requests([int(missing_parent[\"txid\"], 16)])\n+\n+    @cleanup\n+    def test_orphan_inherit_rejection(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+        peer3 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282862310",
      "id" : 1282862310,
      "in_reply_to_id" : 1282274277,
      "line" : 376,
      "node_id" : "PRRC_kwDOABII585Mduzm",
      "original_commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_line" : 376,
      "original_position" : 391,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : 376,
      "pull_request_review_id" : 1560507719,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282862310/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-03T10:13:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282862310",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282889026"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282889026"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Added",
      "commit_id" : "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "created_at" : "2023-08-03T09:07:38Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282889026",
      "id" : 1282889026,
      "in_reply_to_id" : 1282234657,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Md1VC",
      "original_commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_line" : 258,
      "original_position" : 258,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : null,
      "pull_request_review_id" : 1560507719,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282889026/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-03T10:13:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282889026",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282919246"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282919246"
         }
      },
      "author_association" : "MEMBER",
      "body" : "changed so we grab the utxos before making any transactions, so they all have to be confirmed and not related",
      "commit_id" : "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "created_at" : "2023-08-03T09:32:01Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)\n+        self.generate(node, 1)\n+        node.syncwithvalidationinterfacequeue()\n+\n+        # This UTXO confirmed recently.\n+        utxo_conf_recent = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        self.generate(node, 1)\n+\n+        # This UTXO is unconfirmed and in the mempool.\n+        assert_equal(len(node.getrawmempool()), 0)\n+        mempool_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_unconf_mempool = mempool_tx[\"new_utxo\"]\n+\n+        # This UTXO is unconfirmed and missing.\n+        missing_tx = self.wallet.create_self_transfer()\n+        utxo_unconf_missing = missing_tx[\"new_utxo\"]\n+\n+        orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[utxo_conf_old,\n+            utxo_conf_recent, utxo_unconf_mempool, utxo_unconf_missing])\n+\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.sync_with_ping()\n+        assert_equal(len(peer.last_message[\"getdata\"].inv), 2)\n+        peer.wait_for_parent_requests([int(txid_conf_old, 16), int(missing_tx[\"txid\"], 16)])\n+\n+        # Even though the peer would send a notfound for the \"old\" confirmed transaction, the node\n+        # doesn't give up on the orphan. Once all of the missing parents are received, it should be\n+        # submitted to mempool.\n+        peer.send_message(msg_notfound(vec=[CInv(MSG_WITNESS_TX, int(txid_conf_old, 16))]))\n+        peer.send_and_ping(msg_tx(missing_tx[\"tx\"]))\n+        peer.sync_with_ping()\n+        assert_equal(node.getmempoolentry(orphan[\"txid\"])[\"ancestorcount\"], 3)\n+\n+    @cleanup\n+    def test_orphans_overlapping_parents(self):\n+        node = self.nodes[0]\n+        # In the process of relaying inflight_parent_AB\n+        peer_txrequest = node.add_p2p_connection(PeerTxRelayer())\n+        # Sends the orphans\n+        peer_orphans = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test handling of multiple orphans with missing parents that are already being requested\")\n+        # Parent of child_A only\n+        missing_parent_A = self.wallet_nonsegwit.create_self_transfer()\n+        # Parents of child_A and child_B\n+        missing_parent_AB = self.wallet_nonsegwit.create_self_transfer()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282919246",
      "id" : 1282919246,
      "in_reply_to_id" : 1282261573,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Md8tO",
      "original_commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_line" : 326,
      "original_position" : 326,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : null,
      "pull_request_review_id" : 1560507719,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282919246/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-03T10:13:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282919246",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282920253"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282920253"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Sure, changed.",
      "commit_id" : "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "created_at" : "2023-08-03T09:32:50Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282920253",
      "id" : 1282920253,
      "in_reply_to_id" : 1282243358,
      "line" : 261,
      "node_id" : "PRRC_kwDOABII585Md889",
      "original_commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_line" : 261,
      "original_position" : 280,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : 261,
      "pull_request_review_id" : 1560507719,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282920253/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-03T10:13:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282920253",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1283215687"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283215687"
         }
      },
      "author_association" : "MEMBER",
      "body" : "much clearer, thanks",
      "commit_id" : "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "created_at" : "2023-08-03T13:34:58Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)\n+        self.generate(node, 1)\n+        node.syncwithvalidationinterfacequeue()\n+\n+        # This UTXO confirmed recently.\n+        utxo_conf_recent = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        self.generate(node, 1)\n+\n+        # This UTXO is unconfirmed and in the mempool.\n+        assert_equal(len(node.getrawmempool()), 0)\n+        mempool_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_unconf_mempool = mempool_tx[\"new_utxo\"]\n+\n+        # This UTXO is unconfirmed and missing.\n+        missing_tx = self.wallet.create_self_transfer()\n+        utxo_unconf_missing = missing_tx[\"new_utxo\"]\n+\n+        orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[utxo_conf_old,\n+            utxo_conf_recent, utxo_unconf_mempool, utxo_unconf_missing])\n+\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.sync_with_ping()\n+        assert_equal(len(peer.last_message[\"getdata\"].inv), 2)\n+        peer.wait_for_parent_requests([int(txid_conf_old, 16), int(missing_tx[\"txid\"], 16)])\n+\n+        # Even though the peer would send a notfound for the \"old\" confirmed transaction, the node\n+        # doesn't give up on the orphan. Once all of the missing parents are received, it should be\n+        # submitted to mempool.\n+        peer.send_message(msg_notfound(vec=[CInv(MSG_WITNESS_TX, int(txid_conf_old, 16))]))\n+        peer.send_and_ping(msg_tx(missing_tx[\"tx\"]))\n+        peer.sync_with_ping()\n+        assert_equal(node.getmempoolentry(orphan[\"txid\"])[\"ancestorcount\"], 3)\n+\n+    @cleanup\n+    def test_orphans_overlapping_parents(self):\n+        node = self.nodes[0]\n+        # In the process of relaying inflight_parent_AB\n+        peer_txrequest = node.add_p2p_connection(PeerTxRelayer())\n+        # Sends the orphans\n+        peer_orphans = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test handling of multiple orphans with missing parents that are already being requested\")\n+        # Parent of child_A only\n+        missing_parent_A = self.wallet_nonsegwit.create_self_transfer()\n+        # Parents of child_A and child_B\n+        missing_parent_AB = self.wallet_nonsegwit.create_self_transfer()\n+        inflight_parent_AB = self.wallet_nonsegwit.create_self_transfer()\n+        # Parent of child_B only\n+        missing_parent_B = self.wallet_nonsegwit.create_self_transfer()\n+        child_A = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_A[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+        child_B = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_B[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+\n+        # The wtxid and txid need to be the same for the node to recognize that the missing input\n+        # and in-flight request for inflight_parent_AB are the same transaction.\n+        assert_equal(inflight_parent_AB[\"txid\"], inflight_parent_AB[\"tx\"].getwtxid())\n+\n+        # Announce inflight_parent_AB and wait for getdata\n+        peer_txrequest.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=int(inflight_parent_AB[\"tx\"].getwtxid(), 16))]))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_txrequest.wait_for_getdata([int(inflight_parent_AB[\"tx\"].getwtxid(), 16)])\n+\n+        self.log.info(\"The node should not request a parent if it has an in-flight txrequest\")\n+        # Relay orphan child_A\n+        self.relay_transaction(peer_orphans, child_A[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        # Both missing parents should be requested.\n+        peer_orphans.wait_for_parent_requests([int(missing_parent_A[\"txid\"], 16), int(missing_parent_AB[\"txid\"], 16)])",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1283215687",
      "id" : 1283215687,
      "in_reply_to_id" : 1282268679,
      "line" : 336,
      "node_id" : "PRRC_kwDOABII585MfFFH",
      "original_commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_line" : 336,
      "original_position" : 351,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : 336,
      "pull_request_review_id" : 1561117972,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283215687/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-03T13:58:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283215687",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1283217052"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283217052"
         }
      },
      "author_association" : "MEMBER",
      "body" : "didn't realize `preciousblock` also reconsidered the block!\r\n\r\nwas thinking `reconsiderblock`\r\n",
      "commit_id" : "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "created_at" : "2023-08-03T13:35:57Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1283217052",
      "id" : 1283217052,
      "in_reply_to_id" : 1282243358,
      "line" : 261,
      "node_id" : "PRRC_kwDOABII585MfFac",
      "original_commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_line" : 261,
      "original_position" : 280,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : 261,
      "pull_request_review_id" : 1561117972,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283217052/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-03T13:58:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283217052",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1283241941"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283241941"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n        peer_normal.send_and_ping(msg_tx(tx_parent_arrives[\"tx\"]))\r\n        assert tx_parent_arrives[\"txid\"] in node.getrawmempool()\r\n```\r\nmy brain for some reason was thinking it was in the orphan pool as well",
      "commit_id" : "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "created_at" : "2023-08-03T13:53:57Z",
      "diff_hunk" : "@@ -0,0 +1,424 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+def cleanup(func):\n+    # Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+    # one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+    # (though nothing should since state should be cleared) in p2p data structures.\n+    LONG_TIME_SKIP = 12 * 60 * 60\n+\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_no_immediate_response(self, message):\n+        \"\"\"Check that the node does not immediately respond to this message with any of getdata,\n+        inv, tx. The node may respond later.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test missing parents that arrive during delay are not requested\")\n+        node = self.nodes[0]\n+        tx_parent_arrives = self.wallet.create_self_transfer()\n+        tx_parent_doesnt_arrive = self.wallet.create_self_transfer()\n+        # Fake orphan spends nonexistent outputs of the two parents\n+        tx_fake_orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[\n+            {\"txid\": tx_parent_doesnt_arrive[\"txid\"], \"vout\": 10, \"value\": tx_parent_doesnt_arrive[\"new_utxo\"][\"value\"]},\n+            {\"txid\": tx_parent_arrives[\"txid\"], \"vout\": 10, \"value\": tx_parent_arrives[\"new_utxo\"][\"value\"]}\n+        ])\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        peer_normal = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_no_immediate_response(msg_tx(tx_fake_orphan[\"tx\"]))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool. Send unsolicited because otherwise we need to wait for\n+        # request delays.\n+        peer_normal.send_and_ping(msg_tx(tx_parent_arrives[\"tx\"]))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1283241941",
      "id" : 1283241941,
      "line" : 161,
      "node_id" : "PRRC_kwDOABII585MfLfV",
      "original_commit_id" : "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "original_line" : 161,
      "original_position" : 161,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : 161,
      "pull_request_review_id" : 1561117972,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283241941/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-03T13:58:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283241941",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1283247917"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283247917"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Ok I feel like I understand the test, but I still don't know why it's important the orphan is fake so I'm likely missing something",
      "commit_id" : "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "created_at" : "2023-08-03T13:57:57Z",
      "diff_hunk" : "@@ -0,0 +1,424 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+def cleanup(func):\n+    # Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+    # one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+    # (though nothing should since state should be cleared) in p2p data structures.\n+    LONG_TIME_SKIP = 12 * 60 * 60\n+\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_no_immediate_response(self, message):\n+        \"\"\"Check that the node does not immediately respond to this message with any of getdata,\n+        inv, tx. The node may respond later.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test missing parents that arrive during delay are not requested\")\n+        node = self.nodes[0]\n+        tx_parent_arrives = self.wallet.create_self_transfer()\n+        tx_parent_doesnt_arrive = self.wallet.create_self_transfer()\n+        # Fake orphan spends nonexistent outputs of the two parents",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1283247917",
      "id" : 1283247917,
      "line" : 144,
      "node_id" : "PRRC_kwDOABII585MfM8t",
      "original_commit_id" : "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "original_line" : 144,
      "original_position" : 144,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : 144,
      "pull_request_review_id" : 1561117972,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283247917/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-03T13:58:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283247917",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1283271742"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283271742"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It's not that important :shrug: it can be a real child. I wrote the test trying to illustrate a spy peer trying to get information, i.e. one that doesn't have the ability to spend the transaction's UTXOs.",
      "commit_id" : "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "created_at" : "2023-08-03T14:15:25Z",
      "diff_hunk" : "@@ -0,0 +1,424 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+def cleanup(func):\n+    # Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+    # one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+    # (though nothing should since state should be cleared) in p2p data structures.\n+    LONG_TIME_SKIP = 12 * 60 * 60\n+\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_no_immediate_response(self, message):\n+        \"\"\"Check that the node does not immediately respond to this message with any of getdata,\n+        inv, tx. The node may respond later.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test missing parents that arrive during delay are not requested\")\n+        node = self.nodes[0]\n+        tx_parent_arrives = self.wallet.create_self_transfer()\n+        tx_parent_doesnt_arrive = self.wallet.create_self_transfer()\n+        # Fake orphan spends nonexistent outputs of the two parents",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1283271742",
      "id" : 1283271742,
      "in_reply_to_id" : 1283247917,
      "line" : 144,
      "node_id" : "PRRC_kwDOABII585MfSw-",
      "original_commit_id" : "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "original_line" : 144,
      "original_position" : 144,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : 144,
      "pull_request_review_id" : 1561207055,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283271742/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-03T14:15:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283271742",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1283274009"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283274009"
         }
      },
      "author_association" : "MEMBER",
      "body" : "(I didn't change it but I also don't feel strongly, could combine if you want)",
      "commit_id" : "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "created_at" : "2023-08-03T14:17:00Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)\n+        self.generate(node, 1)\n+        node.syncwithvalidationinterfacequeue()\n+\n+        # This UTXO confirmed recently.\n+        utxo_conf_recent = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        self.generate(node, 1)\n+\n+        # This UTXO is unconfirmed and in the mempool.\n+        assert_equal(len(node.getrawmempool()), 0)\n+        mempool_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_unconf_mempool = mempool_tx[\"new_utxo\"]\n+\n+        # This UTXO is unconfirmed and missing.\n+        missing_tx = self.wallet.create_self_transfer()\n+        utxo_unconf_missing = missing_tx[\"new_utxo\"]\n+\n+        orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[utxo_conf_old,\n+            utxo_conf_recent, utxo_unconf_mempool, utxo_unconf_missing])\n+\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.sync_with_ping()\n+        assert_equal(len(peer.last_message[\"getdata\"].inv), 2)\n+        peer.wait_for_parent_requests([int(txid_conf_old, 16), int(missing_tx[\"txid\"], 16)])\n+\n+        # Even though the peer would send a notfound for the \"old\" confirmed transaction, the node\n+        # doesn't give up on the orphan. Once all of the missing parents are received, it should be\n+        # submitted to mempool.\n+        peer.send_message(msg_notfound(vec=[CInv(MSG_WITNESS_TX, int(txid_conf_old, 16))]))\n+        peer.send_and_ping(msg_tx(missing_tx[\"tx\"]))\n+        peer.sync_with_ping()\n+        assert_equal(node.getmempoolentry(orphan[\"txid\"])[\"ancestorcount\"], 3)\n+\n+    @cleanup\n+    def test_orphans_overlapping_parents(self):\n+        node = self.nodes[0]\n+        # In the process of relaying inflight_parent_AB\n+        peer_txrequest = node.add_p2p_connection(PeerTxRelayer())\n+        # Sends the orphans\n+        peer_orphans = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test handling of multiple orphans with missing parents that are already being requested\")\n+        # Parent of child_A only\n+        missing_parent_A = self.wallet_nonsegwit.create_self_transfer()\n+        # Parents of child_A and child_B\n+        missing_parent_AB = self.wallet_nonsegwit.create_self_transfer()\n+        inflight_parent_AB = self.wallet_nonsegwit.create_self_transfer()\n+        # Parent of child_B only\n+        missing_parent_B = self.wallet_nonsegwit.create_self_transfer()\n+        child_A = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_A[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+        child_B = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_B[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+\n+        # The wtxid and txid need to be the same for the node to recognize that the missing input\n+        # and in-flight request for inflight_parent_AB are the same transaction.\n+        assert_equal(inflight_parent_AB[\"txid\"], inflight_parent_AB[\"tx\"].getwtxid())\n+\n+        # Announce inflight_parent_AB and wait for getdata\n+        peer_txrequest.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=int(inflight_parent_AB[\"tx\"].getwtxid(), 16))]))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_txrequest.wait_for_getdata([int(inflight_parent_AB[\"tx\"].getwtxid(), 16)])\n+\n+        self.log.info(\"The node should not request a parent if it has an in-flight txrequest\")\n+        # Relay orphan child_A\n+        self.relay_transaction(peer_orphans, child_A[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        # Both missing parents should be requested.\n+        peer_orphans.wait_for_parent_requests([int(missing_parent_A[\"txid\"], 16), int(missing_parent_AB[\"txid\"], 16)])\n+\n+        self.log.info(\"The node should not request a parent if it has an in-flight orphan parent request\")\n+        # Relay orphan child_B\n+        self.relay_transaction(peer_orphans, child_B[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        # Only missing_parent_B should be requested. Not inflight_parent_AB or missing_parent_AB\n+        # because they are already being requested from peer_orphans.\n+        peer_orphans.wait_for_parent_requests([int(missing_parent_B[\"txid\"], 16)])\n+        peer_orphans.assert_never_requested(int(inflight_parent_AB[\"txid\"], 16))\n+\n+    @cleanup\n+    def test_orphan_of_orphan(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test handling of an orphan with a parent who is another orphan\")\n+        missing_grandparent = self.wallet_nonsegwit.create_self_transfer()\n+        missing_parent_orphan = self.wallet_nonsegwit.create_self_transfer(utxo_to_spend=missing_grandparent[\"new_utxo\"])\n+        missing_parent = self.wallet_nonsegwit.create_self_transfer()\n+        orphan = self.wallet_nonsegwit.create_self_transfer_multi(utxos_to_spend=[missing_parent[\"new_utxo\"], missing_parent_orphan[\"new_utxo\"]])\n+\n+        # The node should put missing_parent_orphan into the orphanage and request missing_grandparent\n+        self.relay_transaction(peer, missing_parent_orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.wait_for_parent_requests([int(missing_grandparent[\"txid\"], 16)])\n+\n+        # The node should put the orphan into the orphanage and request missing_parent, skipping\n+        # missing_parent_orphan because it already has it in the orphanage.\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.wait_for_parent_requests([int(missing_parent[\"txid\"], 16)])\n+\n+    @cleanup\n+    def test_orphan_inherit_rejection(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+        peer3 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1283274009",
      "id" : 1283274009,
      "in_reply_to_id" : 1282274277,
      "line" : 376,
      "node_id" : "PRRC_kwDOABII585MfTUZ",
      "original_commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_line" : 376,
      "original_position" : 391,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : 376,
      "pull_request_review_id" : 1561210429,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283274009/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-03T14:17:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283274009",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1283274749"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283274749"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nope it's fine",
      "commit_id" : "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "created_at" : "2023-08-03T14:17:31Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)\n+        self.generate(node, 1)\n+        node.syncwithvalidationinterfacequeue()\n+\n+        # This UTXO confirmed recently.\n+        utxo_conf_recent = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        self.generate(node, 1)\n+\n+        # This UTXO is unconfirmed and in the mempool.\n+        assert_equal(len(node.getrawmempool()), 0)\n+        mempool_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_unconf_mempool = mempool_tx[\"new_utxo\"]\n+\n+        # This UTXO is unconfirmed and missing.\n+        missing_tx = self.wallet.create_self_transfer()\n+        utxo_unconf_missing = missing_tx[\"new_utxo\"]\n+\n+        orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[utxo_conf_old,\n+            utxo_conf_recent, utxo_unconf_mempool, utxo_unconf_missing])\n+\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.sync_with_ping()\n+        assert_equal(len(peer.last_message[\"getdata\"].inv), 2)\n+        peer.wait_for_parent_requests([int(txid_conf_old, 16), int(missing_tx[\"txid\"], 16)])\n+\n+        # Even though the peer would send a notfound for the \"old\" confirmed transaction, the node\n+        # doesn't give up on the orphan. Once all of the missing parents are received, it should be\n+        # submitted to mempool.\n+        peer.send_message(msg_notfound(vec=[CInv(MSG_WITNESS_TX, int(txid_conf_old, 16))]))\n+        peer.send_and_ping(msg_tx(missing_tx[\"tx\"]))\n+        peer.sync_with_ping()\n+        assert_equal(node.getmempoolentry(orphan[\"txid\"])[\"ancestorcount\"], 3)\n+\n+    @cleanup\n+    def test_orphans_overlapping_parents(self):\n+        node = self.nodes[0]\n+        # In the process of relaying inflight_parent_AB\n+        peer_txrequest = node.add_p2p_connection(PeerTxRelayer())\n+        # Sends the orphans\n+        peer_orphans = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test handling of multiple orphans with missing parents that are already being requested\")\n+        # Parent of child_A only\n+        missing_parent_A = self.wallet_nonsegwit.create_self_transfer()\n+        # Parents of child_A and child_B\n+        missing_parent_AB = self.wallet_nonsegwit.create_self_transfer()\n+        inflight_parent_AB = self.wallet_nonsegwit.create_self_transfer()\n+        # Parent of child_B only\n+        missing_parent_B = self.wallet_nonsegwit.create_self_transfer()\n+        child_A = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_A[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+        child_B = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_B[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+\n+        # The wtxid and txid need to be the same for the node to recognize that the missing input\n+        # and in-flight request for inflight_parent_AB are the same transaction.\n+        assert_equal(inflight_parent_AB[\"txid\"], inflight_parent_AB[\"tx\"].getwtxid())\n+\n+        # Announce inflight_parent_AB and wait for getdata\n+        peer_txrequest.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=int(inflight_parent_AB[\"tx\"].getwtxid(), 16))]))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_txrequest.wait_for_getdata([int(inflight_parent_AB[\"tx\"].getwtxid(), 16)])\n+\n+        self.log.info(\"The node should not request a parent if it has an in-flight txrequest\")\n+        # Relay orphan child_A\n+        self.relay_transaction(peer_orphans, child_A[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        # Both missing parents should be requested.\n+        peer_orphans.wait_for_parent_requests([int(missing_parent_A[\"txid\"], 16), int(missing_parent_AB[\"txid\"], 16)])\n+\n+        self.log.info(\"The node should not request a parent if it has an in-flight orphan parent request\")\n+        # Relay orphan child_B\n+        self.relay_transaction(peer_orphans, child_B[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        # Only missing_parent_B should be requested. Not inflight_parent_AB or missing_parent_AB\n+        # because they are already being requested from peer_orphans.\n+        peer_orphans.wait_for_parent_requests([int(missing_parent_B[\"txid\"], 16)])\n+        peer_orphans.assert_never_requested(int(inflight_parent_AB[\"txid\"], 16))\n+\n+    @cleanup\n+    def test_orphan_of_orphan(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test handling of an orphan with a parent who is another orphan\")\n+        missing_grandparent = self.wallet_nonsegwit.create_self_transfer()\n+        missing_parent_orphan = self.wallet_nonsegwit.create_self_transfer(utxo_to_spend=missing_grandparent[\"new_utxo\"])\n+        missing_parent = self.wallet_nonsegwit.create_self_transfer()\n+        orphan = self.wallet_nonsegwit.create_self_transfer_multi(utxos_to_spend=[missing_parent[\"new_utxo\"], missing_parent_orphan[\"new_utxo\"]])\n+\n+        # The node should put missing_parent_orphan into the orphanage and request missing_grandparent\n+        self.relay_transaction(peer, missing_parent_orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.wait_for_parent_requests([int(missing_grandparent[\"txid\"], 16)])\n+\n+        # The node should put the orphan into the orphanage and request missing_parent, skipping\n+        # missing_parent_orphan because it already has it in the orphanage.\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.wait_for_parent_requests([int(missing_parent[\"txid\"], 16)])\n+\n+    @cleanup\n+    def test_orphan_inherit_rejection(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+        peer3 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1283274749",
      "id" : 1283274749,
      "in_reply_to_id" : 1282274277,
      "line" : 376,
      "node_id" : "PRRC_kwDOABII585MfTf9",
      "original_commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_line" : 376,
      "original_position" : 391,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : 376,
      "pull_request_review_id" : 1561211587,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283274749/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-03T14:17:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283274749",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK",
      "created_at" : "2023-08-03T21:40:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1664679951",
      "id" : 1664679951,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28199",
      "node_id" : "IC_kwDOABII585jOQAP",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1664679951/reactions"
      },
      "updated_at" : "2023-08-03T21:40:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1664679951",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5470?v=4",
         "events_url" : "https://api.github.com/users/Empact/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Empact/followers",
         "following_url" : "https://api.github.com/users/Empact/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Empact/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Empact",
         "id" : 5470,
         "login" : "Empact",
         "node_id" : "MDQ6VXNlcjU0NzA=",
         "organizations_url" : "https://api.github.com/users/Empact/orgs",
         "received_events_url" : "https://api.github.com/users/Empact/received_events",
         "repos_url" : "https://api.github.com/users/Empact/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Empact/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Empact/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Empact"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1287224406"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1287224406"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Could you say that in the test then? This really throws me off as a reader!",
      "commit_id" : "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "created_at" : "2023-08-08T14:38:32Z",
      "diff_hunk" : "@@ -0,0 +1,424 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+def cleanup(func):\n+    # Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+    # one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+    # (though nothing should since state should be cleared) in p2p data structures.\n+    LONG_TIME_SKIP = 12 * 60 * 60\n+\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_no_immediate_response(self, message):\n+        \"\"\"Check that the node does not immediately respond to this message with any of getdata,\n+        inv, tx. The node may respond later.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test missing parents that arrive during delay are not requested\")\n+        node = self.nodes[0]\n+        tx_parent_arrives = self.wallet.create_self_transfer()\n+        tx_parent_doesnt_arrive = self.wallet.create_self_transfer()\n+        # Fake orphan spends nonexistent outputs of the two parents",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1287224406",
      "id" : 1287224406,
      "in_reply_to_id" : 1283247917,
      "line" : 144,
      "node_id" : "PRRC_kwDOABII585MuXxW",
      "original_commit_id" : "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "original_line" : 144,
      "original_position" : 144,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : 144,
      "pull_request_review_id" : 1567470685,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1287224406/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-08T14:38:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1287224406",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "ACK https://github.com/bitcoin/bitcoin/pull/28199/commits/abe8536192c9f2cd6ba9d0e083f23dec4d20841f\r\n\r\nhttps://github.com/bitcoin/bitcoin/pull/28199#discussion_r1283271742 would be nice to be slightly cleaned up for future readers",
      "created_at" : "2023-08-08T14:39:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1669753053",
      "id" : 1669753053,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28199",
      "node_id" : "IC_kwDOABII585jhmjd",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 1,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1669753053/reactions"
      },
      "updated_at" : "2023-08-08T14:39:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1669753053",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "thanks for the concept acks @dergoegge @jamesob @brunoerg @Empact @jonatack, would appreciate a review of test too :pray:",
      "created_at" : "2023-08-08T14:59:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1669788993",
      "id" : 1669788993,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28199",
      "node_id" : "IC_kwDOABII585jhvVB",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1669788993/reactions"
      },
      "updated_at" : "2023-08-08T14:59:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1669788993",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1290819834"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1290819834"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Should we add an rpc to allow querying the orphanage?",
      "commit_id" : "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "created_at" : "2023-08-11T01:34:09Z",
      "diff_hunk" : "@@ -0,0 +1,424 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+def cleanup(func):\n+    # Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+    # one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+    # (though nothing should since state should be cleared) in p2p data structures.\n+    LONG_TIME_SKIP = 12 * 60 * 60\n+\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_no_immediate_response(self, message):\n+        \"\"\"Check that the node does not immediately respond to this message with any of getdata,\n+        inv, tx. The node may respond later.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test missing parents that arrive during delay are not requested\")\n+        node = self.nodes[0]\n+        tx_parent_arrives = self.wallet.create_self_transfer()\n+        tx_parent_doesnt_arrive = self.wallet.create_self_transfer()\n+        # Fake orphan spends nonexistent outputs of the two parents\n+        tx_fake_orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[\n+            {\"txid\": tx_parent_doesnt_arrive[\"txid\"], \"vout\": 10, \"value\": tx_parent_doesnt_arrive[\"new_utxo\"][\"value\"]},\n+            {\"txid\": tx_parent_arrives[\"txid\"], \"vout\": 10, \"value\": tx_parent_arrives[\"new_utxo\"][\"value\"]}\n+        ])\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        peer_normal = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_no_immediate_response(msg_tx(tx_fake_orphan[\"tx\"]))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool. Send unsolicited because otherwise we need to wait for\n+        # request delays.\n+        peer_normal.send_and_ping(msg_tx(tx_parent_arrives[\"tx\"]))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1290819834",
      "id" : 1290819834,
      "in_reply_to_id" : 1283241941,
      "line" : 161,
      "node_id" : "PRRC_kwDOABII585M8Fj6",
      "original_commit_id" : "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "original_line" : 161,
      "original_position" : 161,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : 161,
      "pull_request_review_id" : 1572911779,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1290819834/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-11T01:34:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1290819834",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1290823896"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1290823896"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Might be better to be clearer about the different behaviours you're testing for, rather than how you're triggering those behaviours? eg:\r\n\r\n * Orphan handling when parent is known to be invalid\r\n * Orphan handling when segwit parent may be retried with alternate witness data",
      "commit_id" : "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "created_at" : "2023-08-11T01:46:11Z",
      "diff_hunk" : "@@ -0,0 +1,424 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+def cleanup(func):\n+    # Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+    # one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+    # (though nothing should since state should be cleared) in p2p data structures.\n+    LONG_TIME_SKIP = 12 * 60 * 60\n+\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_no_immediate_response(self, message):\n+        \"\"\"Check that the node does not immediately respond to this message with any of getdata,\n+        inv, tx. The node may respond later.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test missing parents that arrive during delay are not requested\")\n+        node = self.nodes[0]\n+        tx_parent_arrives = self.wallet.create_self_transfer()\n+        tx_parent_doesnt_arrive = self.wallet.create_self_transfer()\n+        # Fake orphan spends nonexistent outputs of the two parents\n+        tx_fake_orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[\n+            {\"txid\": tx_parent_doesnt_arrive[\"txid\"], \"vout\": 10, \"value\": tx_parent_doesnt_arrive[\"new_utxo\"][\"value\"]},\n+            {\"txid\": tx_parent_arrives[\"txid\"], \"vout\": 10, \"value\": tx_parent_arrives[\"new_utxo\"][\"value\"]}\n+        ])\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        peer_normal = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_no_immediate_response(msg_tx(tx_fake_orphan[\"tx\"]))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool. Send unsolicited because otherwise we need to wait for\n+        # request delays.\n+        peer_normal.send_and_ping(msg_tx(tx_parent_arrives[\"tx\"]))\n+\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_parent_arrives[\"tx\"].getwtxid(), 16))\n+        assert_equal(len(peer_spy.get_invs()), 0)\n+        peer_spy.assert_no_immediate_response(msg_getdata([parent_inv]))\n+\n+        # Request would be scheduled with this delay because it is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(tx_parent_arrives[\"txid\"], 16))\n+        peer_spy.assert_never_requested(int(tx_parent_doesnt_arrive[\"txid\"], 16))\n+        # Request would be scheduled with this delay because it is by txid.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.wait_for_parent_requests([int(tx_parent_doesnt_arrive[\"txid\"], 16)])\n+        peer_spy.assert_never_requested(int(tx_parent_arrives[\"txid\"], 16))\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1290823896",
      "id" : 1290823896,
      "line" : 184,
      "node_id" : "PRRC_kwDOABII585M8GjY",
      "original_commit_id" : "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "original_line" : 184,
      "original_position" : 184,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : 184,
      "pull_request_review_id" : 1572916458,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1290823896/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-11T01:53:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1290823896",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1290824888"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1290824888"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Maybe name this something that's a bit more clearly related to mocktime (`bumpmocktime`?) and add it to `BitcoinTestFramework` ?",
      "commit_id" : "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "created_at" : "2023-08-11T01:49:01Z",
      "diff_hunk" : "@@ -0,0 +1,424 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+def cleanup(func):\n+    # Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+    # one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+    # (though nothing should since state should be cleared) in p2p data structures.\n+    LONG_TIME_SKIP = 12 * 60 * 60\n+\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_no_immediate_response(self, message):\n+        \"\"\"Check that the node does not immediately respond to this message with any of getdata,\n+        inv, tx. The node may respond later.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1290824888",
      "id" : 1290824888,
      "line" : 124,
      "node_id" : "PRRC_kwDOABII585M8Gy4",
      "original_commit_id" : "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "original_line" : 124,
      "original_position" : 124,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : 124,
      "pull_request_review_id" : 1572916458,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1290824888/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-11T01:53:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1290824888",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1291012828"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1291012828"
         }
      },
      "author_association" : "NONE",
      "body" : "Release ",
      "commit_id" : "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "created_at" : "2023-08-11T07:49:03Z",
      "diff_hunk" : "@@ -0,0 +1,424 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+def cleanup(func):\n+    # Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+    # one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+    # (though nothing should since state should be cleared) in p2p data structures.\n+    LONG_TIME_SKIP = 12 * 60 * 60\n+\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_no_immediate_response(self, message):\n+        \"\"\"Check that the node does not immediately respond to this message with any of getdata,\n+        inv, tx. The node may respond later.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test missing parents that arrive during delay are not requested\")\n+        node = self.nodes[0]\n+        tx_parent_arrives = self.wallet.create_self_transfer()\n+        tx_parent_doesnt_arrive = self.wallet.create_self_transfer()\n+        # Fake orphan spends nonexistent outputs of the two parents\n+        tx_fake_orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[\n+            {\"txid\": tx_parent_doesnt_arrive[\"txid\"], \"vout\": 10, \"value\": tx_parent_doesnt_arrive[\"new_utxo\"][\"value\"]},\n+            {\"txid\": tx_parent_arrives[\"txid\"], \"vout\": 10, \"value\": tx_parent_arrives[\"new_utxo\"][\"value\"]}\n+        ])\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        peer_normal = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_no_immediate_response(msg_tx(tx_fake_orphan[\"tx\"]))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool. Send unsolicited because otherwise we need to wait for\n+        # request delays.\n+        peer_normal.send_and_ping(msg_tx(tx_parent_arrives[\"tx\"]))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1291012828",
      "id" : 1291012828,
      "in_reply_to_id" : 1283241941,
      "line" : 161,
      "node_id" : "PRRC_kwDOABII585M80rc",
      "original_commit_id" : "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "original_line" : 161,
      "original_position" : 161,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : 161,
      "pull_request_review_id" : 1573171643,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1291012828/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-11T07:49:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1291012828",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/108148678?v=4",
         "events_url" : "https://api.github.com/users/Jones098/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Jones098/followers",
         "following_url" : "https://api.github.com/users/Jones098/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Jones098/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Jones098",
         "id" : 108148678,
         "login" : "Jones098",
         "node_id" : "U_kgDOBnI3xg",
         "organizations_url" : "https://api.github.com/users/Jones098/orgs",
         "received_events_url" : "https://api.github.com/users/Jones098/received_events",
         "repos_url" : "https://api.github.com/users/Jones098/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Jones098/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Jones098/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Jones098"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1291139542"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1291139542"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> Should we add an rpc to allow querying the orphanage?\r\n\r\nCould do that, as there's a bit of black box-ness here. Though I also think that the ideal situation would be to write unit tests if we're interested in the exact contents of the orphanage.",
      "commit_id" : "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "created_at" : "2023-08-11T09:54:34Z",
      "diff_hunk" : "@@ -0,0 +1,424 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+def cleanup(func):\n+    # Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+    # one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+    # (though nothing should since state should be cleared) in p2p data structures.\n+    LONG_TIME_SKIP = 12 * 60 * 60\n+\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_no_immediate_response(self, message):\n+        \"\"\"Check that the node does not immediately respond to this message with any of getdata,\n+        inv, tx. The node may respond later.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test missing parents that arrive during delay are not requested\")\n+        node = self.nodes[0]\n+        tx_parent_arrives = self.wallet.create_self_transfer()\n+        tx_parent_doesnt_arrive = self.wallet.create_self_transfer()\n+        # Fake orphan spends nonexistent outputs of the two parents\n+        tx_fake_orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[\n+            {\"txid\": tx_parent_doesnt_arrive[\"txid\"], \"vout\": 10, \"value\": tx_parent_doesnt_arrive[\"new_utxo\"][\"value\"]},\n+            {\"txid\": tx_parent_arrives[\"txid\"], \"vout\": 10, \"value\": tx_parent_arrives[\"new_utxo\"][\"value\"]}\n+        ])\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        peer_normal = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_no_immediate_response(msg_tx(tx_fake_orphan[\"tx\"]))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool. Send unsolicited because otherwise we need to wait for\n+        # request delays.\n+        peer_normal.send_and_ping(msg_tx(tx_parent_arrives[\"tx\"]))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1291139542",
      "id" : 1291139542,
      "in_reply_to_id" : 1283241941,
      "line" : 161,
      "node_id" : "PRRC_kwDOABII585M9TnW",
      "original_commit_id" : "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "original_line" : 161,
      "original_position" : 161,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : 161,
      "pull_request_review_id" : 1573359133,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1291139542/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-11T09:54:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1291139542",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1291466087"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1291466087"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Agree, updated the logging",
      "commit_id" : "7a82b98dbbd9de66786dcf079b59e854a1886a6e",
      "created_at" : "2023-08-11T15:13:10Z",
      "diff_hunk" : "@@ -0,0 +1,424 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+def cleanup(func):\n+    # Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+    # one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+    # (though nothing should since state should be cleared) in p2p data structures.\n+    LONG_TIME_SKIP = 12 * 60 * 60\n+\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_no_immediate_response(self, message):\n+        \"\"\"Check that the node does not immediately respond to this message with any of getdata,\n+        inv, tx. The node may respond later.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test missing parents that arrive during delay are not requested\")\n+        node = self.nodes[0]\n+        tx_parent_arrives = self.wallet.create_self_transfer()\n+        tx_parent_doesnt_arrive = self.wallet.create_self_transfer()\n+        # Fake orphan spends nonexistent outputs of the two parents\n+        tx_fake_orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[\n+            {\"txid\": tx_parent_doesnt_arrive[\"txid\"], \"vout\": 10, \"value\": tx_parent_doesnt_arrive[\"new_utxo\"][\"value\"]},\n+            {\"txid\": tx_parent_arrives[\"txid\"], \"vout\": 10, \"value\": tx_parent_arrives[\"new_utxo\"][\"value\"]}\n+        ])\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        peer_normal = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_no_immediate_response(msg_tx(tx_fake_orphan[\"tx\"]))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool. Send unsolicited because otherwise we need to wait for\n+        # request delays.\n+        peer_normal.send_and_ping(msg_tx(tx_parent_arrives[\"tx\"]))\n+\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_parent_arrives[\"tx\"].getwtxid(), 16))\n+        assert_equal(len(peer_spy.get_invs()), 0)\n+        peer_spy.assert_no_immediate_response(msg_getdata([parent_inv]))\n+\n+        # Request would be scheduled with this delay because it is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(tx_parent_arrives[\"txid\"], 16))\n+        peer_spy.assert_never_requested(int(tx_parent_doesnt_arrive[\"txid\"], 16))\n+        # Request would be scheduled with this delay because it is by txid.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.wait_for_parent_requests([int(tx_parent_doesnt_arrive[\"txid\"], 16)])\n+        peer_spy.assert_never_requested(int(tx_parent_arrives[\"txid\"], 16))\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1291466087",
      "id" : 1291466087,
      "in_reply_to_id" : 1290823896,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585M-jVn",
      "original_commit_id" : "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "original_line" : 184,
      "original_position" : 184,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : null,
      "pull_request_review_id" : 1573875706,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1291466087/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-11T15:13:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1291466087",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1291467564"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1291467564"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Good point, added a `bumpmocktime` to test framework, I'll probably use it in other tests in the future.",
      "commit_id" : "7a82b98dbbd9de66786dcf079b59e854a1886a6e",
      "created_at" : "2023-08-11T15:13:36Z",
      "diff_hunk" : "@@ -0,0 +1,424 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+def cleanup(func):\n+    # Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+    # one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+    # (though nothing should since state should be cleared) in p2p data structures.\n+    LONG_TIME_SKIP = 12 * 60 * 60\n+\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_no_immediate_response(self, message):\n+        \"\"\"Check that the node does not immediately respond to this message with any of getdata,\n+        inv, tx. The node may respond later.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1291467564",
      "id" : 1291467564,
      "in_reply_to_id" : 1290824888,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585M-jss",
      "original_commit_id" : "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "original_line" : 124,
      "original_position" : 124,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : null,
      "pull_request_review_id" : 1573878072,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1291467564/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-11T15:13:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1291467564",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1291469104"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1291469104"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Sorree! Added explanation in the comment.",
      "commit_id" : "7a82b98dbbd9de66786dcf079b59e854a1886a6e",
      "created_at" : "2023-08-11T15:13:57Z",
      "diff_hunk" : "@@ -0,0 +1,424 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+def cleanup(func):\n+    # Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+    # one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+    # (though nothing should since state should be cleared) in p2p data structures.\n+    LONG_TIME_SKIP = 12 * 60 * 60\n+\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_no_immediate_response(self, message):\n+        \"\"\"Check that the node does not immediately respond to this message with any of getdata,\n+        inv, tx. The node may respond later.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test missing parents that arrive during delay are not requested\")\n+        node = self.nodes[0]\n+        tx_parent_arrives = self.wallet.create_self_transfer()\n+        tx_parent_doesnt_arrive = self.wallet.create_self_transfer()\n+        # Fake orphan spends nonexistent outputs of the two parents",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1291469104",
      "id" : 1291469104,
      "in_reply_to_id" : 1283247917,
      "line" : 134,
      "node_id" : "PRRC_kwDOABII585M-kEw",
      "original_commit_id" : "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "original_line" : 134,
      "original_position" : 144,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : 134,
      "pull_request_review_id" : 1573880351,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1291469104/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-11T15:13:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1291469104",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1291514800"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1291514800"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Wouldn't it make more sense to have `bumpmocktime` on TestNode and set `self.mocktime` when ever `setmocktime` is called?\r\n\r\n* allows for node independent mocktime bumping\r\n* allows to use an initial mocktime other than time.time()",
      "commit_id" : "7a82b98dbbd9de66786dcf079b59e854a1886a6e",
      "created_at" : "2023-08-11T15:34:43Z",
      "diff_hunk" : "@@ -103,6 +103,11 @@ def __init__(self) -> None:\n         self.supports_cli = True\n         self.bind_to_localhost_only = True\n         self.parse_args()\n+        # Note that we haven't called setmocktime on any nodes yet. If a test wants to use\n+        # setmocktime, it should call bumpmocktime(0) at the beginning of run_test in order to\n+        # prevent spurious failures. If the test does not want to use setmocktime, it must not call\n+        # setmocktime because the time will not move forward afterwards.\n+        self.mocktime = int(time.time())",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1291514800",
      "id" : 1291514800,
      "line" : 110,
      "node_id" : "PRRC_kwDOABII585M-vOw",
      "original_commit_id" : "afbc2b17e5e830b273675ee04d337bad304127fb",
      "original_line" : 110,
      "original_position" : 8,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/test_framework.py",
      "position" : 8,
      "pull_request_review_id" : 1573953791,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1291514800/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-11T15:34:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1291514800",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   }
]
