[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| Concept ACK | [dergoegge](https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1662073675), [jamesob](https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1662122993), [brunoerg](https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1662147529), [jonatack](https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1662205614) |\n\nIf your review is incorrectly listed, please react with ð to this comment and the bot will ignore it on the next update.\n",
      "created_at" : "2023-08-02T11:14:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1662019735",
      "id" : 1662019735,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28199",
      "node_id" : "IC_kwDOABII585jEGiX",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1662019735/reactions"
      },
      "updated_at" : "2023-08-02T13:22:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1662019735",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK\r\n\r\nGood to have these tests prior to refactoring",
      "created_at" : "2023-08-02T11:54:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1662073675",
      "id" : 1662073675,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28199",
      "node_id" : "IC_kwDOABII585jETtL",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1662073675/reactions"
      },
      "updated_at" : "2023-08-02T11:54:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1662073675",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK, looks like some great additional coverage.",
      "created_at" : "2023-08-02T12:29:21Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1662122993",
      "id" : 1662122993,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28199",
      "node_id" : "IC_kwDOABII585jEfvx",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1662122993/reactions"
      },
      "updated_at" : "2023-08-02T12:29:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1662122993",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Concept ACK ",
      "created_at" : "2023-08-02T12:46:32Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1662147529",
      "id" : 1662147529,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28199",
      "node_id" : "IC_kwDOABII585jElvJ",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1662147529/reactions"
      },
      "updated_at" : "2023-08-02T12:46:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1662147529",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19480819?v=4",
         "events_url" : "https://api.github.com/users/brunoerg/events{/privacy}",
         "followers_url" : "https://api.github.com/users/brunoerg/followers",
         "following_url" : "https://api.github.com/users/brunoerg/following{/other_user}",
         "gists_url" : "https://api.github.com/users/brunoerg/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/brunoerg",
         "id" : 19480819,
         "login" : "brunoerg",
         "node_id" : "MDQ6VXNlcjE5NDgwODE5",
         "organizations_url" : "https://api.github.com/users/brunoerg/orgs",
         "received_events_url" : "https://api.github.com/users/brunoerg/received_events",
         "repos_url" : "https://api.github.com/users/brunoerg/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/brunoerg/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/brunoerg/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/brunoerg"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Concept ACK",
      "created_at" : "2023-08-02T13:22:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1662205614",
      "id" : 1662205614,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28199",
      "node_id" : "IC_kwDOABII585jEz6u",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1662205614/reactions"
      },
      "updated_at" : "2023-08-02T13:22:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1662205614",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282131242"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282131242"
         }
      },
      "author_association" : "MEMBER",
      "body" : "comment block seems extraneous if there's logging for each test",
      "commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "created_at" : "2023-08-02T16:14:00Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282131242",
      "id" : 1282131242,
      "line" : 6,
      "node_id" : "PRRC_kwDOABII585Ma8Uq",
      "original_commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_line" : 6,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : 6,
      "pull_request_review_id" : 1559366940,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282131242/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-02T18:24:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282131242",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282208201"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282208201"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Stick the constant inside `cleanup` and move the comment for `cleanup`, since it explains what the whole thing is doing.",
      "commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "created_at" : "2023-08-02T17:17:38Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282208201",
      "id" : 1282208201,
      "line" : 57,
      "node_id" : "PRRC_kwDOABII585MbPHJ",
      "original_commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_line" : 57,
      "original_position" : 57,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : 57,
      "pull_request_review_id" : 1559366940,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282208201/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-02T18:24:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282208201",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282234657"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282234657"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n        # The parent should be requested since the unstripped wtxid would differ. Delayed because it's by txid and this is not a preferred relay peer.\r\n```",
      "commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "created_at" : "2023-08-02T17:44:18Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282234657",
      "id" : 1282234657,
      "line" : 258,
      "node_id" : "PRRC_kwDOABII585MbVkh",
      "original_commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_line" : 258,
      "original_position" : 258,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : 258,
      "pull_request_review_id" : 1559366940,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282234657/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-02T18:24:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282234657",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282243358"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282243358"
         }
      },
      "author_association" : "MEMBER",
      "body" : "can't we just reconsider it again?",
      "commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "created_at" : "2023-08-02T17:53:41Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282243358",
      "id" : 1282243358,
      "line" : 280,
      "node_id" : "PRRC_kwDOABII585MbXse",
      "original_commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_line" : 280,
      "original_position" : 280,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : 280,
      "pull_request_review_id" : 1559366940,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282243358/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-02T18:24:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282243358",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282251680"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282251680"
         }
      },
      "author_association" : "MEMBER",
      "body" : "took me a second, just assert it's not in mempool for those quickly reading ",
      "commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "created_at" : "2023-08-02T18:02:11Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)\n+        self.generate(node, 1)\n+        node.syncwithvalidationinterfacequeue()\n+\n+        # This UTXO confirmed recently.\n+        utxo_conf_recent = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        self.generate(node, 1)\n+\n+        # This UTXO is unconfirmed and in the mempool.\n+        assert_equal(len(node.getrawmempool()), 0)\n+        mempool_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_unconf_mempool = mempool_tx[\"new_utxo\"]\n+\n+        # This UTXO is unconfirmed and missing.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282251680",
      "id" : 1282251680,
      "line" : 293,
      "node_id" : "PRRC_kwDOABII585MbZug",
      "original_commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_line" : 293,
      "original_position" : 293,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : 293,
      "pull_request_review_id" : 1559366940,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282251680/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-02T18:24:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282251680",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282257631"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282257631"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n        \"\"\"Check that the node does not immediately respond to this message with any of\r\n```",
      "commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "created_at" : "2023-08-02T18:06:00Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282257631",
      "id" : 1282257631,
      "line" : 109,
      "node_id" : "PRRC_kwDOABII585MbbLf",
      "original_commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_line" : 109,
      "original_position" : 109,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : 109,
      "pull_request_review_id" : 1559366940,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282257631/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-02T18:24:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282257631",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282258402"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282258402"
         }
      },
      "author_association" : "MEMBER",
      "body" : "can we assert that peer_spy hasn't received the INV, just to be sure?",
      "commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "created_at" : "2023-08-02T18:06:57Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282258402",
      "id" : 1282258402,
      "line" : 180,
      "node_id" : "PRRC_kwDOABII585MbbXi",
      "original_commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_line" : 180,
      "original_position" : 180,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : 180,
      "pull_request_review_id" : 1559366940,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282258402/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-02T18:24:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282258402",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282259677"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282259677"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't get this case. Why wouldn't you request a \"fake\" parent if you don't know it's fake already?",
      "commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "created_at" : "2023-08-02T18:08:27Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282259677",
      "id" : 1282259677,
      "line" : 191,
      "node_id" : "PRRC_kwDOABII585Mbbrd",
      "original_commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_line" : 191,
      "original_position" : 191,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : 191,
      "pull_request_review_id" : 1559366940,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282259677/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-02T18:24:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282259677",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282261573"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282261573"
         }
      },
      "author_association" : "MEMBER",
      "body" : "does this wallet never use 0-conf change? would be nice to assert to make it clear the lack of utxo connection",
      "commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "created_at" : "2023-08-02T18:09:53Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)\n+        self.generate(node, 1)\n+        node.syncwithvalidationinterfacequeue()\n+\n+        # This UTXO confirmed recently.\n+        utxo_conf_recent = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        self.generate(node, 1)\n+\n+        # This UTXO is unconfirmed and in the mempool.\n+        assert_equal(len(node.getrawmempool()), 0)\n+        mempool_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_unconf_mempool = mempool_tx[\"new_utxo\"]\n+\n+        # This UTXO is unconfirmed and missing.\n+        missing_tx = self.wallet.create_self_transfer()\n+        utxo_unconf_missing = missing_tx[\"new_utxo\"]\n+\n+        orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[utxo_conf_old,\n+            utxo_conf_recent, utxo_unconf_mempool, utxo_unconf_missing])\n+\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.sync_with_ping()\n+        assert_equal(len(peer.last_message[\"getdata\"].inv), 2)\n+        peer.wait_for_parent_requests([int(txid_conf_old, 16), int(missing_tx[\"txid\"], 16)])\n+\n+        # Even though the peer would send a notfound for the \"old\" confirmed transaction, the node\n+        # doesn't give up on the orphan. Once all of the missing parents are received, it should be\n+        # submitted to mempool.\n+        peer.send_message(msg_notfound(vec=[CInv(MSG_WITNESS_TX, int(txid_conf_old, 16))]))\n+        peer.send_and_ping(msg_tx(missing_tx[\"tx\"]))\n+        peer.sync_with_ping()\n+        assert_equal(node.getmempoolentry(orphan[\"txid\"])[\"ancestorcount\"], 3)\n+\n+    @cleanup\n+    def test_orphans_overlapping_parents(self):\n+        node = self.nodes[0]\n+        # In the process of relaying inflight_parent_AB\n+        peer_txrequest = node.add_p2p_connection(PeerTxRelayer())\n+        # Sends the orphans\n+        peer_orphans = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test handling of multiple orphans with missing parents that are already being requested\")\n+        # Parent of child_A only\n+        missing_parent_A = self.wallet_nonsegwit.create_self_transfer()\n+        # Parents of child_A and child_B\n+        missing_parent_AB = self.wallet_nonsegwit.create_self_transfer()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282261573",
      "id" : 1282261573,
      "line" : 326,
      "node_id" : "PRRC_kwDOABII585MbcJF",
      "original_commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_line" : 326,
      "original_position" : 326,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : 326,
      "pull_request_review_id" : 1559366940,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282261573/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-02T18:24:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282261573",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282268679"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282268679"
         }
      },
      "author_association" : "MEMBER",
      "body" : "\"The node should not request a parent if it has an in-flight txrequest\" ? Seems like parents are being reqiested. Maybe a typo or I can't tell what scenario it's covering.",
      "commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "created_at" : "2023-08-02T18:17:38Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)\n+        self.generate(node, 1)\n+        node.syncwithvalidationinterfacequeue()\n+\n+        # This UTXO confirmed recently.\n+        utxo_conf_recent = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        self.generate(node, 1)\n+\n+        # This UTXO is unconfirmed and in the mempool.\n+        assert_equal(len(node.getrawmempool()), 0)\n+        mempool_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_unconf_mempool = mempool_tx[\"new_utxo\"]\n+\n+        # This UTXO is unconfirmed and missing.\n+        missing_tx = self.wallet.create_self_transfer()\n+        utxo_unconf_missing = missing_tx[\"new_utxo\"]\n+\n+        orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[utxo_conf_old,\n+            utxo_conf_recent, utxo_unconf_mempool, utxo_unconf_missing])\n+\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.sync_with_ping()\n+        assert_equal(len(peer.last_message[\"getdata\"].inv), 2)\n+        peer.wait_for_parent_requests([int(txid_conf_old, 16), int(missing_tx[\"txid\"], 16)])\n+\n+        # Even though the peer would send a notfound for the \"old\" confirmed transaction, the node\n+        # doesn't give up on the orphan. Once all of the missing parents are received, it should be\n+        # submitted to mempool.\n+        peer.send_message(msg_notfound(vec=[CInv(MSG_WITNESS_TX, int(txid_conf_old, 16))]))\n+        peer.send_and_ping(msg_tx(missing_tx[\"tx\"]))\n+        peer.sync_with_ping()\n+        assert_equal(node.getmempoolentry(orphan[\"txid\"])[\"ancestorcount\"], 3)\n+\n+    @cleanup\n+    def test_orphans_overlapping_parents(self):\n+        node = self.nodes[0]\n+        # In the process of relaying inflight_parent_AB\n+        peer_txrequest = node.add_p2p_connection(PeerTxRelayer())\n+        # Sends the orphans\n+        peer_orphans = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test handling of multiple orphans with missing parents that are already being requested\")\n+        # Parent of child_A only\n+        missing_parent_A = self.wallet_nonsegwit.create_self_transfer()\n+        # Parents of child_A and child_B\n+        missing_parent_AB = self.wallet_nonsegwit.create_self_transfer()\n+        inflight_parent_AB = self.wallet_nonsegwit.create_self_transfer()\n+        # Parent of child_B only\n+        missing_parent_B = self.wallet_nonsegwit.create_self_transfer()\n+        child_A = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_A[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+        child_B = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_B[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+\n+        # The wtxid and txid need to be the same for the node to recognize that the missing input\n+        # and in-flight request for inflight_parent_AB are the same transaction.\n+        assert_equal(inflight_parent_AB[\"txid\"], inflight_parent_AB[\"tx\"].getwtxid())\n+\n+        # Announce inflight_parent_AB and wait for getdata\n+        peer_txrequest.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=int(inflight_parent_AB[\"tx\"].getwtxid(), 16))]))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_txrequest.wait_for_getdata([int(inflight_parent_AB[\"tx\"].getwtxid(), 16)])\n+\n+        self.log.info(\"The node should not request a parent if it has an in-flight txrequest\")\n+        # Relay orphan child_A\n+        self.relay_transaction(peer_orphans, child_A[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        # Both missing parents should be requested.\n+        peer_orphans.wait_for_parent_requests([int(missing_parent_A[\"txid\"], 16), int(missing_parent_AB[\"txid\"], 16)])",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282268679",
      "id" : 1282268679,
      "line" : 351,
      "node_id" : "PRRC_kwDOABII585Mbd4H",
      "original_commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_line" : 351,
      "original_position" : 351,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : 351,
      "pull_request_review_id" : 1559366940,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282268679/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-02T18:24:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282268679",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282274277"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282274277"
         }
      },
      "author_association" : "MEMBER",
      "body" : "bit of a repeat with test_orphan_rejected_parents_exceptions ?",
      "commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "created_at" : "2023-08-02T18:23:51Z",
      "diff_hunk" : "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)\n+        self.generate(node, 1)\n+        node.syncwithvalidationinterfacequeue()\n+\n+        # This UTXO confirmed recently.\n+        utxo_conf_recent = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        self.generate(node, 1)\n+\n+        # This UTXO is unconfirmed and in the mempool.\n+        assert_equal(len(node.getrawmempool()), 0)\n+        mempool_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_unconf_mempool = mempool_tx[\"new_utxo\"]\n+\n+        # This UTXO is unconfirmed and missing.\n+        missing_tx = self.wallet.create_self_transfer()\n+        utxo_unconf_missing = missing_tx[\"new_utxo\"]\n+\n+        orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[utxo_conf_old,\n+            utxo_conf_recent, utxo_unconf_mempool, utxo_unconf_missing])\n+\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.sync_with_ping()\n+        assert_equal(len(peer.last_message[\"getdata\"].inv), 2)\n+        peer.wait_for_parent_requests([int(txid_conf_old, 16), int(missing_tx[\"txid\"], 16)])\n+\n+        # Even though the peer would send a notfound for the \"old\" confirmed transaction, the node\n+        # doesn't give up on the orphan. Once all of the missing parents are received, it should be\n+        # submitted to mempool.\n+        peer.send_message(msg_notfound(vec=[CInv(MSG_WITNESS_TX, int(txid_conf_old, 16))]))\n+        peer.send_and_ping(msg_tx(missing_tx[\"tx\"]))\n+        peer.sync_with_ping()\n+        assert_equal(node.getmempoolentry(orphan[\"txid\"])[\"ancestorcount\"], 3)\n+\n+    @cleanup\n+    def test_orphans_overlapping_parents(self):\n+        node = self.nodes[0]\n+        # In the process of relaying inflight_parent_AB\n+        peer_txrequest = node.add_p2p_connection(PeerTxRelayer())\n+        # Sends the orphans\n+        peer_orphans = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test handling of multiple orphans with missing parents that are already being requested\")\n+        # Parent of child_A only\n+        missing_parent_A = self.wallet_nonsegwit.create_self_transfer()\n+        # Parents of child_A and child_B\n+        missing_parent_AB = self.wallet_nonsegwit.create_self_transfer()\n+        inflight_parent_AB = self.wallet_nonsegwit.create_self_transfer()\n+        # Parent of child_B only\n+        missing_parent_B = self.wallet_nonsegwit.create_self_transfer()\n+        child_A = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_A[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+        child_B = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_B[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+\n+        # The wtxid and txid need to be the same for the node to recognize that the missing input\n+        # and in-flight request for inflight_parent_AB are the same transaction.\n+        assert_equal(inflight_parent_AB[\"txid\"], inflight_parent_AB[\"tx\"].getwtxid())\n+\n+        # Announce inflight_parent_AB and wait for getdata\n+        peer_txrequest.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=int(inflight_parent_AB[\"tx\"].getwtxid(), 16))]))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_txrequest.wait_for_getdata([int(inflight_parent_AB[\"tx\"].getwtxid(), 16)])\n+\n+        self.log.info(\"The node should not request a parent if it has an in-flight txrequest\")\n+        # Relay orphan child_A\n+        self.relay_transaction(peer_orphans, child_A[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        # Both missing parents should be requested.\n+        peer_orphans.wait_for_parent_requests([int(missing_parent_A[\"txid\"], 16), int(missing_parent_AB[\"txid\"], 16)])\n+\n+        self.log.info(\"The node should not request a parent if it has an in-flight orphan parent request\")\n+        # Relay orphan child_B\n+        self.relay_transaction(peer_orphans, child_B[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        # Only missing_parent_B should be requested. Not inflight_parent_AB or missing_parent_AB\n+        # because they are already being requested from peer_orphans.\n+        peer_orphans.wait_for_parent_requests([int(missing_parent_B[\"txid\"], 16)])\n+        peer_orphans.assert_never_requested(int(inflight_parent_AB[\"txid\"], 16))\n+\n+    @cleanup\n+    def test_orphan_of_orphan(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test handling of an orphan with a parent who is another orphan\")\n+        missing_grandparent = self.wallet_nonsegwit.create_self_transfer()\n+        missing_parent_orphan = self.wallet_nonsegwit.create_self_transfer(utxo_to_spend=missing_grandparent[\"new_utxo\"])\n+        missing_parent = self.wallet_nonsegwit.create_self_transfer()\n+        orphan = self.wallet_nonsegwit.create_self_transfer_multi(utxos_to_spend=[missing_parent[\"new_utxo\"], missing_parent_orphan[\"new_utxo\"]])\n+\n+        # The node should put missing_parent_orphan into the orphanage and request missing_grandparent\n+        self.relay_transaction(peer, missing_parent_orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.wait_for_parent_requests([int(missing_grandparent[\"txid\"], 16)])\n+\n+        # The node should put the orphan into the orphanage and request missing_parent, skipping\n+        # missing_parent_orphan because it already has it in the orphanage.\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.wait_for_parent_requests([int(missing_parent[\"txid\"], 16)])\n+\n+    @cleanup\n+    def test_orphan_inherit_rejection(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+        peer3 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282274277",
      "id" : 1282274277,
      "line" : 391,
      "node_id" : "PRRC_kwDOABII585MbfPl",
      "original_commit_id" : "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_line" : 391,
      "original_position" : 391,
      "original_start_line" : null,
      "path" : "test/functional/p2p_orphan_handling.py",
      "position" : 391,
      "pull_request_review_id" : 1559366940,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282274277/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-02T18:24:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282274277",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   }
]
