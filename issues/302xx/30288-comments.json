[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> This is not what currently happens, but simplest approach might be for the original chainstate to be unaffected by the snapshot chainstate, and to continue to download and attach the same blocks it otherwise would have if no snapshot were loaded. It would just do it more slowly due to a reduced cache size and lower priority for block requests compared to the snapshot chainstate.\r\n\r\nI think that the concept of the Active Chainstate / Active Tip is important for this this discussion. Currently, it is tied to the snapshot chainstate until the background sync has finished.\r\nIf we keep that logic, having the background chainstate target the most-work block doesn't really achieve anything - if that chain turns out to be valid, we would still never use it for anything meaningful because the snapshot chainstate will remain the active one.\r\nSo in order for targeting the most-work chain to make any sense, we'd also need to introduce the possibility of switching the active chainstate to it without the requirement that the background sync has to finish. Which would lead to other questions: I we don't prioritize syncing the background chainstate towards it anymore, should we keep the now-unused snapshot chainstate around indefinitely and just ignore it exists? Should we be able to switch the active chainstate back to the snapshot chain in case we receive more blocks building on top of it, so that it becomes the most-work chain again?\r\n\r\nConsidering that AssumeUtxo sync is meant to be an optional and temporary optimization, and that large reorgs should be very infrequent, it could also make sense to abandon the AssumeUtxo sync, delete the snapshot chainstate and revert to normal sync as soon as we accept a header on a different chain that has more work than the best header of the snapshot chain.\r\n\r\nI think that pragmatically we shouldn't accept a snapshot in the first place if it's not an ancestor of the most-work header `m_best_header` (I plan on opening a PR for that soon), but that doesn't solve the problem completely because we might only learn about another chain after having loaded the snapshot successfully.",
      "created_at" : "2024-06-14T17:10:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/30288#issuecomment-2168444052",
      "id" : 2168444052,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30288",
      "node_id" : "IC_kwDOABII586BP9SU",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2168444052/reactions"
      },
      "updated_at" : "2024-06-14T17:10:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2168444052",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> I think that the concept of the Active Chainstate / Active Tip is important for this this discussion\r\n\r\nAgree it's worth mentioning. I think decisions about how chainstates are synced are mostly separate from decisions about how they are used and prioritized. But for completeness, I was assuming that if the original chainstate ever had more work than the snapshot chainstate, the snapshot chainstate would be unused and could be deleted, and the original chainstate would become the \"active\" chainstate again. Also, cache and download priority would be shifted to whichever chainstate had headers showing the most-work.\r\n\r\n(Somewhat related to this: I don't think the concept of an \"active\" chainstate is useful, and in #30214 I eliminate many uses of that designation. Right now when a snapshot is loaded, indexes treat the original chainstate as active, while wallets treat the snapshot chainstate as active. RPCs mostly treat the snapshot chainstate as active, but sometimes show information about both chainstates. I think it's better to refer to chainstates as current vs historical, or validated vs. assumed-valid instead of referring more nebulously to an \"active\" chainstate.)\r\n\r\n> it could also make sense to abandon the AssumeUtxo sync, delete the snapshot chainstate and revert to normal sync as soon as we accept a header on a different chain that has more work than the best header of the snapshot chain.\r\n\r\nThat would be a third approach. Keeping the \"Original chainstate targets the snapshot block\" logic, but then abandoning the snapshot and switching back to \"Original chainstate targets the most-work chain\" logic when some condition is detected. I'm not sure this approach has advantages over always targeting the most-work chain, but it could, depending on the implementation details.\r\n\r\nI'm also not sure just the existence of headers with the most work not including the snapshot block is a good enough reason to refuse loading the snapshot, or to delete the snapshot chainstate after a snapshot is loaded. It could be weird if the other chain that seemed to have more work turned out to be invalid, or more headers were received later that actually included the snapshot block allowed loading the snapshot again after it had previously been discarded or refused.\r\n\r\nIn general, just letting original chainstate sync to most-work chain, regardless of whether a snapshot chainstate is loaded seems like the simplest approach with the fewest special cases, and doesn't seem to have significant drawbacks?",
      "created_at" : "2024-06-14T20:23:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/30288#issuecomment-2168713360",
      "id" : 2168713360,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30288",
      "node_id" : "IC_kwDOABII586BQ_CQ",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2168713360/reactions"
      },
      "updated_at" : "2024-06-14T20:23:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2168713360",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Good discussion question, thanks for raising!\r\n\r\n> Considering that AssumeUtxo sync is meant to be an optional and temporary optimization, and that large reorgs should be very infrequent, it could also make sense to abandon the AssumeUtxo sync, delete the snapshot chainstate and revert to normal sync as soon as we accept a header on a different chain that has more work than the best header of the snapshot chain.\r\n\r\nI think something like this makes more sense than to change how the background sync works.  In my view, the purpose of the assumeutxo optimization is to offer users a different trust model where they can still reasonably safely get online and using the network prior to the background sync finishing.  In the event that there is a competing tip with more work than a tip built on the snapshot, it's impossible for the software to determine which tip is the right one without doing a lot of work, and I think our choices are:\r\n 1. Proceed under the assumption that the assumeutxo snapshot is correct, and effectively \"checkpoint\" the assumeutxo block hash (so that the snapshot chainstate doesn't try to reorg to the most work chain), allowing the user to continue using the network in the meantime.\r\n 2. Abandon the assumeutxo optimization in this scenario and fall back to current sync behavior.\r\n\r\nOption 1 is of course incredibly risky to a user if that assumption is wrong (ie acting as though that is the most valid work chain can result in funds loss). Moreover, the scenario that we'd be optimizing for is a highly unusual one, as we'd be optimizing for faster startup time for assumeutxo users in the event that there's a more-work but consensus invalid fork of the chain.  In that unusual scenario, we could always write new code to optimize for that case -- or do simpler things like invalidating the block hash of the first consensus-invalid block header on that chain to avoid processing it (we could hard code this in future software versions, and perhaps instruct users on how to use invalidateblock as a temporary workaround).\r\n\r\nSo I think option 2 makes more sense for now: let's change our code so that if we ever detect the potential for an assumeutxo snapshot to not be on the most-work chain, just abandon the optimization and proceed without it.  Exactly how we handle that in our software still requires some thought: if a user has already started transacting based on an assumeutxo snapshot, and then we learn about some more work headers chain that forks before the snapshot height, what exactly do we do?  Perhaps we should shut down and throw whatever the biggest warning/error message we can is, requiring a restart that will discard the snapshot chainstate?  Or we could just treat it as a reorg down to a less work tip (ie from the snapshot's tip back to the fully-validated tip), which while not normally allowed is already possible in our code if `invalidateblock` is used, so maybe that works ok too?",
      "created_at" : "2024-06-15T13:07:10Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/30288#issuecomment-2169559245",
      "id" : 2169559245,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30288",
      "node_id" : "IC_kwDOABII586BUNjN",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2169559245/reactions"
      },
      "updated_at" : "2024-06-15T13:07:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2169559245",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "If I can summarize and clarify, neither of you think the current behavior of locking in snapshot block, and temporarily refusing to consider chains that don't include it is a good idea? The list of reasons above trying to justify current behavior are basically B.S.? (The \"Possible advantages of original chainstate targeting the snapshot block\" section about network hard forks and eclipse attacks)\r\n\r\nInstead, the behavior you both seem to prefer is just: when a snapshot is loaded, as soon as a new header is received showing the chain with the most work not include the snapshot block, we should immediately stop using the snapshot chainstate, and maybe delete it, and maybe warn the user and shut down?\r\n\r\nThis is a little different, but not very different, than the approach I was envisioning where if the snapshot block was not on the most-work header chain, instead of abandoning the snapshot chainstate, we would continue to let it sync in the background with lower priority, in case the other chain with more work turned out to be invalid. Later, if the chain with more work turned out to be valid, the snapshot chainstate would be deleted. Specifically this would happen when the tip of the snapshot chainstate had less work than the tip of original chainstate. This way, wallets would always use the chain that had the most work AND was valid, they wouldn't be affected by headers for another chain that might not be valid (other than by syncing more slowly).\r\n\r\nIn any case, it sounds like we want to abandon the idea of locking in the snapshot block, and ignoring chains with more work that don't include it. If so, it sounds like special case code targeting the snapshot block could be removed either way.",
      "created_at" : "2024-06-16T13:10:08Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/30288#issuecomment-2171582899",
      "id" : 2171582899,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30288",
      "node_id" : "IC_kwDOABII586Bb7mz",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2171582899/reactions"
      },
      "updated_at" : "2024-06-16T13:10:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2171582899",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> If I can summarize and clarify, neither of you think the current behavior of locking in snapshot block, and temporarily refusing to consider chains that don't include it is a good idea? \r\n\r\nI'm not sure I'm following this point exactly: my recollection is that the current **observable** behavior in this scenario would be to crash, because even though the original/fully validated chainstate locks in ancestors of the snapshot block to be possible tips, we'd still try to reorg the snapshot chainstate to that more-work chain, and before that more-work chain could be validated we would crash when trying to disconnect a block for which we don't have undo data.\r\n\r\nI actually think that apart from the terrible UX, this is essentially the right behavior, in that we're trying to maximally protect users from thinking everything is fine in the event that our assumptions around how this feature is meant to be used are violated (and we haven't fully validated things for ourselves to know what's going on).\r\n\r\nAnother way of putting it: the intent of assumeutxo is to optimize start-up time for a new node, not introduce a checkpointing system for which chains are considered valid or affect consensus in an observable way.  We could debate the idea of adding more checkpoints to our software (whether shipped with our code or configurable by users with a command line option), but I think we should separate these two concerns, because assumeutxo ought to be generally useful without introducing new checkpoints.\r\n\r\nAlso, the logic where we limit the tips that we consider for the original chainstate to only be ones that are ancestors of the snapshot block (when a snapshot chainstate is present) is just designed to simplify the consensus logic so that it's clear what is supposed to be happening.  I also think that this is just an implementation detail and not really something that should be externally observable, and that the code could be designed differently without affecting the overall behavior, so if others feel differently about how this logic is implemented then we could change it so that it's more easily understandable/robust/etc.\r\n\r\n> Possible advantages of original chainstate targeting the snapshot block:\r\n> ...\r\n> Maybe could provide resilience against hard forks that contain more work? If loading a snapshot makes a node temporarily ignore any chain not containing a snapshot block, maybe that is a useful feature if the chain with more work turns out to be invalid.\r\n\r\nI think if this were to happen, then it'd be legitimate to want the assumeutxo feature to still work to help users who opt-in be able to sync a new node more quickly and start using the network.  However, I think the existence of a more-work hard fork that is several months old is something that (a) would be well known to us, and (b) would require us to solve many other problems as well in order to support our users generally (regardless of the assumeutxo feature).  For instance, we'd want to try to partition the p2p network so that we prevent our new users from being immediately eclipsed by nodes on an invalid chain (which by the way would preclude even learning the block headers needed for assumeutxo to work in the first place), and we'd want to prevent our users from trying to download all the blocks leading up to the alternate chain's tip (which might require a lot of block download in order to have all the blocks needed to attempt the big reorg, which would be a huge bandwidth waste). The simplest way to do that might just be to explicitly hardcode the block hash of the alternate chain which forks from ours as invalid, which would immediately address both of these additional problems in addition to making assumeutxo work in this scenario.\r\n\r\nOf course we could consider other options as well, such as user-configurable checkpoints, or an option to explicitly checkpoint the assumeutxo blockhash -- but again I think it's helpful to separate the idea of changes to which tips we consider as valid from the startup optimization that I think assumeutxo is really designed to be.\r\n\r\n> Could help in an eclipse attack? If headers or blocks after the snapshot block were withheld, this could temporarily stop the node from syncing to a undesirable fork excluding the snapshot block that seemed to have more work.\r\n\r\nI think that eclipse attacks are mostly orthogonal to assumeutxo: if an attacker has eclipsed you, then they can bypass whatever protection assumeutxo might give in this regard by simply presenting a chain that forks after the assumeutxo blockhash.  (Moreover I think that shutting down is a safer option for users in this kind of scenario than pretending everything is ok.)\r\n\r\n> Instead, the behavior you both seem to prefer is just: when a snapshot is loaded, as soon as a new header is received showing the chain with the most work not include the snapshot block, we should immediately stop using the snapshot chainstate, and maybe delete it, and maybe warn the user and shut down?\r\n\r\nYes this is what I'm thinking (coupled with @mzumsande's suggestion to just fail to load a snapshot if it's not an ancestor of the most work header we have).\r\n\r\n> In any case, it sounds like we want to abandon the idea of locking in the snapshot block, and ignoring chains with more work that don't include it. If so, it sounds like special case code targeting the snapshot block could be removed either way.\r\n\r\nI'm actually not sure I would agree with this (assuming I'm understanding your suggestion correctly), but I may be biased as I think I authored the code you're probably talking about, after finding the more general logic that someone else had written to be confusing!  That said I'm open to alternate ways of implementing the desired behavior and if there's a simpler version that is easier to understand/more robust/etc then that's fine with me too.",
      "created_at" : "2024-06-16T18:08:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/30288#issuecomment-2171794670",
      "id" : 2171794670,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30288",
      "node_id" : "IC_kwDOABII586BcvTu",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2171794670/reactions"
      },
      "updated_at" : "2024-06-16T18:08:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2171794670",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   }
]
