[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage\nFor detailed information about the code coverage, see the [test coverage report](https://corecheck.dev/bitcoin/bitcoin/pulls/29975).\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| Concept ACK | [TheCharlatan](https://github.com/bitcoin/bitcoin/pull/29975#issuecomment-2080168836), [furszy](https://github.com/bitcoin/bitcoin/pull/29975#pullrequestreview-2026654546), [BrandonOdiwuor](https://github.com/bitcoin/bitcoin/pull/29975#pullrequestreview-2028283852) |\n\nIf your review is incorrectly listed, please react with ð to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#29700](https://github.com/bitcoin/bitcoin/pull/29700) (kernel, refactor: return error status on all fatal errors by ryanofsky)\n* [#29641](https://github.com/bitcoin/bitcoin/pull/29641) (scripted-diff: Use LogInfo/LogDebug over LogPrintf/LogPrint by maflcko)\n* [#29231](https://github.com/bitcoin/bitcoin/pull/29231) (logging: Update to new logging API by ajtowns)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "created_at" : "2024-04-26T21:30:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#issuecomment-2080140998",
      "id" : 2080140998,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/29975",
      "node_id" : "IC_kwDOABII5857_G7G",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2080140998/reactions"
      },
      "updated_at" : "2024-04-29T11:50:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2080140998",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--85328a0da195eb286784d51f73fa0af9-->\n\nð§ At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/24317664317</sub>",
      "created_at" : "2024-04-26T21:42:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#issuecomment-2080156364",
      "id" : 2080156364,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/29975",
      "node_id" : "IC_kwDOABII5857_KrM",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2080156364/reactions"
      },
      "updated_at" : "2024-04-26T21:42:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2080156364",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Concept ACK",
      "created_at" : "2024-04-26T21:57:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#issuecomment-2080168836",
      "id" : 2080168836,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/29975",
      "node_id" : "IC_kwDOABII5857_NuE",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2080168836/reactions"
      },
      "updated_at" : "2024-04-26T21:57:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2080168836",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8421793?v=4",
         "events_url" : "https://api.github.com/users/TheCharlatan/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheCharlatan/followers",
         "following_url" : "https://api.github.com/users/TheCharlatan/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheCharlatan/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheCharlatan",
         "id" : 8421793,
         "login" : "TheCharlatan",
         "node_id" : "MDQ6VXNlcjg0MjE3OTM=",
         "organizations_url" : "https://api.github.com/users/TheCharlatan/orgs",
         "received_events_url" : "https://api.github.com/users/TheCharlatan/received_events",
         "repos_url" : "https://api.github.com/users/TheCharlatan/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheCharlatan/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheCharlatan/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheCharlatan"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1581784723"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581784723"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "seems to me the related comments needs to be updated in this file (e.g line 184 and 199)",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-04-27T10:00:24Z",
      "diff_hunk" : "@@ -189,7 +189,7 @@ BOOST_AUTO_TEST_CASE(blockmanager_flush_block_file)\n     // to block 2 location.\n     CBlockFileInfo* block_data = blockman.GetBlockFileInfo(0);\n     BOOST_CHECK_EQUAL(block_data->nBlocks, 2);\n-    BOOST_CHECK(blockman.SaveBlockToDisk(block3, /*nHeight=*/3, /*dbp=*/&pos2) == pos2);\n+    blockman.AddToBlockFileInfo(block3, /*nHeight=*/3, /*pos=*/pos2);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1581784723",
      "id" : 1581784723,
      "line" : 189,
      "node_id" : "PRRC_kwDOABII585eSB6T",
      "original_commit_id" : "39ad8d825e35b7326ad0ea25c37d3fe12ded64c9",
      "original_line" : 189,
      "original_position" : 43,
      "original_start_line" : null,
      "path" : "src/test/blockmanager_tests.cpp",
      "position" : 56,
      "pull_request_review_id" : 2026623423,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581784723/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-04-27T12:59:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581784723",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1841944?v=4",
         "events_url" : "https://api.github.com/users/paplorinc/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paplorinc/followers",
         "following_url" : "https://api.github.com/users/paplorinc/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paplorinc/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paplorinc",
         "id" : 1841944,
         "login" : "paplorinc",
         "node_id" : "MDQ6VXNlcjE4NDE5NDQ=",
         "organizations_url" : "https://api.github.com/users/paplorinc/orgs",
         "received_events_url" : "https://api.github.com/users/paplorinc/received_events",
         "repos_url" : "https://api.github.com/users/paplorinc/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paplorinc/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paplorinc/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paplorinc"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1581822649"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581822649"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: is the naming style deliberate here? When is it camel and when snake?",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-04-27T12:28:32Z",
      "diff_hunk" : "@@ -863,90 +863,104 @@ bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigne\n     }\n     const int last_blockfile = m_blockfile_cursors[chain_type]->file_num;\n \n-    int nFile = fKnown ? pos.nFile : last_blockfile;\n+    int nFile = last_blockfile;\n     if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n         m_blockfile_info.resize(nFile + 1);\n     }\n \n     bool finalize_undo = false;\n-    if (!fKnown) {\n-        unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n-        // Use smaller blockfiles in test-only -fastprune mode - but avoid\n-        // the possibility of having a block not fit into the block file.\n-        if (m_opts.fast_prune) {\n-            max_blockfile_size = 0x10000; // 64kiB\n-            if (nAddSize >= max_blockfile_size) {\n-                // dynamically adjust the blockfile size to be larger than the added size\n-                max_blockfile_size = nAddSize + 1;\n-            }\n+    unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n+    // Use smaller blockfiles in test-only -fastprune mode - but avoid\n+    // the possibility of having a block not fit into the block file.\n+    if (m_opts.fast_prune) {\n+        max_blockfile_size = 0x10000; // 64kiB\n+        if (nAddSize >= max_blockfile_size) {\n+            // dynamically adjust the blockfile size to be larger than the added size\n+            max_blockfile_size = nAddSize + 1;\n         }\n-        assert(nAddSize < max_blockfile_size);\n-\n-        while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n-            // when the undo file is keeping up with the block file, we want to flush it explicitly\n-            // when it is lagging behind (more blocks arrive than are being connected), we let the\n-            // undo block write case handle it\n-            finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n-                    Assert(m_blockfile_cursors[chain_type])->undo_height);\n-\n-            // Try the next unclaimed blockfile number\n-            nFile = this->MaxBlockfileNum() + 1;\n-            // Set to increment MaxBlockfileNum() for next iteration\n-            m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n-\n-            if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n-                m_blockfile_info.resize(nFile + 1);\n-            }\n+    }\n+    assert(nAddSize < max_blockfile_size);\n+\n+    while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n+        // when the undo file is keeping up with the block file, we want to flush it explicitly\n+        // when it is lagging behind (more blocks arrive than are being connected), we let the\n+        // undo block write case handle it\n+        finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n+                         Assert(m_blockfile_cursors[chain_type])->undo_height);\n+\n+        // Try the next unclaimed blockfile number\n+        nFile = this->MaxBlockfileNum() + 1;\n+        // Set to increment MaxBlockfileNum() for next iteration\n+        m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n+\n+        if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n+            m_blockfile_info.resize(nFile + 1);\n         }\n-        pos.nFile = nFile;\n-        pos.nPos = m_blockfile_info[nFile].nSize;\n     }\n+    pos.nFile = nFile;\n+    pos.nPos = m_blockfile_info[nFile].nSize;\n \n     if (nFile != last_blockfile) {\n-        if (!fKnown) {\n-            LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n-                last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n-\n-            // Do not propagate the return code. The flush concerns a previous block\n-            // and undo file that has already been written to. If a flush fails\n-            // here, and we crash, there is no expected additional block data\n-            // inconsistency arising from the flush failure here. However, the undo\n-            // data may be inconsistent after a crash if the flush is called during\n-            // a reindex. A flush error might also leave some of the data files\n-            // untrimmed.\n-            if (!FlushBlockFile(last_blockfile, !fKnown, finalize_undo)) {\n-                LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n-                              \"Failed to flush previous block file %05i (finalize=%i, finalize_undo=%i) before opening new block file %05i\\n\",\n-                              last_blockfile, !fKnown, finalize_undo, nFile);\n-            }\n+        LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n+                 last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n+\n+        // Do not propagate the return code. The flush concerns a previous block\n+        // and undo file that has already been written to. If a flush fails\n+        // here, and we crash, there is no expected additional block data\n+        // inconsistency arising from the flush failure here. However, the undo\n+        // data may be inconsistent after a crash if the flush is called during\n+        // a reindex. A flush error might also leave some of the data files\n+        // untrimmed.\n+        if (!FlushBlockFile(last_blockfile, true, finalize_undo)) {\n+            LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n+                          \"Failed to flush previous block file %05i (finalize=1, finalize_undo=%i) before opening new block file %05i\\n\",\n+                          last_blockfile, finalize_undo, nFile);\n         }\n         // No undo data yet in the new file, so reset our undo-height tracking.\n         m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n     }\n \n     m_blockfile_info[nFile].AddBlock(nHeight, nTime);\n-    if (fKnown) {\n-        m_blockfile_info[nFile].nSize = std::max(pos.nPos + nAddSize, m_blockfile_info[nFile].nSize);\n-    } else {\n-        m_blockfile_info[nFile].nSize += nAddSize;\n-    }\n+    m_blockfile_info[nFile].nSize += nAddSize;\n \n-    if (!fKnown) {\n-        bool out_of_space;\n-        size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n-        if (out_of_space) {\n-            m_opts.notifications.fatalError(_(\"Disk space is too low!\"));\n-            return false;\n-        }\n-        if (bytes_allocated != 0 && IsPruneMode()) {\n-            m_check_for_pruning = true;\n-        }\n+    bool out_of_space;\n+    size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n+    if (out_of_space) {\n+        m_opts.notifications.fatalError(_(\"Disk space is too low!\"));\n+        return false;\n+    }\n+    if (bytes_allocated != 0 && IsPruneMode()) {\n+        m_check_for_pruning = true;\n     }\n \n     m_dirty_fileinfo.insert(nFile);\n     return true;\n }\n \n+\n+void BlockManager::AddToBlockFileInfo(const CBlock& block, unsigned int nHeight, const FlatFilePos& pos)\n+{\n+    LOCK(cs_LastBlockFile);\n+\n+    unsigned int nAddSize = ::GetSerializeSize(TX_WITH_WITNESS(block));\n+    const BlockfileType chain_type = BlockfileTypeForHeight(nHeight);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1581822649",
      "id" : 1581822649,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585eSLK5",
      "original_commit_id" : "39ad8d825e35b7326ad0ea25c37d3fe12ded64c9",
      "original_line" : 946,
      "original_position" : 154,
      "original_start_line" : 945,
      "path" : "src/node/blockstorage.cpp",
      "position" : null,
      "pull_request_review_id" : 2026623423,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581822649/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2024-04-27T12:59:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581822649",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1841944?v=4",
         "events_url" : "https://api.github.com/users/paplorinc/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paplorinc/followers",
         "following_url" : "https://api.github.com/users/paplorinc/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paplorinc/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paplorinc",
         "id" : 1841944,
         "login" : "paplorinc",
         "node_id" : "MDQ6VXNlcjE4NDE5NDQ=",
         "organizations_url" : "https://api.github.com/users/paplorinc/orgs",
         "received_events_url" : "https://api.github.com/users/paplorinc/received_events",
         "repos_url" : "https://api.github.com/users/paplorinc/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paplorinc/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paplorinc/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paplorinc"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1581824896"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581824896"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Does this reassignment still make sense?",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-04-27T12:41:59Z",
      "diff_hunk" : "@@ -863,90 +863,104 @@ bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigne\n     }\n     const int last_blockfile = m_blockfile_cursors[chain_type]->file_num;\n \n-    int nFile = fKnown ? pos.nFile : last_blockfile;\n+    int nFile = last_blockfile;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1581824896",
      "id" : 1581824896,
      "line" : 866,
      "node_id" : "PRRC_kwDOABII585eSLuA",
      "original_commit_id" : "39ad8d825e35b7326ad0ea25c37d3fe12ded64c9",
      "original_line" : 866,
      "original_position" : 14,
      "original_start_line" : null,
      "path" : "src/node/blockstorage.cpp",
      "position" : 14,
      "pull_request_review_id" : 2026623423,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581824896/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-04-27T12:59:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581824896",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1841944?v=4",
         "events_url" : "https://api.github.com/users/paplorinc/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paplorinc/followers",
         "following_url" : "https://api.github.com/users/paplorinc/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paplorinc/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paplorinc",
         "id" : 1841944,
         "login" : "paplorinc",
         "node_id" : "MDQ6VXNlcjE4NDE5NDQ=",
         "organizations_url" : "https://api.github.com/users/paplorinc/orgs",
         "received_events_url" : "https://api.github.com/users/paplorinc/received_events",
         "repos_url" : "https://api.github.com/users/paplorinc/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paplorinc/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paplorinc/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paplorinc"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1581825021"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581825021"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "should we keep the original comment here?",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-04-27T12:42:44Z",
      "diff_hunk" : "@@ -863,90 +863,104 @@ bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigne\n     }\n     const int last_blockfile = m_blockfile_cursors[chain_type]->file_num;\n \n-    int nFile = fKnown ? pos.nFile : last_blockfile;\n+    int nFile = last_blockfile;\n     if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n         m_blockfile_info.resize(nFile + 1);\n     }\n \n     bool finalize_undo = false;\n-    if (!fKnown) {\n-        unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n-        // Use smaller blockfiles in test-only -fastprune mode - but avoid\n-        // the possibility of having a block not fit into the block file.\n-        if (m_opts.fast_prune) {\n-            max_blockfile_size = 0x10000; // 64kiB\n-            if (nAddSize >= max_blockfile_size) {\n-                // dynamically adjust the blockfile size to be larger than the added size\n-                max_blockfile_size = nAddSize + 1;\n-            }\n+    unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n+    // Use smaller blockfiles in test-only -fastprune mode - but avoid\n+    // the possibility of having a block not fit into the block file.\n+    if (m_opts.fast_prune) {\n+        max_blockfile_size = 0x10000; // 64kiB\n+        if (nAddSize >= max_blockfile_size) {\n+            // dynamically adjust the blockfile size to be larger than the added size\n+            max_blockfile_size = nAddSize + 1;\n         }\n-        assert(nAddSize < max_blockfile_size);\n-\n-        while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n-            // when the undo file is keeping up with the block file, we want to flush it explicitly\n-            // when it is lagging behind (more blocks arrive than are being connected), we let the\n-            // undo block write case handle it\n-            finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n-                    Assert(m_blockfile_cursors[chain_type])->undo_height);\n-\n-            // Try the next unclaimed blockfile number\n-            nFile = this->MaxBlockfileNum() + 1;\n-            // Set to increment MaxBlockfileNum() for next iteration\n-            m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n-\n-            if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n-                m_blockfile_info.resize(nFile + 1);\n-            }\n+    }\n+    assert(nAddSize < max_blockfile_size);\n+\n+    while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n+        // when the undo file is keeping up with the block file, we want to flush it explicitly\n+        // when it is lagging behind (more blocks arrive than are being connected), we let the\n+        // undo block write case handle it\n+        finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n+                         Assert(m_blockfile_cursors[chain_type])->undo_height);\n+\n+        // Try the next unclaimed blockfile number\n+        nFile = this->MaxBlockfileNum() + 1;\n+        // Set to increment MaxBlockfileNum() for next iteration\n+        m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n+\n+        if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n+            m_blockfile_info.resize(nFile + 1);\n         }\n-        pos.nFile = nFile;\n-        pos.nPos = m_blockfile_info[nFile].nSize;\n     }\n+    pos.nFile = nFile;\n+    pos.nPos = m_blockfile_info[nFile].nSize;\n \n     if (nFile != last_blockfile) {\n-        if (!fKnown) {\n-            LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n-                last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n-\n-            // Do not propagate the return code. The flush concerns a previous block\n-            // and undo file that has already been written to. If a flush fails\n-            // here, and we crash, there is no expected additional block data\n-            // inconsistency arising from the flush failure here. However, the undo\n-            // data may be inconsistent after a crash if the flush is called during\n-            // a reindex. A flush error might also leave some of the data files\n-            // untrimmed.\n-            if (!FlushBlockFile(last_blockfile, !fKnown, finalize_undo)) {\n-                LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n-                              \"Failed to flush previous block file %05i (finalize=%i, finalize_undo=%i) before opening new block file %05i\\n\",\n-                              last_blockfile, !fKnown, finalize_undo, nFile);\n-            }\n+        LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n+                 last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n+\n+        // Do not propagate the return code. The flush concerns a previous block\n+        // and undo file that has already been written to. If a flush fails\n+        // here, and we crash, there is no expected additional block data\n+        // inconsistency arising from the flush failure here. However, the undo\n+        // data may be inconsistent after a crash if the flush is called during\n+        // a reindex. A flush error might also leave some of the data files\n+        // untrimmed.\n+        if (!FlushBlockFile(last_blockfile, true, finalize_undo)) {\n+            LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n+                          \"Failed to flush previous block file %05i (finalize=1, finalize_undo=%i) before opening new block file %05i\\n\",\n+                          last_blockfile, finalize_undo, nFile);\n         }\n         // No undo data yet in the new file, so reset our undo-height tracking.\n         m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n     }\n \n     m_blockfile_info[nFile].AddBlock(nHeight, nTime);\n-    if (fKnown) {\n-        m_blockfile_info[nFile].nSize = std::max(pos.nPos + nAddSize, m_blockfile_info[nFile].nSize);\n-    } else {\n-        m_blockfile_info[nFile].nSize += nAddSize;\n-    }\n+    m_blockfile_info[nFile].nSize += nAddSize;\n \n-    if (!fKnown) {\n-        bool out_of_space;\n-        size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n-        if (out_of_space) {\n-            m_opts.notifications.fatalError(_(\"Disk space is too low!\"));\n-            return false;\n-        }\n-        if (bytes_allocated != 0 && IsPruneMode()) {\n-            m_check_for_pruning = true;\n-        }\n+    bool out_of_space;\n+    size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n+    if (out_of_space) {\n+        m_opts.notifications.fatalError(_(\"Disk space is too low!\"));\n+        return false;\n+    }\n+    if (bytes_allocated != 0 && IsPruneMode()) {\n+        m_check_for_pruning = true;\n     }\n \n     m_dirty_fileinfo.insert(nFile);\n     return true;\n }\n \n+\n+void BlockManager::AddToBlockFileInfo(const CBlock& block, unsigned int nHeight, const FlatFilePos& pos)\n+{\n+    LOCK(cs_LastBlockFile);\n+\n+    unsigned int nAddSize = ::GetSerializeSize(TX_WITH_WITNESS(block));\n+    const BlockfileType chain_type = BlockfileTypeForHeight(nHeight);\n+    // -reindex and -reindex-chainstate delete any snapshot chainstate during init\n+    Assume(chain_type == BlockfileType::NORMAL);\n+\n+    const int last_blockfile = m_blockfile_cursors[chain_type]->file_num;\n+    const int nFile = pos.nFile;\n+\n+    if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n+        m_blockfile_info.resize(nFile + 1);\n+    }\n+    if (nFile != last_blockfile) {\n+        m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1581825021",
      "id" : 1581825021,
      "line" : 958,
      "node_id" : "PRRC_kwDOABII585eSLv9",
      "original_commit_id" : "39ad8d825e35b7326ad0ea25c37d3fe12ded64c9",
      "original_line" : 958,
      "original_position" : 165,
      "original_start_line" : null,
      "path" : "src/node/blockstorage.cpp",
      "position" : 166,
      "pull_request_review_id" : 2026623423,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581825021/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-04-27T12:59:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581825021",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1841944?v=4",
         "events_url" : "https://api.github.com/users/paplorinc/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paplorinc/followers",
         "following_url" : "https://api.github.com/users/paplorinc/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paplorinc/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paplorinc",
         "id" : 1841944,
         "login" : "paplorinc",
         "node_id" : "MDQ6VXNlcjE4NDE5NDQ=",
         "organizations_url" : "https://api.github.com/users/paplorinc/orgs",
         "received_events_url" : "https://api.github.com/users/paplorinc/received_events",
         "repos_url" : "https://api.github.com/users/paplorinc/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paplorinc/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paplorinc/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paplorinc"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1581825604"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581825604"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Does the comment on line 215 need any update after the change?",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-04-27T12:46:50Z",
      "diff_hunk" : "@@ -155,7 +155,13 @@ class BlockManager\n     /** Return false if undo file flushing fails. */\n     [[nodiscard]] bool FlushUndoFile(int block_file, bool finalize = false);\n \n-    [[nodiscard]] bool FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, uint64_t nTime, bool fKnown);\n+    /**\n+     * Helper function performing various preparations before a block can be saved to disk:\n+     * Locates the correct position for the block to be saved, which may be in the current or a new\n+     * block file depending on nAddSize. May flush the previous blockfile to disk if full, updates\n+     * blockfile info, and checks if there is enough disk space to save the block.\n+     */\n+    [[nodiscard]] bool FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, uint64_t nTime);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1581825604",
      "id" : 1581825604,
      "line" : 164,
      "node_id" : "PRRC_kwDOABII585eSL5E",
      "original_commit_id" : "39ad8d825e35b7326ad0ea25c37d3fe12ded64c9",
      "original_line" : 164,
      "original_position" : 11,
      "original_start_line" : null,
      "path" : "src/node/blockstorage.h",
      "position" : 11,
      "pull_request_review_id" : 2026623423,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581825604/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-04-27T12:59:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581825604",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1841944?v=4",
         "events_url" : "https://api.github.com/users/paplorinc/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paplorinc/followers",
         "following_url" : "https://api.github.com/users/paplorinc/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paplorinc/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paplorinc",
         "id" : 1841944,
         "login" : "paplorinc",
         "node_id" : "MDQ6VXNlcjE4NDE5NDQ=",
         "organizations_url" : "https://api.github.com/users/paplorinc/orgs",
         "received_events_url" : "https://api.github.com/users/paplorinc/received_events",
         "repos_url" : "https://api.github.com/users/paplorinc/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paplorinc/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paplorinc/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paplorinc"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1581825870"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581825870"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "we might as well use `blockPos` here\r\n```C++\r\nm_blockman.AddToBlockFileInfo(block, pindex->nHeight, blockPos);\r\n```",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-04-27T12:48:47Z",
      "diff_hunk" : "@@ -4342,10 +4342,16 @@ bool ChainstateManager::AcceptBlock(const std::shared_ptr<const CBlock>& pblock,\n     // Write block to history file\n     if (fNewBlock) *fNewBlock = true;\n     try {\n-        FlatFilePos blockPos{m_blockman.SaveBlockToDisk(block, pindex->nHeight, dbp)};\n-        if (blockPos.IsNull()) {\n-            state.Error(strprintf(\"%s: Failed to find position to write new block to disk\", __func__));\n-            return false;\n+        FlatFilePos blockPos{};\n+        if (dbp) {\n+            blockPos = *dbp;\n+            m_blockman.AddToBlockFileInfo(block, pindex->nHeight, *dbp);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1581825870",
      "id" : 1581825870,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585eSL9O",
      "original_commit_id" : "39ad8d825e35b7326ad0ea25c37d3fe12ded64c9",
      "original_line" : 4348,
      "original_position" : 11,
      "original_start_line" : null,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 2026623423,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581825870/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-04-27T12:59:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581825870",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1841944?v=4",
         "events_url" : "https://api.github.com/users/paplorinc/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paplorinc/followers",
         "following_url" : "https://api.github.com/users/paplorinc/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paplorinc/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paplorinc",
         "id" : 1841944,
         "login" : "paplorinc",
         "node_id" : "MDQ6VXNlcjE4NDE5NDQ=",
         "organizations_url" : "https://api.github.com/users/paplorinc/orgs",
         "received_events_url" : "https://api.github.com/users/paplorinc/received_events",
         "repos_url" : "https://api.github.com/users/paplorinc/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paplorinc/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paplorinc/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paplorinc"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1581826711"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581826711"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "we could move this closer to the usage",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-04-27T12:55:01Z",
      "diff_hunk" : "@@ -865,90 +863,104 @@ bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigne\n     }\n     const int last_blockfile = m_blockfile_cursors[chain_type]->file_num;\n \n-    int nFile = fKnown ? pos.nFile : last_blockfile;\n+    int nFile = last_blockfile;\n     if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n         m_blockfile_info.resize(nFile + 1);\n     }\n \n     bool finalize_undo = false;\n-    if (!fKnown) {\n-        unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n-        // Use smaller blockfiles in test-only -fastprune mode - but avoid\n-        // the possibility of having a block not fit into the block file.\n-        if (m_opts.fast_prune) {\n-            max_blockfile_size = 0x10000; // 64kiB\n-            if (nAddSize >= max_blockfile_size) {\n-                // dynamically adjust the blockfile size to be larger than the added size\n-                max_blockfile_size = nAddSize + 1;\n-            }\n+    unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n+    // Use smaller blockfiles in test-only -fastprune mode - but avoid\n+    // the possibility of having a block not fit into the block file.\n+    if (m_opts.fast_prune) {\n+        max_blockfile_size = 0x10000; // 64kiB\n+        if (nAddSize >= max_blockfile_size) {\n+            // dynamically adjust the blockfile size to be larger than the added size\n+            max_blockfile_size = nAddSize + 1;\n         }\n-        assert(nAddSize < max_blockfile_size);\n-\n-        while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n-            // when the undo file is keeping up with the block file, we want to flush it explicitly\n-            // when it is lagging behind (more blocks arrive than are being connected), we let the\n-            // undo block write case handle it\n-            finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n-                    Assert(m_blockfile_cursors[chain_type])->undo_height);\n-\n-            // Try the next unclaimed blockfile number\n-            nFile = this->MaxBlockfileNum() + 1;\n-            // Set to increment MaxBlockfileNum() for next iteration\n-            m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n-\n-            if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n-                m_blockfile_info.resize(nFile + 1);\n-            }\n+    }\n+    assert(nAddSize < max_blockfile_size);\n+\n+    while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n+        // when the undo file is keeping up with the block file, we want to flush it explicitly\n+        // when it is lagging behind (more blocks arrive than are being connected), we let the\n+        // undo block write case handle it\n+        finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n+                         Assert(m_blockfile_cursors[chain_type])->undo_height);\n+\n+        // Try the next unclaimed blockfile number\n+        nFile = this->MaxBlockfileNum() + 1;\n+        // Set to increment MaxBlockfileNum() for next iteration\n+        m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n+\n+        if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n+            m_blockfile_info.resize(nFile + 1);\n         }\n-        pos.nFile = nFile;\n-        pos.nPos = m_blockfile_info[nFile].nSize;\n     }\n+    pos.nFile = nFile;\n+    pos.nPos = m_blockfile_info[nFile].nSize;\n \n     if (nFile != last_blockfile) {\n-        if (!fKnown) {\n-            LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n-                last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n-\n-            // Do not propagate the return code. The flush concerns a previous block\n-            // and undo file that has already been written to. If a flush fails\n-            // here, and we crash, there is no expected additional block data\n-            // inconsistency arising from the flush failure here. However, the undo\n-            // data may be inconsistent after a crash if the flush is called during\n-            // a reindex. A flush error might also leave some of the data files\n-            // untrimmed.\n-            if (!FlushBlockFile(last_blockfile, !fKnown, finalize_undo)) {\n-                LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n-                              \"Failed to flush previous block file %05i (finalize=%i, finalize_undo=%i) before opening new block file %05i\\n\",\n-                              last_blockfile, !fKnown, finalize_undo, nFile);\n-            }\n+        LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n+                 last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n+\n+        // Do not propagate the return code. The flush concerns a previous block\n+        // and undo file that has already been written to. If a flush fails\n+        // here, and we crash, there is no expected additional block data\n+        // inconsistency arising from the flush failure here. However, the undo\n+        // data may be inconsistent after a crash if the flush is called during\n+        // a reindex. A flush error might also leave some of the data files\n+        // untrimmed.\n+        if (!FlushBlockFile(last_blockfile, true, finalize_undo)) {\n+            LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n+                          \"Failed to flush previous block file %05i (finalize=1, finalize_undo=%i) before opening new block file %05i\\n\",\n+                          last_blockfile, finalize_undo, nFile);\n         }\n         // No undo data yet in the new file, so reset our undo-height tracking.\n         m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n     }\n \n     m_blockfile_info[nFile].AddBlock(nHeight, nTime);\n-    if (fKnown) {\n-        m_blockfile_info[nFile].nSize = std::max(pos.nPos + nAddSize, m_blockfile_info[nFile].nSize);\n-    } else {\n-        m_blockfile_info[nFile].nSize += nAddSize;\n-    }\n+    m_blockfile_info[nFile].nSize += nAddSize;\n \n-    if (!fKnown) {\n-        bool out_of_space;\n-        size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n-        if (out_of_space) {\n-            m_opts.notifications.fatalError(_(\"Disk space is too low!\"));\n-            return false;\n-        }\n-        if (bytes_allocated != 0 && IsPruneMode()) {\n-            m_check_for_pruning = true;\n-        }\n+    bool out_of_space;\n+    size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n+    if (out_of_space) {\n+        m_opts.notifications.fatalError(_(\"Disk space is too low!\"));\n+        return false;\n+    }\n+    if (bytes_allocated != 0 && IsPruneMode()) {\n+        m_check_for_pruning = true;\n     }\n \n     m_dirty_fileinfo.insert(nFile);\n     return true;\n }\n \n+\n+void BlockManager::AddToBlockFileInfo(const CBlock& block, unsigned int nHeight, const FlatFilePos& pos)\n+{\n+    LOCK(cs_LastBlockFile);\n+\n+    unsigned int nAddSize = ::GetSerializeSize(TX_WITH_WITNESS(block));\n+    const BlockfileType chain_type = BlockfileTypeForHeight(nHeight);\n+    // -reindex and -reindex-chainstate delete any snapshot chainstate during init\n+    Assume(chain_type == BlockfileType::NORMAL);\n+\n+    const int last_blockfile = m_blockfile_cursors[chain_type]->file_num;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1581826711",
      "id" : 1581826711,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585eSMKX",
      "original_commit_id" : "20efb411bd51ff3bfcb7f4a2cc7bd0d704ad7c26",
      "original_line" : 950,
      "original_position" : 167,
      "original_start_line" : null,
      "path" : "src/node/blockstorage.cpp",
      "position" : null,
      "pull_request_review_id" : 2026623423,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581826711/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-04-27T12:59:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581826711",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1841944?v=4",
         "events_url" : "https://api.github.com/users/paplorinc/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paplorinc/followers",
         "following_url" : "https://api.github.com/users/paplorinc/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paplorinc/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paplorinc",
         "id" : 1841944,
         "login" : "paplorinc",
         "node_id" : "MDQ6VXNlcjE4NDE5NDQ=",
         "organizations_url" : "https://api.github.com/users/paplorinc/orgs",
         "received_events_url" : "https://api.github.com/users/paplorinc/received_events",
         "repos_url" : "https://api.github.com/users/paplorinc/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paplorinc/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paplorinc/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paplorinc"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1581827125"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581827125"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This is the reason why\r\n```C++\r\nif (!m_blockfile_cursors[chain_type]) {\r\n    // If a snapshot is loaded during runtime, we may not have initialized this cursor yet.\r\n    assert(chain_type == BlockfileType::ASSUMED);\r\n    const auto new_cursor = BlockfileCursor{this->MaxBlockfileNum() + 1};\r\n    m_blockfile_cursors[chain_type] = new_cursor;\r\n    LogPrint(BCLog::BLOCKSTORAGE, \"[%s] initializing blockfile cursor to %s\\n\", chain_type, new_cursor);\r\n}\r\n```\r\n is not applicable here, right?\r\n Would it make sense to also assume `m_blockfile_cursors[chain_type]`?",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-04-27T12:57:38Z",
      "diff_hunk" : "@@ -865,90 +863,104 @@ bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigne\n     }\n     const int last_blockfile = m_blockfile_cursors[chain_type]->file_num;\n \n-    int nFile = fKnown ? pos.nFile : last_blockfile;\n+    int nFile = last_blockfile;\n     if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n         m_blockfile_info.resize(nFile + 1);\n     }\n \n     bool finalize_undo = false;\n-    if (!fKnown) {\n-        unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n-        // Use smaller blockfiles in test-only -fastprune mode - but avoid\n-        // the possibility of having a block not fit into the block file.\n-        if (m_opts.fast_prune) {\n-            max_blockfile_size = 0x10000; // 64kiB\n-            if (nAddSize >= max_blockfile_size) {\n-                // dynamically adjust the blockfile size to be larger than the added size\n-                max_blockfile_size = nAddSize + 1;\n-            }\n+    unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n+    // Use smaller blockfiles in test-only -fastprune mode - but avoid\n+    // the possibility of having a block not fit into the block file.\n+    if (m_opts.fast_prune) {\n+        max_blockfile_size = 0x10000; // 64kiB\n+        if (nAddSize >= max_blockfile_size) {\n+            // dynamically adjust the blockfile size to be larger than the added size\n+            max_blockfile_size = nAddSize + 1;\n         }\n-        assert(nAddSize < max_blockfile_size);\n-\n-        while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n-            // when the undo file is keeping up with the block file, we want to flush it explicitly\n-            // when it is lagging behind (more blocks arrive than are being connected), we let the\n-            // undo block write case handle it\n-            finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n-                    Assert(m_blockfile_cursors[chain_type])->undo_height);\n-\n-            // Try the next unclaimed blockfile number\n-            nFile = this->MaxBlockfileNum() + 1;\n-            // Set to increment MaxBlockfileNum() for next iteration\n-            m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n-\n-            if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n-                m_blockfile_info.resize(nFile + 1);\n-            }\n+    }\n+    assert(nAddSize < max_blockfile_size);\n+\n+    while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n+        // when the undo file is keeping up with the block file, we want to flush it explicitly\n+        // when it is lagging behind (more blocks arrive than are being connected), we let the\n+        // undo block write case handle it\n+        finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n+                         Assert(m_blockfile_cursors[chain_type])->undo_height);\n+\n+        // Try the next unclaimed blockfile number\n+        nFile = this->MaxBlockfileNum() + 1;\n+        // Set to increment MaxBlockfileNum() for next iteration\n+        m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n+\n+        if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n+            m_blockfile_info.resize(nFile + 1);\n         }\n-        pos.nFile = nFile;\n-        pos.nPos = m_blockfile_info[nFile].nSize;\n     }\n+    pos.nFile = nFile;\n+    pos.nPos = m_blockfile_info[nFile].nSize;\n \n     if (nFile != last_blockfile) {\n-        if (!fKnown) {\n-            LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n-                last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n-\n-            // Do not propagate the return code. The flush concerns a previous block\n-            // and undo file that has already been written to. If a flush fails\n-            // here, and we crash, there is no expected additional block data\n-            // inconsistency arising from the flush failure here. However, the undo\n-            // data may be inconsistent after a crash if the flush is called during\n-            // a reindex. A flush error might also leave some of the data files\n-            // untrimmed.\n-            if (!FlushBlockFile(last_blockfile, !fKnown, finalize_undo)) {\n-                LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n-                              \"Failed to flush previous block file %05i (finalize=%i, finalize_undo=%i) before opening new block file %05i\\n\",\n-                              last_blockfile, !fKnown, finalize_undo, nFile);\n-            }\n+        LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n+                 last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n+\n+        // Do not propagate the return code. The flush concerns a previous block\n+        // and undo file that has already been written to. If a flush fails\n+        // here, and we crash, there is no expected additional block data\n+        // inconsistency arising from the flush failure here. However, the undo\n+        // data may be inconsistent after a crash if the flush is called during\n+        // a reindex. A flush error might also leave some of the data files\n+        // untrimmed.\n+        if (!FlushBlockFile(last_blockfile, true, finalize_undo)) {\n+            LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n+                          \"Failed to flush previous block file %05i (finalize=1, finalize_undo=%i) before opening new block file %05i\\n\",\n+                          last_blockfile, finalize_undo, nFile);\n         }\n         // No undo data yet in the new file, so reset our undo-height tracking.\n         m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n     }\n \n     m_blockfile_info[nFile].AddBlock(nHeight, nTime);\n-    if (fKnown) {\n-        m_blockfile_info[nFile].nSize = std::max(pos.nPos + nAddSize, m_blockfile_info[nFile].nSize);\n-    } else {\n-        m_blockfile_info[nFile].nSize += nAddSize;\n-    }\n+    m_blockfile_info[nFile].nSize += nAddSize;\n \n-    if (!fKnown) {\n-        bool out_of_space;\n-        size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n-        if (out_of_space) {\n-            m_opts.notifications.fatalError(_(\"Disk space is too low!\"));\n-            return false;\n-        }\n-        if (bytes_allocated != 0 && IsPruneMode()) {\n-            m_check_for_pruning = true;\n-        }\n+    bool out_of_space;\n+    size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n+    if (out_of_space) {\n+        m_opts.notifications.fatalError(_(\"Disk space is too low!\"));\n+        return false;\n+    }\n+    if (bytes_allocated != 0 && IsPruneMode()) {\n+        m_check_for_pruning = true;\n     }\n \n     m_dirty_fileinfo.insert(nFile);\n     return true;\n }\n \n+\n+void BlockManager::AddToBlockFileInfo(const CBlock& block, unsigned int nHeight, const FlatFilePos& pos)\n+{\n+    LOCK(cs_LastBlockFile);\n+\n+    unsigned int nAddSize = ::GetSerializeSize(TX_WITH_WITNESS(block));\n+    const BlockfileType chain_type = BlockfileTypeForHeight(nHeight);\n+    // -reindex and -reindex-chainstate delete any snapshot chainstate during init\n+    Assume(chain_type == BlockfileType::NORMAL);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1581827125",
      "id" : 1581827125,
      "line" : 948,
      "node_id" : "PRRC_kwDOABII585eSMQ1",
      "original_commit_id" : "20efb411bd51ff3bfcb7f4a2cc7bd0d704ad7c26",
      "original_line" : 948,
      "original_position" : 165,
      "original_start_line" : null,
      "path" : "src/node/blockstorage.cpp",
      "position" : 156,
      "pull_request_review_id" : 2026623423,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581827125/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-04-27T12:59:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581827125",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1841944?v=4",
         "events_url" : "https://api.github.com/users/paplorinc/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paplorinc/followers",
         "following_url" : "https://api.github.com/users/paplorinc/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paplorinc/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paplorinc",
         "id" : 1841944,
         "login" : "paplorinc",
         "node_id" : "MDQ6VXNlcjE4NDE5NDQ=",
         "organizations_url" : "https://api.github.com/users/paplorinc/orgs",
         "received_events_url" : "https://api.github.com/users/paplorinc/received_events",
         "repos_url" : "https://api.github.com/users/paplorinc/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paplorinc/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paplorinc/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paplorinc"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1583635647"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583635647"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done.",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-04-29T19:35:07Z",
      "diff_hunk" : "@@ -863,90 +863,104 @@ bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigne\n     }\n     const int last_blockfile = m_blockfile_cursors[chain_type]->file_num;\n \n-    int nFile = fKnown ? pos.nFile : last_blockfile;\n+    int nFile = last_blockfile;\n     if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n         m_blockfile_info.resize(nFile + 1);\n     }\n \n     bool finalize_undo = false;\n-    if (!fKnown) {\n-        unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n-        // Use smaller blockfiles in test-only -fastprune mode - but avoid\n-        // the possibility of having a block not fit into the block file.\n-        if (m_opts.fast_prune) {\n-            max_blockfile_size = 0x10000; // 64kiB\n-            if (nAddSize >= max_blockfile_size) {\n-                // dynamically adjust the blockfile size to be larger than the added size\n-                max_blockfile_size = nAddSize + 1;\n-            }\n+    unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n+    // Use smaller blockfiles in test-only -fastprune mode - but avoid\n+    // the possibility of having a block not fit into the block file.\n+    if (m_opts.fast_prune) {\n+        max_blockfile_size = 0x10000; // 64kiB\n+        if (nAddSize >= max_blockfile_size) {\n+            // dynamically adjust the blockfile size to be larger than the added size\n+            max_blockfile_size = nAddSize + 1;\n         }\n-        assert(nAddSize < max_blockfile_size);\n-\n-        while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n-            // when the undo file is keeping up with the block file, we want to flush it explicitly\n-            // when it is lagging behind (more blocks arrive than are being connected), we let the\n-            // undo block write case handle it\n-            finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n-                    Assert(m_blockfile_cursors[chain_type])->undo_height);\n-\n-            // Try the next unclaimed blockfile number\n-            nFile = this->MaxBlockfileNum() + 1;\n-            // Set to increment MaxBlockfileNum() for next iteration\n-            m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n-\n-            if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n-                m_blockfile_info.resize(nFile + 1);\n-            }\n+    }\n+    assert(nAddSize < max_blockfile_size);\n+\n+    while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n+        // when the undo file is keeping up with the block file, we want to flush it explicitly\n+        // when it is lagging behind (more blocks arrive than are being connected), we let the\n+        // undo block write case handle it\n+        finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n+                         Assert(m_blockfile_cursors[chain_type])->undo_height);\n+\n+        // Try the next unclaimed blockfile number\n+        nFile = this->MaxBlockfileNum() + 1;\n+        // Set to increment MaxBlockfileNum() for next iteration\n+        m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n+\n+        if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n+            m_blockfile_info.resize(nFile + 1);\n         }\n-        pos.nFile = nFile;\n-        pos.nPos = m_blockfile_info[nFile].nSize;\n     }\n+    pos.nFile = nFile;\n+    pos.nPos = m_blockfile_info[nFile].nSize;\n \n     if (nFile != last_blockfile) {\n-        if (!fKnown) {\n-            LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n-                last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n-\n-            // Do not propagate the return code. The flush concerns a previous block\n-            // and undo file that has already been written to. If a flush fails\n-            // here, and we crash, there is no expected additional block data\n-            // inconsistency arising from the flush failure here. However, the undo\n-            // data may be inconsistent after a crash if the flush is called during\n-            // a reindex. A flush error might also leave some of the data files\n-            // untrimmed.\n-            if (!FlushBlockFile(last_blockfile, !fKnown, finalize_undo)) {\n-                LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n-                              \"Failed to flush previous block file %05i (finalize=%i, finalize_undo=%i) before opening new block file %05i\\n\",\n-                              last_blockfile, !fKnown, finalize_undo, nFile);\n-            }\n+        LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n+                 last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n+\n+        // Do not propagate the return code. The flush concerns a previous block\n+        // and undo file that has already been written to. If a flush fails\n+        // here, and we crash, there is no expected additional block data\n+        // inconsistency arising from the flush failure here. However, the undo\n+        // data may be inconsistent after a crash if the flush is called during\n+        // a reindex. A flush error might also leave some of the data files\n+        // untrimmed.\n+        if (!FlushBlockFile(last_blockfile, true, finalize_undo)) {\n+            LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n+                          \"Failed to flush previous block file %05i (finalize=1, finalize_undo=%i) before opening new block file %05i\\n\",\n+                          last_blockfile, finalize_undo, nFile);\n         }\n         // No undo data yet in the new file, so reset our undo-height tracking.\n         m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n     }\n \n     m_blockfile_info[nFile].AddBlock(nHeight, nTime);\n-    if (fKnown) {\n-        m_blockfile_info[nFile].nSize = std::max(pos.nPos + nAddSize, m_blockfile_info[nFile].nSize);\n-    } else {\n-        m_blockfile_info[nFile].nSize += nAddSize;\n-    }\n+    m_blockfile_info[nFile].nSize += nAddSize;\n \n-    if (!fKnown) {\n-        bool out_of_space;\n-        size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n-        if (out_of_space) {\n-            m_opts.notifications.fatalError(_(\"Disk space is too low!\"));\n-            return false;\n-        }\n-        if (bytes_allocated != 0 && IsPruneMode()) {\n-            m_check_for_pruning = true;\n-        }\n+    bool out_of_space;\n+    size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n+    if (out_of_space) {\n+        m_opts.notifications.fatalError(_(\"Disk space is too low!\"));\n+        return false;\n+    }\n+    if (bytes_allocated != 0 && IsPruneMode()) {\n+        m_check_for_pruning = true;\n     }\n \n     m_dirty_fileinfo.insert(nFile);\n     return true;\n }\n \n+\n+void BlockManager::AddToBlockFileInfo(const CBlock& block, unsigned int nHeight, const FlatFilePos& pos)\n+{\n+    LOCK(cs_LastBlockFile);\n+\n+    unsigned int nAddSize = ::GetSerializeSize(TX_WITH_WITNESS(block));\n+    const BlockfileType chain_type = BlockfileTypeForHeight(nHeight);\n+    // -reindex and -reindex-chainstate delete any snapshot chainstate during init\n+    Assume(chain_type == BlockfileType::NORMAL);\n+\n+    const int last_blockfile = m_blockfile_cursors[chain_type]->file_num;\n+    const int nFile = pos.nFile;\n+\n+    if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n+        m_blockfile_info.resize(nFile + 1);\n+    }\n+    if (nFile != last_blockfile) {\n+        m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1583635647",
      "id" : 1583635647,
      "in_reply_to_id" : 1581825021,
      "line" : 958,
      "node_id" : "PRRC_kwDOABII585eZFy_",
      "original_commit_id" : "39ad8d825e35b7326ad0ea25c37d3fe12ded64c9",
      "original_line" : 958,
      "original_position" : 165,
      "original_start_line" : null,
      "path" : "src/node/blockstorage.cpp",
      "position" : 166,
      "pull_request_review_id" : 2029424460,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583635647/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-04-29T19:35:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583635647",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1583636377"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583636377"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Yes, I think so. We later may increase nFile and then compare it to `last_blockfile` (line  `if (nFile != last_blockfile)`)",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-04-29T19:35:51Z",
      "diff_hunk" : "@@ -863,90 +863,104 @@ bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigne\n     }\n     const int last_blockfile = m_blockfile_cursors[chain_type]->file_num;\n \n-    int nFile = fKnown ? pos.nFile : last_blockfile;\n+    int nFile = last_blockfile;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1583636377",
      "id" : 1583636377,
      "in_reply_to_id" : 1581824896,
      "line" : 866,
      "node_id" : "PRRC_kwDOABII585eZF-Z",
      "original_commit_id" : "39ad8d825e35b7326ad0ea25c37d3fe12ded64c9",
      "original_line" : 866,
      "original_position" : 14,
      "original_start_line" : null,
      "path" : "src/node/blockstorage.cpp",
      "position" : 14,
      "pull_request_review_id" : 2029425696,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583636377/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-04-29T19:35:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583636377",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1583637879"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583637879"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I took both from FindBlockPos, snake case is correct, but for historical reasons camel case is still used in lots of places.\r\nBut since this is arguably new code I renamed `nAddSize` to `added_size` ",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-04-29T19:36:48Z",
      "diff_hunk" : "@@ -863,90 +863,104 @@ bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigne\n     }\n     const int last_blockfile = m_blockfile_cursors[chain_type]->file_num;\n \n-    int nFile = fKnown ? pos.nFile : last_blockfile;\n+    int nFile = last_blockfile;\n     if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n         m_blockfile_info.resize(nFile + 1);\n     }\n \n     bool finalize_undo = false;\n-    if (!fKnown) {\n-        unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n-        // Use smaller blockfiles in test-only -fastprune mode - but avoid\n-        // the possibility of having a block not fit into the block file.\n-        if (m_opts.fast_prune) {\n-            max_blockfile_size = 0x10000; // 64kiB\n-            if (nAddSize >= max_blockfile_size) {\n-                // dynamically adjust the blockfile size to be larger than the added size\n-                max_blockfile_size = nAddSize + 1;\n-            }\n+    unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n+    // Use smaller blockfiles in test-only -fastprune mode - but avoid\n+    // the possibility of having a block not fit into the block file.\n+    if (m_opts.fast_prune) {\n+        max_blockfile_size = 0x10000; // 64kiB\n+        if (nAddSize >= max_blockfile_size) {\n+            // dynamically adjust the blockfile size to be larger than the added size\n+            max_blockfile_size = nAddSize + 1;\n         }\n-        assert(nAddSize < max_blockfile_size);\n-\n-        while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n-            // when the undo file is keeping up with the block file, we want to flush it explicitly\n-            // when it is lagging behind (more blocks arrive than are being connected), we let the\n-            // undo block write case handle it\n-            finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n-                    Assert(m_blockfile_cursors[chain_type])->undo_height);\n-\n-            // Try the next unclaimed blockfile number\n-            nFile = this->MaxBlockfileNum() + 1;\n-            // Set to increment MaxBlockfileNum() for next iteration\n-            m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n-\n-            if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n-                m_blockfile_info.resize(nFile + 1);\n-            }\n+    }\n+    assert(nAddSize < max_blockfile_size);\n+\n+    while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n+        // when the undo file is keeping up with the block file, we want to flush it explicitly\n+        // when it is lagging behind (more blocks arrive than are being connected), we let the\n+        // undo block write case handle it\n+        finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n+                         Assert(m_blockfile_cursors[chain_type])->undo_height);\n+\n+        // Try the next unclaimed blockfile number\n+        nFile = this->MaxBlockfileNum() + 1;\n+        // Set to increment MaxBlockfileNum() for next iteration\n+        m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n+\n+        if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n+            m_blockfile_info.resize(nFile + 1);\n         }\n-        pos.nFile = nFile;\n-        pos.nPos = m_blockfile_info[nFile].nSize;\n     }\n+    pos.nFile = nFile;\n+    pos.nPos = m_blockfile_info[nFile].nSize;\n \n     if (nFile != last_blockfile) {\n-        if (!fKnown) {\n-            LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n-                last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n-\n-            // Do not propagate the return code. The flush concerns a previous block\n-            // and undo file that has already been written to. If a flush fails\n-            // here, and we crash, there is no expected additional block data\n-            // inconsistency arising from the flush failure here. However, the undo\n-            // data may be inconsistent after a crash if the flush is called during\n-            // a reindex. A flush error might also leave some of the data files\n-            // untrimmed.\n-            if (!FlushBlockFile(last_blockfile, !fKnown, finalize_undo)) {\n-                LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n-                              \"Failed to flush previous block file %05i (finalize=%i, finalize_undo=%i) before opening new block file %05i\\n\",\n-                              last_blockfile, !fKnown, finalize_undo, nFile);\n-            }\n+        LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n+                 last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n+\n+        // Do not propagate the return code. The flush concerns a previous block\n+        // and undo file that has already been written to. If a flush fails\n+        // here, and we crash, there is no expected additional block data\n+        // inconsistency arising from the flush failure here. However, the undo\n+        // data may be inconsistent after a crash if the flush is called during\n+        // a reindex. A flush error might also leave some of the data files\n+        // untrimmed.\n+        if (!FlushBlockFile(last_blockfile, true, finalize_undo)) {\n+            LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n+                          \"Failed to flush previous block file %05i (finalize=1, finalize_undo=%i) before opening new block file %05i\\n\",\n+                          last_blockfile, finalize_undo, nFile);\n         }\n         // No undo data yet in the new file, so reset our undo-height tracking.\n         m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n     }\n \n     m_blockfile_info[nFile].AddBlock(nHeight, nTime);\n-    if (fKnown) {\n-        m_blockfile_info[nFile].nSize = std::max(pos.nPos + nAddSize, m_blockfile_info[nFile].nSize);\n-    } else {\n-        m_blockfile_info[nFile].nSize += nAddSize;\n-    }\n+    m_blockfile_info[nFile].nSize += nAddSize;\n \n-    if (!fKnown) {\n-        bool out_of_space;\n-        size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n-        if (out_of_space) {\n-            m_opts.notifications.fatalError(_(\"Disk space is too low!\"));\n-            return false;\n-        }\n-        if (bytes_allocated != 0 && IsPruneMode()) {\n-            m_check_for_pruning = true;\n-        }\n+    bool out_of_space;\n+    size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n+    if (out_of_space) {\n+        m_opts.notifications.fatalError(_(\"Disk space is too low!\"));\n+        return false;\n+    }\n+    if (bytes_allocated != 0 && IsPruneMode()) {\n+        m_check_for_pruning = true;\n     }\n \n     m_dirty_fileinfo.insert(nFile);\n     return true;\n }\n \n+\n+void BlockManager::AddToBlockFileInfo(const CBlock& block, unsigned int nHeight, const FlatFilePos& pos)\n+{\n+    LOCK(cs_LastBlockFile);\n+\n+    unsigned int nAddSize = ::GetSerializeSize(TX_WITH_WITNESS(block));\n+    const BlockfileType chain_type = BlockfileTypeForHeight(nHeight);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1583637879",
      "id" : 1583637879,
      "in_reply_to_id" : 1581822649,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585eZGV3",
      "original_commit_id" : "39ad8d825e35b7326ad0ea25c37d3fe12ded64c9",
      "original_line" : 946,
      "original_position" : 154,
      "original_start_line" : 945,
      "path" : "src/node/blockstorage.cpp",
      "position" : null,
      "pull_request_review_id" : 2029428884,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583637879/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2024-04-29T19:36:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583637879",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1583638770"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583638770"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "You mean the comment \"The ASSUMED state is initialized, when necessary, in FindBlockPos().\"?\r\nThat behavior is unchanged, it's part of the normal usage of `FindBlockPos` and wasn't happening during reindex anyway (see first commit), so I don't think it needs to be updated.",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-04-29T19:37:51Z",
      "diff_hunk" : "@@ -155,7 +155,13 @@ class BlockManager\n     /** Return false if undo file flushing fails. */\n     [[nodiscard]] bool FlushUndoFile(int block_file, bool finalize = false);\n \n-    [[nodiscard]] bool FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, uint64_t nTime, bool fKnown);\n+    /**\n+     * Helper function performing various preparations before a block can be saved to disk:\n+     * Locates the correct position for the block to be saved, which may be in the current or a new\n+     * block file depending on nAddSize. May flush the previous blockfile to disk if full, updates\n+     * blockfile info, and checks if there is enough disk space to save the block.\n+     */\n+    [[nodiscard]] bool FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, uint64_t nTime);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1583638770",
      "id" : 1583638770,
      "in_reply_to_id" : 1581825604,
      "line" : 164,
      "node_id" : "PRRC_kwDOABII585eZGjy",
      "original_commit_id" : "39ad8d825e35b7326ad0ea25c37d3fe12ded64c9",
      "original_line" : 164,
      "original_position" : 11,
      "original_start_line" : null,
      "path" : "src/node/blockstorage.h",
      "position" : 11,
      "pull_request_review_id" : 2029430446,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583638770/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-04-29T19:37:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583638770",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1583638866"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583638866"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-04-29T19:37:59Z",
      "diff_hunk" : "@@ -4342,10 +4342,16 @@ bool ChainstateManager::AcceptBlock(const std::shared_ptr<const CBlock>& pblock,\n     // Write block to history file\n     if (fNewBlock) *fNewBlock = true;\n     try {\n-        FlatFilePos blockPos{m_blockman.SaveBlockToDisk(block, pindex->nHeight, dbp)};\n-        if (blockPos.IsNull()) {\n-            state.Error(strprintf(\"%s: Failed to find position to write new block to disk\", __func__));\n-            return false;\n+        FlatFilePos blockPos{};\n+        if (dbp) {\n+            blockPos = *dbp;\n+            m_blockman.AddToBlockFileInfo(block, pindex->nHeight, *dbp);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1583638866",
      "id" : 1583638866,
      "in_reply_to_id" : 1581825870,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585eZGlS",
      "original_commit_id" : "39ad8d825e35b7326ad0ea25c37d3fe12ded64c9",
      "original_line" : 4348,
      "original_position" : 11,
      "original_start_line" : null,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 2029430636,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583638866/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-04-29T19:37:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583638866",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1583639069"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583639069"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-04-29T19:38:14Z",
      "diff_hunk" : "@@ -865,90 +863,104 @@ bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigne\n     }\n     const int last_blockfile = m_blockfile_cursors[chain_type]->file_num;\n \n-    int nFile = fKnown ? pos.nFile : last_blockfile;\n+    int nFile = last_blockfile;\n     if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n         m_blockfile_info.resize(nFile + 1);\n     }\n \n     bool finalize_undo = false;\n-    if (!fKnown) {\n-        unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n-        // Use smaller blockfiles in test-only -fastprune mode - but avoid\n-        // the possibility of having a block not fit into the block file.\n-        if (m_opts.fast_prune) {\n-            max_blockfile_size = 0x10000; // 64kiB\n-            if (nAddSize >= max_blockfile_size) {\n-                // dynamically adjust the blockfile size to be larger than the added size\n-                max_blockfile_size = nAddSize + 1;\n-            }\n+    unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n+    // Use smaller blockfiles in test-only -fastprune mode - but avoid\n+    // the possibility of having a block not fit into the block file.\n+    if (m_opts.fast_prune) {\n+        max_blockfile_size = 0x10000; // 64kiB\n+        if (nAddSize >= max_blockfile_size) {\n+            // dynamically adjust the blockfile size to be larger than the added size\n+            max_blockfile_size = nAddSize + 1;\n         }\n-        assert(nAddSize < max_blockfile_size);\n-\n-        while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n-            // when the undo file is keeping up with the block file, we want to flush it explicitly\n-            // when it is lagging behind (more blocks arrive than are being connected), we let the\n-            // undo block write case handle it\n-            finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n-                    Assert(m_blockfile_cursors[chain_type])->undo_height);\n-\n-            // Try the next unclaimed blockfile number\n-            nFile = this->MaxBlockfileNum() + 1;\n-            // Set to increment MaxBlockfileNum() for next iteration\n-            m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n-\n-            if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n-                m_blockfile_info.resize(nFile + 1);\n-            }\n+    }\n+    assert(nAddSize < max_blockfile_size);\n+\n+    while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n+        // when the undo file is keeping up with the block file, we want to flush it explicitly\n+        // when it is lagging behind (more blocks arrive than are being connected), we let the\n+        // undo block write case handle it\n+        finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n+                         Assert(m_blockfile_cursors[chain_type])->undo_height);\n+\n+        // Try the next unclaimed blockfile number\n+        nFile = this->MaxBlockfileNum() + 1;\n+        // Set to increment MaxBlockfileNum() for next iteration\n+        m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n+\n+        if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n+            m_blockfile_info.resize(nFile + 1);\n         }\n-        pos.nFile = nFile;\n-        pos.nPos = m_blockfile_info[nFile].nSize;\n     }\n+    pos.nFile = nFile;\n+    pos.nPos = m_blockfile_info[nFile].nSize;\n \n     if (nFile != last_blockfile) {\n-        if (!fKnown) {\n-            LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n-                last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n-\n-            // Do not propagate the return code. The flush concerns a previous block\n-            // and undo file that has already been written to. If a flush fails\n-            // here, and we crash, there is no expected additional block data\n-            // inconsistency arising from the flush failure here. However, the undo\n-            // data may be inconsistent after a crash if the flush is called during\n-            // a reindex. A flush error might also leave some of the data files\n-            // untrimmed.\n-            if (!FlushBlockFile(last_blockfile, !fKnown, finalize_undo)) {\n-                LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n-                              \"Failed to flush previous block file %05i (finalize=%i, finalize_undo=%i) before opening new block file %05i\\n\",\n-                              last_blockfile, !fKnown, finalize_undo, nFile);\n-            }\n+        LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n+                 last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n+\n+        // Do not propagate the return code. The flush concerns a previous block\n+        // and undo file that has already been written to. If a flush fails\n+        // here, and we crash, there is no expected additional block data\n+        // inconsistency arising from the flush failure here. However, the undo\n+        // data may be inconsistent after a crash if the flush is called during\n+        // a reindex. A flush error might also leave some of the data files\n+        // untrimmed.\n+        if (!FlushBlockFile(last_blockfile, true, finalize_undo)) {\n+            LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n+                          \"Failed to flush previous block file %05i (finalize=1, finalize_undo=%i) before opening new block file %05i\\n\",\n+                          last_blockfile, finalize_undo, nFile);\n         }\n         // No undo data yet in the new file, so reset our undo-height tracking.\n         m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n     }\n \n     m_blockfile_info[nFile].AddBlock(nHeight, nTime);\n-    if (fKnown) {\n-        m_blockfile_info[nFile].nSize = std::max(pos.nPos + nAddSize, m_blockfile_info[nFile].nSize);\n-    } else {\n-        m_blockfile_info[nFile].nSize += nAddSize;\n-    }\n+    m_blockfile_info[nFile].nSize += nAddSize;\n \n-    if (!fKnown) {\n-        bool out_of_space;\n-        size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n-        if (out_of_space) {\n-            m_opts.notifications.fatalError(_(\"Disk space is too low!\"));\n-            return false;\n-        }\n-        if (bytes_allocated != 0 && IsPruneMode()) {\n-            m_check_for_pruning = true;\n-        }\n+    bool out_of_space;\n+    size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n+    if (out_of_space) {\n+        m_opts.notifications.fatalError(_(\"Disk space is too low!\"));\n+        return false;\n+    }\n+    if (bytes_allocated != 0 && IsPruneMode()) {\n+        m_check_for_pruning = true;\n     }\n \n     m_dirty_fileinfo.insert(nFile);\n     return true;\n }\n \n+\n+void BlockManager::AddToBlockFileInfo(const CBlock& block, unsigned int nHeight, const FlatFilePos& pos)\n+{\n+    LOCK(cs_LastBlockFile);\n+\n+    unsigned int nAddSize = ::GetSerializeSize(TX_WITH_WITNESS(block));\n+    const BlockfileType chain_type = BlockfileTypeForHeight(nHeight);\n+    // -reindex and -reindex-chainstate delete any snapshot chainstate during init\n+    Assume(chain_type == BlockfileType::NORMAL);\n+\n+    const int last_blockfile = m_blockfile_cursors[chain_type]->file_num;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1583639069",
      "id" : 1583639069,
      "in_reply_to_id" : 1581826711,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585eZGod",
      "original_commit_id" : "20efb411bd51ff3bfcb7f4a2cc7bd0d704ad7c26",
      "original_line" : 950,
      "original_position" : 167,
      "original_start_line" : null,
      "path" : "src/node/blockstorage.cpp",
      "position" : null,
      "pull_request_review_id" : 2029430977,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583639069/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-04-29T19:38:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583639069",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1583640596"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583640596"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : " Yes. I added this in the first commit, so that the second commit doesn't change behavior.\r\n \r\nAs for your second q: Well, it'd be undefined behavior if `m_blockfile_cursors` didn't haven an element for `BlockfileType::NORMAL`. On the other hand, `m_blockfile_cursors[...]` is used all over the place, I'm not sure if we want to have an assert for each occurence. Other opinions?",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-04-29T19:39:46Z",
      "diff_hunk" : "@@ -865,90 +863,104 @@ bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigne\n     }\n     const int last_blockfile = m_blockfile_cursors[chain_type]->file_num;\n \n-    int nFile = fKnown ? pos.nFile : last_blockfile;\n+    int nFile = last_blockfile;\n     if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n         m_blockfile_info.resize(nFile + 1);\n     }\n \n     bool finalize_undo = false;\n-    if (!fKnown) {\n-        unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n-        // Use smaller blockfiles in test-only -fastprune mode - but avoid\n-        // the possibility of having a block not fit into the block file.\n-        if (m_opts.fast_prune) {\n-            max_blockfile_size = 0x10000; // 64kiB\n-            if (nAddSize >= max_blockfile_size) {\n-                // dynamically adjust the blockfile size to be larger than the added size\n-                max_blockfile_size = nAddSize + 1;\n-            }\n+    unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n+    // Use smaller blockfiles in test-only -fastprune mode - but avoid\n+    // the possibility of having a block not fit into the block file.\n+    if (m_opts.fast_prune) {\n+        max_blockfile_size = 0x10000; // 64kiB\n+        if (nAddSize >= max_blockfile_size) {\n+            // dynamically adjust the blockfile size to be larger than the added size\n+            max_blockfile_size = nAddSize + 1;\n         }\n-        assert(nAddSize < max_blockfile_size);\n-\n-        while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n-            // when the undo file is keeping up with the block file, we want to flush it explicitly\n-            // when it is lagging behind (more blocks arrive than are being connected), we let the\n-            // undo block write case handle it\n-            finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n-                    Assert(m_blockfile_cursors[chain_type])->undo_height);\n-\n-            // Try the next unclaimed blockfile number\n-            nFile = this->MaxBlockfileNum() + 1;\n-            // Set to increment MaxBlockfileNum() for next iteration\n-            m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n-\n-            if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n-                m_blockfile_info.resize(nFile + 1);\n-            }\n+    }\n+    assert(nAddSize < max_blockfile_size);\n+\n+    while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n+        // when the undo file is keeping up with the block file, we want to flush it explicitly\n+        // when it is lagging behind (more blocks arrive than are being connected), we let the\n+        // undo block write case handle it\n+        finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n+                         Assert(m_blockfile_cursors[chain_type])->undo_height);\n+\n+        // Try the next unclaimed blockfile number\n+        nFile = this->MaxBlockfileNum() + 1;\n+        // Set to increment MaxBlockfileNum() for next iteration\n+        m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n+\n+        if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n+            m_blockfile_info.resize(nFile + 1);\n         }\n-        pos.nFile = nFile;\n-        pos.nPos = m_blockfile_info[nFile].nSize;\n     }\n+    pos.nFile = nFile;\n+    pos.nPos = m_blockfile_info[nFile].nSize;\n \n     if (nFile != last_blockfile) {\n-        if (!fKnown) {\n-            LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n-                last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n-\n-            // Do not propagate the return code. The flush concerns a previous block\n-            // and undo file that has already been written to. If a flush fails\n-            // here, and we crash, there is no expected additional block data\n-            // inconsistency arising from the flush failure here. However, the undo\n-            // data may be inconsistent after a crash if the flush is called during\n-            // a reindex. A flush error might also leave some of the data files\n-            // untrimmed.\n-            if (!FlushBlockFile(last_blockfile, !fKnown, finalize_undo)) {\n-                LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n-                              \"Failed to flush previous block file %05i (finalize=%i, finalize_undo=%i) before opening new block file %05i\\n\",\n-                              last_blockfile, !fKnown, finalize_undo, nFile);\n-            }\n+        LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n+                 last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n+\n+        // Do not propagate the return code. The flush concerns a previous block\n+        // and undo file that has already been written to. If a flush fails\n+        // here, and we crash, there is no expected additional block data\n+        // inconsistency arising from the flush failure here. However, the undo\n+        // data may be inconsistent after a crash if the flush is called during\n+        // a reindex. A flush error might also leave some of the data files\n+        // untrimmed.\n+        if (!FlushBlockFile(last_blockfile, true, finalize_undo)) {\n+            LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n+                          \"Failed to flush previous block file %05i (finalize=1, finalize_undo=%i) before opening new block file %05i\\n\",\n+                          last_blockfile, finalize_undo, nFile);\n         }\n         // No undo data yet in the new file, so reset our undo-height tracking.\n         m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n     }\n \n     m_blockfile_info[nFile].AddBlock(nHeight, nTime);\n-    if (fKnown) {\n-        m_blockfile_info[nFile].nSize = std::max(pos.nPos + nAddSize, m_blockfile_info[nFile].nSize);\n-    } else {\n-        m_blockfile_info[nFile].nSize += nAddSize;\n-    }\n+    m_blockfile_info[nFile].nSize += nAddSize;\n \n-    if (!fKnown) {\n-        bool out_of_space;\n-        size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n-        if (out_of_space) {\n-            m_opts.notifications.fatalError(_(\"Disk space is too low!\"));\n-            return false;\n-        }\n-        if (bytes_allocated != 0 && IsPruneMode()) {\n-            m_check_for_pruning = true;\n-        }\n+    bool out_of_space;\n+    size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n+    if (out_of_space) {\n+        m_opts.notifications.fatalError(_(\"Disk space is too low!\"));\n+        return false;\n+    }\n+    if (bytes_allocated != 0 && IsPruneMode()) {\n+        m_check_for_pruning = true;\n     }\n \n     m_dirty_fileinfo.insert(nFile);\n     return true;\n }\n \n+\n+void BlockManager::AddToBlockFileInfo(const CBlock& block, unsigned int nHeight, const FlatFilePos& pos)\n+{\n+    LOCK(cs_LastBlockFile);\n+\n+    unsigned int nAddSize = ::GetSerializeSize(TX_WITH_WITNESS(block));\n+    const BlockfileType chain_type = BlockfileTypeForHeight(nHeight);\n+    // -reindex and -reindex-chainstate delete any snapshot chainstate during init\n+    Assume(chain_type == BlockfileType::NORMAL);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1583640596",
      "id" : 1583640596,
      "in_reply_to_id" : 1581827125,
      "line" : 948,
      "node_id" : "PRRC_kwDOABII585eZHAU",
      "original_commit_id" : "20efb411bd51ff3bfcb7f4a2cc7bd0d704ad7c26",
      "original_line" : 948,
      "original_position" : 165,
      "original_start_line" : null,
      "path" : "src/node/blockstorage.cpp",
      "position" : 156,
      "pull_request_review_id" : 2029433363,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583640596/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-04-29T19:39:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583640596",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1583642139"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583642139"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I updated some comments. The entire test setup probably makes a bit less sense after the refactor, users unfamiliar\r\nwith the history might ask themselves why someone could think that `Reindex` / `AddToBlockFileInfo` would change the block files so that we'd require a test making sure it doesn't.",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-04-29T19:40:39Z",
      "diff_hunk" : "@@ -189,7 +189,7 @@ BOOST_AUTO_TEST_CASE(blockmanager_flush_block_file)\n     // to block 2 location.\n     CBlockFileInfo* block_data = blockman.GetBlockFileInfo(0);\n     BOOST_CHECK_EQUAL(block_data->nBlocks, 2);\n-    BOOST_CHECK(blockman.SaveBlockToDisk(block3, /*nHeight=*/3, /*dbp=*/&pos2) == pos2);\n+    blockman.AddToBlockFileInfo(block3, /*nHeight=*/3, /*pos=*/pos2);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1583642139",
      "id" : 1583642139,
      "in_reply_to_id" : 1581784723,
      "line" : 189,
      "node_id" : "PRRC_kwDOABII585eZHYb",
      "original_commit_id" : "39ad8d825e35b7326ad0ea25c37d3fe12ded64c9",
      "original_line" : 189,
      "original_position" : 43,
      "original_start_line" : null,
      "path" : "src/test/blockmanager_tests.cpp",
      "position" : 56,
      "pull_request_review_id" : 2029436933,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583642139/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-04-29T19:41:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583642139",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "[39ad8d8 ](https://github.com/bitcoin/bitcoin/commit/39ad8d825e35b7326ad0ea25c37d3fe12ded64c9)to [194e84a](https://github.com/bitcoin/bitcoin/commit/194e84accced947ef63c6db389bc62a2b58cffa3): Addressed review feedback by @paplorinc, thanks!",
      "created_at" : "2024-04-29T19:42:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#issuecomment-2083526332",
      "id" : 2083526332,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/29975",
      "node_id" : "IC_kwDOABII5858MBa8",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2083526332/reactions"
      },
      "updated_at" : "2024-04-29T19:42:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2083526332",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   }
]
