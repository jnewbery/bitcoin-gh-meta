[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage\nFor detailed information about the code coverage, see the [test coverage report](https://corecheck.dev/bitcoin/bitcoin/pulls/29975).\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [ryanofsky](https://github.com/bitcoin/bitcoin/pull/29975#pullrequestreview-2041313158) |\n| Concept ACK | [TheCharlatan](https://github.com/bitcoin/bitcoin/pull/29975#issuecomment-2080168836), [furszy](https://github.com/bitcoin/bitcoin/pull/29975#pullrequestreview-2026654546), [BrandonOdiwuor](https://github.com/bitcoin/bitcoin/pull/29975#pullrequestreview-2028283852) |\n\nIf your review is incorrectly listed, please react with ð to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#29700](https://github.com/bitcoin/bitcoin/pull/29700) (kernel, refactor: return error status on all fatal errors by ryanofsky)\n* [#29641](https://github.com/bitcoin/bitcoin/pull/29641) (scripted-diff: Use LogInfo/LogDebug over LogPrintf/LogPrint by maflcko)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "created_at" : "2024-04-26T21:30:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#issuecomment-2080140998",
      "id" : 2080140998,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/29975",
      "node_id" : "IC_kwDOABII5857_G7G",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2080140998/reactions"
      },
      "updated_at" : "2024-05-07T18:03:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2080140998",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--85328a0da195eb286784d51f73fa0af9-->\n\nð§ At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/24317664317</sub>",
      "created_at" : "2024-04-26T21:42:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#issuecomment-2080156364",
      "id" : 2080156364,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/29975",
      "node_id" : "IC_kwDOABII5857_KrM",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2080156364/reactions"
      },
      "updated_at" : "2024-04-26T21:42:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2080156364",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Concept ACK",
      "created_at" : "2024-04-26T21:57:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#issuecomment-2080168836",
      "id" : 2080168836,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/29975",
      "node_id" : "IC_kwDOABII5857_NuE",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2080168836/reactions"
      },
      "updated_at" : "2024-04-26T21:57:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2080168836",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8421793?v=4",
         "events_url" : "https://api.github.com/users/TheCharlatan/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheCharlatan/followers",
         "following_url" : "https://api.github.com/users/TheCharlatan/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheCharlatan/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheCharlatan",
         "id" : 8421793,
         "login" : "TheCharlatan",
         "node_id" : "MDQ6VXNlcjg0MjE3OTM=",
         "organizations_url" : "https://api.github.com/users/TheCharlatan/orgs",
         "received_events_url" : "https://api.github.com/users/TheCharlatan/received_events",
         "repos_url" : "https://api.github.com/users/TheCharlatan/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheCharlatan/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheCharlatan/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheCharlatan"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1581784723"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581784723"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "seems to me the related comments needs to be updated in this file (e.g line 184 and 199)",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-04-27T10:00:24Z",
      "diff_hunk" : "@@ -189,7 +189,7 @@ BOOST_AUTO_TEST_CASE(blockmanager_flush_block_file)\n     // to block 2 location.\n     CBlockFileInfo* block_data = blockman.GetBlockFileInfo(0);\n     BOOST_CHECK_EQUAL(block_data->nBlocks, 2);\n-    BOOST_CHECK(blockman.SaveBlockToDisk(block3, /*nHeight=*/3, /*dbp=*/&pos2) == pos2);\n+    blockman.AddToBlockFileInfo(block3, /*nHeight=*/3, /*pos=*/pos2);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1581784723",
      "id" : 1581784723,
      "line" : 189,
      "node_id" : "PRRC_kwDOABII585eSB6T",
      "original_commit_id" : "39ad8d825e35b7326ad0ea25c37d3fe12ded64c9",
      "original_line" : 189,
      "original_position" : 43,
      "original_start_line" : null,
      "path" : "src/test/blockmanager_tests.cpp",
      "position" : 56,
      "pull_request_review_id" : 2026623423,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581784723/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-04-27T12:59:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581784723",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1841944?v=4",
         "events_url" : "https://api.github.com/users/paplorinc/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paplorinc/followers",
         "following_url" : "https://api.github.com/users/paplorinc/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paplorinc/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paplorinc",
         "id" : 1841944,
         "login" : "paplorinc",
         "node_id" : "MDQ6VXNlcjE4NDE5NDQ=",
         "organizations_url" : "https://api.github.com/users/paplorinc/orgs",
         "received_events_url" : "https://api.github.com/users/paplorinc/received_events",
         "repos_url" : "https://api.github.com/users/paplorinc/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paplorinc/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paplorinc/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paplorinc"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1581822649"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581822649"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: is the naming style deliberate here? When is it camel and when snake?",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-04-27T12:28:32Z",
      "diff_hunk" : "@@ -863,90 +863,104 @@ bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigne\n     }\n     const int last_blockfile = m_blockfile_cursors[chain_type]->file_num;\n \n-    int nFile = fKnown ? pos.nFile : last_blockfile;\n+    int nFile = last_blockfile;\n     if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n         m_blockfile_info.resize(nFile + 1);\n     }\n \n     bool finalize_undo = false;\n-    if (!fKnown) {\n-        unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n-        // Use smaller blockfiles in test-only -fastprune mode - but avoid\n-        // the possibility of having a block not fit into the block file.\n-        if (m_opts.fast_prune) {\n-            max_blockfile_size = 0x10000; // 64kiB\n-            if (nAddSize >= max_blockfile_size) {\n-                // dynamically adjust the blockfile size to be larger than the added size\n-                max_blockfile_size = nAddSize + 1;\n-            }\n+    unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n+    // Use smaller blockfiles in test-only -fastprune mode - but avoid\n+    // the possibility of having a block not fit into the block file.\n+    if (m_opts.fast_prune) {\n+        max_blockfile_size = 0x10000; // 64kiB\n+        if (nAddSize >= max_blockfile_size) {\n+            // dynamically adjust the blockfile size to be larger than the added size\n+            max_blockfile_size = nAddSize + 1;\n         }\n-        assert(nAddSize < max_blockfile_size);\n-\n-        while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n-            // when the undo file is keeping up with the block file, we want to flush it explicitly\n-            // when it is lagging behind (more blocks arrive than are being connected), we let the\n-            // undo block write case handle it\n-            finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n-                    Assert(m_blockfile_cursors[chain_type])->undo_height);\n-\n-            // Try the next unclaimed blockfile number\n-            nFile = this->MaxBlockfileNum() + 1;\n-            // Set to increment MaxBlockfileNum() for next iteration\n-            m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n-\n-            if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n-                m_blockfile_info.resize(nFile + 1);\n-            }\n+    }\n+    assert(nAddSize < max_blockfile_size);\n+\n+    while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n+        // when the undo file is keeping up with the block file, we want to flush it explicitly\n+        // when it is lagging behind (more blocks arrive than are being connected), we let the\n+        // undo block write case handle it\n+        finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n+                         Assert(m_blockfile_cursors[chain_type])->undo_height);\n+\n+        // Try the next unclaimed blockfile number\n+        nFile = this->MaxBlockfileNum() + 1;\n+        // Set to increment MaxBlockfileNum() for next iteration\n+        m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n+\n+        if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n+            m_blockfile_info.resize(nFile + 1);\n         }\n-        pos.nFile = nFile;\n-        pos.nPos = m_blockfile_info[nFile].nSize;\n     }\n+    pos.nFile = nFile;\n+    pos.nPos = m_blockfile_info[nFile].nSize;\n \n     if (nFile != last_blockfile) {\n-        if (!fKnown) {\n-            LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n-                last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n-\n-            // Do not propagate the return code. The flush concerns a previous block\n-            // and undo file that has already been written to. If a flush fails\n-            // here, and we crash, there is no expected additional block data\n-            // inconsistency arising from the flush failure here. However, the undo\n-            // data may be inconsistent after a crash if the flush is called during\n-            // a reindex. A flush error might also leave some of the data files\n-            // untrimmed.\n-            if (!FlushBlockFile(last_blockfile, !fKnown, finalize_undo)) {\n-                LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n-                              \"Failed to flush previous block file %05i (finalize=%i, finalize_undo=%i) before opening new block file %05i\\n\",\n-                              last_blockfile, !fKnown, finalize_undo, nFile);\n-            }\n+        LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n+                 last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n+\n+        // Do not propagate the return code. The flush concerns a previous block\n+        // and undo file that has already been written to. If a flush fails\n+        // here, and we crash, there is no expected additional block data\n+        // inconsistency arising from the flush failure here. However, the undo\n+        // data may be inconsistent after a crash if the flush is called during\n+        // a reindex. A flush error might also leave some of the data files\n+        // untrimmed.\n+        if (!FlushBlockFile(last_blockfile, true, finalize_undo)) {\n+            LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n+                          \"Failed to flush previous block file %05i (finalize=1, finalize_undo=%i) before opening new block file %05i\\n\",\n+                          last_blockfile, finalize_undo, nFile);\n         }\n         // No undo data yet in the new file, so reset our undo-height tracking.\n         m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n     }\n \n     m_blockfile_info[nFile].AddBlock(nHeight, nTime);\n-    if (fKnown) {\n-        m_blockfile_info[nFile].nSize = std::max(pos.nPos + nAddSize, m_blockfile_info[nFile].nSize);\n-    } else {\n-        m_blockfile_info[nFile].nSize += nAddSize;\n-    }\n+    m_blockfile_info[nFile].nSize += nAddSize;\n \n-    if (!fKnown) {\n-        bool out_of_space;\n-        size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n-        if (out_of_space) {\n-            m_opts.notifications.fatalError(_(\"Disk space is too low!\"));\n-            return false;\n-        }\n-        if (bytes_allocated != 0 && IsPruneMode()) {\n-            m_check_for_pruning = true;\n-        }\n+    bool out_of_space;\n+    size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n+    if (out_of_space) {\n+        m_opts.notifications.fatalError(_(\"Disk space is too low!\"));\n+        return false;\n+    }\n+    if (bytes_allocated != 0 && IsPruneMode()) {\n+        m_check_for_pruning = true;\n     }\n \n     m_dirty_fileinfo.insert(nFile);\n     return true;\n }\n \n+\n+void BlockManager::AddToBlockFileInfo(const CBlock& block, unsigned int nHeight, const FlatFilePos& pos)\n+{\n+    LOCK(cs_LastBlockFile);\n+\n+    unsigned int nAddSize = ::GetSerializeSize(TX_WITH_WITNESS(block));\n+    const BlockfileType chain_type = BlockfileTypeForHeight(nHeight);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1581822649",
      "id" : 1581822649,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585eSLK5",
      "original_commit_id" : "39ad8d825e35b7326ad0ea25c37d3fe12ded64c9",
      "original_line" : 946,
      "original_position" : 154,
      "original_start_line" : 945,
      "path" : "src/node/blockstorage.cpp",
      "position" : null,
      "pull_request_review_id" : 2026623423,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581822649/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2024-04-27T12:59:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581822649",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1841944?v=4",
         "events_url" : "https://api.github.com/users/paplorinc/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paplorinc/followers",
         "following_url" : "https://api.github.com/users/paplorinc/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paplorinc/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paplorinc",
         "id" : 1841944,
         "login" : "paplorinc",
         "node_id" : "MDQ6VXNlcjE4NDE5NDQ=",
         "organizations_url" : "https://api.github.com/users/paplorinc/orgs",
         "received_events_url" : "https://api.github.com/users/paplorinc/received_events",
         "repos_url" : "https://api.github.com/users/paplorinc/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paplorinc/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paplorinc/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paplorinc"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1581824896"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581824896"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Does this reassignment still make sense?",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-04-27T12:41:59Z",
      "diff_hunk" : "@@ -863,90 +863,104 @@ bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigne\n     }\n     const int last_blockfile = m_blockfile_cursors[chain_type]->file_num;\n \n-    int nFile = fKnown ? pos.nFile : last_blockfile;\n+    int nFile = last_blockfile;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1581824896",
      "id" : 1581824896,
      "line" : 866,
      "node_id" : "PRRC_kwDOABII585eSLuA",
      "original_commit_id" : "39ad8d825e35b7326ad0ea25c37d3fe12ded64c9",
      "original_line" : 866,
      "original_position" : 14,
      "original_start_line" : null,
      "path" : "src/node/blockstorage.cpp",
      "position" : 14,
      "pull_request_review_id" : 2026623423,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581824896/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-04-27T12:59:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581824896",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1841944?v=4",
         "events_url" : "https://api.github.com/users/paplorinc/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paplorinc/followers",
         "following_url" : "https://api.github.com/users/paplorinc/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paplorinc/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paplorinc",
         "id" : 1841944,
         "login" : "paplorinc",
         "node_id" : "MDQ6VXNlcjE4NDE5NDQ=",
         "organizations_url" : "https://api.github.com/users/paplorinc/orgs",
         "received_events_url" : "https://api.github.com/users/paplorinc/received_events",
         "repos_url" : "https://api.github.com/users/paplorinc/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paplorinc/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paplorinc/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paplorinc"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1581825021"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581825021"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "should we keep the original comment here?",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-04-27T12:42:44Z",
      "diff_hunk" : "@@ -863,90 +863,104 @@ bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigne\n     }\n     const int last_blockfile = m_blockfile_cursors[chain_type]->file_num;\n \n-    int nFile = fKnown ? pos.nFile : last_blockfile;\n+    int nFile = last_blockfile;\n     if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n         m_blockfile_info.resize(nFile + 1);\n     }\n \n     bool finalize_undo = false;\n-    if (!fKnown) {\n-        unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n-        // Use smaller blockfiles in test-only -fastprune mode - but avoid\n-        // the possibility of having a block not fit into the block file.\n-        if (m_opts.fast_prune) {\n-            max_blockfile_size = 0x10000; // 64kiB\n-            if (nAddSize >= max_blockfile_size) {\n-                // dynamically adjust the blockfile size to be larger than the added size\n-                max_blockfile_size = nAddSize + 1;\n-            }\n+    unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n+    // Use smaller blockfiles in test-only -fastprune mode - but avoid\n+    // the possibility of having a block not fit into the block file.\n+    if (m_opts.fast_prune) {\n+        max_blockfile_size = 0x10000; // 64kiB\n+        if (nAddSize >= max_blockfile_size) {\n+            // dynamically adjust the blockfile size to be larger than the added size\n+            max_blockfile_size = nAddSize + 1;\n         }\n-        assert(nAddSize < max_blockfile_size);\n-\n-        while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n-            // when the undo file is keeping up with the block file, we want to flush it explicitly\n-            // when it is lagging behind (more blocks arrive than are being connected), we let the\n-            // undo block write case handle it\n-            finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n-                    Assert(m_blockfile_cursors[chain_type])->undo_height);\n-\n-            // Try the next unclaimed blockfile number\n-            nFile = this->MaxBlockfileNum() + 1;\n-            // Set to increment MaxBlockfileNum() for next iteration\n-            m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n-\n-            if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n-                m_blockfile_info.resize(nFile + 1);\n-            }\n+    }\n+    assert(nAddSize < max_blockfile_size);\n+\n+    while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n+        // when the undo file is keeping up with the block file, we want to flush it explicitly\n+        // when it is lagging behind (more blocks arrive than are being connected), we let the\n+        // undo block write case handle it\n+        finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n+                         Assert(m_blockfile_cursors[chain_type])->undo_height);\n+\n+        // Try the next unclaimed blockfile number\n+        nFile = this->MaxBlockfileNum() + 1;\n+        // Set to increment MaxBlockfileNum() for next iteration\n+        m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n+\n+        if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n+            m_blockfile_info.resize(nFile + 1);\n         }\n-        pos.nFile = nFile;\n-        pos.nPos = m_blockfile_info[nFile].nSize;\n     }\n+    pos.nFile = nFile;\n+    pos.nPos = m_blockfile_info[nFile].nSize;\n \n     if (nFile != last_blockfile) {\n-        if (!fKnown) {\n-            LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n-                last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n-\n-            // Do not propagate the return code. The flush concerns a previous block\n-            // and undo file that has already been written to. If a flush fails\n-            // here, and we crash, there is no expected additional block data\n-            // inconsistency arising from the flush failure here. However, the undo\n-            // data may be inconsistent after a crash if the flush is called during\n-            // a reindex. A flush error might also leave some of the data files\n-            // untrimmed.\n-            if (!FlushBlockFile(last_blockfile, !fKnown, finalize_undo)) {\n-                LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n-                              \"Failed to flush previous block file %05i (finalize=%i, finalize_undo=%i) before opening new block file %05i\\n\",\n-                              last_blockfile, !fKnown, finalize_undo, nFile);\n-            }\n+        LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n+                 last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n+\n+        // Do not propagate the return code. The flush concerns a previous block\n+        // and undo file that has already been written to. If a flush fails\n+        // here, and we crash, there is no expected additional block data\n+        // inconsistency arising from the flush failure here. However, the undo\n+        // data may be inconsistent after a crash if the flush is called during\n+        // a reindex. A flush error might also leave some of the data files\n+        // untrimmed.\n+        if (!FlushBlockFile(last_blockfile, true, finalize_undo)) {\n+            LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n+                          \"Failed to flush previous block file %05i (finalize=1, finalize_undo=%i) before opening new block file %05i\\n\",\n+                          last_blockfile, finalize_undo, nFile);\n         }\n         // No undo data yet in the new file, so reset our undo-height tracking.\n         m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n     }\n \n     m_blockfile_info[nFile].AddBlock(nHeight, nTime);\n-    if (fKnown) {\n-        m_blockfile_info[nFile].nSize = std::max(pos.nPos + nAddSize, m_blockfile_info[nFile].nSize);\n-    } else {\n-        m_blockfile_info[nFile].nSize += nAddSize;\n-    }\n+    m_blockfile_info[nFile].nSize += nAddSize;\n \n-    if (!fKnown) {\n-        bool out_of_space;\n-        size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n-        if (out_of_space) {\n-            m_opts.notifications.fatalError(_(\"Disk space is too low!\"));\n-            return false;\n-        }\n-        if (bytes_allocated != 0 && IsPruneMode()) {\n-            m_check_for_pruning = true;\n-        }\n+    bool out_of_space;\n+    size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n+    if (out_of_space) {\n+        m_opts.notifications.fatalError(_(\"Disk space is too low!\"));\n+        return false;\n+    }\n+    if (bytes_allocated != 0 && IsPruneMode()) {\n+        m_check_for_pruning = true;\n     }\n \n     m_dirty_fileinfo.insert(nFile);\n     return true;\n }\n \n+\n+void BlockManager::AddToBlockFileInfo(const CBlock& block, unsigned int nHeight, const FlatFilePos& pos)\n+{\n+    LOCK(cs_LastBlockFile);\n+\n+    unsigned int nAddSize = ::GetSerializeSize(TX_WITH_WITNESS(block));\n+    const BlockfileType chain_type = BlockfileTypeForHeight(nHeight);\n+    // -reindex and -reindex-chainstate delete any snapshot chainstate during init\n+    Assume(chain_type == BlockfileType::NORMAL);\n+\n+    const int last_blockfile = m_blockfile_cursors[chain_type]->file_num;\n+    const int nFile = pos.nFile;\n+\n+    if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n+        m_blockfile_info.resize(nFile + 1);\n+    }\n+    if (nFile != last_blockfile) {\n+        m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1581825021",
      "id" : 1581825021,
      "line" : 958,
      "node_id" : "PRRC_kwDOABII585eSLv9",
      "original_commit_id" : "39ad8d825e35b7326ad0ea25c37d3fe12ded64c9",
      "original_line" : 958,
      "original_position" : 165,
      "original_start_line" : null,
      "path" : "src/node/blockstorage.cpp",
      "position" : 166,
      "pull_request_review_id" : 2026623423,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581825021/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-04-27T12:59:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581825021",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1841944?v=4",
         "events_url" : "https://api.github.com/users/paplorinc/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paplorinc/followers",
         "following_url" : "https://api.github.com/users/paplorinc/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paplorinc/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paplorinc",
         "id" : 1841944,
         "login" : "paplorinc",
         "node_id" : "MDQ6VXNlcjE4NDE5NDQ=",
         "organizations_url" : "https://api.github.com/users/paplorinc/orgs",
         "received_events_url" : "https://api.github.com/users/paplorinc/received_events",
         "repos_url" : "https://api.github.com/users/paplorinc/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paplorinc/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paplorinc/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paplorinc"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1581825604"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581825604"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Does the comment on line 215 need any update after the change?",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-04-27T12:46:50Z",
      "diff_hunk" : "@@ -155,7 +155,13 @@ class BlockManager\n     /** Return false if undo file flushing fails. */\n     [[nodiscard]] bool FlushUndoFile(int block_file, bool finalize = false);\n \n-    [[nodiscard]] bool FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, uint64_t nTime, bool fKnown);\n+    /**\n+     * Helper function performing various preparations before a block can be saved to disk:\n+     * Locates the correct position for the block to be saved, which may be in the current or a new\n+     * block file depending on nAddSize. May flush the previous blockfile to disk if full, updates\n+     * blockfile info, and checks if there is enough disk space to save the block.\n+     */\n+    [[nodiscard]] bool FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, uint64_t nTime);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1581825604",
      "id" : 1581825604,
      "line" : 164,
      "node_id" : "PRRC_kwDOABII585eSL5E",
      "original_commit_id" : "39ad8d825e35b7326ad0ea25c37d3fe12ded64c9",
      "original_line" : 164,
      "original_position" : 11,
      "original_start_line" : null,
      "path" : "src/node/blockstorage.h",
      "position" : 11,
      "pull_request_review_id" : 2026623423,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581825604/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-04-27T12:59:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581825604",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1841944?v=4",
         "events_url" : "https://api.github.com/users/paplorinc/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paplorinc/followers",
         "following_url" : "https://api.github.com/users/paplorinc/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paplorinc/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paplorinc",
         "id" : 1841944,
         "login" : "paplorinc",
         "node_id" : "MDQ6VXNlcjE4NDE5NDQ=",
         "organizations_url" : "https://api.github.com/users/paplorinc/orgs",
         "received_events_url" : "https://api.github.com/users/paplorinc/received_events",
         "repos_url" : "https://api.github.com/users/paplorinc/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paplorinc/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paplorinc/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paplorinc"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1581825870"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581825870"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "we might as well use `blockPos` here\r\n```C++\r\nm_blockman.AddToBlockFileInfo(block, pindex->nHeight, blockPos);\r\n```",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-04-27T12:48:47Z",
      "diff_hunk" : "@@ -4342,10 +4342,16 @@ bool ChainstateManager::AcceptBlock(const std::shared_ptr<const CBlock>& pblock,\n     // Write block to history file\n     if (fNewBlock) *fNewBlock = true;\n     try {\n-        FlatFilePos blockPos{m_blockman.SaveBlockToDisk(block, pindex->nHeight, dbp)};\n-        if (blockPos.IsNull()) {\n-            state.Error(strprintf(\"%s: Failed to find position to write new block to disk\", __func__));\n-            return false;\n+        FlatFilePos blockPos{};\n+        if (dbp) {\n+            blockPos = *dbp;\n+            m_blockman.AddToBlockFileInfo(block, pindex->nHeight, *dbp);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1581825870",
      "id" : 1581825870,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585eSL9O",
      "original_commit_id" : "39ad8d825e35b7326ad0ea25c37d3fe12ded64c9",
      "original_line" : 4348,
      "original_position" : 11,
      "original_start_line" : null,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 2026623423,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581825870/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-04-27T12:59:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581825870",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1841944?v=4",
         "events_url" : "https://api.github.com/users/paplorinc/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paplorinc/followers",
         "following_url" : "https://api.github.com/users/paplorinc/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paplorinc/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paplorinc",
         "id" : 1841944,
         "login" : "paplorinc",
         "node_id" : "MDQ6VXNlcjE4NDE5NDQ=",
         "organizations_url" : "https://api.github.com/users/paplorinc/orgs",
         "received_events_url" : "https://api.github.com/users/paplorinc/received_events",
         "repos_url" : "https://api.github.com/users/paplorinc/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paplorinc/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paplorinc/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paplorinc"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1581826711"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581826711"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "we could move this closer to the usage",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-04-27T12:55:01Z",
      "diff_hunk" : "@@ -865,90 +863,104 @@ bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigne\n     }\n     const int last_blockfile = m_blockfile_cursors[chain_type]->file_num;\n \n-    int nFile = fKnown ? pos.nFile : last_blockfile;\n+    int nFile = last_blockfile;\n     if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n         m_blockfile_info.resize(nFile + 1);\n     }\n \n     bool finalize_undo = false;\n-    if (!fKnown) {\n-        unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n-        // Use smaller blockfiles in test-only -fastprune mode - but avoid\n-        // the possibility of having a block not fit into the block file.\n-        if (m_opts.fast_prune) {\n-            max_blockfile_size = 0x10000; // 64kiB\n-            if (nAddSize >= max_blockfile_size) {\n-                // dynamically adjust the blockfile size to be larger than the added size\n-                max_blockfile_size = nAddSize + 1;\n-            }\n+    unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n+    // Use smaller blockfiles in test-only -fastprune mode - but avoid\n+    // the possibility of having a block not fit into the block file.\n+    if (m_opts.fast_prune) {\n+        max_blockfile_size = 0x10000; // 64kiB\n+        if (nAddSize >= max_blockfile_size) {\n+            // dynamically adjust the blockfile size to be larger than the added size\n+            max_blockfile_size = nAddSize + 1;\n         }\n-        assert(nAddSize < max_blockfile_size);\n-\n-        while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n-            // when the undo file is keeping up with the block file, we want to flush it explicitly\n-            // when it is lagging behind (more blocks arrive than are being connected), we let the\n-            // undo block write case handle it\n-            finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n-                    Assert(m_blockfile_cursors[chain_type])->undo_height);\n-\n-            // Try the next unclaimed blockfile number\n-            nFile = this->MaxBlockfileNum() + 1;\n-            // Set to increment MaxBlockfileNum() for next iteration\n-            m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n-\n-            if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n-                m_blockfile_info.resize(nFile + 1);\n-            }\n+    }\n+    assert(nAddSize < max_blockfile_size);\n+\n+    while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n+        // when the undo file is keeping up with the block file, we want to flush it explicitly\n+        // when it is lagging behind (more blocks arrive than are being connected), we let the\n+        // undo block write case handle it\n+        finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n+                         Assert(m_blockfile_cursors[chain_type])->undo_height);\n+\n+        // Try the next unclaimed blockfile number\n+        nFile = this->MaxBlockfileNum() + 1;\n+        // Set to increment MaxBlockfileNum() for next iteration\n+        m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n+\n+        if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n+            m_blockfile_info.resize(nFile + 1);\n         }\n-        pos.nFile = nFile;\n-        pos.nPos = m_blockfile_info[nFile].nSize;\n     }\n+    pos.nFile = nFile;\n+    pos.nPos = m_blockfile_info[nFile].nSize;\n \n     if (nFile != last_blockfile) {\n-        if (!fKnown) {\n-            LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n-                last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n-\n-            // Do not propagate the return code. The flush concerns a previous block\n-            // and undo file that has already been written to. If a flush fails\n-            // here, and we crash, there is no expected additional block data\n-            // inconsistency arising from the flush failure here. However, the undo\n-            // data may be inconsistent after a crash if the flush is called during\n-            // a reindex. A flush error might also leave some of the data files\n-            // untrimmed.\n-            if (!FlushBlockFile(last_blockfile, !fKnown, finalize_undo)) {\n-                LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n-                              \"Failed to flush previous block file %05i (finalize=%i, finalize_undo=%i) before opening new block file %05i\\n\",\n-                              last_blockfile, !fKnown, finalize_undo, nFile);\n-            }\n+        LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n+                 last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n+\n+        // Do not propagate the return code. The flush concerns a previous block\n+        // and undo file that has already been written to. If a flush fails\n+        // here, and we crash, there is no expected additional block data\n+        // inconsistency arising from the flush failure here. However, the undo\n+        // data may be inconsistent after a crash if the flush is called during\n+        // a reindex. A flush error might also leave some of the data files\n+        // untrimmed.\n+        if (!FlushBlockFile(last_blockfile, true, finalize_undo)) {\n+            LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n+                          \"Failed to flush previous block file %05i (finalize=1, finalize_undo=%i) before opening new block file %05i\\n\",\n+                          last_blockfile, finalize_undo, nFile);\n         }\n         // No undo data yet in the new file, so reset our undo-height tracking.\n         m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n     }\n \n     m_blockfile_info[nFile].AddBlock(nHeight, nTime);\n-    if (fKnown) {\n-        m_blockfile_info[nFile].nSize = std::max(pos.nPos + nAddSize, m_blockfile_info[nFile].nSize);\n-    } else {\n-        m_blockfile_info[nFile].nSize += nAddSize;\n-    }\n+    m_blockfile_info[nFile].nSize += nAddSize;\n \n-    if (!fKnown) {\n-        bool out_of_space;\n-        size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n-        if (out_of_space) {\n-            m_opts.notifications.fatalError(_(\"Disk space is too low!\"));\n-            return false;\n-        }\n-        if (bytes_allocated != 0 && IsPruneMode()) {\n-            m_check_for_pruning = true;\n-        }\n+    bool out_of_space;\n+    size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n+    if (out_of_space) {\n+        m_opts.notifications.fatalError(_(\"Disk space is too low!\"));\n+        return false;\n+    }\n+    if (bytes_allocated != 0 && IsPruneMode()) {\n+        m_check_for_pruning = true;\n     }\n \n     m_dirty_fileinfo.insert(nFile);\n     return true;\n }\n \n+\n+void BlockManager::AddToBlockFileInfo(const CBlock& block, unsigned int nHeight, const FlatFilePos& pos)\n+{\n+    LOCK(cs_LastBlockFile);\n+\n+    unsigned int nAddSize = ::GetSerializeSize(TX_WITH_WITNESS(block));\n+    const BlockfileType chain_type = BlockfileTypeForHeight(nHeight);\n+    // -reindex and -reindex-chainstate delete any snapshot chainstate during init\n+    Assume(chain_type == BlockfileType::NORMAL);\n+\n+    const int last_blockfile = m_blockfile_cursors[chain_type]->file_num;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1581826711",
      "id" : 1581826711,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585eSMKX",
      "original_commit_id" : "20efb411bd51ff3bfcb7f4a2cc7bd0d704ad7c26",
      "original_line" : 950,
      "original_position" : 167,
      "original_start_line" : null,
      "path" : "src/node/blockstorage.cpp",
      "position" : null,
      "pull_request_review_id" : 2026623423,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581826711/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-04-27T12:59:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581826711",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1841944?v=4",
         "events_url" : "https://api.github.com/users/paplorinc/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paplorinc/followers",
         "following_url" : "https://api.github.com/users/paplorinc/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paplorinc/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paplorinc",
         "id" : 1841944,
         "login" : "paplorinc",
         "node_id" : "MDQ6VXNlcjE4NDE5NDQ=",
         "organizations_url" : "https://api.github.com/users/paplorinc/orgs",
         "received_events_url" : "https://api.github.com/users/paplorinc/received_events",
         "repos_url" : "https://api.github.com/users/paplorinc/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paplorinc/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paplorinc/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paplorinc"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1581827125"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581827125"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This is the reason why\r\n```C++\r\nif (!m_blockfile_cursors[chain_type]) {\r\n    // If a snapshot is loaded during runtime, we may not have initialized this cursor yet.\r\n    assert(chain_type == BlockfileType::ASSUMED);\r\n    const auto new_cursor = BlockfileCursor{this->MaxBlockfileNum() + 1};\r\n    m_blockfile_cursors[chain_type] = new_cursor;\r\n    LogPrint(BCLog::BLOCKSTORAGE, \"[%s] initializing blockfile cursor to %s\\n\", chain_type, new_cursor);\r\n}\r\n```\r\n is not applicable here, right?\r\n Would it make sense to also assume `m_blockfile_cursors[chain_type]`?",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-04-27T12:57:38Z",
      "diff_hunk" : "@@ -865,90 +863,104 @@ bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigne\n     }\n     const int last_blockfile = m_blockfile_cursors[chain_type]->file_num;\n \n-    int nFile = fKnown ? pos.nFile : last_blockfile;\n+    int nFile = last_blockfile;\n     if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n         m_blockfile_info.resize(nFile + 1);\n     }\n \n     bool finalize_undo = false;\n-    if (!fKnown) {\n-        unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n-        // Use smaller blockfiles in test-only -fastprune mode - but avoid\n-        // the possibility of having a block not fit into the block file.\n-        if (m_opts.fast_prune) {\n-            max_blockfile_size = 0x10000; // 64kiB\n-            if (nAddSize >= max_blockfile_size) {\n-                // dynamically adjust the blockfile size to be larger than the added size\n-                max_blockfile_size = nAddSize + 1;\n-            }\n+    unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n+    // Use smaller blockfiles in test-only -fastprune mode - but avoid\n+    // the possibility of having a block not fit into the block file.\n+    if (m_opts.fast_prune) {\n+        max_blockfile_size = 0x10000; // 64kiB\n+        if (nAddSize >= max_blockfile_size) {\n+            // dynamically adjust the blockfile size to be larger than the added size\n+            max_blockfile_size = nAddSize + 1;\n         }\n-        assert(nAddSize < max_blockfile_size);\n-\n-        while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n-            // when the undo file is keeping up with the block file, we want to flush it explicitly\n-            // when it is lagging behind (more blocks arrive than are being connected), we let the\n-            // undo block write case handle it\n-            finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n-                    Assert(m_blockfile_cursors[chain_type])->undo_height);\n-\n-            // Try the next unclaimed blockfile number\n-            nFile = this->MaxBlockfileNum() + 1;\n-            // Set to increment MaxBlockfileNum() for next iteration\n-            m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n-\n-            if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n-                m_blockfile_info.resize(nFile + 1);\n-            }\n+    }\n+    assert(nAddSize < max_blockfile_size);\n+\n+    while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n+        // when the undo file is keeping up with the block file, we want to flush it explicitly\n+        // when it is lagging behind (more blocks arrive than are being connected), we let the\n+        // undo block write case handle it\n+        finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n+                         Assert(m_blockfile_cursors[chain_type])->undo_height);\n+\n+        // Try the next unclaimed blockfile number\n+        nFile = this->MaxBlockfileNum() + 1;\n+        // Set to increment MaxBlockfileNum() for next iteration\n+        m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n+\n+        if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n+            m_blockfile_info.resize(nFile + 1);\n         }\n-        pos.nFile = nFile;\n-        pos.nPos = m_blockfile_info[nFile].nSize;\n     }\n+    pos.nFile = nFile;\n+    pos.nPos = m_blockfile_info[nFile].nSize;\n \n     if (nFile != last_blockfile) {\n-        if (!fKnown) {\n-            LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n-                last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n-\n-            // Do not propagate the return code. The flush concerns a previous block\n-            // and undo file that has already been written to. If a flush fails\n-            // here, and we crash, there is no expected additional block data\n-            // inconsistency arising from the flush failure here. However, the undo\n-            // data may be inconsistent after a crash if the flush is called during\n-            // a reindex. A flush error might also leave some of the data files\n-            // untrimmed.\n-            if (!FlushBlockFile(last_blockfile, !fKnown, finalize_undo)) {\n-                LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n-                              \"Failed to flush previous block file %05i (finalize=%i, finalize_undo=%i) before opening new block file %05i\\n\",\n-                              last_blockfile, !fKnown, finalize_undo, nFile);\n-            }\n+        LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n+                 last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n+\n+        // Do not propagate the return code. The flush concerns a previous block\n+        // and undo file that has already been written to. If a flush fails\n+        // here, and we crash, there is no expected additional block data\n+        // inconsistency arising from the flush failure here. However, the undo\n+        // data may be inconsistent after a crash if the flush is called during\n+        // a reindex. A flush error might also leave some of the data files\n+        // untrimmed.\n+        if (!FlushBlockFile(last_blockfile, true, finalize_undo)) {\n+            LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n+                          \"Failed to flush previous block file %05i (finalize=1, finalize_undo=%i) before opening new block file %05i\\n\",\n+                          last_blockfile, finalize_undo, nFile);\n         }\n         // No undo data yet in the new file, so reset our undo-height tracking.\n         m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n     }\n \n     m_blockfile_info[nFile].AddBlock(nHeight, nTime);\n-    if (fKnown) {\n-        m_blockfile_info[nFile].nSize = std::max(pos.nPos + nAddSize, m_blockfile_info[nFile].nSize);\n-    } else {\n-        m_blockfile_info[nFile].nSize += nAddSize;\n-    }\n+    m_blockfile_info[nFile].nSize += nAddSize;\n \n-    if (!fKnown) {\n-        bool out_of_space;\n-        size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n-        if (out_of_space) {\n-            m_opts.notifications.fatalError(_(\"Disk space is too low!\"));\n-            return false;\n-        }\n-        if (bytes_allocated != 0 && IsPruneMode()) {\n-            m_check_for_pruning = true;\n-        }\n+    bool out_of_space;\n+    size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n+    if (out_of_space) {\n+        m_opts.notifications.fatalError(_(\"Disk space is too low!\"));\n+        return false;\n+    }\n+    if (bytes_allocated != 0 && IsPruneMode()) {\n+        m_check_for_pruning = true;\n     }\n \n     m_dirty_fileinfo.insert(nFile);\n     return true;\n }\n \n+\n+void BlockManager::AddToBlockFileInfo(const CBlock& block, unsigned int nHeight, const FlatFilePos& pos)\n+{\n+    LOCK(cs_LastBlockFile);\n+\n+    unsigned int nAddSize = ::GetSerializeSize(TX_WITH_WITNESS(block));\n+    const BlockfileType chain_type = BlockfileTypeForHeight(nHeight);\n+    // -reindex and -reindex-chainstate delete any snapshot chainstate during init\n+    Assume(chain_type == BlockfileType::NORMAL);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1581827125",
      "id" : 1581827125,
      "line" : 948,
      "node_id" : "PRRC_kwDOABII585eSMQ1",
      "original_commit_id" : "20efb411bd51ff3bfcb7f4a2cc7bd0d704ad7c26",
      "original_line" : 948,
      "original_position" : 165,
      "original_start_line" : null,
      "path" : "src/node/blockstorage.cpp",
      "position" : 156,
      "pull_request_review_id" : 2026623423,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581827125/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-04-27T12:59:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581827125",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1841944?v=4",
         "events_url" : "https://api.github.com/users/paplorinc/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paplorinc/followers",
         "following_url" : "https://api.github.com/users/paplorinc/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paplorinc/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paplorinc",
         "id" : 1841944,
         "login" : "paplorinc",
         "node_id" : "MDQ6VXNlcjE4NDE5NDQ=",
         "organizations_url" : "https://api.github.com/users/paplorinc/orgs",
         "received_events_url" : "https://api.github.com/users/paplorinc/received_events",
         "repos_url" : "https://api.github.com/users/paplorinc/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paplorinc/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paplorinc/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paplorinc"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1583635647"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583635647"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done.",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-04-29T19:35:07Z",
      "diff_hunk" : "@@ -863,90 +863,104 @@ bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigne\n     }\n     const int last_blockfile = m_blockfile_cursors[chain_type]->file_num;\n \n-    int nFile = fKnown ? pos.nFile : last_blockfile;\n+    int nFile = last_blockfile;\n     if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n         m_blockfile_info.resize(nFile + 1);\n     }\n \n     bool finalize_undo = false;\n-    if (!fKnown) {\n-        unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n-        // Use smaller blockfiles in test-only -fastprune mode - but avoid\n-        // the possibility of having a block not fit into the block file.\n-        if (m_opts.fast_prune) {\n-            max_blockfile_size = 0x10000; // 64kiB\n-            if (nAddSize >= max_blockfile_size) {\n-                // dynamically adjust the blockfile size to be larger than the added size\n-                max_blockfile_size = nAddSize + 1;\n-            }\n+    unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n+    // Use smaller blockfiles in test-only -fastprune mode - but avoid\n+    // the possibility of having a block not fit into the block file.\n+    if (m_opts.fast_prune) {\n+        max_blockfile_size = 0x10000; // 64kiB\n+        if (nAddSize >= max_blockfile_size) {\n+            // dynamically adjust the blockfile size to be larger than the added size\n+            max_blockfile_size = nAddSize + 1;\n         }\n-        assert(nAddSize < max_blockfile_size);\n-\n-        while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n-            // when the undo file is keeping up with the block file, we want to flush it explicitly\n-            // when it is lagging behind (more blocks arrive than are being connected), we let the\n-            // undo block write case handle it\n-            finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n-                    Assert(m_blockfile_cursors[chain_type])->undo_height);\n-\n-            // Try the next unclaimed blockfile number\n-            nFile = this->MaxBlockfileNum() + 1;\n-            // Set to increment MaxBlockfileNum() for next iteration\n-            m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n-\n-            if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n-                m_blockfile_info.resize(nFile + 1);\n-            }\n+    }\n+    assert(nAddSize < max_blockfile_size);\n+\n+    while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n+        // when the undo file is keeping up with the block file, we want to flush it explicitly\n+        // when it is lagging behind (more blocks arrive than are being connected), we let the\n+        // undo block write case handle it\n+        finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n+                         Assert(m_blockfile_cursors[chain_type])->undo_height);\n+\n+        // Try the next unclaimed blockfile number\n+        nFile = this->MaxBlockfileNum() + 1;\n+        // Set to increment MaxBlockfileNum() for next iteration\n+        m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n+\n+        if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n+            m_blockfile_info.resize(nFile + 1);\n         }\n-        pos.nFile = nFile;\n-        pos.nPos = m_blockfile_info[nFile].nSize;\n     }\n+    pos.nFile = nFile;\n+    pos.nPos = m_blockfile_info[nFile].nSize;\n \n     if (nFile != last_blockfile) {\n-        if (!fKnown) {\n-            LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n-                last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n-\n-            // Do not propagate the return code. The flush concerns a previous block\n-            // and undo file that has already been written to. If a flush fails\n-            // here, and we crash, there is no expected additional block data\n-            // inconsistency arising from the flush failure here. However, the undo\n-            // data may be inconsistent after a crash if the flush is called during\n-            // a reindex. A flush error might also leave some of the data files\n-            // untrimmed.\n-            if (!FlushBlockFile(last_blockfile, !fKnown, finalize_undo)) {\n-                LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n-                              \"Failed to flush previous block file %05i (finalize=%i, finalize_undo=%i) before opening new block file %05i\\n\",\n-                              last_blockfile, !fKnown, finalize_undo, nFile);\n-            }\n+        LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n+                 last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n+\n+        // Do not propagate the return code. The flush concerns a previous block\n+        // and undo file that has already been written to. If a flush fails\n+        // here, and we crash, there is no expected additional block data\n+        // inconsistency arising from the flush failure here. However, the undo\n+        // data may be inconsistent after a crash if the flush is called during\n+        // a reindex. A flush error might also leave some of the data files\n+        // untrimmed.\n+        if (!FlushBlockFile(last_blockfile, true, finalize_undo)) {\n+            LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n+                          \"Failed to flush previous block file %05i (finalize=1, finalize_undo=%i) before opening new block file %05i\\n\",\n+                          last_blockfile, finalize_undo, nFile);\n         }\n         // No undo data yet in the new file, so reset our undo-height tracking.\n         m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n     }\n \n     m_blockfile_info[nFile].AddBlock(nHeight, nTime);\n-    if (fKnown) {\n-        m_blockfile_info[nFile].nSize = std::max(pos.nPos + nAddSize, m_blockfile_info[nFile].nSize);\n-    } else {\n-        m_blockfile_info[nFile].nSize += nAddSize;\n-    }\n+    m_blockfile_info[nFile].nSize += nAddSize;\n \n-    if (!fKnown) {\n-        bool out_of_space;\n-        size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n-        if (out_of_space) {\n-            m_opts.notifications.fatalError(_(\"Disk space is too low!\"));\n-            return false;\n-        }\n-        if (bytes_allocated != 0 && IsPruneMode()) {\n-            m_check_for_pruning = true;\n-        }\n+    bool out_of_space;\n+    size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n+    if (out_of_space) {\n+        m_opts.notifications.fatalError(_(\"Disk space is too low!\"));\n+        return false;\n+    }\n+    if (bytes_allocated != 0 && IsPruneMode()) {\n+        m_check_for_pruning = true;\n     }\n \n     m_dirty_fileinfo.insert(nFile);\n     return true;\n }\n \n+\n+void BlockManager::AddToBlockFileInfo(const CBlock& block, unsigned int nHeight, const FlatFilePos& pos)\n+{\n+    LOCK(cs_LastBlockFile);\n+\n+    unsigned int nAddSize = ::GetSerializeSize(TX_WITH_WITNESS(block));\n+    const BlockfileType chain_type = BlockfileTypeForHeight(nHeight);\n+    // -reindex and -reindex-chainstate delete any snapshot chainstate during init\n+    Assume(chain_type == BlockfileType::NORMAL);\n+\n+    const int last_blockfile = m_blockfile_cursors[chain_type]->file_num;\n+    const int nFile = pos.nFile;\n+\n+    if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n+        m_blockfile_info.resize(nFile + 1);\n+    }\n+    if (nFile != last_blockfile) {\n+        m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1583635647",
      "id" : 1583635647,
      "in_reply_to_id" : 1581825021,
      "line" : 958,
      "node_id" : "PRRC_kwDOABII585eZFy_",
      "original_commit_id" : "39ad8d825e35b7326ad0ea25c37d3fe12ded64c9",
      "original_line" : 958,
      "original_position" : 165,
      "original_start_line" : null,
      "path" : "src/node/blockstorage.cpp",
      "position" : 166,
      "pull_request_review_id" : 2029424460,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583635647/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-04-29T19:35:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583635647",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1583636377"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583636377"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Yes, I think so. We later may increase nFile and then compare it to `last_blockfile` (line  `if (nFile != last_blockfile)`)",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-04-29T19:35:51Z",
      "diff_hunk" : "@@ -863,90 +863,104 @@ bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigne\n     }\n     const int last_blockfile = m_blockfile_cursors[chain_type]->file_num;\n \n-    int nFile = fKnown ? pos.nFile : last_blockfile;\n+    int nFile = last_blockfile;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1583636377",
      "id" : 1583636377,
      "in_reply_to_id" : 1581824896,
      "line" : 866,
      "node_id" : "PRRC_kwDOABII585eZF-Z",
      "original_commit_id" : "39ad8d825e35b7326ad0ea25c37d3fe12ded64c9",
      "original_line" : 866,
      "original_position" : 14,
      "original_start_line" : null,
      "path" : "src/node/blockstorage.cpp",
      "position" : 14,
      "pull_request_review_id" : 2029425696,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583636377/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-04-29T19:35:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583636377",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1583637879"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583637879"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I took both from FindBlockPos, snake case is correct, but for historical reasons camel case is still used in lots of places.\r\nBut since this is arguably new code I renamed `nAddSize` to `added_size` ",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-04-29T19:36:48Z",
      "diff_hunk" : "@@ -863,90 +863,104 @@ bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigne\n     }\n     const int last_blockfile = m_blockfile_cursors[chain_type]->file_num;\n \n-    int nFile = fKnown ? pos.nFile : last_blockfile;\n+    int nFile = last_blockfile;\n     if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n         m_blockfile_info.resize(nFile + 1);\n     }\n \n     bool finalize_undo = false;\n-    if (!fKnown) {\n-        unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n-        // Use smaller blockfiles in test-only -fastprune mode - but avoid\n-        // the possibility of having a block not fit into the block file.\n-        if (m_opts.fast_prune) {\n-            max_blockfile_size = 0x10000; // 64kiB\n-            if (nAddSize >= max_blockfile_size) {\n-                // dynamically adjust the blockfile size to be larger than the added size\n-                max_blockfile_size = nAddSize + 1;\n-            }\n+    unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n+    // Use smaller blockfiles in test-only -fastprune mode - but avoid\n+    // the possibility of having a block not fit into the block file.\n+    if (m_opts.fast_prune) {\n+        max_blockfile_size = 0x10000; // 64kiB\n+        if (nAddSize >= max_blockfile_size) {\n+            // dynamically adjust the blockfile size to be larger than the added size\n+            max_blockfile_size = nAddSize + 1;\n         }\n-        assert(nAddSize < max_blockfile_size);\n-\n-        while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n-            // when the undo file is keeping up with the block file, we want to flush it explicitly\n-            // when it is lagging behind (more blocks arrive than are being connected), we let the\n-            // undo block write case handle it\n-            finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n-                    Assert(m_blockfile_cursors[chain_type])->undo_height);\n-\n-            // Try the next unclaimed blockfile number\n-            nFile = this->MaxBlockfileNum() + 1;\n-            // Set to increment MaxBlockfileNum() for next iteration\n-            m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n-\n-            if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n-                m_blockfile_info.resize(nFile + 1);\n-            }\n+    }\n+    assert(nAddSize < max_blockfile_size);\n+\n+    while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n+        // when the undo file is keeping up with the block file, we want to flush it explicitly\n+        // when it is lagging behind (more blocks arrive than are being connected), we let the\n+        // undo block write case handle it\n+        finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n+                         Assert(m_blockfile_cursors[chain_type])->undo_height);\n+\n+        // Try the next unclaimed blockfile number\n+        nFile = this->MaxBlockfileNum() + 1;\n+        // Set to increment MaxBlockfileNum() for next iteration\n+        m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n+\n+        if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n+            m_blockfile_info.resize(nFile + 1);\n         }\n-        pos.nFile = nFile;\n-        pos.nPos = m_blockfile_info[nFile].nSize;\n     }\n+    pos.nFile = nFile;\n+    pos.nPos = m_blockfile_info[nFile].nSize;\n \n     if (nFile != last_blockfile) {\n-        if (!fKnown) {\n-            LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n-                last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n-\n-            // Do not propagate the return code. The flush concerns a previous block\n-            // and undo file that has already been written to. If a flush fails\n-            // here, and we crash, there is no expected additional block data\n-            // inconsistency arising from the flush failure here. However, the undo\n-            // data may be inconsistent after a crash if the flush is called during\n-            // a reindex. A flush error might also leave some of the data files\n-            // untrimmed.\n-            if (!FlushBlockFile(last_blockfile, !fKnown, finalize_undo)) {\n-                LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n-                              \"Failed to flush previous block file %05i (finalize=%i, finalize_undo=%i) before opening new block file %05i\\n\",\n-                              last_blockfile, !fKnown, finalize_undo, nFile);\n-            }\n+        LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n+                 last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n+\n+        // Do not propagate the return code. The flush concerns a previous block\n+        // and undo file that has already been written to. If a flush fails\n+        // here, and we crash, there is no expected additional block data\n+        // inconsistency arising from the flush failure here. However, the undo\n+        // data may be inconsistent after a crash if the flush is called during\n+        // a reindex. A flush error might also leave some of the data files\n+        // untrimmed.\n+        if (!FlushBlockFile(last_blockfile, true, finalize_undo)) {\n+            LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n+                          \"Failed to flush previous block file %05i (finalize=1, finalize_undo=%i) before opening new block file %05i\\n\",\n+                          last_blockfile, finalize_undo, nFile);\n         }\n         // No undo data yet in the new file, so reset our undo-height tracking.\n         m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n     }\n \n     m_blockfile_info[nFile].AddBlock(nHeight, nTime);\n-    if (fKnown) {\n-        m_blockfile_info[nFile].nSize = std::max(pos.nPos + nAddSize, m_blockfile_info[nFile].nSize);\n-    } else {\n-        m_blockfile_info[nFile].nSize += nAddSize;\n-    }\n+    m_blockfile_info[nFile].nSize += nAddSize;\n \n-    if (!fKnown) {\n-        bool out_of_space;\n-        size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n-        if (out_of_space) {\n-            m_opts.notifications.fatalError(_(\"Disk space is too low!\"));\n-            return false;\n-        }\n-        if (bytes_allocated != 0 && IsPruneMode()) {\n-            m_check_for_pruning = true;\n-        }\n+    bool out_of_space;\n+    size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n+    if (out_of_space) {\n+        m_opts.notifications.fatalError(_(\"Disk space is too low!\"));\n+        return false;\n+    }\n+    if (bytes_allocated != 0 && IsPruneMode()) {\n+        m_check_for_pruning = true;\n     }\n \n     m_dirty_fileinfo.insert(nFile);\n     return true;\n }\n \n+\n+void BlockManager::AddToBlockFileInfo(const CBlock& block, unsigned int nHeight, const FlatFilePos& pos)\n+{\n+    LOCK(cs_LastBlockFile);\n+\n+    unsigned int nAddSize = ::GetSerializeSize(TX_WITH_WITNESS(block));\n+    const BlockfileType chain_type = BlockfileTypeForHeight(nHeight);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1583637879",
      "id" : 1583637879,
      "in_reply_to_id" : 1581822649,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585eZGV3",
      "original_commit_id" : "39ad8d825e35b7326ad0ea25c37d3fe12ded64c9",
      "original_line" : 946,
      "original_position" : 154,
      "original_start_line" : 945,
      "path" : "src/node/blockstorage.cpp",
      "position" : null,
      "pull_request_review_id" : 2029428884,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583637879/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2024-04-29T19:36:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583637879",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1583638770"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583638770"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "You mean the comment \"The ASSUMED state is initialized, when necessary, in FindBlockPos().\"?\r\nThat behavior is unchanged, it's part of the normal usage of `FindBlockPos` and wasn't happening during reindex anyway (see first commit), so I don't think it needs to be updated.",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-04-29T19:37:51Z",
      "diff_hunk" : "@@ -155,7 +155,13 @@ class BlockManager\n     /** Return false if undo file flushing fails. */\n     [[nodiscard]] bool FlushUndoFile(int block_file, bool finalize = false);\n \n-    [[nodiscard]] bool FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, uint64_t nTime, bool fKnown);\n+    /**\n+     * Helper function performing various preparations before a block can be saved to disk:\n+     * Locates the correct position for the block to be saved, which may be in the current or a new\n+     * block file depending on nAddSize. May flush the previous blockfile to disk if full, updates\n+     * blockfile info, and checks if there is enough disk space to save the block.\n+     */\n+    [[nodiscard]] bool FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, uint64_t nTime);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1583638770",
      "id" : 1583638770,
      "in_reply_to_id" : 1581825604,
      "line" : 164,
      "node_id" : "PRRC_kwDOABII585eZGjy",
      "original_commit_id" : "39ad8d825e35b7326ad0ea25c37d3fe12ded64c9",
      "original_line" : 164,
      "original_position" : 11,
      "original_start_line" : null,
      "path" : "src/node/blockstorage.h",
      "position" : 11,
      "pull_request_review_id" : 2029430446,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583638770/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-04-29T19:37:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583638770",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1583638866"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583638866"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-04-29T19:37:59Z",
      "diff_hunk" : "@@ -4342,10 +4342,16 @@ bool ChainstateManager::AcceptBlock(const std::shared_ptr<const CBlock>& pblock,\n     // Write block to history file\n     if (fNewBlock) *fNewBlock = true;\n     try {\n-        FlatFilePos blockPos{m_blockman.SaveBlockToDisk(block, pindex->nHeight, dbp)};\n-        if (blockPos.IsNull()) {\n-            state.Error(strprintf(\"%s: Failed to find position to write new block to disk\", __func__));\n-            return false;\n+        FlatFilePos blockPos{};\n+        if (dbp) {\n+            blockPos = *dbp;\n+            m_blockman.AddToBlockFileInfo(block, pindex->nHeight, *dbp);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1583638866",
      "id" : 1583638866,
      "in_reply_to_id" : 1581825870,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585eZGlS",
      "original_commit_id" : "39ad8d825e35b7326ad0ea25c37d3fe12ded64c9",
      "original_line" : 4348,
      "original_position" : 11,
      "original_start_line" : null,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 2029430636,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583638866/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-04-29T19:37:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583638866",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1583639069"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583639069"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-04-29T19:38:14Z",
      "diff_hunk" : "@@ -865,90 +863,104 @@ bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigne\n     }\n     const int last_blockfile = m_blockfile_cursors[chain_type]->file_num;\n \n-    int nFile = fKnown ? pos.nFile : last_blockfile;\n+    int nFile = last_blockfile;\n     if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n         m_blockfile_info.resize(nFile + 1);\n     }\n \n     bool finalize_undo = false;\n-    if (!fKnown) {\n-        unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n-        // Use smaller blockfiles in test-only -fastprune mode - but avoid\n-        // the possibility of having a block not fit into the block file.\n-        if (m_opts.fast_prune) {\n-            max_blockfile_size = 0x10000; // 64kiB\n-            if (nAddSize >= max_blockfile_size) {\n-                // dynamically adjust the blockfile size to be larger than the added size\n-                max_blockfile_size = nAddSize + 1;\n-            }\n+    unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n+    // Use smaller blockfiles in test-only -fastprune mode - but avoid\n+    // the possibility of having a block not fit into the block file.\n+    if (m_opts.fast_prune) {\n+        max_blockfile_size = 0x10000; // 64kiB\n+        if (nAddSize >= max_blockfile_size) {\n+            // dynamically adjust the blockfile size to be larger than the added size\n+            max_blockfile_size = nAddSize + 1;\n         }\n-        assert(nAddSize < max_blockfile_size);\n-\n-        while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n-            // when the undo file is keeping up with the block file, we want to flush it explicitly\n-            // when it is lagging behind (more blocks arrive than are being connected), we let the\n-            // undo block write case handle it\n-            finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n-                    Assert(m_blockfile_cursors[chain_type])->undo_height);\n-\n-            // Try the next unclaimed blockfile number\n-            nFile = this->MaxBlockfileNum() + 1;\n-            // Set to increment MaxBlockfileNum() for next iteration\n-            m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n-\n-            if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n-                m_blockfile_info.resize(nFile + 1);\n-            }\n+    }\n+    assert(nAddSize < max_blockfile_size);\n+\n+    while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n+        // when the undo file is keeping up with the block file, we want to flush it explicitly\n+        // when it is lagging behind (more blocks arrive than are being connected), we let the\n+        // undo block write case handle it\n+        finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n+                         Assert(m_blockfile_cursors[chain_type])->undo_height);\n+\n+        // Try the next unclaimed blockfile number\n+        nFile = this->MaxBlockfileNum() + 1;\n+        // Set to increment MaxBlockfileNum() for next iteration\n+        m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n+\n+        if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n+            m_blockfile_info.resize(nFile + 1);\n         }\n-        pos.nFile = nFile;\n-        pos.nPos = m_blockfile_info[nFile].nSize;\n     }\n+    pos.nFile = nFile;\n+    pos.nPos = m_blockfile_info[nFile].nSize;\n \n     if (nFile != last_blockfile) {\n-        if (!fKnown) {\n-            LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n-                last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n-\n-            // Do not propagate the return code. The flush concerns a previous block\n-            // and undo file that has already been written to. If a flush fails\n-            // here, and we crash, there is no expected additional block data\n-            // inconsistency arising from the flush failure here. However, the undo\n-            // data may be inconsistent after a crash if the flush is called during\n-            // a reindex. A flush error might also leave some of the data files\n-            // untrimmed.\n-            if (!FlushBlockFile(last_blockfile, !fKnown, finalize_undo)) {\n-                LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n-                              \"Failed to flush previous block file %05i (finalize=%i, finalize_undo=%i) before opening new block file %05i\\n\",\n-                              last_blockfile, !fKnown, finalize_undo, nFile);\n-            }\n+        LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n+                 last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n+\n+        // Do not propagate the return code. The flush concerns a previous block\n+        // and undo file that has already been written to. If a flush fails\n+        // here, and we crash, there is no expected additional block data\n+        // inconsistency arising from the flush failure here. However, the undo\n+        // data may be inconsistent after a crash if the flush is called during\n+        // a reindex. A flush error might also leave some of the data files\n+        // untrimmed.\n+        if (!FlushBlockFile(last_blockfile, true, finalize_undo)) {\n+            LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n+                          \"Failed to flush previous block file %05i (finalize=1, finalize_undo=%i) before opening new block file %05i\\n\",\n+                          last_blockfile, finalize_undo, nFile);\n         }\n         // No undo data yet in the new file, so reset our undo-height tracking.\n         m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n     }\n \n     m_blockfile_info[nFile].AddBlock(nHeight, nTime);\n-    if (fKnown) {\n-        m_blockfile_info[nFile].nSize = std::max(pos.nPos + nAddSize, m_blockfile_info[nFile].nSize);\n-    } else {\n-        m_blockfile_info[nFile].nSize += nAddSize;\n-    }\n+    m_blockfile_info[nFile].nSize += nAddSize;\n \n-    if (!fKnown) {\n-        bool out_of_space;\n-        size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n-        if (out_of_space) {\n-            m_opts.notifications.fatalError(_(\"Disk space is too low!\"));\n-            return false;\n-        }\n-        if (bytes_allocated != 0 && IsPruneMode()) {\n-            m_check_for_pruning = true;\n-        }\n+    bool out_of_space;\n+    size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n+    if (out_of_space) {\n+        m_opts.notifications.fatalError(_(\"Disk space is too low!\"));\n+        return false;\n+    }\n+    if (bytes_allocated != 0 && IsPruneMode()) {\n+        m_check_for_pruning = true;\n     }\n \n     m_dirty_fileinfo.insert(nFile);\n     return true;\n }\n \n+\n+void BlockManager::AddToBlockFileInfo(const CBlock& block, unsigned int nHeight, const FlatFilePos& pos)\n+{\n+    LOCK(cs_LastBlockFile);\n+\n+    unsigned int nAddSize = ::GetSerializeSize(TX_WITH_WITNESS(block));\n+    const BlockfileType chain_type = BlockfileTypeForHeight(nHeight);\n+    // -reindex and -reindex-chainstate delete any snapshot chainstate during init\n+    Assume(chain_type == BlockfileType::NORMAL);\n+\n+    const int last_blockfile = m_blockfile_cursors[chain_type]->file_num;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1583639069",
      "id" : 1583639069,
      "in_reply_to_id" : 1581826711,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585eZGod",
      "original_commit_id" : "20efb411bd51ff3bfcb7f4a2cc7bd0d704ad7c26",
      "original_line" : 950,
      "original_position" : 167,
      "original_start_line" : null,
      "path" : "src/node/blockstorage.cpp",
      "position" : null,
      "pull_request_review_id" : 2029430977,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583639069/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-04-29T19:38:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583639069",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1583640596"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583640596"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : " Yes. I added this in the first commit, so that the second commit doesn't change behavior.\r\n \r\nAs for your second q: Well, it'd be undefined behavior if `m_blockfile_cursors` didn't haven an element for `BlockfileType::NORMAL`. On the other hand, `m_blockfile_cursors[...]` is used all over the place, I'm not sure if we want to have an assert for each occurence. Other opinions?",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-04-29T19:39:46Z",
      "diff_hunk" : "@@ -865,90 +863,104 @@ bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigne\n     }\n     const int last_blockfile = m_blockfile_cursors[chain_type]->file_num;\n \n-    int nFile = fKnown ? pos.nFile : last_blockfile;\n+    int nFile = last_blockfile;\n     if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n         m_blockfile_info.resize(nFile + 1);\n     }\n \n     bool finalize_undo = false;\n-    if (!fKnown) {\n-        unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n-        // Use smaller blockfiles in test-only -fastprune mode - but avoid\n-        // the possibility of having a block not fit into the block file.\n-        if (m_opts.fast_prune) {\n-            max_blockfile_size = 0x10000; // 64kiB\n-            if (nAddSize >= max_blockfile_size) {\n-                // dynamically adjust the blockfile size to be larger than the added size\n-                max_blockfile_size = nAddSize + 1;\n-            }\n+    unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n+    // Use smaller blockfiles in test-only -fastprune mode - but avoid\n+    // the possibility of having a block not fit into the block file.\n+    if (m_opts.fast_prune) {\n+        max_blockfile_size = 0x10000; // 64kiB\n+        if (nAddSize >= max_blockfile_size) {\n+            // dynamically adjust the blockfile size to be larger than the added size\n+            max_blockfile_size = nAddSize + 1;\n         }\n-        assert(nAddSize < max_blockfile_size);\n-\n-        while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n-            // when the undo file is keeping up with the block file, we want to flush it explicitly\n-            // when it is lagging behind (more blocks arrive than are being connected), we let the\n-            // undo block write case handle it\n-            finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n-                    Assert(m_blockfile_cursors[chain_type])->undo_height);\n-\n-            // Try the next unclaimed blockfile number\n-            nFile = this->MaxBlockfileNum() + 1;\n-            // Set to increment MaxBlockfileNum() for next iteration\n-            m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n-\n-            if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n-                m_blockfile_info.resize(nFile + 1);\n-            }\n+    }\n+    assert(nAddSize < max_blockfile_size);\n+\n+    while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n+        // when the undo file is keeping up with the block file, we want to flush it explicitly\n+        // when it is lagging behind (more blocks arrive than are being connected), we let the\n+        // undo block write case handle it\n+        finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n+                         Assert(m_blockfile_cursors[chain_type])->undo_height);\n+\n+        // Try the next unclaimed blockfile number\n+        nFile = this->MaxBlockfileNum() + 1;\n+        // Set to increment MaxBlockfileNum() for next iteration\n+        m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n+\n+        if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n+            m_blockfile_info.resize(nFile + 1);\n         }\n-        pos.nFile = nFile;\n-        pos.nPos = m_blockfile_info[nFile].nSize;\n     }\n+    pos.nFile = nFile;\n+    pos.nPos = m_blockfile_info[nFile].nSize;\n \n     if (nFile != last_blockfile) {\n-        if (!fKnown) {\n-            LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n-                last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n-\n-            // Do not propagate the return code. The flush concerns a previous block\n-            // and undo file that has already been written to. If a flush fails\n-            // here, and we crash, there is no expected additional block data\n-            // inconsistency arising from the flush failure here. However, the undo\n-            // data may be inconsistent after a crash if the flush is called during\n-            // a reindex. A flush error might also leave some of the data files\n-            // untrimmed.\n-            if (!FlushBlockFile(last_blockfile, !fKnown, finalize_undo)) {\n-                LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n-                              \"Failed to flush previous block file %05i (finalize=%i, finalize_undo=%i) before opening new block file %05i\\n\",\n-                              last_blockfile, !fKnown, finalize_undo, nFile);\n-            }\n+        LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n+                 last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n+\n+        // Do not propagate the return code. The flush concerns a previous block\n+        // and undo file that has already been written to. If a flush fails\n+        // here, and we crash, there is no expected additional block data\n+        // inconsistency arising from the flush failure here. However, the undo\n+        // data may be inconsistent after a crash if the flush is called during\n+        // a reindex. A flush error might also leave some of the data files\n+        // untrimmed.\n+        if (!FlushBlockFile(last_blockfile, true, finalize_undo)) {\n+            LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n+                          \"Failed to flush previous block file %05i (finalize=1, finalize_undo=%i) before opening new block file %05i\\n\",\n+                          last_blockfile, finalize_undo, nFile);\n         }\n         // No undo data yet in the new file, so reset our undo-height tracking.\n         m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n     }\n \n     m_blockfile_info[nFile].AddBlock(nHeight, nTime);\n-    if (fKnown) {\n-        m_blockfile_info[nFile].nSize = std::max(pos.nPos + nAddSize, m_blockfile_info[nFile].nSize);\n-    } else {\n-        m_blockfile_info[nFile].nSize += nAddSize;\n-    }\n+    m_blockfile_info[nFile].nSize += nAddSize;\n \n-    if (!fKnown) {\n-        bool out_of_space;\n-        size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n-        if (out_of_space) {\n-            m_opts.notifications.fatalError(_(\"Disk space is too low!\"));\n-            return false;\n-        }\n-        if (bytes_allocated != 0 && IsPruneMode()) {\n-            m_check_for_pruning = true;\n-        }\n+    bool out_of_space;\n+    size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n+    if (out_of_space) {\n+        m_opts.notifications.fatalError(_(\"Disk space is too low!\"));\n+        return false;\n+    }\n+    if (bytes_allocated != 0 && IsPruneMode()) {\n+        m_check_for_pruning = true;\n     }\n \n     m_dirty_fileinfo.insert(nFile);\n     return true;\n }\n \n+\n+void BlockManager::AddToBlockFileInfo(const CBlock& block, unsigned int nHeight, const FlatFilePos& pos)\n+{\n+    LOCK(cs_LastBlockFile);\n+\n+    unsigned int nAddSize = ::GetSerializeSize(TX_WITH_WITNESS(block));\n+    const BlockfileType chain_type = BlockfileTypeForHeight(nHeight);\n+    // -reindex and -reindex-chainstate delete any snapshot chainstate during init\n+    Assume(chain_type == BlockfileType::NORMAL);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1583640596",
      "id" : 1583640596,
      "in_reply_to_id" : 1581827125,
      "line" : 948,
      "node_id" : "PRRC_kwDOABII585eZHAU",
      "original_commit_id" : "20efb411bd51ff3bfcb7f4a2cc7bd0d704ad7c26",
      "original_line" : 948,
      "original_position" : 165,
      "original_start_line" : null,
      "path" : "src/node/blockstorage.cpp",
      "position" : 156,
      "pull_request_review_id" : 2029433363,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583640596/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-04-29T19:39:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583640596",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1583642139"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583642139"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I updated some comments. The entire test setup probably makes a bit less sense after the refactor, users unfamiliar\r\nwith the history might ask themselves why someone could think that `Reindex` / `AddToBlockFileInfo` would change the block files so that we'd require a test making sure it doesn't.",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-04-29T19:40:39Z",
      "diff_hunk" : "@@ -189,7 +189,7 @@ BOOST_AUTO_TEST_CASE(blockmanager_flush_block_file)\n     // to block 2 location.\n     CBlockFileInfo* block_data = blockman.GetBlockFileInfo(0);\n     BOOST_CHECK_EQUAL(block_data->nBlocks, 2);\n-    BOOST_CHECK(blockman.SaveBlockToDisk(block3, /*nHeight=*/3, /*dbp=*/&pos2) == pos2);\n+    blockman.AddToBlockFileInfo(block3, /*nHeight=*/3, /*pos=*/pos2);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1583642139",
      "id" : 1583642139,
      "in_reply_to_id" : 1581784723,
      "line" : 189,
      "node_id" : "PRRC_kwDOABII585eZHYb",
      "original_commit_id" : "39ad8d825e35b7326ad0ea25c37d3fe12ded64c9",
      "original_line" : 189,
      "original_position" : 43,
      "original_start_line" : null,
      "path" : "src/test/blockmanager_tests.cpp",
      "position" : 56,
      "pull_request_review_id" : 2029436933,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583642139/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-04-29T19:41:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583642139",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "[39ad8d8 ](https://github.com/bitcoin/bitcoin/commit/39ad8d825e35b7326ad0ea25c37d3fe12ded64c9)to [194e84a](https://github.com/bitcoin/bitcoin/commit/194e84accced947ef63c6db389bc62a2b58cffa3): Addressed review feedback by @paplorinc, thanks!",
      "created_at" : "2024-04-29T19:42:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#issuecomment-2083526332",
      "id" : 2083526332,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/29975",
      "node_id" : "IC_kwDOABII5858MBa8",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2083526332/reactions"
      },
      "updated_at" : "2024-04-29T19:42:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2083526332",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1591338361"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1591338361"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"validation, blockstorage: Separate code paths for reindex and saving new blocks\" (a17eacab1f8790afc5f89ba2ee3e34da4c9369e1)\r\n\r\nIt looks like previously there would have been an error here if `dbp->IsNull()` was true, and now there will not be an error. This is probably a good change, since AcceptBlock should not be looking at block positions, just passing them on.",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-05-06T17:32:15Z",
      "diff_hunk" : "@@ -4342,10 +4342,16 @@ bool ChainstateManager::AcceptBlock(const std::shared_ptr<const CBlock>& pblock,\n     // Write block to history file\n     if (fNewBlock) *fNewBlock = true;\n     try {\n-        FlatFilePos blockPos{m_blockman.SaveBlockToDisk(block, pindex->nHeight, dbp)};\n-        if (blockPos.IsNull()) {\n-            state.Error(strprintf(\"%s: Failed to find position to write new block to disk\", __func__));\n-            return false;\n+        FlatFilePos blockPos{};\n+        if (dbp) {\n+            blockPos = *dbp;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1591338361",
      "id" : 1591338361,
      "line" : 4347,
      "node_id" : "PRRC_kwDOABII585e2eV5",
      "original_commit_id" : "a17eacab1f8790afc5f89ba2ee3e34da4c9369e1",
      "original_line" : 4347,
      "original_position" : 10,
      "original_start_line" : null,
      "path" : "src/validation.cpp",
      "position" : 10,
      "pull_request_review_id" : 2041313158,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1591338361/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-07T18:02:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1591338361",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1591461829"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1591461829"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"blockstorage: Add Assume for fKnown / snapshot chainstate\" (d6b0bb6dd0d26f3e10386d1afbafd8d52a12b2c5)\r\n\r\nI don't think changing this `if` statement is good.\r\n\r\nAdding the Assume call above seems good, since it provides information about the context this code is called in and could potentially catch bugs if the code is run in an unanticipated state.\r\n\r\nBut It's less clear what benefit there is to adding the  `!fKnown &&` condition to this if statement. It just makes the logic more complicated without providing any extra explanation. And if outside code were changed such that `fKnown` was false while the cursor was null, undefined behavior would now happen on line 866 below.\r\n\r\nI think this commit would be a clearer if it avoided changing any existing logic and instead just added two Assume statements:\r\n\r\n```c++\r\n// Check that chain type is NORMAL if fKnown is true, because fKnown is only\r\n// true during reindexing, and reindexing deletes snapshot chainstates, so\r\n// chain_type will not be SNAPSHOT. Also check that cursor exists, because\r\n// the normal cursor should never be null.\r\nif (fKnown) {\r\n    Assume(chain_type == BlockfileType::NORMAL);\r\n    Assume(m_blockfile_cursors[chain_type]);    \r\n}\r\n```",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-05-06T19:28:06Z",
      "diff_hunk" : "@@ -853,8 +853,10 @@ bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigne\n     LOCK(cs_LastBlockFile);\n \n     const BlockfileType chain_type = BlockfileTypeForHeight(nHeight);\n+    // -reindex and -reindex-chainstate delete any snapshot chainstate during init\n+    if (fKnown) Assume(chain_type == BlockfileType::NORMAL);\n \n-    if (!m_blockfile_cursors[chain_type]) {\n+    if (!fKnown && !m_blockfile_cursors[chain_type]) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1591461829",
      "id" : 1591461829,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585e28fF",
      "original_commit_id" : "d6b0bb6dd0d26f3e10386d1afbafd8d52a12b2c5",
      "original_line" : 859,
      "original_position" : 8,
      "original_start_line" : null,
      "path" : "src/node/blockstorage.cpp",
      "position" : null,
      "pull_request_review_id" : 2041313158,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1591461829/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-07T18:02:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1591461829",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1591463595"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1591463595"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"blockstorage: Add Assume for fKnown / snapshot chainstate\" (d6b0bb6dd0d26f3e10386d1afbafd8d52a12b2c5)\r\n\r\nThis comment seems really disconnected from the statement below it, because the statement does not mention reindexing or the snapshot chainstate at all. I left a suggestion to improve the comment below (https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1591461829).",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-05-06T19:29:58Z",
      "diff_hunk" : "@@ -853,8 +853,10 @@ bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigne\n     LOCK(cs_LastBlockFile);\n \n     const BlockfileType chain_type = BlockfileTypeForHeight(nHeight);\n+    // -reindex and -reindex-chainstate delete any snapshot chainstate during init",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1591463595",
      "id" : 1591463595,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585e286r",
      "original_commit_id" : "d6b0bb6dd0d26f3e10386d1afbafd8d52a12b2c5",
      "original_line" : 856,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/node/blockstorage.cpp",
      "position" : null,
      "pull_request_review_id" : 2041313158,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1591463595/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-07T18:03:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1591463595",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1591477885"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1591477885"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"blockstorage: split up FindBlockPos function\" (a2ae0a33c7c30678721d7e7d37d8e6170b013383)\r\n\r\nWould be helpful to clarify with meaning of `true` with `/*fFinalize*/=true`",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-05-06T19:45:17Z",
      "diff_hunk" : "@@ -865,90 +863,105 @@ bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigne\n     }\n     const int last_blockfile = m_blockfile_cursors[chain_type]->file_num;\n \n-    int nFile = fKnown ? pos.nFile : last_blockfile;\n+    int nFile = last_blockfile;\n     if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n         m_blockfile_info.resize(nFile + 1);\n     }\n \n     bool finalize_undo = false;\n-    if (!fKnown) {\n-        unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n-        // Use smaller blockfiles in test-only -fastprune mode - but avoid\n-        // the possibility of having a block not fit into the block file.\n-        if (m_opts.fast_prune) {\n-            max_blockfile_size = 0x10000; // 64kiB\n-            if (nAddSize >= max_blockfile_size) {\n-                // dynamically adjust the blockfile size to be larger than the added size\n-                max_blockfile_size = nAddSize + 1;\n-            }\n+    unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n+    // Use smaller blockfiles in test-only -fastprune mode - but avoid\n+    // the possibility of having a block not fit into the block file.\n+    if (m_opts.fast_prune) {\n+        max_blockfile_size = 0x10000; // 64kiB\n+        if (nAddSize >= max_blockfile_size) {\n+            // dynamically adjust the blockfile size to be larger than the added size\n+            max_blockfile_size = nAddSize + 1;\n         }\n-        assert(nAddSize < max_blockfile_size);\n-\n-        while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n-            // when the undo file is keeping up with the block file, we want to flush it explicitly\n-            // when it is lagging behind (more blocks arrive than are being connected), we let the\n-            // undo block write case handle it\n-            finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n-                    Assert(m_blockfile_cursors[chain_type])->undo_height);\n-\n-            // Try the next unclaimed blockfile number\n-            nFile = this->MaxBlockfileNum() + 1;\n-            // Set to increment MaxBlockfileNum() for next iteration\n-            m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n-\n-            if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n-                m_blockfile_info.resize(nFile + 1);\n-            }\n+    }\n+    assert(nAddSize < max_blockfile_size);\n+\n+    while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n+        // when the undo file is keeping up with the block file, we want to flush it explicitly\n+        // when it is lagging behind (more blocks arrive than are being connected), we let the\n+        // undo block write case handle it\n+        finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n+                         Assert(m_blockfile_cursors[chain_type])->undo_height);\n+\n+        // Try the next unclaimed blockfile number\n+        nFile = this->MaxBlockfileNum() + 1;\n+        // Set to increment MaxBlockfileNum() for next iteration\n+        m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n+\n+        if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n+            m_blockfile_info.resize(nFile + 1);\n         }\n-        pos.nFile = nFile;\n-        pos.nPos = m_blockfile_info[nFile].nSize;\n     }\n+    pos.nFile = nFile;\n+    pos.nPos = m_blockfile_info[nFile].nSize;\n \n     if (nFile != last_blockfile) {\n-        if (!fKnown) {\n-            LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n-                last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n-\n-            // Do not propagate the return code. The flush concerns a previous block\n-            // and undo file that has already been written to. If a flush fails\n-            // here, and we crash, there is no expected additional block data\n-            // inconsistency arising from the flush failure here. However, the undo\n-            // data may be inconsistent after a crash if the flush is called during\n-            // a reindex. A flush error might also leave some of the data files\n-            // untrimmed.\n-            if (!FlushBlockFile(last_blockfile, !fKnown, finalize_undo)) {\n-                LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n-                              \"Failed to flush previous block file %05i (finalize=%i, finalize_undo=%i) before opening new block file %05i\\n\",\n-                              last_blockfile, !fKnown, finalize_undo, nFile);\n-            }\n+        LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n+                 last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n+\n+        // Do not propagate the return code. The flush concerns a previous block\n+        // and undo file that has already been written to. If a flush fails\n+        // here, and we crash, there is no expected additional block data\n+        // inconsistency arising from the flush failure here. However, the undo\n+        // data may be inconsistent after a crash if the flush is called during\n+        // a reindex. A flush error might also leave some of the data files\n+        // untrimmed.\n+        if (!FlushBlockFile(last_blockfile, true, finalize_undo)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1591477885",
      "id" : 1591477885,
      "line" : 914,
      "node_id" : "PRRC_kwDOABII585e3AZ9",
      "original_commit_id" : "a2ae0a33c7c30678721d7e7d37d8e6170b013383",
      "original_line" : 914,
      "original_position" : 116,
      "original_start_line" : null,
      "path" : "src/node/blockstorage.cpp",
      "position" : 107,
      "pull_request_review_id" : 2041313158,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1591477885/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-07T18:02:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1591477885",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1591485559"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1591485559"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"blockstorage: split up FindBlockPos function\" (a2ae0a33c7c30678721d7e7d37d8e6170b013383)\r\n\r\nre: https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1583640596\r\n\r\n> I'm not sure if we want to have an assert for each occurence. Other opinions?\r\n\r\nNot sure about other places, but it seems worth asserting here to avoid undefined behavior on line 955 and to be able to document assumptions this code is making. I suggested a comment in the previous commit that explains both assumptions and could be reused here (https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1591461829).",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-05-06T19:53:29Z",
      "diff_hunk" : "@@ -865,90 +863,104 @@ bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigne\n     }\n     const int last_blockfile = m_blockfile_cursors[chain_type]->file_num;\n \n-    int nFile = fKnown ? pos.nFile : last_blockfile;\n+    int nFile = last_blockfile;\n     if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n         m_blockfile_info.resize(nFile + 1);\n     }\n \n     bool finalize_undo = false;\n-    if (!fKnown) {\n-        unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n-        // Use smaller blockfiles in test-only -fastprune mode - but avoid\n-        // the possibility of having a block not fit into the block file.\n-        if (m_opts.fast_prune) {\n-            max_blockfile_size = 0x10000; // 64kiB\n-            if (nAddSize >= max_blockfile_size) {\n-                // dynamically adjust the blockfile size to be larger than the added size\n-                max_blockfile_size = nAddSize + 1;\n-            }\n+    unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n+    // Use smaller blockfiles in test-only -fastprune mode - but avoid\n+    // the possibility of having a block not fit into the block file.\n+    if (m_opts.fast_prune) {\n+        max_blockfile_size = 0x10000; // 64kiB\n+        if (nAddSize >= max_blockfile_size) {\n+            // dynamically adjust the blockfile size to be larger than the added size\n+            max_blockfile_size = nAddSize + 1;\n         }\n-        assert(nAddSize < max_blockfile_size);\n-\n-        while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n-            // when the undo file is keeping up with the block file, we want to flush it explicitly\n-            // when it is lagging behind (more blocks arrive than are being connected), we let the\n-            // undo block write case handle it\n-            finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n-                    Assert(m_blockfile_cursors[chain_type])->undo_height);\n-\n-            // Try the next unclaimed blockfile number\n-            nFile = this->MaxBlockfileNum() + 1;\n-            // Set to increment MaxBlockfileNum() for next iteration\n-            m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n-\n-            if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n-                m_blockfile_info.resize(nFile + 1);\n-            }\n+    }\n+    assert(nAddSize < max_blockfile_size);\n+\n+    while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n+        // when the undo file is keeping up with the block file, we want to flush it explicitly\n+        // when it is lagging behind (more blocks arrive than are being connected), we let the\n+        // undo block write case handle it\n+        finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n+                         Assert(m_blockfile_cursors[chain_type])->undo_height);\n+\n+        // Try the next unclaimed blockfile number\n+        nFile = this->MaxBlockfileNum() + 1;\n+        // Set to increment MaxBlockfileNum() for next iteration\n+        m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n+\n+        if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n+            m_blockfile_info.resize(nFile + 1);\n         }\n-        pos.nFile = nFile;\n-        pos.nPos = m_blockfile_info[nFile].nSize;\n     }\n+    pos.nFile = nFile;\n+    pos.nPos = m_blockfile_info[nFile].nSize;\n \n     if (nFile != last_blockfile) {\n-        if (!fKnown) {\n-            LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n-                last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n-\n-            // Do not propagate the return code. The flush concerns a previous block\n-            // and undo file that has already been written to. If a flush fails\n-            // here, and we crash, there is no expected additional block data\n-            // inconsistency arising from the flush failure here. However, the undo\n-            // data may be inconsistent after a crash if the flush is called during\n-            // a reindex. A flush error might also leave some of the data files\n-            // untrimmed.\n-            if (!FlushBlockFile(last_blockfile, !fKnown, finalize_undo)) {\n-                LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n-                              \"Failed to flush previous block file %05i (finalize=%i, finalize_undo=%i) before opening new block file %05i\\n\",\n-                              last_blockfile, !fKnown, finalize_undo, nFile);\n-            }\n+        LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n+                 last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n+\n+        // Do not propagate the return code. The flush concerns a previous block\n+        // and undo file that has already been written to. If a flush fails\n+        // here, and we crash, there is no expected additional block data\n+        // inconsistency arising from the flush failure here. However, the undo\n+        // data may be inconsistent after a crash if the flush is called during\n+        // a reindex. A flush error might also leave some of the data files\n+        // untrimmed.\n+        if (!FlushBlockFile(last_blockfile, true, finalize_undo)) {\n+            LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n+                          \"Failed to flush previous block file %05i (finalize=1, finalize_undo=%i) before opening new block file %05i\\n\",\n+                          last_blockfile, finalize_undo, nFile);\n         }\n         // No undo data yet in the new file, so reset our undo-height tracking.\n         m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n     }\n \n     m_blockfile_info[nFile].AddBlock(nHeight, nTime);\n-    if (fKnown) {\n-        m_blockfile_info[nFile].nSize = std::max(pos.nPos + nAddSize, m_blockfile_info[nFile].nSize);\n-    } else {\n-        m_blockfile_info[nFile].nSize += nAddSize;\n-    }\n+    m_blockfile_info[nFile].nSize += nAddSize;\n \n-    if (!fKnown) {\n-        bool out_of_space;\n-        size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n-        if (out_of_space) {\n-            m_opts.notifications.fatalError(_(\"Disk space is too low!\"));\n-            return false;\n-        }\n-        if (bytes_allocated != 0 && IsPruneMode()) {\n-            m_check_for_pruning = true;\n-        }\n+    bool out_of_space;\n+    size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n+    if (out_of_space) {\n+        m_opts.notifications.fatalError(_(\"Disk space is too low!\"));\n+        return false;\n+    }\n+    if (bytes_allocated != 0 && IsPruneMode()) {\n+        m_check_for_pruning = true;\n     }\n \n     m_dirty_fileinfo.insert(nFile);\n     return true;\n }\n \n+\n+void BlockManager::AddToBlockFileInfo(const CBlock& block, unsigned int nHeight, const FlatFilePos& pos)\n+{\n+    LOCK(cs_LastBlockFile);\n+\n+    unsigned int nAddSize = ::GetSerializeSize(TX_WITH_WITNESS(block));\n+    const BlockfileType chain_type = BlockfileTypeForHeight(nHeight);\n+    // -reindex and -reindex-chainstate delete any snapshot chainstate during init\n+    Assume(chain_type == BlockfileType::NORMAL);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1591485559",
      "id" : 1591485559,
      "in_reply_to_id" : 1581827125,
      "line" : 948,
      "node_id" : "PRRC_kwDOABII585e3CR3",
      "original_commit_id" : "20efb411bd51ff3bfcb7f4a2cc7bd0d704ad7c26",
      "original_line" : 948,
      "original_position" : 165,
      "original_start_line" : null,
      "path" : "src/node/blockstorage.cpp",
      "position" : 156,
      "pull_request_review_id" : 2041313158,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1591485559/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-07T18:04:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1591485559",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1592707738"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1592707738"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"blockstorage: split up FindBlockPos function\" (a2ae0a33c7c30678721d7e7d37d8e6170b013383)\r\n\r\nTwo suggestions, maybe for later commits or a followup PR:\r\n\r\nNow that `pos` is an output parameter instead of being an in/out parameter, it would be better to just drop it entirely and make `FindBlockPos` return `FlatFilePos` like `SaveBlockToDisk`, instead of returning `bool`. This would make it more obvious what the function inputs and outputs are, and also make sure the output value is consistently initialized.\r\n\r\nAlso, I think it would make sense to rename `FindBlockPos` to `FindNextBlockPos` to be clear this function is only called to find the position where the next block should be written, and no longer has anything to do with positions of existing blocks.",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-05-07T15:45:11Z",
      "diff_hunk" : "@@ -848,15 +848,13 @@ fs::path BlockManager::GetBlockPosFilename(const FlatFilePos& pos) const\n     return BlockFileSeq().FileName(pos);\n }\n \n-bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, uint64_t nTime, bool fKnown)\n+bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, uint64_t nTime)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1592707738",
      "id" : 1592707738,
      "line" : 851,
      "node_id" : "PRRC_kwDOABII585e7sqa",
      "original_commit_id" : "a2ae0a33c7c30678721d7e7d37d8e6170b013383",
      "original_line" : 851,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/node/blockstorage.cpp",
      "position" : 5,
      "pull_request_review_id" : 2041313158,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1592707738/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-07T18:02:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1592707738",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1592739006"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1592739006"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"blockstorage: split up FindBlockPos function\" (a2ae0a33c7c30678721d7e7d37d8e6170b013383)\r\n\r\nI think this description is technically accurate, but I got confused by it and thought it was wrong because \"the 8 byte serialization header\" sounds like something that is part of `CBlock` serialization, when actually it is referring to separator fields written by `WriteBlockToDisk` *before* the serialized `CBlock`.\r\n\r\nWould suggest changing comment to \"pos: the position of the serialized CBlock on disk. This is the position returned by WriteBlockToDisk pointing at the CBlock, not the separator fields before it.\"\r\n\r\nI would also suggesting adding two more comments to this commit to make it clear what it happening at this stage of the PR.\r\n\r\nIn `WriteBlockToDisk` documentation, \"// The pos argument passed to this function is modified by this call. Before this call, it should point to an unused file location where separator fields will be written followed by the serialized CBlock data. After this call, it will point to the beginning of the serialized CBlock data, after the separator fields\"\r\n\r\nIn `FindBlockPos` documentation, \"// The nAddSize argument passed to this function should include not just the size of the serialized CBlock, but the also size of separator fields which are written before it by WriteBlockToDisk (BLOCK_SERIALIZATION_HEADER_SIZE).",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-05-07T16:08:30Z",
      "diff_hunk" : "@@ -155,7 +155,15 @@ class BlockManager\n     /** Return false if undo file flushing fails. */\n     [[nodiscard]] bool FlushUndoFile(int block_file, bool finalize = false);\n \n-    [[nodiscard]] bool FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, uint64_t nTime, bool fKnown);\n+    [[nodiscard]] bool FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, uint64_t nTime);\n+    /** Update blockfile info while processing a block during reindex. The block must be available on disk.\n+     *\n+     * @param[in]  block        the block being processed\n+     * @param[in]  nHeight      the height of the block\n+     * @param[in]  pos          the position of the block on disk. This must point *after* the\n+     *                          8 byte serialization header, at the beginning of the actual block data.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1592739006",
      "id" : 1592739006,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585e70S-",
      "original_commit_id" : "a2ae0a33c7c30678721d7e7d37d8e6170b013383",
      "original_line" : 164,
      "original_position" : 11,
      "original_start_line" : 163,
      "path" : "src/node/blockstorage.h",
      "position" : null,
      "pull_request_review_id" : 2041313158,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1592739006/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2024-05-07T18:04:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1592739006",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1592824870"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1592824870"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"blockstorage: split up FindBlockPos function\" (a2ae0a33c7c30678721d7e7d37d8e6170b013383)\r\n\r\nI think this comment is a little confusing, because it isn't obvious that `position_known` can only be true during reindexing. Could potentially clarify this, though not necessary since this code will be deleted in the next commit.",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-05-07T17:16:04Z",
      "diff_hunk" : "@@ -1139,17 +1152,17 @@ FlatFilePos BlockManager::SaveBlockToDisk(const CBlock& block, int nHeight, cons\n     const auto position_known {dbp != nullptr};\n     if (position_known) {\n         blockPos = *dbp;\n+        // During reindex, no blocks need to be written, only the blockfile info database needs to be rebuilt",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1592824870",
      "id" : 1592824870,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585e8JQm",
      "original_commit_id" : "a2ae0a33c7c30678721d7e7d37d8e6170b013383",
      "original_line" : 1155,
      "original_position" : 189,
      "original_start_line" : null,
      "path" : "src/node/blockstorage.cpp",
      "position" : null,
      "pull_request_review_id" : 2041313158,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1592824870/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-07T18:02:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1592824870",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1592833124"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1592833124"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"blockstorage: split up FindBlockPos function\" (a2ae0a33c7c30678721d7e7d37d8e6170b013383)\r\n\r\nI think `SaveBlockPos` would be a less ambiguous name for this function than `AddToBlockFileInfo`. It would also be consistent with `FindBlockPos` and I think make the `AcceptBlock` code more obvious (like `if (dbp) SaveBlockPos(...) else SaveBlockToDisk(...)`)\r\n\r\nEDIT: `SaveBlockInfo` or `UpdateBlockInfo` might be a better name than `SaveBlockPos` since block position isn't really what is updated here, other information is just updated based on the position.",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-05-07T17:23:50Z",
      "diff_hunk" : "@@ -155,7 +155,15 @@ class BlockManager\n     /** Return false if undo file flushing fails. */\n     [[nodiscard]] bool FlushUndoFile(int block_file, bool finalize = false);\n \n-    [[nodiscard]] bool FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, uint64_t nTime, bool fKnown);\n+    [[nodiscard]] bool FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, uint64_t nTime);\n+    /** Update blockfile info while processing a block during reindex. The block must be available on disk.\n+     *\n+     * @param[in]  block        the block being processed\n+     * @param[in]  nHeight      the height of the block\n+     * @param[in]  pos          the position of the block on disk. This must point *after* the\n+     *                          8 byte serialization header, at the beginning of the actual block data.\n+     */\n+    void AddToBlockFileInfo(const CBlock& block, unsigned int nHeight, const FlatFilePos& pos);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1592833124",
      "id" : 1592833124,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585e8LRk",
      "original_commit_id" : "a2ae0a33c7c30678721d7e7d37d8e6170b013383",
      "original_line" : 166,
      "original_position" : 13,
      "original_start_line" : null,
      "path" : "src/node/blockstorage.h",
      "position" : null,
      "pull_request_review_id" : 2041313158,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1592833124/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-08T14:01:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1592833124",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1592841734"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1592841734"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"blockstorage: split up FindBlockPos function\" (a2ae0a33c7c30678721d7e7d37d8e6170b013383)\r\n\r\nInstead of adding this method and comment in the private section of the class this commit, and then moving it to the public section of the class in the next commit, and I think it would be better just to add it to the public section initially to make the PR easier to review, since it already makes sense as part of public interface.",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-05-07T17:31:42Z",
      "diff_hunk" : "@@ -155,7 +155,15 @@ class BlockManager\n     /** Return false if undo file flushing fails. */\n     [[nodiscard]] bool FlushUndoFile(int block_file, bool finalize = false);\n \n-    [[nodiscard]] bool FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, uint64_t nTime, bool fKnown);\n+    [[nodiscard]] bool FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, uint64_t nTime);\n+    /** Update blockfile info while processing a block during reindex. The block must be available on disk.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1592841734",
      "id" : 1592841734,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585e8NYG",
      "original_commit_id" : "a2ae0a33c7c30678721d7e7d37d8e6170b013383",
      "original_line" : 159,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "src/node/blockstorage.h",
      "position" : null,
      "pull_request_review_id" : 2041313158,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1592841734/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-07T18:02:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1592841734",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1592848815"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1592848815"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"validation, blockstorage: Separate code paths for reindex and saving new blocks\" (a17eacab1f8790afc5f89ba2ee3e34da4c9369e1)\r\n\r\ns/do/to/",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-05-07T17:38:28Z",
      "diff_hunk" : "@@ -181,22 +180,19 @@ BOOST_AUTO_TEST_CASE(blockmanager_flush_block_file)\n         BOOST_CHECK_EQUAL(read_block.nVersion, 2);\n     }\n \n-    // When FlatFilePos* dbp is given, SaveBlockToDisk() will not write or\n-    // overwrite anything to the flat file block storage. It will, however,\n-    // update the blockfile metadata. This is to facilitate reindexing\n-    // when the user has the blocks on disk but the metadata is being rebuilt.\n+    // During reindex, the flat file block storage will not be written do.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1592848815",
      "id" : 1592848815,
      "line" : 183,
      "node_id" : "PRRC_kwDOABII585e8PGv",
      "original_commit_id" : "a17eacab1f8790afc5f89ba2ee3e34da4c9369e1",
      "original_line" : 183,
      "original_position" : 49,
      "original_start_line" : null,
      "path" : "src/test/blockmanager_tests.cpp",
      "position" : 49,
      "pull_request_review_id" : 2041313158,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1592848815/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-07T18:02:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1592848815",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "With 194e84accced947ef63c6db389bc62a2b58cffa3, since reindexing regenerates undo data, and undo data shouldn't be added until all existing blocks are, it seems like there is no reason for the `AddToBlockFileInfo` function to worry about resetting the `BlockfileCursor::undo_file` field or even accessing the block storage cursors at all. So I think the following simplification would make sense:\r\n\r\n```diff\r\n--- a/src/node/blockstorage.cpp\r\n+++ b/src/node/blockstorage.cpp\r\n@@ -941,22 +941,11 @@ bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigne\r\n void BlockManager::AddToBlockFileInfo(const CBlock& block, unsigned int nHeight, const FlatFilePos& pos)\r\n {\r\n     LOCK(cs_LastBlockFile);\r\n-\r\n     const unsigned int added_size = ::GetSerializeSize(TX_WITH_WITNESS(block));\r\n-    const BlockfileType chain_type = BlockfileTypeForHeight(nHeight);\r\n-    // -reindex and -reindex-chainstate delete any snapshot chainstate during init\r\n-    Assume(chain_type == BlockfileType::NORMAL);\r\n-\r\n     const int nFile = pos.nFile;\r\n     if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\r\n         m_blockfile_info.resize(nFile + 1);\r\n     }\r\n-\r\n-    const int last_blockfile = m_blockfile_cursors[chain_type]->file_num;\r\n-    if (nFile != last_blockfile) {\r\n-        // No undo data yet in the new file, so reset our undo-height tracking.\r\n-        m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\r\n-    }\r\n     m_blockfile_info[nFile].AddBlock(nHeight, block.GetBlockTime());\r\n     m_blockfile_info[nFile].nSize = std::max(pos.nPos + added_size, m_blockfile_info[nFile].nSize);\r\n     m_dirty_fileinfo.insert(nFile);\r\n```\r\n",
      "created_at" : "2024-05-07T18:45:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#issuecomment-2099086073",
      "id" : 2099086073,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/29975",
      "node_id" : "IC_kwDOABII5859HYL5",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2099086073/reactions"
      },
      "updated_at" : "2024-05-07T18:45:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2099086073",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1594531344"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1594531344"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "The reason I added it was to make the following commit, in which every line of code that can be reached with `fKnown==true` is moved into its own function, a mechanical refactor that is easier to review: Lines dependent on `fKnown` move, lines dependent on `!fKnown` stay, independent lines go into both. \r\nWithout it, there would be the question why this block of code does not make it into `AddToBlockFileInfo`.\r\nSo the reason was to move the potential behavior change (which would only be an actual one if our assumptions about reindexing were incorrect) into its own commit.\r\n\r\nHappy to add the suggestion though.",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-05-08T19:28:30Z",
      "diff_hunk" : "@@ -853,8 +853,10 @@ bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigne\n     LOCK(cs_LastBlockFile);\n \n     const BlockfileType chain_type = BlockfileTypeForHeight(nHeight);\n+    // -reindex and -reindex-chainstate delete any snapshot chainstate during init\n+    if (fKnown) Assume(chain_type == BlockfileType::NORMAL);\n \n-    if (!m_blockfile_cursors[chain_type]) {\n+    if (!fKnown && !m_blockfile_cursors[chain_type]) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1594531344",
      "id" : 1594531344,
      "in_reply_to_id" : 1591461829,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585fCp4Q",
      "original_commit_id" : "d6b0bb6dd0d26f3e10386d1afbafd8d52a12b2c5",
      "original_line" : 859,
      "original_position" : 8,
      "original_start_line" : null,
      "path" : "src/node/blockstorage.cpp",
      "position" : null,
      "pull_request_review_id" : 2046482540,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1594531344/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-08T19:29:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1594531344",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1594573095"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1594573095"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Yes, in the reindex case; In this case the passed dbp isn't changed (it's now a const arg to `AddToBlockFileInfo`). If a dpb was passed to AcceptBlock for which `dbp->IsNull()`, the error message (\"Failed to find position to write new block to disk\") would have been very confusing anyway, because we don't write a block to disk during reindex anyway.",
      "commit_id" : "194e84accced947ef63c6db389bc62a2b58cffa3",
      "created_at" : "2024-05-08T20:11:40Z",
      "diff_hunk" : "@@ -4342,10 +4342,16 @@ bool ChainstateManager::AcceptBlock(const std::shared_ptr<const CBlock>& pblock,\n     // Write block to history file\n     if (fNewBlock) *fNewBlock = true;\n     try {\n-        FlatFilePos blockPos{m_blockman.SaveBlockToDisk(block, pindex->nHeight, dbp)};\n-        if (blockPos.IsNull()) {\n-            state.Error(strprintf(\"%s: Failed to find position to write new block to disk\", __func__));\n-            return false;\n+        FlatFilePos blockPos{};\n+        if (dbp) {\n+            blockPos = *dbp;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1594573095",
      "id" : 1594573095,
      "in_reply_to_id" : 1591338361,
      "line" : 4347,
      "node_id" : "PRRC_kwDOABII585fC0En",
      "original_commit_id" : "a17eacab1f8790afc5f89ba2ee3e34da4c9369e1",
      "original_line" : 4347,
      "original_position" : 10,
      "original_start_line" : null,
      "path" : "src/validation.cpp",
      "position" : 10,
      "pull_request_review_id" : 2046551869,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1594573095/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-08T20:11:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1594573095",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1594766043"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1594766043"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I extended the comment according to the suggestion above.",
      "commit_id" : "6a22eede2083616ecc7558a16d8189c22b46403d",
      "created_at" : "2024-05-08T22:23:10Z",
      "diff_hunk" : "@@ -853,8 +853,10 @@ bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigne\n     LOCK(cs_LastBlockFile);\n \n     const BlockfileType chain_type = BlockfileTypeForHeight(nHeight);\n+    // -reindex and -reindex-chainstate delete any snapshot chainstate during init",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1594766043",
      "id" : 1594766043,
      "in_reply_to_id" : 1591463595,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585fDjLb",
      "original_commit_id" : "d6b0bb6dd0d26f3e10386d1afbafd8d52a12b2c5",
      "original_line" : 856,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/node/blockstorage.cpp",
      "position" : null,
      "pull_request_review_id" : 2046861072,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1594766043/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-08T22:25:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1594766043",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1594766203"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1594766203"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done",
      "commit_id" : "6a22eede2083616ecc7558a16d8189c22b46403d",
      "created_at" : "2024-05-08T22:23:26Z",
      "diff_hunk" : "@@ -865,90 +863,105 @@ bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigne\n     }\n     const int last_blockfile = m_blockfile_cursors[chain_type]->file_num;\n \n-    int nFile = fKnown ? pos.nFile : last_blockfile;\n+    int nFile = last_blockfile;\n     if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n         m_blockfile_info.resize(nFile + 1);\n     }\n \n     bool finalize_undo = false;\n-    if (!fKnown) {\n-        unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n-        // Use smaller blockfiles in test-only -fastprune mode - but avoid\n-        // the possibility of having a block not fit into the block file.\n-        if (m_opts.fast_prune) {\n-            max_blockfile_size = 0x10000; // 64kiB\n-            if (nAddSize >= max_blockfile_size) {\n-                // dynamically adjust the blockfile size to be larger than the added size\n-                max_blockfile_size = nAddSize + 1;\n-            }\n+    unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n+    // Use smaller blockfiles in test-only -fastprune mode - but avoid\n+    // the possibility of having a block not fit into the block file.\n+    if (m_opts.fast_prune) {\n+        max_blockfile_size = 0x10000; // 64kiB\n+        if (nAddSize >= max_blockfile_size) {\n+            // dynamically adjust the blockfile size to be larger than the added size\n+            max_blockfile_size = nAddSize + 1;\n         }\n-        assert(nAddSize < max_blockfile_size);\n-\n-        while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n-            // when the undo file is keeping up with the block file, we want to flush it explicitly\n-            // when it is lagging behind (more blocks arrive than are being connected), we let the\n-            // undo block write case handle it\n-            finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n-                    Assert(m_blockfile_cursors[chain_type])->undo_height);\n-\n-            // Try the next unclaimed blockfile number\n-            nFile = this->MaxBlockfileNum() + 1;\n-            // Set to increment MaxBlockfileNum() for next iteration\n-            m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n-\n-            if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n-                m_blockfile_info.resize(nFile + 1);\n-            }\n+    }\n+    assert(nAddSize < max_blockfile_size);\n+\n+    while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n+        // when the undo file is keeping up with the block file, we want to flush it explicitly\n+        // when it is lagging behind (more blocks arrive than are being connected), we let the\n+        // undo block write case handle it\n+        finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n+                         Assert(m_blockfile_cursors[chain_type])->undo_height);\n+\n+        // Try the next unclaimed blockfile number\n+        nFile = this->MaxBlockfileNum() + 1;\n+        // Set to increment MaxBlockfileNum() for next iteration\n+        m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n+\n+        if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n+            m_blockfile_info.resize(nFile + 1);\n         }\n-        pos.nFile = nFile;\n-        pos.nPos = m_blockfile_info[nFile].nSize;\n     }\n+    pos.nFile = nFile;\n+    pos.nPos = m_blockfile_info[nFile].nSize;\n \n     if (nFile != last_blockfile) {\n-        if (!fKnown) {\n-            LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n-                last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n-\n-            // Do not propagate the return code. The flush concerns a previous block\n-            // and undo file that has already been written to. If a flush fails\n-            // here, and we crash, there is no expected additional block data\n-            // inconsistency arising from the flush failure here. However, the undo\n-            // data may be inconsistent after a crash if the flush is called during\n-            // a reindex. A flush error might also leave some of the data files\n-            // untrimmed.\n-            if (!FlushBlockFile(last_blockfile, !fKnown, finalize_undo)) {\n-                LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n-                              \"Failed to flush previous block file %05i (finalize=%i, finalize_undo=%i) before opening new block file %05i\\n\",\n-                              last_blockfile, !fKnown, finalize_undo, nFile);\n-            }\n+        LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n+                 last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n+\n+        // Do not propagate the return code. The flush concerns a previous block\n+        // and undo file that has already been written to. If a flush fails\n+        // here, and we crash, there is no expected additional block data\n+        // inconsistency arising from the flush failure here. However, the undo\n+        // data may be inconsistent after a crash if the flush is called during\n+        // a reindex. A flush error might also leave some of the data files\n+        // untrimmed.\n+        if (!FlushBlockFile(last_blockfile, true, finalize_undo)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1594766203",
      "id" : 1594766203,
      "in_reply_to_id" : 1591477885,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585fDjN7",
      "original_commit_id" : "a2ae0a33c7c30678721d7e7d37d8e6170b013383",
      "original_line" : 914,
      "original_position" : 116,
      "original_start_line" : null,
      "path" : "src/node/blockstorage.cpp",
      "position" : null,
      "pull_request_review_id" : 2046861307,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1594766203/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-08T22:23:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1594766203",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1594767022"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1594767022"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Added the assumptions.",
      "commit_id" : "6a22eede2083616ecc7558a16d8189c22b46403d",
      "created_at" : "2024-05-08T22:24:47Z",
      "diff_hunk" : "@@ -865,90 +863,104 @@ bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigne\n     }\n     const int last_blockfile = m_blockfile_cursors[chain_type]->file_num;\n \n-    int nFile = fKnown ? pos.nFile : last_blockfile;\n+    int nFile = last_blockfile;\n     if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n         m_blockfile_info.resize(nFile + 1);\n     }\n \n     bool finalize_undo = false;\n-    if (!fKnown) {\n-        unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n-        // Use smaller blockfiles in test-only -fastprune mode - but avoid\n-        // the possibility of having a block not fit into the block file.\n-        if (m_opts.fast_prune) {\n-            max_blockfile_size = 0x10000; // 64kiB\n-            if (nAddSize >= max_blockfile_size) {\n-                // dynamically adjust the blockfile size to be larger than the added size\n-                max_blockfile_size = nAddSize + 1;\n-            }\n+    unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n+    // Use smaller blockfiles in test-only -fastprune mode - but avoid\n+    // the possibility of having a block not fit into the block file.\n+    if (m_opts.fast_prune) {\n+        max_blockfile_size = 0x10000; // 64kiB\n+        if (nAddSize >= max_blockfile_size) {\n+            // dynamically adjust the blockfile size to be larger than the added size\n+            max_blockfile_size = nAddSize + 1;\n         }\n-        assert(nAddSize < max_blockfile_size);\n-\n-        while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n-            // when the undo file is keeping up with the block file, we want to flush it explicitly\n-            // when it is lagging behind (more blocks arrive than are being connected), we let the\n-            // undo block write case handle it\n-            finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n-                    Assert(m_blockfile_cursors[chain_type])->undo_height);\n-\n-            // Try the next unclaimed blockfile number\n-            nFile = this->MaxBlockfileNum() + 1;\n-            // Set to increment MaxBlockfileNum() for next iteration\n-            m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n-\n-            if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n-                m_blockfile_info.resize(nFile + 1);\n-            }\n+    }\n+    assert(nAddSize < max_blockfile_size);\n+\n+    while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n+        // when the undo file is keeping up with the block file, we want to flush it explicitly\n+        // when it is lagging behind (more blocks arrive than are being connected), we let the\n+        // undo block write case handle it\n+        finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n+                         Assert(m_blockfile_cursors[chain_type])->undo_height);\n+\n+        // Try the next unclaimed blockfile number\n+        nFile = this->MaxBlockfileNum() + 1;\n+        // Set to increment MaxBlockfileNum() for next iteration\n+        m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n+\n+        if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n+            m_blockfile_info.resize(nFile + 1);\n         }\n-        pos.nFile = nFile;\n-        pos.nPos = m_blockfile_info[nFile].nSize;\n     }\n+    pos.nFile = nFile;\n+    pos.nPos = m_blockfile_info[nFile].nSize;\n \n     if (nFile != last_blockfile) {\n-        if (!fKnown) {\n-            LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n-                last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n-\n-            // Do not propagate the return code. The flush concerns a previous block\n-            // and undo file that has already been written to. If a flush fails\n-            // here, and we crash, there is no expected additional block data\n-            // inconsistency arising from the flush failure here. However, the undo\n-            // data may be inconsistent after a crash if the flush is called during\n-            // a reindex. A flush error might also leave some of the data files\n-            // untrimmed.\n-            if (!FlushBlockFile(last_blockfile, !fKnown, finalize_undo)) {\n-                LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n-                              \"Failed to flush previous block file %05i (finalize=%i, finalize_undo=%i) before opening new block file %05i\\n\",\n-                              last_blockfile, !fKnown, finalize_undo, nFile);\n-            }\n+        LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n+                 last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n+\n+        // Do not propagate the return code. The flush concerns a previous block\n+        // and undo file that has already been written to. If a flush fails\n+        // here, and we crash, there is no expected additional block data\n+        // inconsistency arising from the flush failure here. However, the undo\n+        // data may be inconsistent after a crash if the flush is called during\n+        // a reindex. A flush error might also leave some of the data files\n+        // untrimmed.\n+        if (!FlushBlockFile(last_blockfile, true, finalize_undo)) {\n+            LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n+                          \"Failed to flush previous block file %05i (finalize=1, finalize_undo=%i) before opening new block file %05i\\n\",\n+                          last_blockfile, finalize_undo, nFile);\n         }\n         // No undo data yet in the new file, so reset our undo-height tracking.\n         m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n     }\n \n     m_blockfile_info[nFile].AddBlock(nHeight, nTime);\n-    if (fKnown) {\n-        m_blockfile_info[nFile].nSize = std::max(pos.nPos + nAddSize, m_blockfile_info[nFile].nSize);\n-    } else {\n-        m_blockfile_info[nFile].nSize += nAddSize;\n-    }\n+    m_blockfile_info[nFile].nSize += nAddSize;\n \n-    if (!fKnown) {\n-        bool out_of_space;\n-        size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n-        if (out_of_space) {\n-            m_opts.notifications.fatalError(_(\"Disk space is too low!\"));\n-            return false;\n-        }\n-        if (bytes_allocated != 0 && IsPruneMode()) {\n-            m_check_for_pruning = true;\n-        }\n+    bool out_of_space;\n+    size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n+    if (out_of_space) {\n+        m_opts.notifications.fatalError(_(\"Disk space is too low!\"));\n+        return false;\n+    }\n+    if (bytes_allocated != 0 && IsPruneMode()) {\n+        m_check_for_pruning = true;\n     }\n \n     m_dirty_fileinfo.insert(nFile);\n     return true;\n }\n \n+\n+void BlockManager::AddToBlockFileInfo(const CBlock& block, unsigned int nHeight, const FlatFilePos& pos)\n+{\n+    LOCK(cs_LastBlockFile);\n+\n+    unsigned int nAddSize = ::GetSerializeSize(TX_WITH_WITNESS(block));\n+    const BlockfileType chain_type = BlockfileTypeForHeight(nHeight);\n+    // -reindex and -reindex-chainstate delete any snapshot chainstate during init\n+    Assume(chain_type == BlockfileType::NORMAL);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1594767022",
      "id" : 1594767022,
      "in_reply_to_id" : 1581827125,
      "line" : 951,
      "node_id" : "PRRC_kwDOABII585fDjau",
      "original_commit_id" : "20efb411bd51ff3bfcb7f4a2cc7bd0d704ad7c26",
      "original_line" : 951,
      "original_position" : 165,
      "original_start_line" : null,
      "path" : "src/node/blockstorage.cpp",
      "position" : 159,
      "pull_request_review_id" : 2046862476,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1594767022/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-08T22:24:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1594767022",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1594767896"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1594767896"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I added a clarification.",
      "commit_id" : "6a22eede2083616ecc7558a16d8189c22b46403d",
      "created_at" : "2024-05-08T22:26:03Z",
      "diff_hunk" : "@@ -1139,17 +1152,17 @@ FlatFilePos BlockManager::SaveBlockToDisk(const CBlock& block, int nHeight, cons\n     const auto position_known {dbp != nullptr};\n     if (position_known) {\n         blockPos = *dbp;\n+        // During reindex, no blocks need to be written, only the blockfile info database needs to be rebuilt",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1594767896",
      "id" : 1594767896,
      "in_reply_to_id" : 1592824870,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585fDjoY",
      "original_commit_id" : "a2ae0a33c7c30678721d7e7d37d8e6170b013383",
      "original_line" : 1155,
      "original_position" : 189,
      "original_start_line" : null,
      "path" : "src/node/blockstorage.cpp",
      "position" : null,
      "pull_request_review_id" : 2046863837,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1594767896/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-08T22:26:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1594767896",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1594768464"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1594768464"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Renamed to `UpdateBlockInfo`",
      "commit_id" : "6a22eede2083616ecc7558a16d8189c22b46403d",
      "created_at" : "2024-05-08T22:26:55Z",
      "diff_hunk" : "@@ -155,7 +155,15 @@ class BlockManager\n     /** Return false if undo file flushing fails. */\n     [[nodiscard]] bool FlushUndoFile(int block_file, bool finalize = false);\n \n-    [[nodiscard]] bool FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, uint64_t nTime, bool fKnown);\n+    [[nodiscard]] bool FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, uint64_t nTime);\n+    /** Update blockfile info while processing a block during reindex. The block must be available on disk.\n+     *\n+     * @param[in]  block        the block being processed\n+     * @param[in]  nHeight      the height of the block\n+     * @param[in]  pos          the position of the block on disk. This must point *after* the\n+     *                          8 byte serialization header, at the beginning of the actual block data.\n+     */\n+    void AddToBlockFileInfo(const CBlock& block, unsigned int nHeight, const FlatFilePos& pos);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1594768464",
      "id" : 1594768464,
      "in_reply_to_id" : 1592833124,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585fDjxQ",
      "original_commit_id" : "a2ae0a33c7c30678721d7e7d37d8e6170b013383",
      "original_line" : 166,
      "original_position" : 13,
      "original_start_line" : null,
      "path" : "src/node/blockstorage.h",
      "position" : null,
      "pull_request_review_id" : 2046864594,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1594768464/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-08T22:26:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1594768464",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1594768654"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1594768654"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done",
      "commit_id" : "6a22eede2083616ecc7558a16d8189c22b46403d",
      "created_at" : "2024-05-08T22:27:13Z",
      "diff_hunk" : "@@ -155,7 +155,15 @@ class BlockManager\n     /** Return false if undo file flushing fails. */\n     [[nodiscard]] bool FlushUndoFile(int block_file, bool finalize = false);\n \n-    [[nodiscard]] bool FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, uint64_t nTime, bool fKnown);\n+    [[nodiscard]] bool FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, uint64_t nTime);\n+    /** Update blockfile info while processing a block during reindex. The block must be available on disk.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1594768654",
      "id" : 1594768654,
      "in_reply_to_id" : 1592841734,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585fDj0O",
      "original_commit_id" : "a2ae0a33c7c30678721d7e7d37d8e6170b013383",
      "original_line" : 159,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "src/node/blockstorage.h",
      "position" : null,
      "pull_request_review_id" : 2046864927,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1594768654/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-08T22:27:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1594768654",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1594769886"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1594769886"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "fixed",
      "commit_id" : "6a22eede2083616ecc7558a16d8189c22b46403d",
      "created_at" : "2024-05-08T22:29:18Z",
      "diff_hunk" : "@@ -181,22 +180,19 @@ BOOST_AUTO_TEST_CASE(blockmanager_flush_block_file)\n         BOOST_CHECK_EQUAL(read_block.nVersion, 2);\n     }\n \n-    // When FlatFilePos* dbp is given, SaveBlockToDisk() will not write or\n-    // overwrite anything to the flat file block storage. It will, however,\n-    // update the blockfile metadata. This is to facilitate reindexing\n-    // when the user has the blocks on disk but the metadata is being rebuilt.\n+    // During reindex, the flat file block storage will not be written do.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1594769886",
      "id" : 1594769886,
      "in_reply_to_id" : 1592848815,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585fDkHe",
      "original_commit_id" : "a17eacab1f8790afc5f89ba2ee3e34da4c9369e1",
      "original_line" : 183,
      "original_position" : 49,
      "original_start_line" : null,
      "path" : "src/test/blockmanager_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 2046866826,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1594769886/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-08T22:29:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1594769886",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1595600259"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1595600259"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1594531344\r\n\r\nThat makes sense. I didn't realize that. I can see how it makes the next commit more straightforward, at the cost of introducing a slightly mysterious change to this commit and adding a little more churn to the PR as a whole. Could be a good thing, as the next commit is the most complicated one, so either approach seems fine.\r\n",
      "commit_id" : "6a22eede2083616ecc7558a16d8189c22b46403d",
      "created_at" : "2024-05-09T15:22:47Z",
      "diff_hunk" : "@@ -853,8 +853,10 @@ bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigne\n     LOCK(cs_LastBlockFile);\n \n     const BlockfileType chain_type = BlockfileTypeForHeight(nHeight);\n+    // -reindex and -reindex-chainstate delete any snapshot chainstate during init\n+    if (fKnown) Assume(chain_type == BlockfileType::NORMAL);\n \n-    if (!m_blockfile_cursors[chain_type]) {\n+    if (!fKnown && !m_blockfile_cursors[chain_type]) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1595600259",
      "id" : 1595600259,
      "in_reply_to_id" : 1591461829,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585fGu2D",
      "original_commit_id" : "d6b0bb6dd0d26f3e10386d1afbafd8d52a12b2c5",
      "original_line" : 859,
      "original_position" : 8,
      "original_start_line" : null,
      "path" : "src/node/blockstorage.cpp",
      "position" : null,
      "pull_request_review_id" : 2048211642,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1595600259/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-09T15:33:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1595600259",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1595669798"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1595669798"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"blockstorage: split up FindBlockPos function\" (2b6d274af050ea21e39ce59b6a6b3b7fb61e8cbd)\r\n\r\nI think this comment is not really accurate in this context. There should be no need to reset `BlockfileCursor::undo_height` here, only to set a new `BlockfileCursor::file_num` value so `MaxBlockfileNum()` returns the right thing. So the comment could be changed to something like \"update the cursor so it points to the last file\".\r\n\r\nMaybe it would also make sense to make this a little more robust so doesn't move the cursor backwards if `UpdateBlockInfo` calls are made out of order. We are already doing this for blocks within the file by using std::max to set the file size below. Generalizing this would also allow dropping the `Assume()` checks:\r\n\r\n```diff\r\n--- a/src/node/blockstorage.cpp\r\n+++ b/src/node/blockstorage.cpp\r\n@@ -942,24 +942,19 @@ void BlockManager::UpdateBlockInfo(const CBlock& block, unsigned int nHeight, co\r\n {\r\n     LOCK(cs_LastBlockFile);\r\n \r\n+    // Update the cursor so it points to the last file.\r\n+    const BlockfileType chain_type{BlockfileTypeForHeight(nHeight)};\r\n+    auto& cursor{m_blockfile_cursors[chain_type]};\r\n+    if (!cursor || cursor->file_num < pos.nFile) {\r\n+        m_blockfile_cursors[chain_type] = BlockfileCursor{pos.nFile};\r\n+    }\r\n+\r\n+    // Update the file information so it points to the last block.\r\n     const unsigned int added_size = ::GetSerializeSize(TX_WITH_WITNESS(block));\r\n-    const BlockfileType chain_type = BlockfileTypeForHeight(nHeight);\r\n-    // Check that chain type is NORMAL, because this function is only\r\n-    // called during reindexing, and reindexing deletes snapshot chainstates, so\r\n-    // chain_type will not be SNAPSHOT. Also check that cursor exists, because\r\n-    // the normal cursor should never be null.\r\n-    Assume(chain_type == BlockfileType::NORMAL);\r\n-    Assume(m_blockfile_cursors[chain_type]);\r\n     const int nFile = pos.nFile;\r\n     if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\r\n         m_blockfile_info.resize(nFile + 1);\r\n     }\r\n-\r\n-    const int last_blockfile = m_blockfile_cursors[chain_type]->file_num;\r\n-    if (nFile != last_blockfile) {\r\n-        // No undo data yet in the new file, so reset our undo-height tracking.\r\n-        m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\r\n-    }\r\n     m_blockfile_info[nFile].AddBlock(nHeight, block.GetBlockTime());\r\n     m_blockfile_info[nFile].nSize = std::max(pos.nPos + added_size, m_blockfile_info[nFile].nSize);\r\n     m_dirty_fileinfo.insert(nFile);\r\n```\r\n",
      "commit_id" : "6a22eede2083616ecc7558a16d8189c22b46403d",
      "created_at" : "2024-05-09T16:11:43Z",
      "diff_hunk" : "@@ -871,90 +863,108 @@ bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigne\n     }\n     const int last_blockfile = m_blockfile_cursors[chain_type]->file_num;\n \n-    int nFile = fKnown ? pos.nFile : last_blockfile;\n+    int nFile = last_blockfile;\n     if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n         m_blockfile_info.resize(nFile + 1);\n     }\n \n     bool finalize_undo = false;\n-    if (!fKnown) {\n-        unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n-        // Use smaller blockfiles in test-only -fastprune mode - but avoid\n-        // the possibility of having a block not fit into the block file.\n-        if (m_opts.fast_prune) {\n-            max_blockfile_size = 0x10000; // 64kiB\n-            if (nAddSize >= max_blockfile_size) {\n-                // dynamically adjust the blockfile size to be larger than the added size\n-                max_blockfile_size = nAddSize + 1;\n-            }\n+    unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n+    // Use smaller blockfiles in test-only -fastprune mode - but avoid\n+    // the possibility of having a block not fit into the block file.\n+    if (m_opts.fast_prune) {\n+        max_blockfile_size = 0x10000; // 64kiB\n+        if (nAddSize >= max_blockfile_size) {\n+            // dynamically adjust the blockfile size to be larger than the added size\n+            max_blockfile_size = nAddSize + 1;\n         }\n-        assert(nAddSize < max_blockfile_size);\n-\n-        while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n-            // when the undo file is keeping up with the block file, we want to flush it explicitly\n-            // when it is lagging behind (more blocks arrive than are being connected), we let the\n-            // undo block write case handle it\n-            finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n-                    Assert(m_blockfile_cursors[chain_type])->undo_height);\n-\n-            // Try the next unclaimed blockfile number\n-            nFile = this->MaxBlockfileNum() + 1;\n-            // Set to increment MaxBlockfileNum() for next iteration\n-            m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n-\n-            if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n-                m_blockfile_info.resize(nFile + 1);\n-            }\n+    }\n+    assert(nAddSize < max_blockfile_size);\n+\n+    while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n+        // when the undo file is keeping up with the block file, we want to flush it explicitly\n+        // when it is lagging behind (more blocks arrive than are being connected), we let the\n+        // undo block write case handle it\n+        finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n+                         Assert(m_blockfile_cursors[chain_type])->undo_height);\n+\n+        // Try the next unclaimed blockfile number\n+        nFile = this->MaxBlockfileNum() + 1;\n+        // Set to increment MaxBlockfileNum() for next iteration\n+        m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n+\n+        if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n+            m_blockfile_info.resize(nFile + 1);\n         }\n-        pos.nFile = nFile;\n-        pos.nPos = m_blockfile_info[nFile].nSize;\n     }\n+    pos.nFile = nFile;\n+    pos.nPos = m_blockfile_info[nFile].nSize;\n \n     if (nFile != last_blockfile) {\n-        if (!fKnown) {\n-            LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n-                last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n-\n-            // Do not propagate the return code. The flush concerns a previous block\n-            // and undo file that has already been written to. If a flush fails\n-            // here, and we crash, there is no expected additional block data\n-            // inconsistency arising from the flush failure here. However, the undo\n-            // data may be inconsistent after a crash if the flush is called during\n-            // a reindex. A flush error might also leave some of the data files\n-            // untrimmed.\n-            if (!FlushBlockFile(last_blockfile, !fKnown, finalize_undo)) {\n-                LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n-                              \"Failed to flush previous block file %05i (finalize=%i, finalize_undo=%i) before opening new block file %05i\\n\",\n-                              last_blockfile, !fKnown, finalize_undo, nFile);\n-            }\n+        LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n+                 last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n+\n+        // Do not propagate the return code. The flush concerns a previous block\n+        // and undo file that has already been written to. If a flush fails\n+        // here, and we crash, there is no expected additional block data\n+        // inconsistency arising from the flush failure here. However, the undo\n+        // data may be inconsistent after a crash if the flush is called during\n+        // a reindex. A flush error might also leave some of the data files\n+        // untrimmed.\n+        if (!FlushBlockFile(last_blockfile, /*fFinalize=*/true, finalize_undo)) {\n+            LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n+                          \"Failed to flush previous block file %05i (finalize=1, finalize_undo=%i) before opening new block file %05i\\n\",\n+                          last_blockfile, finalize_undo, nFile);\n         }\n         // No undo data yet in the new file, so reset our undo-height tracking.\n         m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n     }\n \n     m_blockfile_info[nFile].AddBlock(nHeight, nTime);\n-    if (fKnown) {\n-        m_blockfile_info[nFile].nSize = std::max(pos.nPos + nAddSize, m_blockfile_info[nFile].nSize);\n-    } else {\n-        m_blockfile_info[nFile].nSize += nAddSize;\n-    }\n+    m_blockfile_info[nFile].nSize += nAddSize;\n \n-    if (!fKnown) {\n-        bool out_of_space;\n-        size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n-        if (out_of_space) {\n-            m_opts.notifications.fatalError(_(\"Disk space is too low!\"));\n-            return false;\n-        }\n-        if (bytes_allocated != 0 && IsPruneMode()) {\n-            m_check_for_pruning = true;\n-        }\n+    bool out_of_space;\n+    size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n+    if (out_of_space) {\n+        m_opts.notifications.fatalError(_(\"Disk space is too low!\"));\n+        return false;\n+    }\n+    if (bytes_allocated != 0 && IsPruneMode()) {\n+        m_check_for_pruning = true;\n     }\n \n     m_dirty_fileinfo.insert(nFile);\n     return true;\n }\n \n+\n+void BlockManager::UpdateBlockInfo(const CBlock& block, unsigned int nHeight, const FlatFilePos& pos)\n+{\n+    LOCK(cs_LastBlockFile);\n+\n+    const unsigned int added_size = ::GetSerializeSize(TX_WITH_WITNESS(block));\n+    const BlockfileType chain_type = BlockfileTypeForHeight(nHeight);\n+    // Check that chain type is NORMAL, because this function is only\n+    // called during reindexing, and reindexing deletes snapshot chainstates, so\n+    // chain_type will not be SNAPSHOT. Also check that cursor exists, because\n+    // the normal cursor should never be null.\n+    Assume(chain_type == BlockfileType::NORMAL);\n+    Assume(m_blockfile_cursors[chain_type]);\n+    const int nFile = pos.nFile;\n+    if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n+        m_blockfile_info.resize(nFile + 1);\n+    }\n+\n+    const int last_blockfile = m_blockfile_cursors[chain_type]->file_num;\n+    if (nFile != last_blockfile) {\n+        // No undo data yet in the new file, so reset our undo-height tracking.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1595669798",
      "id" : 1595669798,
      "line" : 960,
      "node_id" : "PRRC_kwDOABII585fG_0m",
      "original_commit_id" : "2b6d274af050ea21e39ce59b6a6b3b7fb61e8cbd",
      "original_line" : 960,
      "original_position" : 183,
      "original_start_line" : null,
      "path" : "src/node/blockstorage.cpp",
      "position" : 168,
      "pull_request_review_id" : 2048324457,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1595669798/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-09T16:11:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1595669798",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1596018428"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1596018428"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "The current logic seems really brittle to me, I suspected that there might be a bug hiding somewhere, but it barely works out in all scenarios I could think of.\r\nWith blocks being save on disk out of order, it is possible that at the end of a reindex, the cursor points to an older block file. Yet, it appears that nothing really bad happens as a result: When a new blocks arrives, `FindBlockPos` will still find the correct position in [this while loop](https://github.com/bitcoin/bitcoin/blob/24572cf768167c0e82a688e7eaef865a5cbc4ffd/src/node/blockstorage.cpp#L885-L900), skipping ahead.\r\nIn a similar way, `MaxBlockfileNum()` being incorrect can result in an incorrect `DB_LAST_BLOCK` being written to disk on shutdown.  However, we also recover from that because at next startup, `LoadBlockIndexDB` uses `DB_LAST_BLOCK` basically only for logging but doesn't trust it's actually pointing to the last block, searching for more db entries [here](https://github.com/bitcoin/bitcoin/blob/24572cf768167c0e82a688e7eaef865a5cbc4ffd/src/node/blockstorage.cpp#L513-L520), so only the log messages on startup will be wrong.\r\n\r\nThis seems really fragile to me, so I think that your suggestion is a good idea, and I'll add a commit for it!",
      "commit_id" : "6a22eede2083616ecc7558a16d8189c22b46403d",
      "created_at" : "2024-05-09T21:44:06Z",
      "diff_hunk" : "@@ -871,90 +863,108 @@ bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigne\n     }\n     const int last_blockfile = m_blockfile_cursors[chain_type]->file_num;\n \n-    int nFile = fKnown ? pos.nFile : last_blockfile;\n+    int nFile = last_blockfile;\n     if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n         m_blockfile_info.resize(nFile + 1);\n     }\n \n     bool finalize_undo = false;\n-    if (!fKnown) {\n-        unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n-        // Use smaller blockfiles in test-only -fastprune mode - but avoid\n-        // the possibility of having a block not fit into the block file.\n-        if (m_opts.fast_prune) {\n-            max_blockfile_size = 0x10000; // 64kiB\n-            if (nAddSize >= max_blockfile_size) {\n-                // dynamically adjust the blockfile size to be larger than the added size\n-                max_blockfile_size = nAddSize + 1;\n-            }\n+    unsigned int max_blockfile_size{MAX_BLOCKFILE_SIZE};\n+    // Use smaller blockfiles in test-only -fastprune mode - but avoid\n+    // the possibility of having a block not fit into the block file.\n+    if (m_opts.fast_prune) {\n+        max_blockfile_size = 0x10000; // 64kiB\n+        if (nAddSize >= max_blockfile_size) {\n+            // dynamically adjust the blockfile size to be larger than the added size\n+            max_blockfile_size = nAddSize + 1;\n         }\n-        assert(nAddSize < max_blockfile_size);\n-\n-        while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n-            // when the undo file is keeping up with the block file, we want to flush it explicitly\n-            // when it is lagging behind (more blocks arrive than are being connected), we let the\n-            // undo block write case handle it\n-            finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n-                    Assert(m_blockfile_cursors[chain_type])->undo_height);\n-\n-            // Try the next unclaimed blockfile number\n-            nFile = this->MaxBlockfileNum() + 1;\n-            // Set to increment MaxBlockfileNum() for next iteration\n-            m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n-\n-            if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n-                m_blockfile_info.resize(nFile + 1);\n-            }\n+    }\n+    assert(nAddSize < max_blockfile_size);\n+\n+    while (m_blockfile_info[nFile].nSize + nAddSize >= max_blockfile_size) {\n+        // when the undo file is keeping up with the block file, we want to flush it explicitly\n+        // when it is lagging behind (more blocks arrive than are being connected), we let the\n+        // undo block write case handle it\n+        finalize_undo = (static_cast<int>(m_blockfile_info[nFile].nHeightLast) ==\n+                         Assert(m_blockfile_cursors[chain_type])->undo_height);\n+\n+        // Try the next unclaimed blockfile number\n+        nFile = this->MaxBlockfileNum() + 1;\n+        // Set to increment MaxBlockfileNum() for next iteration\n+        m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n+\n+        if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n+            m_blockfile_info.resize(nFile + 1);\n         }\n-        pos.nFile = nFile;\n-        pos.nPos = m_blockfile_info[nFile].nSize;\n     }\n+    pos.nFile = nFile;\n+    pos.nPos = m_blockfile_info[nFile].nSize;\n \n     if (nFile != last_blockfile) {\n-        if (!fKnown) {\n-            LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n-                last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n-\n-            // Do not propagate the return code. The flush concerns a previous block\n-            // and undo file that has already been written to. If a flush fails\n-            // here, and we crash, there is no expected additional block data\n-            // inconsistency arising from the flush failure here. However, the undo\n-            // data may be inconsistent after a crash if the flush is called during\n-            // a reindex. A flush error might also leave some of the data files\n-            // untrimmed.\n-            if (!FlushBlockFile(last_blockfile, !fKnown, finalize_undo)) {\n-                LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n-                              \"Failed to flush previous block file %05i (finalize=%i, finalize_undo=%i) before opening new block file %05i\\n\",\n-                              last_blockfile, !fKnown, finalize_undo, nFile);\n-            }\n+        LogPrint(BCLog::BLOCKSTORAGE, \"Leaving block file %i: %s (onto %i) (height %i)\\n\",\n+                 last_blockfile, m_blockfile_info[last_blockfile].ToString(), nFile, nHeight);\n+\n+        // Do not propagate the return code. The flush concerns a previous block\n+        // and undo file that has already been written to. If a flush fails\n+        // here, and we crash, there is no expected additional block data\n+        // inconsistency arising from the flush failure here. However, the undo\n+        // data may be inconsistent after a crash if the flush is called during\n+        // a reindex. A flush error might also leave some of the data files\n+        // untrimmed.\n+        if (!FlushBlockFile(last_blockfile, /*fFinalize=*/true, finalize_undo)) {\n+            LogPrintLevel(BCLog::BLOCKSTORAGE, BCLog::Level::Warning,\n+                          \"Failed to flush previous block file %05i (finalize=1, finalize_undo=%i) before opening new block file %05i\\n\",\n+                          last_blockfile, finalize_undo, nFile);\n         }\n         // No undo data yet in the new file, so reset our undo-height tracking.\n         m_blockfile_cursors[chain_type] = BlockfileCursor{nFile};\n     }\n \n     m_blockfile_info[nFile].AddBlock(nHeight, nTime);\n-    if (fKnown) {\n-        m_blockfile_info[nFile].nSize = std::max(pos.nPos + nAddSize, m_blockfile_info[nFile].nSize);\n-    } else {\n-        m_blockfile_info[nFile].nSize += nAddSize;\n-    }\n+    m_blockfile_info[nFile].nSize += nAddSize;\n \n-    if (!fKnown) {\n-        bool out_of_space;\n-        size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n-        if (out_of_space) {\n-            m_opts.notifications.fatalError(_(\"Disk space is too low!\"));\n-            return false;\n-        }\n-        if (bytes_allocated != 0 && IsPruneMode()) {\n-            m_check_for_pruning = true;\n-        }\n+    bool out_of_space;\n+    size_t bytes_allocated = BlockFileSeq().Allocate(pos, nAddSize, out_of_space);\n+    if (out_of_space) {\n+        m_opts.notifications.fatalError(_(\"Disk space is too low!\"));\n+        return false;\n+    }\n+    if (bytes_allocated != 0 && IsPruneMode()) {\n+        m_check_for_pruning = true;\n     }\n \n     m_dirty_fileinfo.insert(nFile);\n     return true;\n }\n \n+\n+void BlockManager::UpdateBlockInfo(const CBlock& block, unsigned int nHeight, const FlatFilePos& pos)\n+{\n+    LOCK(cs_LastBlockFile);\n+\n+    const unsigned int added_size = ::GetSerializeSize(TX_WITH_WITNESS(block));\n+    const BlockfileType chain_type = BlockfileTypeForHeight(nHeight);\n+    // Check that chain type is NORMAL, because this function is only\n+    // called during reindexing, and reindexing deletes snapshot chainstates, so\n+    // chain_type will not be SNAPSHOT. Also check that cursor exists, because\n+    // the normal cursor should never be null.\n+    Assume(chain_type == BlockfileType::NORMAL);\n+    Assume(m_blockfile_cursors[chain_type]);\n+    const int nFile = pos.nFile;\n+    if (static_cast<int>(m_blockfile_info.size()) <= nFile) {\n+        m_blockfile_info.resize(nFile + 1);\n+    }\n+\n+    const int last_blockfile = m_blockfile_cursors[chain_type]->file_num;\n+    if (nFile != last_blockfile) {\n+        // No undo data yet in the new file, so reset our undo-height tracking.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29975#discussion_r1596018428",
      "id" : 1596018428,
      "in_reply_to_id" : 1595669798,
      "line" : 960,
      "node_id" : "PRRC_kwDOABII585fIU78",
      "original_commit_id" : "2b6d274af050ea21e39ce59b6a6b3b7fb61e8cbd",
      "original_line" : 960,
      "original_position" : 183,
      "original_start_line" : null,
      "path" : "src/node/blockstorage.cpp",
      "position" : 168,
      "pull_request_review_id" : 2048889711,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29975",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1596018428/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-09T21:44:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1596018428",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   }
]
