[
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613576870"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613576870"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: Seems like this would be easier?\r\n```suggestion\r\n        unsigned idx = real.empty() ? 0 : provider.ConsumeIntegralInRange<unsigned>(0, real.size() - 1);\r\n```",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T14:31:17Z",
      "diff_hunk" : "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613576870",
      "id" : 1613576870,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gLTqm",
      "original_commit_id" : "017272dff1076068d5d878dbe599fb5a3e12115c",
      "original_line" : 58,
      "original_position" : 58,
      "original_start_line" : null,
      "path" : "src/test/fuzz/ringbuffer.cpp",
      "position" : null,
      "pull_request_review_id" : 2077094091,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613576870/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T16:46:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613576870",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613595996"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613595996"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n        // Pick one operation based on value of command. Not all operations are always applicable.\r\n        // Loop through the applicable ones until command reaches 0 (avoids the need to compute\r\n        // the number of applicable commands ahead of time).\r\n```",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T14:44:12Z",
      "diff_hunk" : "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613595996",
      "id" : 1613595996,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gLYVc",
      "original_commit_id" : "017272dff1076068d5d878dbe599fb5a3e12115c",
      "original_line" : 61,
      "original_position" : 61,
      "original_start_line" : null,
      "path" : "src/test/fuzz/ringbuffer.cpp",
      "position" : null,
      "pull_request_review_id" : 2077094091,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613595996/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T16:01:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613595996",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613608895"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613608895"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\r\n```\r\n\r\nstyle-nit: I think `inline` can be dropped, according to https://en.cppreference.com/w/cpp/language/inline\r\n\r\n> A function defined entirely inside a [class/struct/union definition](https://en.cppreference.com/w/cpp/language/classes), whether it's a member function or a non-member friend function, is implicitly an inline function [...]\r\n\r\n",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T14:52:59Z",
      "diff_hunk" : "@@ -0,0 +1,259 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_RINGBUFFER_H\n+#define BITCOIN_UTIL_RINGBUFFER_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class RingBuffer\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    inline size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613608895",
      "id" : 1613608895,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gLbe_",
      "original_commit_id" : "017272dff1076068d5d878dbe599fb5a3e12115c",
      "original_line" : 34,
      "original_position" : 34,
      "original_start_line" : null,
      "path" : "src/util/ringbuffer.h",
      "position" : null,
      "pull_request_review_id" : 2077153695,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613608895/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T14:53:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613608895",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/maflcko/events{/privacy}",
         "followers_url" : "https://api.github.com/users/maflcko/followers",
         "following_url" : "https://api.github.com/users/maflcko/following{/other_user}",
         "gists_url" : "https://api.github.com/users/maflcko/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/maflcko",
         "id" : 6399679,
         "login" : "maflcko",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/maflcko/orgs",
         "received_events_url" : "https://api.github.com/users/maflcko/received_events",
         "repos_url" : "https://api.github.com/users/maflcko/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/maflcko/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/maflcko/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/maflcko"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage\nFor detailed information about the code coverage, see the [test coverage report](https://corecheck.dev/bitcoin/bitcoin/pulls/30161).\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [instagibbs](https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2153187763), [hebasto](https://github.com/bitcoin/bitcoin/pull/30161#pullrequestreview-2103018546) |\n\nIf your review is incorrectly listed, please react with ð to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#30126](https://github.com/bitcoin/bitcoin/pull/30126) (Low-level cluster linearization code by sipa)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "created_at" : "2024-05-24T14:53:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2129732891",
      "id" : 2129732891,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30161",
      "node_id" : "IC_kwDOABII585-8SUb",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2129732891/reactions"
      },
      "updated_at" : "2024-06-06T19:14:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2129732891",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613637296"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613637296"
         }
      },
      "author_association" : "MEMBER",
      "body" : "There's an assumption that at least one of the operations is applicable every time. Pretty obviously true but I assigned variables to all the possible conditions while reviewing and used it to add an assertion. Might be easier to read so I figured I'd leave a comment.\r\n```suggestion\r\n        const bool non_empty{num_buffers != 0};\r\n        const bool non_full{num_buffers < MAX_BUFFERS};\r\n        const bool partially_full{num_buffers > 0 && num_buffers < MAX_BUFFERS};\r\n        const bool multiple_exist{num_buffers > 1};\r\n        const bool existing_buffer_nonfull{non_empty && sim[idx].size() < MAX_BUFFER_SIZE};\r\n        const bool existing_buffer_nonempty{non_empty && !sim[idx].empty()};\r\n        assert(non_full || non_empty || partially_full);\r\n        \r\n        while (true) {\r\n```",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T15:13:13Z",
      "diff_hunk" : "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach\n+        // avoids the need to compute the number of applicable commands ahead of time).\n+        while (true) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613637296",
      "id" : 1613637296,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gLiaw",
      "original_commit_id" : "017272dff1076068d5d878dbe599fb5a3e12115c",
      "original_line" : 70,
      "original_position" : 63,
      "original_start_line" : null,
      "path" : "src/test/fuzz/ringbuffer.cpp",
      "position" : null,
      "pull_request_review_id" : 2077094091,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613637296/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T16:01:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613637296",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613660947"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613660947"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n    // Create entry for this object in g_tracker and populate m_track_entry\r\n    void Register()\r\n```",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T15:31:26Z",
      "diff_hunk" : "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach\n+        // avoids the need to compute the number of applicable commands ahead of time).\n+        while (true) {\n+            if (num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Default construct. */\n+                real.emplace_back();\n+                sim.emplace_back();\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* resize() */\n+                size_t new_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                real[idx].resize(new_size);\n+                sim[idx].resize(new_size);\n+                assert(real[idx].size() == new_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* clear() */\n+                real[idx].clear();\n+                sim[idx].clear();\n+                assert(real[idx].empty());\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Copy construct default. */\n+                real[idx] = RingBuffer<T>();\n+                sim[idx].clear();\n+                assert(real[idx].size() == 0);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Destruct. */\n+                compare_fn(real.back(), sim.back());\n+                real.pop_back();\n+                sim.pop_back();\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Copy construct. */\n+                real.emplace_back(real[idx]);\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Move construct. */\n+                RingBuffer<T> copy(real[idx]);\n+                real.emplace_back(std::move(copy));\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* swap() */\n+                swap(real[idx], real[(idx + 1) % num_buffers]);\n+                swap(sim[idx], sim[(idx + 1) % sim.size()]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Copy assign. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = real[(idx + 1) % num_buffers];\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Move assign. */\n+                RingBuffer<T> copy(real[(idx + 1) % num_buffers]);\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = std::move(copy);\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* reserve() */\n+                size_t res_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                size_t old_cap = real[idx].capacity();\n+                size_t old_size = real[idx].size();\n+                real[idx].reserve(res_size);\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == std::max(old_cap, res_size));\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* shrink_to_fit() */\n+                size_t old_size = real[idx].size();\n+                real[idx].shrink_to_fit();\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_back(*tmp);\n+                sim[idx].push_back(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_back(*tmp);\n+                real[idx].push_back(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_back() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_back(seed);\n+                real[idx].emplace_back(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_front(*tmp);\n+                sim[idx].push_front(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_front(*tmp);\n+                real[idx].push_front(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_front() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_front(seed);\n+                real[idx].emplace_front(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* front() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].front() == real[idx].front());\n+                sim[idx].front() = *tmp;\n+                real[idx].front() = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* back() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].back() == real[idx].back());\n+                sim[idx].back() = *tmp;\n+                real[idx].back() = *tmp;\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* operator[] [modifying] */\n+                tmp = T(rng());\n+                size_t pos = provider.ConsumeIntegralInRange<size_t>(0, sim[idx].size() - 1);\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx][pos] == real[idx][pos]);\n+                sim[idx][pos] = *tmp;\n+                real[idx][pos] = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Fully compare the final state. */\n+    for (unsigned i = 0; i < sim.size(); ++i) {\n+        // Make sure const getters work.\n+        const RingBuffer<T>& realbuf = real[i];\n+        const std::deque<T>& simbuf = sim[i];\n+        compare_fn(realbuf, simbuf);\n+        for (unsigned j = 0; j < sim.size(); ++j) {\n+            assert((realbuf == real[j]) == (simbuf == sim[j]));\n+            assert(((realbuf <=> real[j]) >= 0) == (simbuf >= sim[j]));\n+            assert(((realbuf <=> real[j]) <= 0) == (simbuf <= sim[j]));\n+        }\n+        // Clear out the buffers so we can check below that no objects exist anymore.\n+        sim[i].clear();\n+        real[i].clear();\n+    }\n+\n+    if constexpr (CheckNoneLeft) {\n+        tmp = std::nullopt;\n+        T::CheckNoneExist();\n+    }\n+}\n+\n+/** Data structure with built-in tracking of all existing objects. */\n+template<size_t Size>\n+class TrackedObj\n+{\n+    static_assert(Size > 0);\n+\n+    /* Data type for map that actually stores the object data.\n+     *\n+     * The key is a pointer to the TrackedObj, the value is the uint64_t it was initialized with.\n+     * Default-constructed and moved-from objects hold an std::nullopt.\n+     */\n+    using track_map_type = std::map<const TrackedObj<Size>*, std::optional<uint64_t>>;\n+\n+private:\n+\n+    /** Actual map. */\n+    static inline track_map_type g_tracker;\n+\n+    /** Iterators into the tracker map for this object.\n+     *\n+     * This is an array of size Size, all holding the same value, to give the object configurable\n+     * size. The value is g_tracker.end() if this object is not fully initialized. */\n+    typename track_map_type::iterator m_track_entry[Size];\n+\n+    void Check() const\n+    {\n+        auto it = g_tracker.find(this);\n+        for (size_t i = 0; i < Size; ++i) {\n+            assert(m_track_entry[i] == it);\n+        }\n+    }\n+\n+    void Register()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613660947",
      "id" : 1613660947,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gLoMT",
      "original_commit_id" : "017272dff1076068d5d878dbe599fb5a3e12115c",
      "original_line" : 313,
      "original_position" : 305,
      "original_start_line" : null,
      "path" : "src/test/fuzz/ringbuffer.cpp",
      "position" : null,
      "pull_request_review_id" : 2077094091,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613660947/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T16:01:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613660947",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613661502"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613661502"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n    // Get value corresponding to this object in g_tracker\r\n    std::optional<uint64_t>& Deref()\r\n```",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T15:31:47Z",
      "diff_hunk" : "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach\n+        // avoids the need to compute the number of applicable commands ahead of time).\n+        while (true) {\n+            if (num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Default construct. */\n+                real.emplace_back();\n+                sim.emplace_back();\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* resize() */\n+                size_t new_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                real[idx].resize(new_size);\n+                sim[idx].resize(new_size);\n+                assert(real[idx].size() == new_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* clear() */\n+                real[idx].clear();\n+                sim[idx].clear();\n+                assert(real[idx].empty());\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Copy construct default. */\n+                real[idx] = RingBuffer<T>();\n+                sim[idx].clear();\n+                assert(real[idx].size() == 0);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Destruct. */\n+                compare_fn(real.back(), sim.back());\n+                real.pop_back();\n+                sim.pop_back();\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Copy construct. */\n+                real.emplace_back(real[idx]);\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Move construct. */\n+                RingBuffer<T> copy(real[idx]);\n+                real.emplace_back(std::move(copy));\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* swap() */\n+                swap(real[idx], real[(idx + 1) % num_buffers]);\n+                swap(sim[idx], sim[(idx + 1) % sim.size()]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Copy assign. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = real[(idx + 1) % num_buffers];\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Move assign. */\n+                RingBuffer<T> copy(real[(idx + 1) % num_buffers]);\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = std::move(copy);\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* reserve() */\n+                size_t res_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                size_t old_cap = real[idx].capacity();\n+                size_t old_size = real[idx].size();\n+                real[idx].reserve(res_size);\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == std::max(old_cap, res_size));\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* shrink_to_fit() */\n+                size_t old_size = real[idx].size();\n+                real[idx].shrink_to_fit();\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_back(*tmp);\n+                sim[idx].push_back(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_back(*tmp);\n+                real[idx].push_back(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_back() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_back(seed);\n+                real[idx].emplace_back(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_front(*tmp);\n+                sim[idx].push_front(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_front(*tmp);\n+                real[idx].push_front(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_front() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_front(seed);\n+                real[idx].emplace_front(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* front() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].front() == real[idx].front());\n+                sim[idx].front() = *tmp;\n+                real[idx].front() = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* back() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].back() == real[idx].back());\n+                sim[idx].back() = *tmp;\n+                real[idx].back() = *tmp;\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* operator[] [modifying] */\n+                tmp = T(rng());\n+                size_t pos = provider.ConsumeIntegralInRange<size_t>(0, sim[idx].size() - 1);\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx][pos] == real[idx][pos]);\n+                sim[idx][pos] = *tmp;\n+                real[idx][pos] = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Fully compare the final state. */\n+    for (unsigned i = 0; i < sim.size(); ++i) {\n+        // Make sure const getters work.\n+        const RingBuffer<T>& realbuf = real[i];\n+        const std::deque<T>& simbuf = sim[i];\n+        compare_fn(realbuf, simbuf);\n+        for (unsigned j = 0; j < sim.size(); ++j) {\n+            assert((realbuf == real[j]) == (simbuf == sim[j]));\n+            assert(((realbuf <=> real[j]) >= 0) == (simbuf >= sim[j]));\n+            assert(((realbuf <=> real[j]) <= 0) == (simbuf <= sim[j]));\n+        }\n+        // Clear out the buffers so we can check below that no objects exist anymore.\n+        sim[i].clear();\n+        real[i].clear();\n+    }\n+\n+    if constexpr (CheckNoneLeft) {\n+        tmp = std::nullopt;\n+        T::CheckNoneExist();\n+    }\n+}\n+\n+/** Data structure with built-in tracking of all existing objects. */\n+template<size_t Size>\n+class TrackedObj\n+{\n+    static_assert(Size > 0);\n+\n+    /* Data type for map that actually stores the object data.\n+     *\n+     * The key is a pointer to the TrackedObj, the value is the uint64_t it was initialized with.\n+     * Default-constructed and moved-from objects hold an std::nullopt.\n+     */\n+    using track_map_type = std::map<const TrackedObj<Size>*, std::optional<uint64_t>>;\n+\n+private:\n+\n+    /** Actual map. */\n+    static inline track_map_type g_tracker;\n+\n+    /** Iterators into the tracker map for this object.\n+     *\n+     * This is an array of size Size, all holding the same value, to give the object configurable\n+     * size. The value is g_tracker.end() if this object is not fully initialized. */\n+    typename track_map_type::iterator m_track_entry[Size];\n+\n+    void Check() const\n+    {\n+        auto it = g_tracker.find(this);\n+        for (size_t i = 0; i < Size; ++i) {\n+            assert(m_track_entry[i] == it);\n+        }\n+    }\n+\n+    void Register()\n+    {\n+        auto [it, inserted] = g_tracker.emplace(this, std::nullopt);\n+        assert(inserted);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = it;\n+        }\n+    }\n+\n+    void Deregister()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        g_tracker.erase(m_track_entry[0]);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = g_tracker.end();\n+        }\n+    }\n+\n+    std::optional<uint64_t>& Deref()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613661502",
      "id" : 1613661502,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gLoU-",
      "original_commit_id" : "017272dff1076068d5d878dbe599fb5a3e12115c",
      "original_line" : 333,
      "original_position" : 324,
      "original_start_line" : null,
      "path" : "src/test/fuzz/ringbuffer.cpp",
      "position" : null,
      "pull_request_review_id" : 2077094091,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613661502/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T16:01:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613661502",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613663028"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613663028"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`static_assert(!std::is_trivially_copyable_v<TrackedObj<1>>)` ?",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T15:32:32Z",
      "diff_hunk" : "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach\n+        // avoids the need to compute the number of applicable commands ahead of time).\n+        while (true) {\n+            if (num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Default construct. */\n+                real.emplace_back();\n+                sim.emplace_back();\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* resize() */\n+                size_t new_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                real[idx].resize(new_size);\n+                sim[idx].resize(new_size);\n+                assert(real[idx].size() == new_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* clear() */\n+                real[idx].clear();\n+                sim[idx].clear();\n+                assert(real[idx].empty());\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Copy construct default. */\n+                real[idx] = RingBuffer<T>();\n+                sim[idx].clear();\n+                assert(real[idx].size() == 0);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Destruct. */\n+                compare_fn(real.back(), sim.back());\n+                real.pop_back();\n+                sim.pop_back();\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Copy construct. */\n+                real.emplace_back(real[idx]);\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Move construct. */\n+                RingBuffer<T> copy(real[idx]);\n+                real.emplace_back(std::move(copy));\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* swap() */\n+                swap(real[idx], real[(idx + 1) % num_buffers]);\n+                swap(sim[idx], sim[(idx + 1) % sim.size()]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Copy assign. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = real[(idx + 1) % num_buffers];\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Move assign. */\n+                RingBuffer<T> copy(real[(idx + 1) % num_buffers]);\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = std::move(copy);\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* reserve() */\n+                size_t res_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                size_t old_cap = real[idx].capacity();\n+                size_t old_size = real[idx].size();\n+                real[idx].reserve(res_size);\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == std::max(old_cap, res_size));\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* shrink_to_fit() */\n+                size_t old_size = real[idx].size();\n+                real[idx].shrink_to_fit();\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_back(*tmp);\n+                sim[idx].push_back(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_back(*tmp);\n+                real[idx].push_back(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_back() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_back(seed);\n+                real[idx].emplace_back(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_front(*tmp);\n+                sim[idx].push_front(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_front(*tmp);\n+                real[idx].push_front(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_front() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_front(seed);\n+                real[idx].emplace_front(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* front() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].front() == real[idx].front());\n+                sim[idx].front() = *tmp;\n+                real[idx].front() = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* back() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].back() == real[idx].back());\n+                sim[idx].back() = *tmp;\n+                real[idx].back() = *tmp;\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* operator[] [modifying] */\n+                tmp = T(rng());\n+                size_t pos = provider.ConsumeIntegralInRange<size_t>(0, sim[idx].size() - 1);\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx][pos] == real[idx][pos]);\n+                sim[idx][pos] = *tmp;\n+                real[idx][pos] = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Fully compare the final state. */\n+    for (unsigned i = 0; i < sim.size(); ++i) {\n+        // Make sure const getters work.\n+        const RingBuffer<T>& realbuf = real[i];\n+        const std::deque<T>& simbuf = sim[i];\n+        compare_fn(realbuf, simbuf);\n+        for (unsigned j = 0; j < sim.size(); ++j) {\n+            assert((realbuf == real[j]) == (simbuf == sim[j]));\n+            assert(((realbuf <=> real[j]) >= 0) == (simbuf >= sim[j]));\n+            assert(((realbuf <=> real[j]) <= 0) == (simbuf <= sim[j]));\n+        }\n+        // Clear out the buffers so we can check below that no objects exist anymore.\n+        sim[i].clear();\n+        real[i].clear();\n+    }\n+\n+    if constexpr (CheckNoneLeft) {\n+        tmp = std::nullopt;\n+        T::CheckNoneExist();\n+    }\n+}\n+\n+/** Data structure with built-in tracking of all existing objects. */\n+template<size_t Size>\n+class TrackedObj\n+{\n+    static_assert(Size > 0);\n+\n+    /* Data type for map that actually stores the object data.\n+     *\n+     * The key is a pointer to the TrackedObj, the value is the uint64_t it was initialized with.\n+     * Default-constructed and moved-from objects hold an std::nullopt.\n+     */\n+    using track_map_type = std::map<const TrackedObj<Size>*, std::optional<uint64_t>>;\n+\n+private:\n+\n+    /** Actual map. */\n+    static inline track_map_type g_tracker;\n+\n+    /** Iterators into the tracker map for this object.\n+     *\n+     * This is an array of size Size, all holding the same value, to give the object configurable\n+     * size. The value is g_tracker.end() if this object is not fully initialized. */\n+    typename track_map_type::iterator m_track_entry[Size];\n+\n+    void Check() const\n+    {\n+        auto it = g_tracker.find(this);\n+        for (size_t i = 0; i < Size; ++i) {\n+            assert(m_track_entry[i] == it);\n+        }\n+    }\n+\n+    void Register()\n+    {\n+        auto [it, inserted] = g_tracker.emplace(this, std::nullopt);\n+        assert(inserted);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = it;\n+        }\n+    }\n+\n+    void Deregister()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        g_tracker.erase(m_track_entry[0]);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = g_tracker.end();\n+        }\n+    }\n+\n+    std::optional<uint64_t>& Deref()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        return m_track_entry[0]->second;\n+    }\n+\n+    const std::optional<uint64_t>& Deref() const\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        return m_track_entry[0]->second;\n+    }\n+\n+public:\n+    ~TrackedObj() { Deregister(); }\n+    TrackedObj() { Register(); }\n+\n+    TrackedObj(uint64_t value)\n+    {\n+        Register();\n+        Deref() = value;\n+    }\n+\n+    TrackedObj(const TrackedObj& other)\n+    {\n+        Register();\n+        Deref() = other.Deref();\n+    }\n+\n+    TrackedObj(TrackedObj&& other)\n+    {\n+        Register();\n+        Deref() = other.Deref();\n+        other.Deref() = std::nullopt;\n+    }\n+\n+    TrackedObj& operator=(const TrackedObj& other)\n+    {\n+        Deref() = other.Deref();\n+        return *this;\n+    }\n+\n+    TrackedObj& operator=(TrackedObj&& other)\n+    {\n+        Deref() = other.Deref();\n+        other.Deref() = std::nullopt;\n+        return *this;\n+    }\n+\n+    friend bool operator==(const TrackedObj& a, const TrackedObj& b)\n+    {\n+        return a.Deref() == b.Deref();\n+    }\n+\n+    friend std::strong_ordering operator<=>(const TrackedObj& a, const TrackedObj& b)\n+    {\n+        // Libc++ 15 & 16 do not support std::optional<T>::operator<=> yet. See\n+        // https://reviews.llvm.org/D146392.\n+        if (!a.Deref().has_value() || !b.Deref().has_value()) {\n+            return a.Deref().has_value() <=> b.Deref().has_value();\n+        }\n+        return *a.Deref() <=> *b.Deref();\n+    }\n+\n+    static void CheckNoneExist()\n+    {\n+        assert(g_tracker.empty());\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(ringbuffer)\n+{\n+    // Run the test with simple uints (which are std::is_trivially_copyable_v).\n+    TestType<uint8_t, false>(buffer, 1);\n+    TestType<uint16_t, false>(buffer, 2);\n+    TestType<uint32_t, false>(buffer, 3);\n+    TestType<uint64_t, false>(buffer, 4);\n+    // Run the test with TrackedObjs (which are not).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613663028",
      "id" : 1613663028,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gLos0",
      "original_commit_id" : "017272dff1076068d5d878dbe599fb5a3e12115c",
      "original_line" : 404,
      "original_position" : 404,
      "original_start_line" : null,
      "path" : "src/test/fuzz/ringbuffer.cpp",
      "position" : null,
      "pull_request_review_id" : 2077094091,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613663028/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T16:01:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613663028",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613674426"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613674426"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.\r\n\r\n`inline` does have an effect beyond making it an inline function (in GCC and Clang it increases the eagerness of the compiler to actually inline the function), but that's the sort of optimization one should only do guided by benchmarks, which I haven't done, so I dropped the `inline` here.",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T15:37:14Z",
      "diff_hunk" : "@@ -0,0 +1,259 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_RINGBUFFER_H\n+#define BITCOIN_UTIL_RINGBUFFER_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class RingBuffer\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    inline size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613674426",
      "id" : 1613674426,
      "in_reply_to_id" : 1613608895,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gLre6",
      "original_commit_id" : "017272dff1076068d5d878dbe599fb5a3e12115c",
      "original_line" : 34,
      "original_position" : 34,
      "original_start_line" : null,
      "path" : "src/util/ringbuffer.h",
      "position" : null,
      "pull_request_review_id" : 2077266898,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613674426/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T15:37:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613674426",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613702058"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613702058"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I was slightly confused that this was called `RingBuffer` since the data structure itself doesn't act like a ring buffer i.e. will reallocate if adding items beyond capacity (I wrote `vExtraTxnForCompact` to use it before looking at the implementation and then realized I misunderstood the interface). But I now have read that `m_buffer` is the ring buffer - oops.",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T15:57:09Z",
      "diff_hunk" : "@@ -0,0 +1,259 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_RINGBUFFER_H\n+#define BITCOIN_UTIL_RINGBUFFER_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class RingBuffer",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613702058",
      "id" : 1613702058,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gLyOq",
      "original_commit_id" : "c2a4915257f7b2303cd17a9a30728157616b5ce6",
      "original_line" : 23,
      "original_position" : 23,
      "original_start_line" : null,
      "path" : "src/util/ringbuffer.h",
      "position" : null,
      "pull_request_review_id" : 2077094091,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613702058/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T16:01:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613702058",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613746327"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613746327"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Hmm, this is a good point. The `RingBuffer` class' interface isn't a ring buffer, but a deque; the implementation happens to use a ring buffer. Suggestions/bikeshedding for a better name welcome.",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T16:33:21Z",
      "diff_hunk" : "@@ -0,0 +1,259 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_RINGBUFFER_H\n+#define BITCOIN_UTIL_RINGBUFFER_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class RingBuffer",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613746327",
      "id" : 1613746327,
      "in_reply_to_id" : 1613702058,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gL9CX",
      "original_commit_id" : "c2a4915257f7b2303cd17a9a30728157616b5ce6",
      "original_line" : 23,
      "original_position" : 23,
      "original_start_line" : null,
      "path" : "src/util/ringbuffer.h",
      "position" : null,
      "pull_request_review_id" : 2077390047,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613746327/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T16:33:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613746327",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613757739"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613757739"
         }
      },
      "author_association" : "MEMBER",
      "body" : "\"Integral in Rage\" sounds like a high-school metal band.",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T16:42:55Z",
      "diff_hunk" : "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613757739",
      "id" : 1613757739,
      "in_reply_to_id" : 1613576870,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gL_0r",
      "original_commit_id" : "017272dff1076068d5d878dbe599fb5a3e12115c",
      "original_line" : 58,
      "original_position" : 58,
      "original_start_line" : null,
      "path" : "src/test/fuzz/ringbuffer.cpp",
      "position" : null,
      "pull_request_review_id" : 2077411055,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 1,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613757739/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T16:42:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613757739",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613785731"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785731"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T17:08:34Z",
      "diff_hunk" : "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613785731",
      "id" : 1613785731,
      "in_reply_to_id" : 1613576870,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gMGqD",
      "original_commit_id" : "017272dff1076068d5d878dbe599fb5a3e12115c",
      "original_line" : 58,
      "original_position" : 58,
      "original_start_line" : null,
      "path" : "src/test/fuzz/ringbuffer.cpp",
      "position" : null,
      "pull_request_review_id" : 2077454937,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785731/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T17:08:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785731",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613785818"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785818"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T17:08:40Z",
      "diff_hunk" : "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613785818",
      "id" : 1613785818,
      "in_reply_to_id" : 1613595996,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gMGra",
      "original_commit_id" : "017272dff1076068d5d878dbe599fb5a3e12115c",
      "original_line" : 61,
      "original_position" : 61,
      "original_start_line" : null,
      "path" : "src/test/fuzz/ringbuffer.cpp",
      "position" : null,
      "pull_request_review_id" : 2077455089,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785818/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T17:08:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785818",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613785897"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785897"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T17:08:45Z",
      "diff_hunk" : "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach\n+        // avoids the need to compute the number of applicable commands ahead of time).\n+        while (true) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613785897",
      "id" : 1613785897,
      "in_reply_to_id" : 1613637296,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gMGsp",
      "original_commit_id" : "017272dff1076068d5d878dbe599fb5a3e12115c",
      "original_line" : 70,
      "original_position" : 63,
      "original_start_line" : null,
      "path" : "src/test/fuzz/ringbuffer.cpp",
      "position" : null,
      "pull_request_review_id" : 2077455207,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785897/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T17:08:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785897",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613785977"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785977"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T17:08:52Z",
      "diff_hunk" : "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach\n+        // avoids the need to compute the number of applicable commands ahead of time).\n+        while (true) {\n+            if (num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Default construct. */\n+                real.emplace_back();\n+                sim.emplace_back();\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* resize() */\n+                size_t new_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                real[idx].resize(new_size);\n+                sim[idx].resize(new_size);\n+                assert(real[idx].size() == new_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* clear() */\n+                real[idx].clear();\n+                sim[idx].clear();\n+                assert(real[idx].empty());\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Copy construct default. */\n+                real[idx] = RingBuffer<T>();\n+                sim[idx].clear();\n+                assert(real[idx].size() == 0);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Destruct. */\n+                compare_fn(real.back(), sim.back());\n+                real.pop_back();\n+                sim.pop_back();\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Copy construct. */\n+                real.emplace_back(real[idx]);\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Move construct. */\n+                RingBuffer<T> copy(real[idx]);\n+                real.emplace_back(std::move(copy));\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* swap() */\n+                swap(real[idx], real[(idx + 1) % num_buffers]);\n+                swap(sim[idx], sim[(idx + 1) % sim.size()]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Copy assign. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = real[(idx + 1) % num_buffers];\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Move assign. */\n+                RingBuffer<T> copy(real[(idx + 1) % num_buffers]);\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = std::move(copy);\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* reserve() */\n+                size_t res_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                size_t old_cap = real[idx].capacity();\n+                size_t old_size = real[idx].size();\n+                real[idx].reserve(res_size);\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == std::max(old_cap, res_size));\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* shrink_to_fit() */\n+                size_t old_size = real[idx].size();\n+                real[idx].shrink_to_fit();\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_back(*tmp);\n+                sim[idx].push_back(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_back(*tmp);\n+                real[idx].push_back(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_back() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_back(seed);\n+                real[idx].emplace_back(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_front(*tmp);\n+                sim[idx].push_front(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_front(*tmp);\n+                real[idx].push_front(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_front() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_front(seed);\n+                real[idx].emplace_front(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* front() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].front() == real[idx].front());\n+                sim[idx].front() = *tmp;\n+                real[idx].front() = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* back() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].back() == real[idx].back());\n+                sim[idx].back() = *tmp;\n+                real[idx].back() = *tmp;\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* operator[] [modifying] */\n+                tmp = T(rng());\n+                size_t pos = provider.ConsumeIntegralInRange<size_t>(0, sim[idx].size() - 1);\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx][pos] == real[idx][pos]);\n+                sim[idx][pos] = *tmp;\n+                real[idx][pos] = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Fully compare the final state. */\n+    for (unsigned i = 0; i < sim.size(); ++i) {\n+        // Make sure const getters work.\n+        const RingBuffer<T>& realbuf = real[i];\n+        const std::deque<T>& simbuf = sim[i];\n+        compare_fn(realbuf, simbuf);\n+        for (unsigned j = 0; j < sim.size(); ++j) {\n+            assert((realbuf == real[j]) == (simbuf == sim[j]));\n+            assert(((realbuf <=> real[j]) >= 0) == (simbuf >= sim[j]));\n+            assert(((realbuf <=> real[j]) <= 0) == (simbuf <= sim[j]));\n+        }\n+        // Clear out the buffers so we can check below that no objects exist anymore.\n+        sim[i].clear();\n+        real[i].clear();\n+    }\n+\n+    if constexpr (CheckNoneLeft) {\n+        tmp = std::nullopt;\n+        T::CheckNoneExist();\n+    }\n+}\n+\n+/** Data structure with built-in tracking of all existing objects. */\n+template<size_t Size>\n+class TrackedObj\n+{\n+    static_assert(Size > 0);\n+\n+    /* Data type for map that actually stores the object data.\n+     *\n+     * The key is a pointer to the TrackedObj, the value is the uint64_t it was initialized with.\n+     * Default-constructed and moved-from objects hold an std::nullopt.\n+     */\n+    using track_map_type = std::map<const TrackedObj<Size>*, std::optional<uint64_t>>;\n+\n+private:\n+\n+    /** Actual map. */\n+    static inline track_map_type g_tracker;\n+\n+    /** Iterators into the tracker map for this object.\n+     *\n+     * This is an array of size Size, all holding the same value, to give the object configurable\n+     * size. The value is g_tracker.end() if this object is not fully initialized. */\n+    typename track_map_type::iterator m_track_entry[Size];\n+\n+    void Check() const\n+    {\n+        auto it = g_tracker.find(this);\n+        for (size_t i = 0; i < Size; ++i) {\n+            assert(m_track_entry[i] == it);\n+        }\n+    }\n+\n+    void Register()\n+    {\n+        auto [it, inserted] = g_tracker.emplace(this, std::nullopt);\n+        assert(inserted);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = it;\n+        }\n+    }\n+\n+    void Deregister()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        g_tracker.erase(m_track_entry[0]);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = g_tracker.end();\n+        }\n+    }\n+\n+    std::optional<uint64_t>& Deref()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613785977",
      "id" : 1613785977,
      "in_reply_to_id" : 1613661502,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gMGt5",
      "original_commit_id" : "017272dff1076068d5d878dbe599fb5a3e12115c",
      "original_line" : 333,
      "original_position" : 324,
      "original_start_line" : null,
      "path" : "src/test/fuzz/ringbuffer.cpp",
      "position" : null,
      "pull_request_review_id" : 2077455350,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785977/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T17:08:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785977",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613786034"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613786034"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In Rust they call it [`VecDeque`](https://doc.rust-lang.org/std/collections/struct.VecDeque.html), maybe that's a naming option? (It even rhymes!)",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T17:08:55Z",
      "diff_hunk" : "@@ -0,0 +1,259 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_RINGBUFFER_H\n+#define BITCOIN_UTIL_RINGBUFFER_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class RingBuffer",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613786034",
      "id" : 1613786034,
      "in_reply_to_id" : 1613702058,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gMGuy",
      "original_commit_id" : "c2a4915257f7b2303cd17a9a30728157616b5ce6",
      "original_line" : 23,
      "original_position" : 23,
      "original_start_line" : null,
      "path" : "src/util/ringbuffer.h",
      "position" : null,
      "pull_request_review_id" : 2077455436,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613786034/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T17:08:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613786034",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613786106"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613786106"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T17:09:00Z",
      "diff_hunk" : "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach\n+        // avoids the need to compute the number of applicable commands ahead of time).\n+        while (true) {\n+            if (num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Default construct. */\n+                real.emplace_back();\n+                sim.emplace_back();\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* resize() */\n+                size_t new_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                real[idx].resize(new_size);\n+                sim[idx].resize(new_size);\n+                assert(real[idx].size() == new_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* clear() */\n+                real[idx].clear();\n+                sim[idx].clear();\n+                assert(real[idx].empty());\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Copy construct default. */\n+                real[idx] = RingBuffer<T>();\n+                sim[idx].clear();\n+                assert(real[idx].size() == 0);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Destruct. */\n+                compare_fn(real.back(), sim.back());\n+                real.pop_back();\n+                sim.pop_back();\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Copy construct. */\n+                real.emplace_back(real[idx]);\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Move construct. */\n+                RingBuffer<T> copy(real[idx]);\n+                real.emplace_back(std::move(copy));\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* swap() */\n+                swap(real[idx], real[(idx + 1) % num_buffers]);\n+                swap(sim[idx], sim[(idx + 1) % sim.size()]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Copy assign. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = real[(idx + 1) % num_buffers];\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Move assign. */\n+                RingBuffer<T> copy(real[(idx + 1) % num_buffers]);\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = std::move(copy);\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* reserve() */\n+                size_t res_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                size_t old_cap = real[idx].capacity();\n+                size_t old_size = real[idx].size();\n+                real[idx].reserve(res_size);\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == std::max(old_cap, res_size));\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* shrink_to_fit() */\n+                size_t old_size = real[idx].size();\n+                real[idx].shrink_to_fit();\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_back(*tmp);\n+                sim[idx].push_back(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_back(*tmp);\n+                real[idx].push_back(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_back() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_back(seed);\n+                real[idx].emplace_back(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_front(*tmp);\n+                sim[idx].push_front(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_front(*tmp);\n+                real[idx].push_front(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_front() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_front(seed);\n+                real[idx].emplace_front(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* front() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].front() == real[idx].front());\n+                sim[idx].front() = *tmp;\n+                real[idx].front() = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* back() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].back() == real[idx].back());\n+                sim[idx].back() = *tmp;\n+                real[idx].back() = *tmp;\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* operator[] [modifying] */\n+                tmp = T(rng());\n+                size_t pos = provider.ConsumeIntegralInRange<size_t>(0, sim[idx].size() - 1);\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx][pos] == real[idx][pos]);\n+                sim[idx][pos] = *tmp;\n+                real[idx][pos] = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Fully compare the final state. */\n+    for (unsigned i = 0; i < sim.size(); ++i) {\n+        // Make sure const getters work.\n+        const RingBuffer<T>& realbuf = real[i];\n+        const std::deque<T>& simbuf = sim[i];\n+        compare_fn(realbuf, simbuf);\n+        for (unsigned j = 0; j < sim.size(); ++j) {\n+            assert((realbuf == real[j]) == (simbuf == sim[j]));\n+            assert(((realbuf <=> real[j]) >= 0) == (simbuf >= sim[j]));\n+            assert(((realbuf <=> real[j]) <= 0) == (simbuf <= sim[j]));\n+        }\n+        // Clear out the buffers so we can check below that no objects exist anymore.\n+        sim[i].clear();\n+        real[i].clear();\n+    }\n+\n+    if constexpr (CheckNoneLeft) {\n+        tmp = std::nullopt;\n+        T::CheckNoneExist();\n+    }\n+}\n+\n+/** Data structure with built-in tracking of all existing objects. */\n+template<size_t Size>\n+class TrackedObj\n+{\n+    static_assert(Size > 0);\n+\n+    /* Data type for map that actually stores the object data.\n+     *\n+     * The key is a pointer to the TrackedObj, the value is the uint64_t it was initialized with.\n+     * Default-constructed and moved-from objects hold an std::nullopt.\n+     */\n+    using track_map_type = std::map<const TrackedObj<Size>*, std::optional<uint64_t>>;\n+\n+private:\n+\n+    /** Actual map. */\n+    static inline track_map_type g_tracker;\n+\n+    /** Iterators into the tracker map for this object.\n+     *\n+     * This is an array of size Size, all holding the same value, to give the object configurable\n+     * size. The value is g_tracker.end() if this object is not fully initialized. */\n+    typename track_map_type::iterator m_track_entry[Size];\n+\n+    void Check() const\n+    {\n+        auto it = g_tracker.find(this);\n+        for (size_t i = 0; i < Size; ++i) {\n+            assert(m_track_entry[i] == it);\n+        }\n+    }\n+\n+    void Register()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613786106",
      "id" : 1613786106,
      "in_reply_to_id" : 1613660947,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gMGv6",
      "original_commit_id" : "017272dff1076068d5d878dbe599fb5a3e12115c",
      "original_line" : 313,
      "original_position" : 305,
      "original_start_line" : null,
      "path" : "src/test/fuzz/ringbuffer.cpp",
      "position" : null,
      "pull_request_review_id" : 2077455546,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613786106/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T17:09:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613786106",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613786217"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613786217"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done (and more).",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T17:09:08Z",
      "diff_hunk" : "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach\n+        // avoids the need to compute the number of applicable commands ahead of time).\n+        while (true) {\n+            if (num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Default construct. */\n+                real.emplace_back();\n+                sim.emplace_back();\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* resize() */\n+                size_t new_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                real[idx].resize(new_size);\n+                sim[idx].resize(new_size);\n+                assert(real[idx].size() == new_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* clear() */\n+                real[idx].clear();\n+                sim[idx].clear();\n+                assert(real[idx].empty());\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Copy construct default. */\n+                real[idx] = RingBuffer<T>();\n+                sim[idx].clear();\n+                assert(real[idx].size() == 0);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Destruct. */\n+                compare_fn(real.back(), sim.back());\n+                real.pop_back();\n+                sim.pop_back();\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Copy construct. */\n+                real.emplace_back(real[idx]);\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Move construct. */\n+                RingBuffer<T> copy(real[idx]);\n+                real.emplace_back(std::move(copy));\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* swap() */\n+                swap(real[idx], real[(idx + 1) % num_buffers]);\n+                swap(sim[idx], sim[(idx + 1) % sim.size()]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Copy assign. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = real[(idx + 1) % num_buffers];\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Move assign. */\n+                RingBuffer<T> copy(real[(idx + 1) % num_buffers]);\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = std::move(copy);\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* reserve() */\n+                size_t res_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                size_t old_cap = real[idx].capacity();\n+                size_t old_size = real[idx].size();\n+                real[idx].reserve(res_size);\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == std::max(old_cap, res_size));\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* shrink_to_fit() */\n+                size_t old_size = real[idx].size();\n+                real[idx].shrink_to_fit();\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_back(*tmp);\n+                sim[idx].push_back(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_back(*tmp);\n+                real[idx].push_back(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_back() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_back(seed);\n+                real[idx].emplace_back(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_front(*tmp);\n+                sim[idx].push_front(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_front(*tmp);\n+                real[idx].push_front(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_front() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_front(seed);\n+                real[idx].emplace_front(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* front() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].front() == real[idx].front());\n+                sim[idx].front() = *tmp;\n+                real[idx].front() = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* back() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].back() == real[idx].back());\n+                sim[idx].back() = *tmp;\n+                real[idx].back() = *tmp;\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* operator[] [modifying] */\n+                tmp = T(rng());\n+                size_t pos = provider.ConsumeIntegralInRange<size_t>(0, sim[idx].size() - 1);\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx][pos] == real[idx][pos]);\n+                sim[idx][pos] = *tmp;\n+                real[idx][pos] = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Fully compare the final state. */\n+    for (unsigned i = 0; i < sim.size(); ++i) {\n+        // Make sure const getters work.\n+        const RingBuffer<T>& realbuf = real[i];\n+        const std::deque<T>& simbuf = sim[i];\n+        compare_fn(realbuf, simbuf);\n+        for (unsigned j = 0; j < sim.size(); ++j) {\n+            assert((realbuf == real[j]) == (simbuf == sim[j]));\n+            assert(((realbuf <=> real[j]) >= 0) == (simbuf >= sim[j]));\n+            assert(((realbuf <=> real[j]) <= 0) == (simbuf <= sim[j]));\n+        }\n+        // Clear out the buffers so we can check below that no objects exist anymore.\n+        sim[i].clear();\n+        real[i].clear();\n+    }\n+\n+    if constexpr (CheckNoneLeft) {\n+        tmp = std::nullopt;\n+        T::CheckNoneExist();\n+    }\n+}\n+\n+/** Data structure with built-in tracking of all existing objects. */\n+template<size_t Size>\n+class TrackedObj\n+{\n+    static_assert(Size > 0);\n+\n+    /* Data type for map that actually stores the object data.\n+     *\n+     * The key is a pointer to the TrackedObj, the value is the uint64_t it was initialized with.\n+     * Default-constructed and moved-from objects hold an std::nullopt.\n+     */\n+    using track_map_type = std::map<const TrackedObj<Size>*, std::optional<uint64_t>>;\n+\n+private:\n+\n+    /** Actual map. */\n+    static inline track_map_type g_tracker;\n+\n+    /** Iterators into the tracker map for this object.\n+     *\n+     * This is an array of size Size, all holding the same value, to give the object configurable\n+     * size. The value is g_tracker.end() if this object is not fully initialized. */\n+    typename track_map_type::iterator m_track_entry[Size];\n+\n+    void Check() const\n+    {\n+        auto it = g_tracker.find(this);\n+        for (size_t i = 0; i < Size; ++i) {\n+            assert(m_track_entry[i] == it);\n+        }\n+    }\n+\n+    void Register()\n+    {\n+        auto [it, inserted] = g_tracker.emplace(this, std::nullopt);\n+        assert(inserted);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = it;\n+        }\n+    }\n+\n+    void Deregister()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        g_tracker.erase(m_track_entry[0]);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = g_tracker.end();\n+        }\n+    }\n+\n+    std::optional<uint64_t>& Deref()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        return m_track_entry[0]->second;\n+    }\n+\n+    const std::optional<uint64_t>& Deref() const\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        return m_track_entry[0]->second;\n+    }\n+\n+public:\n+    ~TrackedObj() { Deregister(); }\n+    TrackedObj() { Register(); }\n+\n+    TrackedObj(uint64_t value)\n+    {\n+        Register();\n+        Deref() = value;\n+    }\n+\n+    TrackedObj(const TrackedObj& other)\n+    {\n+        Register();\n+        Deref() = other.Deref();\n+    }\n+\n+    TrackedObj(TrackedObj&& other)\n+    {\n+        Register();\n+        Deref() = other.Deref();\n+        other.Deref() = std::nullopt;\n+    }\n+\n+    TrackedObj& operator=(const TrackedObj& other)\n+    {\n+        Deref() = other.Deref();\n+        return *this;\n+    }\n+\n+    TrackedObj& operator=(TrackedObj&& other)\n+    {\n+        Deref() = other.Deref();\n+        other.Deref() = std::nullopt;\n+        return *this;\n+    }\n+\n+    friend bool operator==(const TrackedObj& a, const TrackedObj& b)\n+    {\n+        return a.Deref() == b.Deref();\n+    }\n+\n+    friend std::strong_ordering operator<=>(const TrackedObj& a, const TrackedObj& b)\n+    {\n+        // Libc++ 15 & 16 do not support std::optional<T>::operator<=> yet. See\n+        // https://reviews.llvm.org/D146392.\n+        if (!a.Deref().has_value() || !b.Deref().has_value()) {\n+            return a.Deref().has_value() <=> b.Deref().has_value();\n+        }\n+        return *a.Deref() <=> *b.Deref();\n+    }\n+\n+    static void CheckNoneExist()\n+    {\n+        assert(g_tracker.empty());\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(ringbuffer)\n+{\n+    // Run the test with simple uints (which are std::is_trivially_copyable_v).\n+    TestType<uint8_t, false>(buffer, 1);\n+    TestType<uint16_t, false>(buffer, 2);\n+    TestType<uint32_t, false>(buffer, 3);\n+    TestType<uint64_t, false>(buffer, 4);\n+    // Run the test with TrackedObjs (which are not).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613786217",
      "id" : 1613786217,
      "in_reply_to_id" : 1613663028,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gMGxp",
      "original_commit_id" : "017272dff1076068d5d878dbe599fb5a3e12115c",
      "original_line" : 404,
      "original_position" : 404,
      "original_start_line" : null,
      "path" : "src/test/fuzz/ringbuffer.cpp",
      "position" : null,
      "pull_request_review_id" : 2077455736,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613786217/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T17:09:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613786217",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613810244"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613810244"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Renamed!",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T17:32:13Z",
      "diff_hunk" : "@@ -0,0 +1,259 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_RINGBUFFER_H\n+#define BITCOIN_UTIL_RINGBUFFER_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class RingBuffer",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613810244",
      "id" : 1613810244,
      "in_reply_to_id" : 1613702058,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gMMpE",
      "original_commit_id" : "c2a4915257f7b2303cd17a9a30728157616b5ce6",
      "original_line" : 23,
      "original_position" : 23,
      "original_start_line" : null,
      "path" : "src/util/ringbuffer.h",
      "position" : null,
      "pull_request_review_id" : 2077498512,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613810244/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T17:32:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613810244",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--85328a0da195eb286784d51f73fa0af9-->\n\nð§ At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/25390426376</sub>",
      "created_at" : "2024-05-24T17:35:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2130058565",
      "id" : 2130058565,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30161",
      "node_id" : "IC_kwDOABII585-9h1F",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2130058565/reactions"
      },
      "updated_at" : "2024-05-24T17:35:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2130058565",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613915882"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613915882"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Could do (i think 3?) memcmp here if `is_trivially_copyable_v`, but maybe it's not worth the complexity of differing offsets.",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T19:17:04Z",
      "diff_hunk" : "@@ -0,0 +1,261 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size)\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            if constexpr (std::is_trivially_constructible_v<T>) {\n+                // If T is trivially constructible, just zero-initialize the area being used.\n+                size_t first_part = std::min(m_capacity - Index(m_size), size - m_size);\n+                if (first_part) std::fill(m_buffer + Index(m_size), m_buffer + Index(m_size) + first_part, 0);\n+                if (first_part < size - m_size) std::fill(m_buffer, m_buffer + size - m_size - first_part, 0);\n+                m_size = size;\n+            } else {\n+                // Otherwise invoke the default constructor for every element separately.\n+                while (m_size < size) {\n+                    std::construct_at<T>(m_buffer + Index(m_size));\n+                    ++m_size;\n+                }\n+            }\n+        }\n+    }\n+\n+    void clear() { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at<T>(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613915882",
      "id" : 1613915882,
      "line" : 171,
      "node_id" : "PRRC_kwDOABII585gMmbq",
      "original_commit_id" : "f4d6f4a8548c63dbed72aa618d64b7ac2e7fcbad",
      "original_line" : 171,
      "original_position" : 171,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : 171,
      "pull_request_review_id" : 2077678840,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613915882/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T19:17:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613915882",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=4",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "node_id" : "MDQ6VXNlcjQxNzA0Mw==",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613922119"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613922119"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Trivially copyable does not imply a trivial `operator!=`, I think.",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T19:19:53Z",
      "diff_hunk" : "@@ -0,0 +1,261 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size)\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            if constexpr (std::is_trivially_constructible_v<T>) {\n+                // If T is trivially constructible, just zero-initialize the area being used.\n+                size_t first_part = std::min(m_capacity - Index(m_size), size - m_size);\n+                if (first_part) std::fill(m_buffer + Index(m_size), m_buffer + Index(m_size) + first_part, 0);\n+                if (first_part < size - m_size) std::fill(m_buffer, m_buffer + size - m_size - first_part, 0);\n+                m_size = size;\n+            } else {\n+                // Otherwise invoke the default constructor for every element separately.\n+                while (m_size < size) {\n+                    std::construct_at<T>(m_buffer + Index(m_size));\n+                    ++m_size;\n+                }\n+            }\n+        }\n+    }\n+\n+    void clear() { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at<T>(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613922119",
      "id" : 1613922119,
      "in_reply_to_id" : 1613915882,
      "line" : 171,
      "node_id" : "PRRC_kwDOABII585gMn9H",
      "original_commit_id" : "f4d6f4a8548c63dbed72aa618d64b7ac2e7fcbad",
      "original_line" : 171,
      "original_position" : 171,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : 171,
      "pull_request_review_id" : 2077689045,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613922119/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T19:22:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613922119",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613925002"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613925002"
         }
      },
      "author_association" : "MEMBER",
      "body" : "From https://en.cppreference.com/w/cpp/types/is_trivially_copyable:\r\n\"Objects of trivially-copyable types that are not potentially-overlapping subobjects are the only C++ objects that may be safely copied with [std::memcpy](https://en.cppreference.com/w/cpp/string/byte/memcpy) or serialized to/from binary files with [std::ofstream::write()](https://en.cppreference.com/w/cpp/io/basic_ostream/write) / [std::ifstream::read()](https://en.cppreference.com/w/cpp/io/basic_istream/read).\"\r\n\r\nI assume anything that can be memcpy'd can be memcmp'd.",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T19:22:58Z",
      "diff_hunk" : "@@ -0,0 +1,261 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size)\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            if constexpr (std::is_trivially_constructible_v<T>) {\n+                // If T is trivially constructible, just zero-initialize the area being used.\n+                size_t first_part = std::min(m_capacity - Index(m_size), size - m_size);\n+                if (first_part) std::fill(m_buffer + Index(m_size), m_buffer + Index(m_size) + first_part, 0);\n+                if (first_part < size - m_size) std::fill(m_buffer, m_buffer + size - m_size - first_part, 0);\n+                m_size = size;\n+            } else {\n+                // Otherwise invoke the default constructor for every element separately.\n+                while (m_size < size) {\n+                    std::construct_at<T>(m_buffer + Index(m_size));\n+                    ++m_size;\n+                }\n+            }\n+        }\n+    }\n+\n+    void clear() { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at<T>(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613925002",
      "id" : 1613925002,
      "in_reply_to_id" : 1613915882,
      "line" : 171,
      "node_id" : "PRRC_kwDOABII585gMoqK",
      "original_commit_id" : "f4d6f4a8548c63dbed72aa618d64b7ac2e7fcbad",
      "original_line" : 171,
      "original_position" : 171,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : 171,
      "pull_request_review_id" : 2077694876,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613925002/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T19:23:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613925002",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=4",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "node_id" : "MDQ6VXNlcjQxNzA0Mw==",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613941027"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613941027"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I certainly see why it's reasonable why trivial types would have a trivial comparison operator, but there is no guarantee for that. I think you can have a trivially-constructible type with an complex `operator==` (for such a type you'd expect that something that was memcpy'd you end up with a result that satisfies ==, but I don't think that's required, and it also doesn't work the other way around: objects could satisfy == without being bitwise identical).",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T19:31:04Z",
      "diff_hunk" : "@@ -0,0 +1,261 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size)\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            if constexpr (std::is_trivially_constructible_v<T>) {\n+                // If T is trivially constructible, just zero-initialize the area being used.\n+                size_t first_part = std::min(m_capacity - Index(m_size), size - m_size);\n+                if (first_part) std::fill(m_buffer + Index(m_size), m_buffer + Index(m_size) + first_part, 0);\n+                if (first_part < size - m_size) std::fill(m_buffer, m_buffer + size - m_size - first_part, 0);\n+                m_size = size;\n+            } else {\n+                // Otherwise invoke the default constructor for every element separately.\n+                while (m_size < size) {\n+                    std::construct_at<T>(m_buffer + Index(m_size));\n+                    ++m_size;\n+                }\n+            }\n+        }\n+    }\n+\n+    void clear() { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at<T>(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613941027",
      "id" : 1613941027,
      "in_reply_to_id" : 1613915882,
      "line" : 171,
      "node_id" : "PRRC_kwDOABII585gMskj",
      "original_commit_id" : "f4d6f4a8548c63dbed72aa618d64b7ac2e7fcbad",
      "original_line" : 171,
      "original_position" : 171,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : 171,
      "pull_request_review_id" : 2077727864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613941027/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T19:31:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613941027",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613943540"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613943540"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Ok, yeah, agreed.",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T19:34:39Z",
      "diff_hunk" : "@@ -0,0 +1,261 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size)\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            if constexpr (std::is_trivially_constructible_v<T>) {\n+                // If T is trivially constructible, just zero-initialize the area being used.\n+                size_t first_part = std::min(m_capacity - Index(m_size), size - m_size);\n+                if (first_part) std::fill(m_buffer + Index(m_size), m_buffer + Index(m_size) + first_part, 0);\n+                if (first_part < size - m_size) std::fill(m_buffer, m_buffer + size - m_size - first_part, 0);\n+                m_size = size;\n+            } else {\n+                // Otherwise invoke the default constructor for every element separately.\n+                while (m_size < size) {\n+                    std::construct_at<T>(m_buffer + Index(m_size));\n+                    ++m_size;\n+                }\n+            }\n+        }\n+    }\n+\n+    void clear() { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at<T>(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613943540",
      "id" : 1613943540,
      "in_reply_to_id" : 1613915882,
      "line" : 171,
      "node_id" : "PRRC_kwDOABII585gMtL0",
      "original_commit_id" : "f4d6f4a8548c63dbed72aa618d64b7ac2e7fcbad",
      "original_line" : 171,
      "original_position" : 171,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : 171,
      "pull_request_review_id" : 2077737706,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613943540/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T19:34:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613943540",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=4",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "node_id" : "MDQ6VXNlcjQxNzA0Mw==",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1614029973"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1614029973"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Just adding for posterity because I went down a rabbit hole for this:\r\n\r\nIt seems clang's `__is_trivially_equality_comparable` builtin would do what we want here:\r\n> Returns true if comparing two objects of the provided type is known to be equivalent to comparing their object representations. Note that types containing padding bytes are never trivially equality comparable.\r\n\r\n[From libc++](https://github.com/llvm/llvm-project/blob/main/libcxx/include/__type_traits/is_equality_comparable.h#L36C1-L37C41):\r\n```c++\r\n// A type is_trivially_equality_comparable if the expression `a == b` is equivalent to `std::memcmp(&a, &b, sizeof(T))`\r\n// (with `a` and `b` being of type `T`).\r\n```\r\nNot that it's worth using here.",
      "commit_id" : "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "created_at" : "2024-05-24T21:14:50Z",
      "diff_hunk" : "@@ -0,0 +1,261 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size)\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            if constexpr (std::is_trivially_constructible_v<T>) {\n+                // If T is trivially constructible, just zero-initialize the area being used.\n+                size_t first_part = std::min(m_capacity - Index(m_size), size - m_size);\n+                if (first_part) std::fill(m_buffer + Index(m_size), m_buffer + Index(m_size) + first_part, 0);\n+                if (first_part < size - m_size) std::fill(m_buffer, m_buffer + size - m_size - first_part, 0);\n+                m_size = size;\n+            } else {\n+                // Otherwise invoke the default constructor for every element separately.\n+                while (m_size < size) {\n+                    std::construct_at<T>(m_buffer + Index(m_size));\n+                    ++m_size;\n+                }\n+            }\n+        }\n+    }\n+\n+    void clear() { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at<T>(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1614029973",
      "id" : 1614029973,
      "in_reply_to_id" : 1613915882,
      "line" : 162,
      "node_id" : "PRRC_kwDOABII585gNCSV",
      "original_commit_id" : "f4d6f4a8548c63dbed72aa618d64b7ac2e7fcbad",
      "original_line" : 162,
      "original_position" : 171,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : 162,
      "pull_request_review_id" : 2078066616,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1614029973/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T22:11:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1614029973",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=4",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "node_id" : "MDQ6VXNlcjQxNzA0Mw==",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1614066880"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1614066880"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Interesting!",
      "commit_id" : "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "created_at" : "2024-05-24T21:56:18Z",
      "diff_hunk" : "@@ -0,0 +1,261 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size)\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            if constexpr (std::is_trivially_constructible_v<T>) {\n+                // If T is trivially constructible, just zero-initialize the area being used.\n+                size_t first_part = std::min(m_capacity - Index(m_size), size - m_size);\n+                if (first_part) std::fill(m_buffer + Index(m_size), m_buffer + Index(m_size) + first_part, 0);\n+                if (first_part < size - m_size) std::fill(m_buffer, m_buffer + size - m_size - first_part, 0);\n+                m_size = size;\n+            } else {\n+                // Otherwise invoke the default constructor for every element separately.\n+                while (m_size < size) {\n+                    std::construct_at<T>(m_buffer + Index(m_size));\n+                    ++m_size;\n+                }\n+            }\n+        }\n+    }\n+\n+    void clear() { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at<T>(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1614066880",
      "id" : 1614066880,
      "in_reply_to_id" : 1613915882,
      "line" : 162,
      "node_id" : "PRRC_kwDOABII585gNLTA",
      "original_commit_id" : "f4d6f4a8548c63dbed72aa618d64b7ac2e7fcbad",
      "original_line" : 162,
      "original_position" : 171,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : 162,
      "pull_request_review_id" : 2078108333,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1614066880/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T21:56:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1614066880",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Apparently `std::is_trivially_default_constructible_v<T>` does not imply you can just memset 0 to construct the objects (or at least, I can't find evidence of that). So I've dropped that branch.",
      "created_at" : "2024-05-26T00:01:14Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2131728449",
      "id" : 2131728449,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30161",
      "node_id" : "IC_kwDOABII585_D5hB",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2131728449/reactions"
      },
      "updated_at" : "2024-05-26T00:01:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2131728449",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK.",
      "created_at" : "2024-05-27T12:12:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2133351751",
      "id" : 2133351751,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30161",
      "node_id" : "IC_kwDOABII585_KF1H",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133351751/reactions"
      },
      "updated_at" : "2024-05-27T12:12:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133351751",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> It's not a full drop-in replacement...\r\n\r\nThen, perhaps, it's a good chance to avoid `size_t` for parameter and return types in the interface?\r\n\r\nSee: [Signed and Unsigned Types in Interfaces](https://www.aristeia.com/Papers/C++ReportColumns/sep95.pdf)",
      "created_at" : "2024-05-27T12:59:30Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2133434672",
      "id" : 2133434672,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30161",
      "node_id" : "IC_kwDOABII585_KaEw",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133434672/reactions"
      },
      "updated_at" : "2024-05-27T12:59:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133434672",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@hebasto I do prefer to stay compatible with the `std::deque` interface, even if just for matching behavior users would expect. ",
      "created_at" : "2024-05-27T16:04:53Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2133774404",
      "id" : 2133774404,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30161",
      "node_id" : "IC_kwDOABII585_LtBE",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133774404/reactions"
      },
      "updated_at" : "2024-05-27T16:04:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133774404",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1616905695"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1616905695"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: \r\n```suggestion\r\n    /** Number of objects in the container. m_size <= m_capacity. */\r\n```",
      "commit_id" : "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "created_at" : "2024-05-28T09:30:29Z",
      "diff_hunk" : "@@ -0,0 +1,252 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1616905695",
      "id" : 1616905695,
      "line" : 29,
      "node_id" : "PRRC_kwDOABII585gYAXf",
      "original_commit_id" : "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_line" : 29,
      "original_position" : 29,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : 29,
      "pull_request_review_id" : 2082248884,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1616905695/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-28T09:30:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1616905695",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1616940538"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1616940538"
         }
      },
      "author_association" : "MEMBER",
      "body" : "What is the purpose of this line here? It doesn't look like a pre-condition for the function arguments. It seems it should be used as a post-condition for `m_capacity` mutators (including this function) and `m_offset` mutators, no?",
      "commit_id" : "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "created_at" : "2024-05-28T09:55:18Z",
      "diff_hunk" : "@@ -0,0 +1,252 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1616940538",
      "id" : 1616940538,
      "line" : 39,
      "node_id" : "PRRC_kwDOABII585gYI36",
      "original_commit_id" : "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_line" : 39,
      "original_position" : 39,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : 39,
      "pull_request_review_id" : 2082303692,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1616940538/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-28T09:55:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1616940538",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1616978938"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1616978938"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Does it make sense to skip this call if `std::is_trivially_destructible_v<T>`?",
      "commit_id" : "03cfb8673669edaf275e382e4a0a83d6a377c259",
      "created_at" : "2024-05-28T10:24:31Z",
      "diff_hunk" : "@@ -0,0 +1,252 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1616978938",
      "id" : 1616978938,
      "line" : 58,
      "node_id" : "PRRC_kwDOABII585gYSP6",
      "original_commit_id" : "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_line" : 58,
      "original_position" : 57,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : 58,
      "pull_request_review_id" : 2082368339,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1616978938/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-28T10:24:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1616978938",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1616992405"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1616992405"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Both functions `clear()` and `ResizeDown()` could be declared `noexcept`.",
      "commit_id" : "03cfb8673669edaf275e382e4a0a83d6a377c259",
      "created_at" : "2024-05-28T10:33:37Z",
      "diff_hunk" : "@@ -0,0 +1,252 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size)\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            while (m_size < size) {\n+                std::construct_at<T>(m_buffer + Index(m_size));\n+                ++m_size;\n+            }\n+        }\n+    }\n+\n+    void clear() { ResizeDown(0); }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1616992405",
      "id" : 1616992405,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gYViV",
      "original_commit_id" : "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_line" : 117,
      "original_position" : 117,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : null,
      "pull_request_review_id" : 2082390454,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1616992405/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-28T10:33:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1616992405",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1617005071"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617005071"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The move assignment operator preserves the capacity. Maybe do the same here for consistency?",
      "commit_id" : "03cfb8673669edaf275e382e4a0a83d6a377c259",
      "created_at" : "2024-05-28T10:44:18Z",
      "diff_hunk" : "@@ -0,0 +1,252 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size)\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            while (m_size < size) {\n+                std::construct_at<T>(m_buffer + Index(m_size));\n+                ++m_size;\n+            }\n+        }\n+    }\n+\n+    void clear() { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1617005071",
      "id" : 1617005071,
      "line" : 130,
      "node_id" : "PRRC_kwDOABII585gYYoP",
      "original_commit_id" : "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_line" : 130,
      "original_position" : 128,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : 130,
      "pull_request_review_id" : 2082411034,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617005071/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-28T10:44:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617005071",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1617126230"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617126230"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "*`FUZZ_TARGET(vecdeque)`",
      "commit_id" : "03cfb8673669edaf275e382e4a0a83d6a377c259",
      "created_at" : "2024-05-28T12:06:33Z",
      "diff_hunk" : "@@ -0,0 +1,423 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/vecdeque.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on VecDeque type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<VecDeque<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const VecDeque<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        int command = provider.ConsumeIntegral<uint8_t>() % 32;\n+        unsigned idx = real.empty() ? 0 : provider.ConsumeIntegralInRange<unsigned>(0, real.size() - 1);\n+        const size_t num_buffers = sim.size();\n+        // Pick one operation based on value of command. Not all operations are always applicable.\n+        // Loop through the applicable ones until command reaches 0 (which avoids the need to\n+        // compute the number of applicable commands ahead of time).\n+        const bool non_empty{num_buffers != 0};\n+        const bool non_full{num_buffers < MAX_BUFFERS};\n+        const bool partially_full{non_empty && non_full};\n+        const bool multiple_exist{num_buffers > 1};\n+        const bool existing_buffer_non_full{non_empty && sim[idx].size() < MAX_BUFFER_SIZE};\n+        const bool existing_buffer_non_empty{non_empty && !sim[idx].empty()};\n+        assert(non_full || non_empty);\n+        while (true) {\n+            if (non_full && command-- == 0) {\n+                /* Default construct. */\n+                real.emplace_back();\n+                sim.emplace_back();\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* resize() */\n+                size_t new_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                real[idx].resize(new_size);\n+                sim[idx].resize(new_size);\n+                assert(real[idx].size() == new_size);\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* clear() */\n+                real[idx].clear();\n+                sim[idx].clear();\n+                assert(real[idx].empty());\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* Copy construct default. */\n+                real[idx] = VecDeque<T>();\n+                sim[idx].clear();\n+                assert(real[idx].size() == 0);\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* Destruct. */\n+                compare_fn(real.back(), sim.back());\n+                real.pop_back();\n+                sim.pop_back();\n+                break;\n+            }\n+            if (partially_full && command-- == 0) {\n+                /* Copy construct. */\n+                real.emplace_back(real[idx]);\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (partially_full && command-- == 0) {\n+                /* Move construct. */\n+                VecDeque<T> copy(real[idx]);\n+                real.emplace_back(std::move(copy));\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (multiple_exist && command-- == 0) {\n+                /* swap() */\n+                swap(real[idx], real[(idx + 1) % num_buffers]);\n+                swap(sim[idx], sim[(idx + 1) % num_buffers]);\n+                break;\n+            }\n+            if (multiple_exist && command-- == 0) {\n+                /* Copy assign. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = real[(idx + 1) % num_buffers];\n+                sim[idx] = sim[(idx + 1) % num_buffers];\n+                break;\n+            }\n+            if (multiple_exist && command-- == 0) {\n+                /* Move assign. */\n+                VecDeque<T> copy(real[(idx + 1) % num_buffers]);\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = std::move(copy);\n+                sim[idx] = sim[(idx + 1) % num_buffers];\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* reserve() */\n+                size_t res_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                size_t old_cap = real[idx].capacity();\n+                size_t old_size = real[idx].size();\n+                real[idx].reserve(res_size);\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == std::max(old_cap, res_size));\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* shrink_to_fit() */\n+                size_t old_size = real[idx].size();\n+                real[idx].shrink_to_fit();\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == old_size);\n+                break;\n+            }\n+            if (existing_buffer_non_full && command-- == 0) {\n+                /* push_back() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_back(*tmp);\n+                sim[idx].push_back(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (existing_buffer_non_full && command-- == 0) {\n+                /* push_back() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_back(*tmp);\n+                real[idx].push_back(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (existing_buffer_non_full && command-- == 0) {\n+                /* emplace_back() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_back(seed);\n+                real[idx].emplace_back(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (existing_buffer_non_full && command-- == 0) {\n+                /* push_front() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_front(*tmp);\n+                sim[idx].push_front(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (existing_buffer_non_full && command-- == 0) {\n+                /* push_front() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_front(*tmp);\n+                real[idx].push_front(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (existing_buffer_non_full && command-- == 0) {\n+                /* emplace_front() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_front(seed);\n+                real[idx].emplace_front(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (existing_buffer_non_empty && command-- == 0) {\n+                /* front() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].front() == real[idx].front());\n+                sim[idx].front() = *tmp;\n+                real[idx].front() = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (existing_buffer_non_empty && command-- == 0) {\n+                /* back() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].back() == real[idx].back());\n+                sim[idx].back() = *tmp;\n+                real[idx].back() = *tmp;\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (existing_buffer_non_empty && command-- == 0) {\n+                /* operator[] [modifying] */\n+                tmp = T(rng());\n+                size_t pos = provider.ConsumeIntegralInRange<size_t>(0, sim[idx].size() - 1);\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx][pos] == real[idx][pos]);\n+                sim[idx][pos] = *tmp;\n+                real[idx][pos] = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Fully compare the final state. */\n+    for (unsigned i = 0; i < sim.size(); ++i) {\n+        // Make sure const getters work.\n+        const VecDeque<T>& realbuf = real[i];\n+        const std::deque<T>& simbuf = sim[i];\n+        compare_fn(realbuf, simbuf);\n+        for (unsigned j = 0; j < sim.size(); ++j) {\n+            assert((realbuf == real[j]) == (simbuf == sim[j]));\n+            assert(((realbuf <=> real[j]) >= 0) == (simbuf >= sim[j]));\n+            assert(((realbuf <=> real[j]) <= 0) == (simbuf <= sim[j]));\n+        }\n+        // Clear out the buffers so we can check below that no objects exist anymore.\n+        sim[i].clear();\n+        real[i].clear();\n+    }\n+\n+    if constexpr (CheckNoneLeft) {\n+        tmp = std::nullopt;\n+        T::CheckNoneExist();\n+    }\n+}\n+\n+/** Data structure with built-in tracking of all existing objects. */\n+template<size_t Size>\n+class TrackedObj\n+{\n+    static_assert(Size > 0);\n+\n+    /* Data type for map that actually stores the object data.\n+     *\n+     * The key is a pointer to the TrackedObj, the value is the uint64_t it was initialized with.\n+     * Default-constructed and moved-from objects hold an std::nullopt.\n+     */\n+    using track_map_type = std::map<const TrackedObj<Size>*, std::optional<uint64_t>>;\n+\n+private:\n+\n+    /** Actual map. */\n+    static inline track_map_type g_tracker;\n+\n+    /** Iterators into the tracker map for this object.\n+     *\n+     * This is an array of size Size, all holding the same value, to give the object configurable\n+     * size. The value is g_tracker.end() if this object is not fully initialized. */\n+    typename track_map_type::iterator m_track_entry[Size];\n+\n+    void Check() const\n+    {\n+        auto it = g_tracker.find(this);\n+        for (size_t i = 0; i < Size; ++i) {\n+            assert(m_track_entry[i] == it);\n+        }\n+    }\n+\n+    /** Create entry for this object in g_tracker and populate m_track_entry. */\n+    void Register()\n+    {\n+        auto [it, inserted] = g_tracker.emplace(this, std::nullopt);\n+        assert(inserted);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = it;\n+        }\n+    }\n+\n+    void Deregister()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        g_tracker.erase(m_track_entry[0]);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = g_tracker.end();\n+        }\n+    }\n+\n+    /** Get value corresponding to this object in g_tracker. */\n+    std::optional<uint64_t>& Deref()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        return m_track_entry[0]->second;\n+    }\n+\n+    /** Get value corresponding to this object in g_tracker. */\n+    const std::optional<uint64_t>& Deref() const\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        return m_track_entry[0]->second;\n+    }\n+\n+public:\n+    ~TrackedObj() { Deregister(); }\n+    TrackedObj() { Register(); }\n+\n+    TrackedObj(uint64_t value)\n+    {\n+        Register();\n+        Deref() = value;\n+    }\n+\n+    TrackedObj(const TrackedObj& other)\n+    {\n+        Register();\n+        Deref() = other.Deref();\n+    }\n+\n+    TrackedObj(TrackedObj&& other)\n+    {\n+        Register();\n+        Deref() = other.Deref();\n+        other.Deref() = std::nullopt;\n+    }\n+\n+    TrackedObj& operator=(const TrackedObj& other)\n+    {\n+        Deref() = other.Deref();\n+        return *this;\n+    }\n+\n+    TrackedObj& operator=(TrackedObj&& other)\n+    {\n+        Deref() = other.Deref();\n+        other.Deref() = std::nullopt;\n+        return *this;\n+    }\n+\n+    friend bool operator==(const TrackedObj& a, const TrackedObj& b)\n+    {\n+        return a.Deref() == b.Deref();\n+    }\n+\n+    friend std::strong_ordering operator<=>(const TrackedObj& a, const TrackedObj& b)\n+    {\n+        // Libc++ 15 & 16 do not support std::optional<T>::operator<=> yet. See\n+        // https://reviews.llvm.org/D146392.\n+        if (!a.Deref().has_value() || !b.Deref().has_value()) {\n+            return a.Deref().has_value() <=> b.Deref().has_value();\n+        }\n+        return *a.Deref() <=> *b.Deref();\n+    }\n+\n+    static void CheckNoneExist()\n+    {\n+        assert(g_tracker.empty());\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(ringbuffer)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1617126230",
      "id" : 1617126230,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gY2NW",
      "original_commit_id" : "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_line" : 407,
      "original_position" : 407,
      "original_start_line" : null,
      "path" : "src/test/fuzz/vecdeque.cpp",
      "position" : null,
      "pull_request_review_id" : 2076000498,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617126230/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-28T12:19:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617126230",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/581308?v=4",
         "events_url" : "https://api.github.com/users/cbergqvist/events{/privacy}",
         "followers_url" : "https://api.github.com/users/cbergqvist/followers",
         "following_url" : "https://api.github.com/users/cbergqvist/following{/other_user}",
         "gists_url" : "https://api.github.com/users/cbergqvist/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/cbergqvist",
         "id" : 581308,
         "login" : "cbergqvist",
         "node_id" : "MDQ6VXNlcjU4MTMwOA==",
         "organizations_url" : "https://api.github.com/users/cbergqvist/orgs",
         "received_events_url" : "https://api.github.com/users/cbergqvist/received_events",
         "repos_url" : "https://api.github.com/users/cbergqvist/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/cbergqvist/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/cbergqvist/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/cbergqvist"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1617135964"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617135964"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Appears to be unused? Compiled without it on Clang.",
      "commit_id" : "03cfb8673669edaf275e382e4a0a83d6a377c259",
      "created_at" : "2024-05-28T12:13:23Z",
      "diff_hunk" : "@@ -0,0 +1,423 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/vecdeque.h>\n+\n+#include <iostream>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1617135964",
      "id" : 1617135964,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gY4lc",
      "original_commit_id" : "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_line" : 10,
      "original_position" : 10,
      "original_start_line" : null,
      "path" : "src/test/fuzz/vecdeque.cpp",
      "position" : null,
      "pull_request_review_id" : 2076000498,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617135964/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-28T12:19:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617135964",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/581308?v=4",
         "events_url" : "https://api.github.com/users/cbergqvist/events{/privacy}",
         "followers_url" : "https://api.github.com/users/cbergqvist/followers",
         "following_url" : "https://api.github.com/users/cbergqvist/following{/other_user}",
         "gists_url" : "https://api.github.com/users/cbergqvist/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/cbergqvist",
         "id" : 581308,
         "login" : "cbergqvist",
         "node_id" : "MDQ6VXNlcjU4MTMwOA==",
         "organizations_url" : "https://api.github.com/users/cbergqvist/orgs",
         "received_events_url" : "https://api.github.com/users/cbergqvist/received_events",
         "repos_url" : "https://api.github.com/users/cbergqvist/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/cbergqvist/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/cbergqvist/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/cbergqvist"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1617187166"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617187166"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "03cfb8673669edaf275e382e4a0a83d6a377c259",
      "created_at" : "2024-05-28T12:48:01Z",
      "diff_hunk" : "@@ -0,0 +1,252 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1617187166",
      "id" : 1617187166,
      "in_reply_to_id" : 1616905695,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gZFFe",
      "original_commit_id" : "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_line" : 29,
      "original_position" : 29,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : null,
      "pull_request_review_id" : 2082693918,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617187166/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-28T12:48:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617187166",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1617189498"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617189498"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It's an invariant, but it was poorly described, which I've hopefully addressed now (see `m_offset` docstring).",
      "commit_id" : "03cfb8673669edaf275e382e4a0a83d6a377c259",
      "created_at" : "2024-05-28T12:49:35Z",
      "diff_hunk" : "@@ -0,0 +1,252 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1617189498",
      "id" : 1617189498,
      "in_reply_to_id" : 1616940538,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gZFp6",
      "original_commit_id" : "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_line" : 39,
      "original_position" : 39,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : null,
      "pull_request_review_id" : 2082697686,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617189498/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-28T12:49:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617189498",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1617190116"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617190116"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't think so, since that case doesn't let us avoid the loop.",
      "commit_id" : "03cfb8673669edaf275e382e4a0a83d6a377c259",
      "created_at" : "2024-05-28T12:50:01Z",
      "diff_hunk" : "@@ -0,0 +1,252 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1617190116",
      "id" : 1617190116,
      "in_reply_to_id" : 1616978938,
      "line" : 58,
      "node_id" : "PRRC_kwDOABII585gZFzk",
      "original_commit_id" : "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_line" : 58,
      "original_position" : 57,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : 58,
      "pull_request_review_id" : 2082698640,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617190116/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-28T12:50:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617190116",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1617190282"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617190282"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Good catch, done.",
      "commit_id" : "03cfb8673669edaf275e382e4a0a83d6a377c259",
      "created_at" : "2024-05-28T12:50:08Z",
      "diff_hunk" : "@@ -0,0 +1,252 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size)\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            while (m_size < size) {\n+                std::construct_at<T>(m_buffer + Index(m_size));\n+                ++m_size;\n+            }\n+        }\n+    }\n+\n+    void clear() { ResizeDown(0); }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1617190282",
      "id" : 1617190282,
      "in_reply_to_id" : 1616992405,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gZF2K",
      "original_commit_id" : "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_line" : 117,
      "original_position" : 117,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : null,
      "pull_request_review_id" : 2082698943,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617190282/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-28T12:50:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617190282",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1617193263"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617193263"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think it's better to match `std::vector` behavior here (technically, spec doesn't say anything about the capacity of a copied element, but common implementations make it just big enough to hold the copied data, I believe).",
      "commit_id" : "03cfb8673669edaf275e382e4a0a83d6a377c259",
      "created_at" : "2024-05-28T12:52:12Z",
      "diff_hunk" : "@@ -0,0 +1,252 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size)\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            while (m_size < size) {\n+                std::construct_at<T>(m_buffer + Index(m_size));\n+                ++m_size;\n+            }\n+        }\n+    }\n+\n+    void clear() { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1617193263",
      "id" : 1617193263,
      "in_reply_to_id" : 1617005071,
      "line" : 130,
      "node_id" : "PRRC_kwDOABII585gZGkv",
      "original_commit_id" : "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_line" : 130,
      "original_position" : 128,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : 130,
      "pull_request_review_id" : 2082703737,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617193263/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-28T12:52:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617193263",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1617193395"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617193395"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "03cfb8673669edaf275e382e4a0a83d6a377c259",
      "created_at" : "2024-05-28T12:52:18Z",
      "diff_hunk" : "@@ -0,0 +1,423 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/vecdeque.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on VecDeque type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<VecDeque<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const VecDeque<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        int command = provider.ConsumeIntegral<uint8_t>() % 32;\n+        unsigned idx = real.empty() ? 0 : provider.ConsumeIntegralInRange<unsigned>(0, real.size() - 1);\n+        const size_t num_buffers = sim.size();\n+        // Pick one operation based on value of command. Not all operations are always applicable.\n+        // Loop through the applicable ones until command reaches 0 (which avoids the need to\n+        // compute the number of applicable commands ahead of time).\n+        const bool non_empty{num_buffers != 0};\n+        const bool non_full{num_buffers < MAX_BUFFERS};\n+        const bool partially_full{non_empty && non_full};\n+        const bool multiple_exist{num_buffers > 1};\n+        const bool existing_buffer_non_full{non_empty && sim[idx].size() < MAX_BUFFER_SIZE};\n+        const bool existing_buffer_non_empty{non_empty && !sim[idx].empty()};\n+        assert(non_full || non_empty);\n+        while (true) {\n+            if (non_full && command-- == 0) {\n+                /* Default construct. */\n+                real.emplace_back();\n+                sim.emplace_back();\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* resize() */\n+                size_t new_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                real[idx].resize(new_size);\n+                sim[idx].resize(new_size);\n+                assert(real[idx].size() == new_size);\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* clear() */\n+                real[idx].clear();\n+                sim[idx].clear();\n+                assert(real[idx].empty());\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* Copy construct default. */\n+                real[idx] = VecDeque<T>();\n+                sim[idx].clear();\n+                assert(real[idx].size() == 0);\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* Destruct. */\n+                compare_fn(real.back(), sim.back());\n+                real.pop_back();\n+                sim.pop_back();\n+                break;\n+            }\n+            if (partially_full && command-- == 0) {\n+                /* Copy construct. */\n+                real.emplace_back(real[idx]);\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (partially_full && command-- == 0) {\n+                /* Move construct. */\n+                VecDeque<T> copy(real[idx]);\n+                real.emplace_back(std::move(copy));\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (multiple_exist && command-- == 0) {\n+                /* swap() */\n+                swap(real[idx], real[(idx + 1) % num_buffers]);\n+                swap(sim[idx], sim[(idx + 1) % num_buffers]);\n+                break;\n+            }\n+            if (multiple_exist && command-- == 0) {\n+                /* Copy assign. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = real[(idx + 1) % num_buffers];\n+                sim[idx] = sim[(idx + 1) % num_buffers];\n+                break;\n+            }\n+            if (multiple_exist && command-- == 0) {\n+                /* Move assign. */\n+                VecDeque<T> copy(real[(idx + 1) % num_buffers]);\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = std::move(copy);\n+                sim[idx] = sim[(idx + 1) % num_buffers];\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* reserve() */\n+                size_t res_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                size_t old_cap = real[idx].capacity();\n+                size_t old_size = real[idx].size();\n+                real[idx].reserve(res_size);\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == std::max(old_cap, res_size));\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* shrink_to_fit() */\n+                size_t old_size = real[idx].size();\n+                real[idx].shrink_to_fit();\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == old_size);\n+                break;\n+            }\n+            if (existing_buffer_non_full && command-- == 0) {\n+                /* push_back() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_back(*tmp);\n+                sim[idx].push_back(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (existing_buffer_non_full && command-- == 0) {\n+                /* push_back() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_back(*tmp);\n+                real[idx].push_back(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (existing_buffer_non_full && command-- == 0) {\n+                /* emplace_back() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_back(seed);\n+                real[idx].emplace_back(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (existing_buffer_non_full && command-- == 0) {\n+                /* push_front() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_front(*tmp);\n+                sim[idx].push_front(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (existing_buffer_non_full && command-- == 0) {\n+                /* push_front() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_front(*tmp);\n+                real[idx].push_front(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (existing_buffer_non_full && command-- == 0) {\n+                /* emplace_front() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_front(seed);\n+                real[idx].emplace_front(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (existing_buffer_non_empty && command-- == 0) {\n+                /* front() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].front() == real[idx].front());\n+                sim[idx].front() = *tmp;\n+                real[idx].front() = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (existing_buffer_non_empty && command-- == 0) {\n+                /* back() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].back() == real[idx].back());\n+                sim[idx].back() = *tmp;\n+                real[idx].back() = *tmp;\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (existing_buffer_non_empty && command-- == 0) {\n+                /* operator[] [modifying] */\n+                tmp = T(rng());\n+                size_t pos = provider.ConsumeIntegralInRange<size_t>(0, sim[idx].size() - 1);\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx][pos] == real[idx][pos]);\n+                sim[idx][pos] = *tmp;\n+                real[idx][pos] = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Fully compare the final state. */\n+    for (unsigned i = 0; i < sim.size(); ++i) {\n+        // Make sure const getters work.\n+        const VecDeque<T>& realbuf = real[i];\n+        const std::deque<T>& simbuf = sim[i];\n+        compare_fn(realbuf, simbuf);\n+        for (unsigned j = 0; j < sim.size(); ++j) {\n+            assert((realbuf == real[j]) == (simbuf == sim[j]));\n+            assert(((realbuf <=> real[j]) >= 0) == (simbuf >= sim[j]));\n+            assert(((realbuf <=> real[j]) <= 0) == (simbuf <= sim[j]));\n+        }\n+        // Clear out the buffers so we can check below that no objects exist anymore.\n+        sim[i].clear();\n+        real[i].clear();\n+    }\n+\n+    if constexpr (CheckNoneLeft) {\n+        tmp = std::nullopt;\n+        T::CheckNoneExist();\n+    }\n+}\n+\n+/** Data structure with built-in tracking of all existing objects. */\n+template<size_t Size>\n+class TrackedObj\n+{\n+    static_assert(Size > 0);\n+\n+    /* Data type for map that actually stores the object data.\n+     *\n+     * The key is a pointer to the TrackedObj, the value is the uint64_t it was initialized with.\n+     * Default-constructed and moved-from objects hold an std::nullopt.\n+     */\n+    using track_map_type = std::map<const TrackedObj<Size>*, std::optional<uint64_t>>;\n+\n+private:\n+\n+    /** Actual map. */\n+    static inline track_map_type g_tracker;\n+\n+    /** Iterators into the tracker map for this object.\n+     *\n+     * This is an array of size Size, all holding the same value, to give the object configurable\n+     * size. The value is g_tracker.end() if this object is not fully initialized. */\n+    typename track_map_type::iterator m_track_entry[Size];\n+\n+    void Check() const\n+    {\n+        auto it = g_tracker.find(this);\n+        for (size_t i = 0; i < Size; ++i) {\n+            assert(m_track_entry[i] == it);\n+        }\n+    }\n+\n+    /** Create entry for this object in g_tracker and populate m_track_entry. */\n+    void Register()\n+    {\n+        auto [it, inserted] = g_tracker.emplace(this, std::nullopt);\n+        assert(inserted);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = it;\n+        }\n+    }\n+\n+    void Deregister()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        g_tracker.erase(m_track_entry[0]);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = g_tracker.end();\n+        }\n+    }\n+\n+    /** Get value corresponding to this object in g_tracker. */\n+    std::optional<uint64_t>& Deref()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        return m_track_entry[0]->second;\n+    }\n+\n+    /** Get value corresponding to this object in g_tracker. */\n+    const std::optional<uint64_t>& Deref() const\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        return m_track_entry[0]->second;\n+    }\n+\n+public:\n+    ~TrackedObj() { Deregister(); }\n+    TrackedObj() { Register(); }\n+\n+    TrackedObj(uint64_t value)\n+    {\n+        Register();\n+        Deref() = value;\n+    }\n+\n+    TrackedObj(const TrackedObj& other)\n+    {\n+        Register();\n+        Deref() = other.Deref();\n+    }\n+\n+    TrackedObj(TrackedObj&& other)\n+    {\n+        Register();\n+        Deref() = other.Deref();\n+        other.Deref() = std::nullopt;\n+    }\n+\n+    TrackedObj& operator=(const TrackedObj& other)\n+    {\n+        Deref() = other.Deref();\n+        return *this;\n+    }\n+\n+    TrackedObj& operator=(TrackedObj&& other)\n+    {\n+        Deref() = other.Deref();\n+        other.Deref() = std::nullopt;\n+        return *this;\n+    }\n+\n+    friend bool operator==(const TrackedObj& a, const TrackedObj& b)\n+    {\n+        return a.Deref() == b.Deref();\n+    }\n+\n+    friend std::strong_ordering operator<=>(const TrackedObj& a, const TrackedObj& b)\n+    {\n+        // Libc++ 15 & 16 do not support std::optional<T>::operator<=> yet. See\n+        // https://reviews.llvm.org/D146392.\n+        if (!a.Deref().has_value() || !b.Deref().has_value()) {\n+            return a.Deref().has_value() <=> b.Deref().has_value();\n+        }\n+        return *a.Deref() <=> *b.Deref();\n+    }\n+\n+    static void CheckNoneExist()\n+    {\n+        assert(g_tracker.empty());\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(ringbuffer)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1617193395",
      "id" : 1617193395,
      "in_reply_to_id" : 1617126230,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gZGmz",
      "original_commit_id" : "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_line" : 407,
      "original_position" : 407,
      "original_start_line" : null,
      "path" : "src/test/fuzz/vecdeque.cpp",
      "position" : null,
      "pull_request_review_id" : 2082703918,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617193395/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-28T12:52:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617193395",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1617197710"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617197710"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed!",
      "commit_id" : "03cfb8673669edaf275e382e4a0a83d6a377c259",
      "created_at" : "2024-05-28T12:55:11Z",
      "diff_hunk" : "@@ -0,0 +1,423 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/vecdeque.h>\n+\n+#include <iostream>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1617197710",
      "id" : 1617197710,
      "in_reply_to_id" : 1617135964,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gZHqO",
      "original_commit_id" : "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_line" : 10,
      "original_position" : 10,
      "original_start_line" : null,
      "path" : "src/test/fuzz/vecdeque.cpp",
      "position" : null,
      "pull_request_review_id" : 2082710679,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617197710/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-28T12:55:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617197710",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1619032750"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1619032750"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Using this approach instead of two distinct signatures -- `void push_back(const T&)` and `void push_back(T&&)`  -- can lead to some confusion in error messages.\r\n\r\nConsider this:\r\n```c++\r\nstruct A { int m_a{0}; } a;\r\nstruct B { int m_b{0}; } b;\r\n\r\nstd::vector<A> v;\r\nv.push_back(a);\r\n// ERROR:\r\n// no known conversion for argument 1 from âBâ to âconst std::vector<A>::value_type&â {aka âconst A&â}\r\n// no known conversion for argument 1 from âBâ to âstd::vector<A>::value_type&&â {aka âA&&â}\r\n// v.push_back(b);  \r\n\r\n\r\nVecDeque<A> vd;\r\nvd.push_back(a);\r\n// ERROR:\r\n// cannot convert âBâ to âintâ in initialization\r\n// vd.push_back(b);\r\n```",
      "commit_id" : "03cfb8673669edaf275e382e4a0a83d6a377c259",
      "created_at" : "2024-05-29T14:50:16Z",
      "diff_hunk" : "@@ -0,0 +1,254 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise\n+     *  m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size) noexcept\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            while (m_size < size) {\n+                std::construct_at<T>(m_buffer + Index(m_size));\n+                ++m_size;\n+            }\n+        }\n+    }\n+\n+    void clear() noexcept { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at<T>(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;\n+        for (size_t i = 0; i < a.m_size; ++i) {\n+            if (a[i] != b[i]) return false;\n+        }\n+        return true;\n+    }\n+\n+    std::strong_ordering friend operator<=>(const VecDeque& a, const VecDeque& b)\n+    {\n+        size_t pos_a{0}, pos_b{0};\n+        while (pos_a < a.m_size && pos_b < b.m_size) {\n+            auto cmp = a[pos_a++] <=> b[pos_b++];\n+            if (cmp != 0) return cmp;\n+        }\n+        return a.m_size <=> b.m_size;\n+    }\n+\n+    void reserve(size_t capacity)\n+    {\n+        if (capacity > m_capacity) Reallocate(capacity);\n+    }\n+\n+    void shrink_to_fit()\n+    {\n+        if (m_capacity > m_size) Reallocate(m_size);\n+    }\n+\n+    template<typename U>\n+    void push_back(U&& elem)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1619032750",
      "id" : 1619032750,
      "line" : 192,
      "node_id" : "PRRC_kwDOABII585ggHqu",
      "original_commit_id" : "03cfb8673669edaf275e382e4a0a83d6a377c259",
      "original_line" : 192,
      "original_position" : 192,
      "original_start_line" : 191,
      "path" : "src/util/vecdeque.h",
      "position" : 192,
      "pull_request_review_id" : 2085655168,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1619032750/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 191,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2024-05-29T14:50:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1619032750",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1619089090"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1619089090"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Your code here doesn't use `B` anywhere, so I suspect the comments don't match the code.",
      "commit_id" : "03cfb8673669edaf275e382e4a0a83d6a377c259",
      "created_at" : "2024-05-29T15:26:12Z",
      "diff_hunk" : "@@ -0,0 +1,254 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise\n+     *  m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size) noexcept\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            while (m_size < size) {\n+                std::construct_at<T>(m_buffer + Index(m_size));\n+                ++m_size;\n+            }\n+        }\n+    }\n+\n+    void clear() noexcept { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at<T>(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;\n+        for (size_t i = 0; i < a.m_size; ++i) {\n+            if (a[i] != b[i]) return false;\n+        }\n+        return true;\n+    }\n+\n+    std::strong_ordering friend operator<=>(const VecDeque& a, const VecDeque& b)\n+    {\n+        size_t pos_a{0}, pos_b{0};\n+        while (pos_a < a.m_size && pos_b < b.m_size) {\n+            auto cmp = a[pos_a++] <=> b[pos_b++];\n+            if (cmp != 0) return cmp;\n+        }\n+        return a.m_size <=> b.m_size;\n+    }\n+\n+    void reserve(size_t capacity)\n+    {\n+        if (capacity > m_capacity) Reallocate(capacity);\n+    }\n+\n+    void shrink_to_fit()\n+    {\n+        if (m_capacity > m_size) Reallocate(m_size);\n+    }\n+\n+    template<typename U>\n+    void push_back(U&& elem)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1619089090",
      "id" : 1619089090,
      "in_reply_to_id" : 1619032750,
      "line" : 192,
      "node_id" : "PRRC_kwDOABII585ggVbC",
      "original_commit_id" : "03cfb8673669edaf275e382e4a0a83d6a377c259",
      "original_line" : 192,
      "original_position" : 192,
      "original_start_line" : 191,
      "path" : "src/util/vecdeque.h",
      "position" : 192,
      "pull_request_review_id" : 2085746802,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1619089090/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 191,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2024-05-29T15:26:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1619089090",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1619408564"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1619408564"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think I understand though; the argument to `push_back` or `push_front` should not be inferred but be fixed to be (a reference to) `T`. Done.",
      "commit_id" : "a5a27bae11e14743c08812307cedc9dfb47efebf",
      "created_at" : "2024-05-29T19:58:38Z",
      "diff_hunk" : "@@ -0,0 +1,254 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise\n+     *  m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size) noexcept\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            while (m_size < size) {\n+                std::construct_at<T>(m_buffer + Index(m_size));\n+                ++m_size;\n+            }\n+        }\n+    }\n+\n+    void clear() noexcept { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at<T>(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;\n+        for (size_t i = 0; i < a.m_size; ++i) {\n+            if (a[i] != b[i]) return false;\n+        }\n+        return true;\n+    }\n+\n+    std::strong_ordering friend operator<=>(const VecDeque& a, const VecDeque& b)\n+    {\n+        size_t pos_a{0}, pos_b{0};\n+        while (pos_a < a.m_size && pos_b < b.m_size) {\n+            auto cmp = a[pos_a++] <=> b[pos_b++];\n+            if (cmp != 0) return cmp;\n+        }\n+        return a.m_size <=> b.m_size;\n+    }\n+\n+    void reserve(size_t capacity)\n+    {\n+        if (capacity > m_capacity) Reallocate(capacity);\n+    }\n+\n+    void shrink_to_fit()\n+    {\n+        if (m_capacity > m_size) Reallocate(m_size);\n+    }\n+\n+    template<typename U>\n+    void push_back(U&& elem)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1619408564",
      "id" : 1619408564,
      "in_reply_to_id" : 1619032750,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585ghja0",
      "original_commit_id" : "03cfb8673669edaf275e382e4a0a83d6a377c259",
      "original_line" : 192,
      "original_position" : 192,
      "original_start_line" : 191,
      "path" : "src/util/vecdeque.h",
      "position" : null,
      "pull_request_review_id" : 2086286791,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1619408564/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2024-05-29T19:58:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1619408564",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1620728482"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620728482"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Does `std::move(const T&)` make sense here? The `std::construct_at` won't be able to modify `elem` due to its `const`ness, right?",
      "commit_id" : "a5a27bae11e14743c08812307cedc9dfb47efebf",
      "created_at" : "2024-05-30T13:32:54Z",
      "diff_hunk" : "@@ -0,0 +1,268 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise\n+     *  m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size) noexcept\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            while (m_size < size) {\n+                std::construct_at(m_buffer + Index(m_size));\n+                ++m_size;\n+            }\n+        }\n+    }\n+\n+    void clear() noexcept { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;\n+        for (size_t i = 0; i < a.m_size; ++i) {\n+            if (a[i] != b[i]) return false;\n+        }\n+        return true;\n+    }\n+\n+    std::strong_ordering friend operator<=>(const VecDeque& a, const VecDeque& b)\n+    {\n+        size_t pos_a{0}, pos_b{0};\n+        while (pos_a < a.m_size && pos_b < b.m_size) {\n+            auto cmp = a[pos_a++] <=> b[pos_b++];\n+            if (cmp != 0) return cmp;\n+        }\n+        return a.m_size <=> b.m_size;\n+    }\n+\n+    void reserve(size_t capacity)\n+    {\n+        if (capacity > m_capacity) Reallocate(capacity);\n+    }\n+\n+    void shrink_to_fit()\n+    {\n+        if (m_capacity > m_size) Reallocate(m_size);\n+    }\n+\n+    void push_back(T&& elem)\n+    {\n+        if (m_size == m_capacity) Reallocate((m_size + 1) * 2);\n+        std::construct_at(m_buffer + Index(m_size), std::move(elem));\n+        ++m_size;\n+    }\n+\n+    void push_back(const T& elem)\n+    {\n+        if (m_size == m_capacity) Reallocate((m_size + 1) * 2);\n+        std::construct_at(m_buffer + Index(m_size), std::move(elem));\n+        ++m_size;\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1620728482",
      "id" : 1620728482,
      "line" : 203,
      "node_id" : "PRRC_kwDOABII585gmlqi",
      "original_commit_id" : "a5a27bae11e14743c08812307cedc9dfb47efebf",
      "original_line" : 203,
      "original_position" : 203,
      "original_start_line" : 198,
      "path" : "src/util/vecdeque.h",
      "position" : 203,
      "pull_request_review_id" : 2088303122,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620728482/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 198,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2024-05-30T13:36:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620728482",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1620771700"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620771700"
         }
      },
      "author_association" : "MEMBER",
      "body" : "That depends on `T`'s move constructor. Typically, this won't do anything, but it's not impossible for a `T::T(const T&&)` constructor to exist (and this may make sense if `T` has `mutable` member variables).",
      "commit_id" : "a5a27bae11e14743c08812307cedc9dfb47efebf",
      "created_at" : "2024-05-30T13:55:48Z",
      "diff_hunk" : "@@ -0,0 +1,268 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise\n+     *  m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size) noexcept\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            while (m_size < size) {\n+                std::construct_at(m_buffer + Index(m_size));\n+                ++m_size;\n+            }\n+        }\n+    }\n+\n+    void clear() noexcept { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;\n+        for (size_t i = 0; i < a.m_size; ++i) {\n+            if (a[i] != b[i]) return false;\n+        }\n+        return true;\n+    }\n+\n+    std::strong_ordering friend operator<=>(const VecDeque& a, const VecDeque& b)\n+    {\n+        size_t pos_a{0}, pos_b{0};\n+        while (pos_a < a.m_size && pos_b < b.m_size) {\n+            auto cmp = a[pos_a++] <=> b[pos_b++];\n+            if (cmp != 0) return cmp;\n+        }\n+        return a.m_size <=> b.m_size;\n+    }\n+\n+    void reserve(size_t capacity)\n+    {\n+        if (capacity > m_capacity) Reallocate(capacity);\n+    }\n+\n+    void shrink_to_fit()\n+    {\n+        if (m_capacity > m_size) Reallocate(m_size);\n+    }\n+\n+    void push_back(T&& elem)\n+    {\n+        if (m_size == m_capacity) Reallocate((m_size + 1) * 2);\n+        std::construct_at(m_buffer + Index(m_size), std::move(elem));\n+        ++m_size;\n+    }\n+\n+    void push_back(const T& elem)\n+    {\n+        if (m_size == m_capacity) Reallocate((m_size + 1) * 2);\n+        std::construct_at(m_buffer + Index(m_size), std::move(elem));\n+        ++m_size;\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1620771700",
      "id" : 1620771700,
      "in_reply_to_id" : 1620728482,
      "line" : 203,
      "node_id" : "PRRC_kwDOABII585gmwN0",
      "original_commit_id" : "a5a27bae11e14743c08812307cedc9dfb47efebf",
      "original_line" : 203,
      "original_position" : 203,
      "original_start_line" : 198,
      "path" : "src/util/vecdeque.h",
      "position" : 203,
      "pull_request_review_id" : 2088359274,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620771700/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 198,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2024-05-30T13:55:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620771700",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1620773911"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620773911"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Actually, no, you're right. Even if this does anything, it won't be the desired behavior. Will remove.",
      "commit_id" : "a5a27bae11e14743c08812307cedc9dfb47efebf",
      "created_at" : "2024-05-30T13:56:58Z",
      "diff_hunk" : "@@ -0,0 +1,268 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise\n+     *  m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size) noexcept\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            while (m_size < size) {\n+                std::construct_at(m_buffer + Index(m_size));\n+                ++m_size;\n+            }\n+        }\n+    }\n+\n+    void clear() noexcept { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;\n+        for (size_t i = 0; i < a.m_size; ++i) {\n+            if (a[i] != b[i]) return false;\n+        }\n+        return true;\n+    }\n+\n+    std::strong_ordering friend operator<=>(const VecDeque& a, const VecDeque& b)\n+    {\n+        size_t pos_a{0}, pos_b{0};\n+        while (pos_a < a.m_size && pos_b < b.m_size) {\n+            auto cmp = a[pos_a++] <=> b[pos_b++];\n+            if (cmp != 0) return cmp;\n+        }\n+        return a.m_size <=> b.m_size;\n+    }\n+\n+    void reserve(size_t capacity)\n+    {\n+        if (capacity > m_capacity) Reallocate(capacity);\n+    }\n+\n+    void shrink_to_fit()\n+    {\n+        if (m_capacity > m_size) Reallocate(m_size);\n+    }\n+\n+    void push_back(T&& elem)\n+    {\n+        if (m_size == m_capacity) Reallocate((m_size + 1) * 2);\n+        std::construct_at(m_buffer + Index(m_size), std::move(elem));\n+        ++m_size;\n+    }\n+\n+    void push_back(const T& elem)\n+    {\n+        if (m_size == m_capacity) Reallocate((m_size + 1) * 2);\n+        std::construct_at(m_buffer + Index(m_size), std::move(elem));\n+        ++m_size;\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1620773911",
      "id" : 1620773911,
      "in_reply_to_id" : 1620728482,
      "line" : 203,
      "node_id" : "PRRC_kwDOABII585gmwwX",
      "original_commit_id" : "a5a27bae11e14743c08812307cedc9dfb47efebf",
      "original_line" : 203,
      "original_position" : 203,
      "original_start_line" : 198,
      "path" : "src/util/vecdeque.h",
      "position" : 203,
      "pull_request_review_id" : 2088362062,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620773911/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 198,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2024-05-30T13:56:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620773911",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1620955671"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620955671"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It's a shame that this triggers a reallocation when `m_offset == 0`. Might it be worth optimizing for that case?",
      "commit_id" : "ecb278bb19c53b007380e262fa86d809255eeb49",
      "created_at" : "2024-05-30T15:27:28Z",
      "diff_hunk" : "@@ -0,0 +1,268 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise\n+     *  m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size) noexcept\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            while (m_size < size) {\n+                std::construct_at(m_buffer + Index(m_size));\n+                ++m_size;\n+            }\n+        }\n+    }\n+\n+    void clear() noexcept { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;\n+        for (size_t i = 0; i < a.m_size; ++i) {\n+            if (a[i] != b[i]) return false;\n+        }\n+        return true;\n+    }\n+\n+    std::strong_ordering friend operator<=>(const VecDeque& a, const VecDeque& b)\n+    {\n+        size_t pos_a{0}, pos_b{0};\n+        while (pos_a < a.m_size && pos_b < b.m_size) {\n+            auto cmp = a[pos_a++] <=> b[pos_b++];\n+            if (cmp != 0) return cmp;\n+        }\n+        return a.m_size <=> b.m_size;\n+    }\n+\n+    void reserve(size_t capacity)\n+    {\n+        if (capacity > m_capacity) Reallocate(capacity);\n+    }\n+\n+    void shrink_to_fit()\n+    {\n+        if (m_capacity > m_size) Reallocate(m_size);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1620955671",
      "id" : 1620955671,
      "line" : 188,
      "node_id" : "PRRC_kwDOABII585gndIX",
      "original_commit_id" : "0eba7219a2ab94e2aa92f35ea1b681f168ac6384",
      "original_line" : 188,
      "original_position" : 188,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : 188,
      "pull_request_review_id" : 2088628907,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620955671/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-30T15:27:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620955671",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=4",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "node_id" : "MDQ6VXNlcjQxNzA0Mw==",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1620982315"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620982315"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Actually, same comment for `operator=` as well. Maybe it'd be worth a special case in `Reallocate()` itself instead.",
      "commit_id" : "ecb278bb19c53b007380e262fa86d809255eeb49",
      "created_at" : "2024-05-30T15:41:13Z",
      "diff_hunk" : "@@ -0,0 +1,268 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise\n+     *  m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size) noexcept\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            while (m_size < size) {\n+                std::construct_at(m_buffer + Index(m_size));\n+                ++m_size;\n+            }\n+        }\n+    }\n+\n+    void clear() noexcept { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;\n+        for (size_t i = 0; i < a.m_size; ++i) {\n+            if (a[i] != b[i]) return false;\n+        }\n+        return true;\n+    }\n+\n+    std::strong_ordering friend operator<=>(const VecDeque& a, const VecDeque& b)\n+    {\n+        size_t pos_a{0}, pos_b{0};\n+        while (pos_a < a.m_size && pos_b < b.m_size) {\n+            auto cmp = a[pos_a++] <=> b[pos_b++];\n+            if (cmp != 0) return cmp;\n+        }\n+        return a.m_size <=> b.m_size;\n+    }\n+\n+    void reserve(size_t capacity)\n+    {\n+        if (capacity > m_capacity) Reallocate(capacity);\n+    }\n+\n+    void shrink_to_fit()\n+    {\n+        if (m_capacity > m_size) Reallocate(m_size);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1620982315",
      "id" : 1620982315,
      "in_reply_to_id" : 1620955671,
      "line" : 188,
      "node_id" : "PRRC_kwDOABII585gnjor",
      "original_commit_id" : "0eba7219a2ab94e2aa92f35ea1b681f168ac6384",
      "original_line" : 188,
      "original_position" : 188,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : 188,
      "pull_request_review_id" : 2088687850,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620982315/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-30T15:41:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620982315",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=4",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "node_id" : "MDQ6VXNlcjQxNzA0Mw==",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1620986696"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620986696"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Are you imagining something like `realloc` on the buffer? AFAIK that just doesn't exist in C++; if you want to shrink an object, you need to construct a new object of smaller size and copy over.",
      "commit_id" : "ecb278bb19c53b007380e262fa86d809255eeb49",
      "created_at" : "2024-05-30T15:44:15Z",
      "diff_hunk" : "@@ -0,0 +1,268 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise\n+     *  m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size) noexcept\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            while (m_size < size) {\n+                std::construct_at(m_buffer + Index(m_size));\n+                ++m_size;\n+            }\n+        }\n+    }\n+\n+    void clear() noexcept { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;\n+        for (size_t i = 0; i < a.m_size; ++i) {\n+            if (a[i] != b[i]) return false;\n+        }\n+        return true;\n+    }\n+\n+    std::strong_ordering friend operator<=>(const VecDeque& a, const VecDeque& b)\n+    {\n+        size_t pos_a{0}, pos_b{0};\n+        while (pos_a < a.m_size && pos_b < b.m_size) {\n+            auto cmp = a[pos_a++] <=> b[pos_b++];\n+            if (cmp != 0) return cmp;\n+        }\n+        return a.m_size <=> b.m_size;\n+    }\n+\n+    void reserve(size_t capacity)\n+    {\n+        if (capacity > m_capacity) Reallocate(capacity);\n+    }\n+\n+    void shrink_to_fit()\n+    {\n+        if (m_capacity > m_size) Reallocate(m_size);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1620986696",
      "id" : 1620986696,
      "in_reply_to_id" : 1620955671,
      "line" : 188,
      "node_id" : "PRRC_kwDOABII585gnktI",
      "original_commit_id" : "0eba7219a2ab94e2aa92f35ea1b681f168ac6384",
      "original_line" : 188,
      "original_position" : 188,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : 188,
      "pull_request_review_id" : 2088698131,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620986696/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-30T15:44:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620986696",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1621023146"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1621023146"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Grr, right.",
      "commit_id" : "ecb278bb19c53b007380e262fa86d809255eeb49",
      "created_at" : "2024-05-30T16:08:29Z",
      "diff_hunk" : "@@ -0,0 +1,268 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise\n+     *  m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size) noexcept\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            while (m_size < size) {\n+                std::construct_at(m_buffer + Index(m_size));\n+                ++m_size;\n+            }\n+        }\n+    }\n+\n+    void clear() noexcept { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;\n+        for (size_t i = 0; i < a.m_size; ++i) {\n+            if (a[i] != b[i]) return false;\n+        }\n+        return true;\n+    }\n+\n+    std::strong_ordering friend operator<=>(const VecDeque& a, const VecDeque& b)\n+    {\n+        size_t pos_a{0}, pos_b{0};\n+        while (pos_a < a.m_size && pos_b < b.m_size) {\n+            auto cmp = a[pos_a++] <=> b[pos_b++];\n+            if (cmp != 0) return cmp;\n+        }\n+        return a.m_size <=> b.m_size;\n+    }\n+\n+    void reserve(size_t capacity)\n+    {\n+        if (capacity > m_capacity) Reallocate(capacity);\n+    }\n+\n+    void shrink_to_fit()\n+    {\n+        if (m_capacity > m_size) Reallocate(m_size);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1621023146",
      "id" : 1621023146,
      "in_reply_to_id" : 1620955671,
      "line" : 188,
      "node_id" : "PRRC_kwDOABII585gntmq",
      "original_commit_id" : "0eba7219a2ab94e2aa92f35ea1b681f168ac6384",
      "original_line" : 188,
      "original_position" : 188,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : 188,
      "pull_request_review_id" : 2088752200,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1621023146/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-30T16:08:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1621023146",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=4",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "node_id" : "MDQ6VXNlcjQxNzA0Mw==",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626177967"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626177967"
         }
      },
      "author_association" : "MEMBER",
      "body" : "you can ignore this if you don't like it\r\n```Suggestion\r\n    /** m_buffer + m_offset points to first object in queue. m_offset = 0 if m_capacity is 0; otherwise\r\n```",
      "commit_id" : "e4ecb8217ada3dae1c1645a8d0a12e14b0f935da",
      "created_at" : "2024-06-04T15:00:56Z",
      "diff_hunk" : "@@ -0,0 +1,268 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626177967",
      "id" : 1626177967,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585g7YGv",
      "original_commit_id" : "0eba7219a2ab94e2aa92f35ea1b681f168ac6384",
      "original_line" : 27,
      "original_position" : 27,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : null,
      "pull_request_review_id" : 2096682721,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626177967/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-06-04T19:31:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626177967",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626291871"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626291871"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`s/Index/BufferIndex/` reduces my mental load fwiw",
      "commit_id" : "e4ecb8217ada3dae1c1645a8d0a12e14b0f935da",
      "created_at" : "2024-06-04T16:19:06Z",
      "diff_hunk" : "@@ -0,0 +1,268 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise\n+     *  m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626291871",
      "id" : 1626291871,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585g7z6f",
      "original_commit_id" : "0eba7219a2ab94e2aa92f35ea1b681f168ac6384",
      "original_line" : 73,
      "original_position" : 73,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : null,
      "pull_request_review_id" : 2096682721,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626291871/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-06-04T19:31:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626291871",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626321220"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626321220"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Putting bounds on the capacity growth seems useful here and a few other spots, even if it doesn't necessarily have to be this tight.\r\n```\r\n                if (old_cap > old_size) {\r\n                    assert(real[idx].capacity() == old_cap);\r\n                } else {\r\n                    assert(real[idx].capacity() > old_cap);\r\n                    assert(real[idx].capacity() <= 2 * (old_cap + 1));\r\n                }\r\n```",
      "commit_id" : "e4ecb8217ada3dae1c1645a8d0a12e14b0f935da",
      "created_at" : "2024-06-04T16:43:42Z",
      "diff_hunk" : "@@ -0,0 +1,422 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/vecdeque.h>\n+\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on VecDeque type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<VecDeque<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const VecDeque<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        int command = provider.ConsumeIntegral<uint8_t>() % 32;\n+        unsigned idx = real.empty() ? 0 : provider.ConsumeIntegralInRange<unsigned>(0, real.size() - 1);\n+        const size_t num_buffers = sim.size();\n+        // Pick one operation based on value of command. Not all operations are always applicable.\n+        // Loop through the applicable ones until command reaches 0 (which avoids the need to\n+        // compute the number of applicable commands ahead of time).\n+        const bool non_empty{num_buffers != 0};\n+        const bool non_full{num_buffers < MAX_BUFFERS};\n+        const bool partially_full{non_empty && non_full};\n+        const bool multiple_exist{num_buffers > 1};\n+        const bool existing_buffer_non_full{non_empty && sim[idx].size() < MAX_BUFFER_SIZE};\n+        const bool existing_buffer_non_empty{non_empty && !sim[idx].empty()};\n+        assert(non_full || non_empty);\n+        while (true) {\n+            if (non_full && command-- == 0) {\n+                /* Default construct. */\n+                real.emplace_back();\n+                sim.emplace_back();\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* resize() */\n+                size_t new_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                real[idx].resize(new_size);\n+                sim[idx].resize(new_size);\n+                assert(real[idx].size() == new_size);\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* clear() */\n+                real[idx].clear();\n+                sim[idx].clear();\n+                assert(real[idx].empty());\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* Copy construct default. */\n+                real[idx] = VecDeque<T>();\n+                sim[idx].clear();\n+                assert(real[idx].size() == 0);\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* Destruct. */\n+                compare_fn(real.back(), sim.back());\n+                real.pop_back();\n+                sim.pop_back();\n+                break;\n+            }\n+            if (partially_full && command-- == 0) {\n+                /* Copy construct. */\n+                real.emplace_back(real[idx]);\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (partially_full && command-- == 0) {\n+                /* Move construct. */\n+                VecDeque<T> copy(real[idx]);\n+                real.emplace_back(std::move(copy));\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (multiple_exist && command-- == 0) {\n+                /* swap() */\n+                swap(real[idx], real[(idx + 1) % num_buffers]);\n+                swap(sim[idx], sim[(idx + 1) % num_buffers]);\n+                break;\n+            }\n+            if (multiple_exist && command-- == 0) {\n+                /* Copy assign. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = real[(idx + 1) % num_buffers];\n+                sim[idx] = sim[(idx + 1) % num_buffers];\n+                break;\n+            }\n+            if (multiple_exist && command-- == 0) {\n+                /* Move assign. */\n+                VecDeque<T> copy(real[(idx + 1) % num_buffers]);\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = std::move(copy);\n+                sim[idx] = sim[(idx + 1) % num_buffers];\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* reserve() */\n+                size_t res_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                size_t old_cap = real[idx].capacity();\n+                size_t old_size = real[idx].size();\n+                real[idx].reserve(res_size);\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == std::max(old_cap, res_size));\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* shrink_to_fit() */\n+                size_t old_size = real[idx].size();\n+                real[idx].shrink_to_fit();\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == old_size);\n+                break;\n+            }\n+            if (existing_buffer_non_full && command-- == 0) {\n+                /* push_back() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_back(*tmp);\n+                sim[idx].push_back(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626321220",
      "id" : 1626321220,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585g77FE",
      "original_commit_id" : "ecb278bb19c53b007380e262fa86d809255eeb49",
      "original_line" : 180,
      "original_position" : 165,
      "original_start_line" : null,
      "path" : "src/test/fuzz/vecdeque.cpp",
      "position" : null,
      "pull_request_review_id" : 2096682721,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626321220/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-06-04T19:31:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626321220",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626341902"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626341902"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Calling `compare_fn` here seems more complete than picking and choosing when to call it before the final check\r\n```Suggestion\r\n            if (!real.empty()) compare_fn(real[idx], sim[idx]);\r\n            if (non_full && command-- == 0) {\r\n```",
      "commit_id" : "e4ecb8217ada3dae1c1645a8d0a12e14b0f935da",
      "created_at" : "2024-06-04T17:01:04Z",
      "diff_hunk" : "@@ -0,0 +1,422 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/vecdeque.h>\n+\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on VecDeque type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<VecDeque<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const VecDeque<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        int command = provider.ConsumeIntegral<uint8_t>() % 32;\n+        unsigned idx = real.empty() ? 0 : provider.ConsumeIntegralInRange<unsigned>(0, real.size() - 1);\n+        const size_t num_buffers = sim.size();\n+        // Pick one operation based on value of command. Not all operations are always applicable.\n+        // Loop through the applicable ones until command reaches 0 (which avoids the need to\n+        // compute the number of applicable commands ahead of time).\n+        const bool non_empty{num_buffers != 0};\n+        const bool non_full{num_buffers < MAX_BUFFERS};\n+        const bool partially_full{non_empty && non_full};\n+        const bool multiple_exist{num_buffers > 1};\n+        const bool existing_buffer_non_full{non_empty && sim[idx].size() < MAX_BUFFER_SIZE};\n+        const bool existing_buffer_non_empty{non_empty && !sim[idx].empty()};\n+        assert(non_full || non_empty);\n+        while (true) {\n+            if (non_full && command-- == 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626341902",
      "id" : 1626341902,
      "line" : 70,
      "node_id" : "PRRC_kwDOABII585g8AIO",
      "original_commit_id" : "ecb278bb19c53b007380e262fa86d809255eeb49",
      "original_line" : 70,
      "original_position" : 70,
      "original_start_line" : null,
      "path" : "src/test/fuzz/vecdeque.cpp",
      "position" : 70,
      "pull_request_review_id" : 2096682721,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626341902/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-06-04T19:31:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626341902",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626387016"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626387016"
         }
      },
      "author_association" : "MEMBER",
      "body" : "gave an attempt\r\n```Suggestion\r\n    /** Returns the number of populated objects from m_offset to end of allocated memory. */\r\n    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\r\n```",
      "commit_id" : "e4ecb8217ada3dae1c1645a8d0a12e14b0f935da",
      "created_at" : "2024-06-04T17:35:42Z",
      "diff_hunk" : "@@ -0,0 +1,268 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise\n+     *  m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626387016",
      "id" : 1626387016,
      "line" : 36,
      "node_id" : "PRRC_kwDOABII585g8LJI",
      "original_commit_id" : "0eba7219a2ab94e2aa92f35ea1b681f168ac6384",
      "original_line" : 36,
      "original_position" : 35,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : 36,
      "pull_request_review_id" : 2096682721,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626387016/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-06-04T19:31:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626387016",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626395824"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626395824"
         }
      },
      "author_association" : "MEMBER",
      "body" : "double checking: `first_part == 0` implies `m_size == 0`?",
      "commit_id" : "e4ecb8217ada3dae1c1645a8d0a12e14b0f935da",
      "created_at" : "2024-06-04T17:42:07Z",
      "diff_hunk" : "@@ -0,0 +1,268 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise\n+     *  m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626395824",
      "id" : 1626395824,
      "line" : 48,
      "node_id" : "PRRC_kwDOABII585g8NSw",
      "original_commit_id" : "0eba7219a2ab94e2aa92f35ea1b681f168ac6384",
      "original_line" : 48,
      "original_position" : 47,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : 48,
      "pull_request_review_id" : 2096682721,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626395824/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-06-04T19:31:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626395824",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@hebasto Good idea, self copy-assignment was indeed broken! Fixed, and added tests for self copy/move/swap.",
      "created_at" : "2024-06-04T18:15:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2148130643",
      "id" : 2148130643,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30161",
      "node_id" : "IC_kwDOABII586ACd9T",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 1,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2148130643/reactions"
      },
      "updated_at" : "2024-06-04T18:15:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2148130643",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626448996"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626448996"
         }
      },
      "author_association" : "MEMBER",
      "body" : "seems ever so slightly more direct, even though this seems correct as is\r\n```Suggestion\r\n        if (&other == this) return *this;\r\n```",
      "commit_id" : "e4ecb8217ada3dae1c1645a8d0a12e14b0f935da",
      "created_at" : "2024-06-04T18:29:48Z",
      "diff_hunk" : "@@ -0,0 +1,269 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise\n+     *  m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size) noexcept\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            while (m_size < size) {\n+                std::construct_at(m_buffer + Index(m_size));\n+                ++m_size;\n+            }\n+        }\n+    }\n+\n+    void clear() noexcept { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        if (other.m_buffer == m_buffer) return *this;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626448996",
      "id" : 1626448996,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585g8aRk",
      "original_commit_id" : "5d06357207b570b1c2a66b318545087666fe8605",
      "original_line" : 129,
      "original_position" : 129,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : null,
      "pull_request_review_id" : 2096682721,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626448996/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-06-04T19:31:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626448996",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> @hebasto Good idea, self copy-assignment was indeed broken! Fixed, and added tests for self copy/move/swap.\r\n\r\nI suspect this is probably broken in several of our other classes as well. Speaking for myself at least, I almost always forget about correctness there and never look for it in review.\r\n\r\nFWIW I tried using the [bugprone-unhandled-self-assignment](https://clang.llvm.org/extra/clang-tidy/checks/bugprone/unhandled-self-assignment.html) clang-tidy check which does catch the problem, but it also throws a false-positive for this solution (as well as every other that I tried :( )",
      "created_at" : "2024-06-04T19:15:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2148229582",
      "id" : 2148229582,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30161",
      "node_id" : "IC_kwDOABII586AC2HO",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2148229582/reactions"
      },
      "updated_at" : "2024-06-04T19:15:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2148229582",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=4",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "node_id" : "MDQ6VXNlcjQxNzA0Mw==",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@theuni What if the comparison is changed to `if (this == &other) return *this;`?",
      "created_at" : "2024-06-04T19:30:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2148252096",
      "id" : 2148252096,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30161",
      "node_id" : "IC_kwDOABII586AC7nA",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2148252096/reactions"
      },
      "updated_at" : "2024-06-04T19:30:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2148252096",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> `if (this == &other) return *this;`\r\n\r\nHuh, that worked. But this (the one I tried) doesn't\r\n```c++\r\nif (*this == other) return *this;\r\n```\r\n\r\nEdit: facepalm",
      "created_at" : "2024-06-04T19:42:53Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2148290427",
      "id" : 2148290427,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30161",
      "node_id" : "IC_kwDOABII586ADE97",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 1,
         "rocket" : 1,
         "total_count" : 2,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2148290427/reactions"
      },
      "updated_at" : "2024-06-04T19:46:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2148290427",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=4",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "node_id" : "MDQ6VXNlcjQxNzA0Mw==",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Oh, duh, that's a totally different comparison. Ofc that didn't do what I wanted :)",
      "created_at" : "2024-06-04T19:46:20Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2148299043",
      "id" : 2148299043,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30161",
      "node_id" : "IC_kwDOABII586ADHEj",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2148299043/reactions"
      },
      "updated_at" : "2024-06-04T19:46:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2148299043",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=4",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "node_id" : "MDQ6VXNlcjQxNzA0Mw==",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626544077"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626544077"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Indeed!",
      "commit_id" : "e4ecb8217ada3dae1c1645a8d0a12e14b0f935da",
      "created_at" : "2024-06-04T20:04:11Z",
      "diff_hunk" : "@@ -0,0 +1,268 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise\n+     *  m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626544077",
      "id" : 1626544077,
      "in_reply_to_id" : 1626395824,
      "line" : 48,
      "node_id" : "PRRC_kwDOABII585g8xfN",
      "original_commit_id" : "0eba7219a2ab94e2aa92f35ea1b681f168ac6384",
      "original_line" : 48,
      "original_position" : 47,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : 48,
      "pull_request_review_id" : 2097289437,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626544077/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-06-04T20:04:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626544077",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626579091"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626579091"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "e4ecb8217ada3dae1c1645a8d0a12e14b0f935da",
      "created_at" : "2024-06-04T20:40:38Z",
      "diff_hunk" : "@@ -0,0 +1,268 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626579091",
      "id" : 1626579091,
      "in_reply_to_id" : 1626177967,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585g86CT",
      "original_commit_id" : "0eba7219a2ab94e2aa92f35ea1b681f168ac6384",
      "original_line" : 27,
      "original_position" : 27,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : null,
      "pull_request_review_id" : 2097348195,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626579091/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-06-04T20:40:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626579091",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626579194"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626579194"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "e4ecb8217ada3dae1c1645a8d0a12e14b0f935da",
      "created_at" : "2024-06-04T20:40:43Z",
      "diff_hunk" : "@@ -0,0 +1,268 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise\n+     *  m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626579194",
      "id" : 1626579194,
      "in_reply_to_id" : 1626291871,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585g86D6",
      "original_commit_id" : "0eba7219a2ab94e2aa92f35ea1b681f168ac6384",
      "original_line" : 73,
      "original_position" : 73,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : null,
      "pull_request_review_id" : 2097348355,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626579194/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-06-04T20:40:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626579194",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626579310"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626579310"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "e4ecb8217ada3dae1c1645a8d0a12e14b0f935da",
      "created_at" : "2024-06-04T20:40:48Z",
      "diff_hunk" : "@@ -0,0 +1,422 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/vecdeque.h>\n+\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on VecDeque type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<VecDeque<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const VecDeque<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        int command = provider.ConsumeIntegral<uint8_t>() % 32;\n+        unsigned idx = real.empty() ? 0 : provider.ConsumeIntegralInRange<unsigned>(0, real.size() - 1);\n+        const size_t num_buffers = sim.size();\n+        // Pick one operation based on value of command. Not all operations are always applicable.\n+        // Loop through the applicable ones until command reaches 0 (which avoids the need to\n+        // compute the number of applicable commands ahead of time).\n+        const bool non_empty{num_buffers != 0};\n+        const bool non_full{num_buffers < MAX_BUFFERS};\n+        const bool partially_full{non_empty && non_full};\n+        const bool multiple_exist{num_buffers > 1};\n+        const bool existing_buffer_non_full{non_empty && sim[idx].size() < MAX_BUFFER_SIZE};\n+        const bool existing_buffer_non_empty{non_empty && !sim[idx].empty()};\n+        assert(non_full || non_empty);\n+        while (true) {\n+            if (non_full && command-- == 0) {\n+                /* Default construct. */\n+                real.emplace_back();\n+                sim.emplace_back();\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* resize() */\n+                size_t new_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                real[idx].resize(new_size);\n+                sim[idx].resize(new_size);\n+                assert(real[idx].size() == new_size);\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* clear() */\n+                real[idx].clear();\n+                sim[idx].clear();\n+                assert(real[idx].empty());\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* Copy construct default. */\n+                real[idx] = VecDeque<T>();\n+                sim[idx].clear();\n+                assert(real[idx].size() == 0);\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* Destruct. */\n+                compare_fn(real.back(), sim.back());\n+                real.pop_back();\n+                sim.pop_back();\n+                break;\n+            }\n+            if (partially_full && command-- == 0) {\n+                /* Copy construct. */\n+                real.emplace_back(real[idx]);\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (partially_full && command-- == 0) {\n+                /* Move construct. */\n+                VecDeque<T> copy(real[idx]);\n+                real.emplace_back(std::move(copy));\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (multiple_exist && command-- == 0) {\n+                /* swap() */\n+                swap(real[idx], real[(idx + 1) % num_buffers]);\n+                swap(sim[idx], sim[(idx + 1) % num_buffers]);\n+                break;\n+            }\n+            if (multiple_exist && command-- == 0) {\n+                /* Copy assign. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = real[(idx + 1) % num_buffers];\n+                sim[idx] = sim[(idx + 1) % num_buffers];\n+                break;\n+            }\n+            if (multiple_exist && command-- == 0) {\n+                /* Move assign. */\n+                VecDeque<T> copy(real[(idx + 1) % num_buffers]);\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = std::move(copy);\n+                sim[idx] = sim[(idx + 1) % num_buffers];\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* reserve() */\n+                size_t res_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                size_t old_cap = real[idx].capacity();\n+                size_t old_size = real[idx].size();\n+                real[idx].reserve(res_size);\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == std::max(old_cap, res_size));\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* shrink_to_fit() */\n+                size_t old_size = real[idx].size();\n+                real[idx].shrink_to_fit();\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == old_size);\n+                break;\n+            }\n+            if (existing_buffer_non_full && command-- == 0) {\n+                /* push_back() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_back(*tmp);\n+                sim[idx].push_back(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626579310",
      "id" : 1626579310,
      "in_reply_to_id" : 1626321220,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585g86Fu",
      "original_commit_id" : "ecb278bb19c53b007380e262fa86d809255eeb49",
      "original_line" : 180,
      "original_position" : 165,
      "original_start_line" : null,
      "path" : "src/test/fuzz/vecdeque.cpp",
      "position" : null,
      "pull_request_review_id" : 2097348513,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626579310/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-06-04T20:40:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626579310",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626580105"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626580105"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I didn't take this suggestion. The current code should be invoking `compare_fn` whenever an element is destructed or destructively overwritten; that's not necessarily number `idx` though.",
      "commit_id" : "e4ecb8217ada3dae1c1645a8d0a12e14b0f935da",
      "created_at" : "2024-06-04T20:41:37Z",
      "diff_hunk" : "@@ -0,0 +1,422 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/vecdeque.h>\n+\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on VecDeque type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<VecDeque<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const VecDeque<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        int command = provider.ConsumeIntegral<uint8_t>() % 32;\n+        unsigned idx = real.empty() ? 0 : provider.ConsumeIntegralInRange<unsigned>(0, real.size() - 1);\n+        const size_t num_buffers = sim.size();\n+        // Pick one operation based on value of command. Not all operations are always applicable.\n+        // Loop through the applicable ones until command reaches 0 (which avoids the need to\n+        // compute the number of applicable commands ahead of time).\n+        const bool non_empty{num_buffers != 0};\n+        const bool non_full{num_buffers < MAX_BUFFERS};\n+        const bool partially_full{non_empty && non_full};\n+        const bool multiple_exist{num_buffers > 1};\n+        const bool existing_buffer_non_full{non_empty && sim[idx].size() < MAX_BUFFER_SIZE};\n+        const bool existing_buffer_non_empty{non_empty && !sim[idx].empty()};\n+        assert(non_full || non_empty);\n+        while (true) {\n+            if (non_full && command-- == 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626580105",
      "id" : 1626580105,
      "in_reply_to_id" : 1626341902,
      "line" : 70,
      "node_id" : "PRRC_kwDOABII585g86SJ",
      "original_commit_id" : "ecb278bb19c53b007380e262fa86d809255eeb49",
      "original_line" : 70,
      "original_position" : 70,
      "original_start_line" : null,
      "path" : "src/test/fuzz/vecdeque.cpp",
      "position" : 70,
      "pull_request_review_id" : 2097349729,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626580105/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-06-04T20:41:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626580105",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626580268"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626580268"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "e4ecb8217ada3dae1c1645a8d0a12e14b0f935da",
      "created_at" : "2024-06-04T20:41:49Z",
      "diff_hunk" : "@@ -0,0 +1,268 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise\n+     *  m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626580268",
      "id" : 1626580268,
      "in_reply_to_id" : 1626387016,
      "line" : 36,
      "node_id" : "PRRC_kwDOABII585g86Us",
      "original_commit_id" : "0eba7219a2ab94e2aa92f35ea1b681f168ac6384",
      "original_line" : 36,
      "original_position" : 35,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : 36,
      "pull_request_review_id" : 2097350020,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626580268/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-06-04T20:41:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626580268",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626580385"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626580385"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "e4ecb8217ada3dae1c1645a8d0a12e14b0f935da",
      "created_at" : "2024-06-04T20:41:56Z",
      "diff_hunk" : "@@ -0,0 +1,269 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise\n+     *  m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size) noexcept\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            while (m_size < size) {\n+                std::construct_at(m_buffer + Index(m_size));\n+                ++m_size;\n+            }\n+        }\n+    }\n+\n+    void clear() noexcept { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        if (other.m_buffer == m_buffer) return *this;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626580385",
      "id" : 1626580385,
      "in_reply_to_id" : 1626448996,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585g86Wh",
      "original_commit_id" : "5d06357207b570b1c2a66b318545087666fe8605",
      "original_line" : 129,
      "original_position" : 129,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : null,
      "pull_request_review_id" : 2097350198,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626580385/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-06-04T20:41:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626580385",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626581320"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626581320"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Added an `Assume` to reflect this.",
      "commit_id" : "e4ecb8217ada3dae1c1645a8d0a12e14b0f935da",
      "created_at" : "2024-06-04T20:42:52Z",
      "diff_hunk" : "@@ -0,0 +1,268 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise\n+     *  m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626581320",
      "id" : 1626581320,
      "in_reply_to_id" : 1626395824,
      "line" : 48,
      "node_id" : "PRRC_kwDOABII585g86lI",
      "original_commit_id" : "0eba7219a2ab94e2aa92f35ea1b681f168ac6384",
      "original_line" : 48,
      "original_position" : 47,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : 48,
      "pull_request_review_id" : 2097351889,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626581320/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-06-04T20:42:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626581320",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Added a few missing `compare_fn` calls, and also added branches to the fuzz test to exercise `pop_front()` and `pop_back()`, which were apparently missing.",
      "created_at" : "2024-06-04T21:54:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2148476988",
      "id" : 2148476988,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30161",
      "node_id" : "IC_kwDOABII586ADyg8",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2148476988/reactions"
      },
      "updated_at" : "2024-06-04T21:54:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2148476988",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1627251261"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1627251261"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Would early return for `capacity == 0` simplify the code?",
      "commit_id" : "e4ecb8217ada3dae1c1645a8d0a12e14b0f935da",
      "created_at" : "2024-06-05T08:29:57Z",
      "diff_hunk" : "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object in queue. m_offset = 0 if m_capacity is 0;\n+     *  otherwise 0 <= m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. 0 <= m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    /** Returns the number of populated objects between m_offset and the end of the buffer. */\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1627251261",
      "id" : 1627251261,
      "line" : 43,
      "node_id" : "PRRC_kwDOABII585g_eI9",
      "original_commit_id" : "e4ecb8217ada3dae1c1645a8d0a12e14b0f935da",
      "original_line" : 43,
      "original_position" : 43,
      "original_start_line" : 42,
      "path" : "src/util/vecdeque.h",
      "position" : 43,
      "pull_request_review_id" : 2098403329,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1627251261/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 42,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2024-06-05T08:29:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1627251261",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "ACK e4ecb8217ada3dae1c1645a8d0a12e14b0f935da\r\n\r\nverified fuzz target coverage and sensible invariant checks are being enforced\r\n",
      "created_at" : "2024-06-05T16:05:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2150437453",
      "id" : 2150437453,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30161",
      "node_id" : "IC_kwDOABII586ALRJN",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2150437453/reactions"
      },
      "updated_at" : "2024-06-05T16:05:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2150437453",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I've added some doxygen comments on `VecDeque`.",
      "created_at" : "2024-06-06T17:41:16Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2153072603",
      "id" : 2153072603,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30161",
      "node_id" : "IC_kwDOABII586AVUfb",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2153072603/reactions"
      },
      "updated_at" : "2024-06-06T17:41:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2153072603",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--85328a0da195eb286784d51f73fa0af9-->\n\nð§ At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/25906521916</sub>",
      "created_at" : "2024-06-06T17:44:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2153078101",
      "id" : 2153078101,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30161",
      "node_id" : "IC_kwDOABII586AVV1V",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2153078101/reactions"
      },
      "updated_at" : "2024-06-06T17:44:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2153078101",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "reACK https://github.com/bitcoin/bitcoin/pull/30161/commits/ee253ca7dea9bed01d4c1800760477ef06310df8\r\n\r\nreviewed via `git range-diff master e4ecb82 ee253ca`",
      "created_at" : "2024-06-06T18:52:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2153187763",
      "id" : 2153187763,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30161",
      "node_id" : "IC_kwDOABII586AVwmz",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2153187763/reactions"
      },
      "updated_at" : "2024-06-06T18:52:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2153187763",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   }
]
