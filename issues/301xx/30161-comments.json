[
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613576870"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613576870"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: Seems like this would be easier?\r\n```suggestion\r\n        unsigned idx = real.empty() ? 0 : provider.ConsumeIntegralInRange<unsigned>(0, real.size() - 1);\r\n```",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T14:31:17Z",
      "diff_hunk" : "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613576870",
      "id" : 1613576870,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gLTqm",
      "original_commit_id" : "017272dff1076068d5d878dbe599fb5a3e12115c",
      "original_line" : 58,
      "original_position" : 58,
      "original_start_line" : null,
      "path" : "src/test/fuzz/ringbuffer.cpp",
      "position" : null,
      "pull_request_review_id" : 2077094091,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613576870/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T16:46:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613576870",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613595996"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613595996"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n        // Pick one operation based on value of command. Not all operations are always applicable.\r\n        // Loop through the applicable ones until command reaches 0 (avoids the need to compute\r\n        // the number of applicable commands ahead of time).\r\n```",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T14:44:12Z",
      "diff_hunk" : "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613595996",
      "id" : 1613595996,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gLYVc",
      "original_commit_id" : "017272dff1076068d5d878dbe599fb5a3e12115c",
      "original_line" : 61,
      "original_position" : 61,
      "original_start_line" : null,
      "path" : "src/test/fuzz/ringbuffer.cpp",
      "position" : null,
      "pull_request_review_id" : 2077094091,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613595996/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T16:01:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613595996",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613608895"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613608895"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\r\n```\r\n\r\nstyle-nit: I think `inline` can be dropped, according to https://en.cppreference.com/w/cpp/language/inline\r\n\r\n> A function defined entirely inside a [class/struct/union definition](https://en.cppreference.com/w/cpp/language/classes), whether it's a member function or a non-member friend function, is implicitly an inline function [...]\r\n\r\n",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T14:52:59Z",
      "diff_hunk" : "@@ -0,0 +1,259 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_RINGBUFFER_H\n+#define BITCOIN_UTIL_RINGBUFFER_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class RingBuffer\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    inline size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613608895",
      "id" : 1613608895,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gLbe_",
      "original_commit_id" : "017272dff1076068d5d878dbe599fb5a3e12115c",
      "original_line" : 34,
      "original_position" : 34,
      "original_start_line" : null,
      "path" : "src/util/ringbuffer.h",
      "position" : null,
      "pull_request_review_id" : 2077153695,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613608895/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T14:53:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613608895",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/maflcko/events{/privacy}",
         "followers_url" : "https://api.github.com/users/maflcko/followers",
         "following_url" : "https://api.github.com/users/maflcko/following{/other_user}",
         "gists_url" : "https://api.github.com/users/maflcko/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/maflcko",
         "id" : 6399679,
         "login" : "maflcko",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/maflcko/orgs",
         "received_events_url" : "https://api.github.com/users/maflcko/received_events",
         "repos_url" : "https://api.github.com/users/maflcko/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/maflcko/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/maflcko/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/maflcko"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage\nFor detailed information about the code coverage, see the [test coverage report](https://corecheck.dev/bitcoin/bitcoin/pulls/30161).\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| Concept ACK | [hebasto](https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2133351751) |\n\nIf your review is incorrectly listed, please react with ð to this comment and the bot will ignore it on the next update.\n",
      "created_at" : "2024-05-24T14:53:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2129732891",
      "id" : 2129732891,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30161",
      "node_id" : "IC_kwDOABII585-8SUb",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2129732891/reactions"
      },
      "updated_at" : "2024-05-27T12:12:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2129732891",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613637296"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613637296"
         }
      },
      "author_association" : "MEMBER",
      "body" : "There's an assumption that at least one of the operations is applicable every time. Pretty obviously true but I assigned variables to all the possible conditions while reviewing and used it to add an assertion. Might be easier to read so I figured I'd leave a comment.\r\n```suggestion\r\n        const bool non_empty{num_buffers != 0};\r\n        const bool non_full{num_buffers < MAX_BUFFERS};\r\n        const bool partially_full{num_buffers > 0 && num_buffers < MAX_BUFFERS};\r\n        const bool multiple_exist{num_buffers > 1};\r\n        const bool existing_buffer_nonfull{non_empty && sim[idx].size() < MAX_BUFFER_SIZE};\r\n        const bool existing_buffer_nonempty{non_empty && !sim[idx].empty()};\r\n        assert(non_full || non_empty || partially_full);\r\n        \r\n        while (true) {\r\n```",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T15:13:13Z",
      "diff_hunk" : "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach\n+        // avoids the need to compute the number of applicable commands ahead of time).\n+        while (true) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613637296",
      "id" : 1613637296,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gLiaw",
      "original_commit_id" : "017272dff1076068d5d878dbe599fb5a3e12115c",
      "original_line" : 70,
      "original_position" : 63,
      "original_start_line" : null,
      "path" : "src/test/fuzz/ringbuffer.cpp",
      "position" : null,
      "pull_request_review_id" : 2077094091,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613637296/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T16:01:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613637296",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613660947"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613660947"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n    // Create entry for this object in g_tracker and populate m_track_entry\r\n    void Register()\r\n```",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T15:31:26Z",
      "diff_hunk" : "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach\n+        // avoids the need to compute the number of applicable commands ahead of time).\n+        while (true) {\n+            if (num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Default construct. */\n+                real.emplace_back();\n+                sim.emplace_back();\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* resize() */\n+                size_t new_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                real[idx].resize(new_size);\n+                sim[idx].resize(new_size);\n+                assert(real[idx].size() == new_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* clear() */\n+                real[idx].clear();\n+                sim[idx].clear();\n+                assert(real[idx].empty());\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Copy construct default. */\n+                real[idx] = RingBuffer<T>();\n+                sim[idx].clear();\n+                assert(real[idx].size() == 0);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Destruct. */\n+                compare_fn(real.back(), sim.back());\n+                real.pop_back();\n+                sim.pop_back();\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Copy construct. */\n+                real.emplace_back(real[idx]);\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Move construct. */\n+                RingBuffer<T> copy(real[idx]);\n+                real.emplace_back(std::move(copy));\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* swap() */\n+                swap(real[idx], real[(idx + 1) % num_buffers]);\n+                swap(sim[idx], sim[(idx + 1) % sim.size()]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Copy assign. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = real[(idx + 1) % num_buffers];\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Move assign. */\n+                RingBuffer<T> copy(real[(idx + 1) % num_buffers]);\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = std::move(copy);\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* reserve() */\n+                size_t res_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                size_t old_cap = real[idx].capacity();\n+                size_t old_size = real[idx].size();\n+                real[idx].reserve(res_size);\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == std::max(old_cap, res_size));\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* shrink_to_fit() */\n+                size_t old_size = real[idx].size();\n+                real[idx].shrink_to_fit();\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_back(*tmp);\n+                sim[idx].push_back(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_back(*tmp);\n+                real[idx].push_back(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_back() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_back(seed);\n+                real[idx].emplace_back(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_front(*tmp);\n+                sim[idx].push_front(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_front(*tmp);\n+                real[idx].push_front(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_front() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_front(seed);\n+                real[idx].emplace_front(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* front() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].front() == real[idx].front());\n+                sim[idx].front() = *tmp;\n+                real[idx].front() = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* back() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].back() == real[idx].back());\n+                sim[idx].back() = *tmp;\n+                real[idx].back() = *tmp;\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* operator[] [modifying] */\n+                tmp = T(rng());\n+                size_t pos = provider.ConsumeIntegralInRange<size_t>(0, sim[idx].size() - 1);\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx][pos] == real[idx][pos]);\n+                sim[idx][pos] = *tmp;\n+                real[idx][pos] = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Fully compare the final state. */\n+    for (unsigned i = 0; i < sim.size(); ++i) {\n+        // Make sure const getters work.\n+        const RingBuffer<T>& realbuf = real[i];\n+        const std::deque<T>& simbuf = sim[i];\n+        compare_fn(realbuf, simbuf);\n+        for (unsigned j = 0; j < sim.size(); ++j) {\n+            assert((realbuf == real[j]) == (simbuf == sim[j]));\n+            assert(((realbuf <=> real[j]) >= 0) == (simbuf >= sim[j]));\n+            assert(((realbuf <=> real[j]) <= 0) == (simbuf <= sim[j]));\n+        }\n+        // Clear out the buffers so we can check below that no objects exist anymore.\n+        sim[i].clear();\n+        real[i].clear();\n+    }\n+\n+    if constexpr (CheckNoneLeft) {\n+        tmp = std::nullopt;\n+        T::CheckNoneExist();\n+    }\n+}\n+\n+/** Data structure with built-in tracking of all existing objects. */\n+template<size_t Size>\n+class TrackedObj\n+{\n+    static_assert(Size > 0);\n+\n+    /* Data type for map that actually stores the object data.\n+     *\n+     * The key is a pointer to the TrackedObj, the value is the uint64_t it was initialized with.\n+     * Default-constructed and moved-from objects hold an std::nullopt.\n+     */\n+    using track_map_type = std::map<const TrackedObj<Size>*, std::optional<uint64_t>>;\n+\n+private:\n+\n+    /** Actual map. */\n+    static inline track_map_type g_tracker;\n+\n+    /** Iterators into the tracker map for this object.\n+     *\n+     * This is an array of size Size, all holding the same value, to give the object configurable\n+     * size. The value is g_tracker.end() if this object is not fully initialized. */\n+    typename track_map_type::iterator m_track_entry[Size];\n+\n+    void Check() const\n+    {\n+        auto it = g_tracker.find(this);\n+        for (size_t i = 0; i < Size; ++i) {\n+            assert(m_track_entry[i] == it);\n+        }\n+    }\n+\n+    void Register()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613660947",
      "id" : 1613660947,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gLoMT",
      "original_commit_id" : "017272dff1076068d5d878dbe599fb5a3e12115c",
      "original_line" : 313,
      "original_position" : 305,
      "original_start_line" : null,
      "path" : "src/test/fuzz/ringbuffer.cpp",
      "position" : null,
      "pull_request_review_id" : 2077094091,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613660947/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T16:01:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613660947",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613661502"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613661502"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n    // Get value corresponding to this object in g_tracker\r\n    std::optional<uint64_t>& Deref()\r\n```",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T15:31:47Z",
      "diff_hunk" : "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach\n+        // avoids the need to compute the number of applicable commands ahead of time).\n+        while (true) {\n+            if (num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Default construct. */\n+                real.emplace_back();\n+                sim.emplace_back();\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* resize() */\n+                size_t new_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                real[idx].resize(new_size);\n+                sim[idx].resize(new_size);\n+                assert(real[idx].size() == new_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* clear() */\n+                real[idx].clear();\n+                sim[idx].clear();\n+                assert(real[idx].empty());\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Copy construct default. */\n+                real[idx] = RingBuffer<T>();\n+                sim[idx].clear();\n+                assert(real[idx].size() == 0);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Destruct. */\n+                compare_fn(real.back(), sim.back());\n+                real.pop_back();\n+                sim.pop_back();\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Copy construct. */\n+                real.emplace_back(real[idx]);\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Move construct. */\n+                RingBuffer<T> copy(real[idx]);\n+                real.emplace_back(std::move(copy));\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* swap() */\n+                swap(real[idx], real[(idx + 1) % num_buffers]);\n+                swap(sim[idx], sim[(idx + 1) % sim.size()]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Copy assign. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = real[(idx + 1) % num_buffers];\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Move assign. */\n+                RingBuffer<T> copy(real[(idx + 1) % num_buffers]);\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = std::move(copy);\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* reserve() */\n+                size_t res_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                size_t old_cap = real[idx].capacity();\n+                size_t old_size = real[idx].size();\n+                real[idx].reserve(res_size);\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == std::max(old_cap, res_size));\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* shrink_to_fit() */\n+                size_t old_size = real[idx].size();\n+                real[idx].shrink_to_fit();\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_back(*tmp);\n+                sim[idx].push_back(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_back(*tmp);\n+                real[idx].push_back(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_back() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_back(seed);\n+                real[idx].emplace_back(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_front(*tmp);\n+                sim[idx].push_front(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_front(*tmp);\n+                real[idx].push_front(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_front() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_front(seed);\n+                real[idx].emplace_front(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* front() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].front() == real[idx].front());\n+                sim[idx].front() = *tmp;\n+                real[idx].front() = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* back() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].back() == real[idx].back());\n+                sim[idx].back() = *tmp;\n+                real[idx].back() = *tmp;\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* operator[] [modifying] */\n+                tmp = T(rng());\n+                size_t pos = provider.ConsumeIntegralInRange<size_t>(0, sim[idx].size() - 1);\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx][pos] == real[idx][pos]);\n+                sim[idx][pos] = *tmp;\n+                real[idx][pos] = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Fully compare the final state. */\n+    for (unsigned i = 0; i < sim.size(); ++i) {\n+        // Make sure const getters work.\n+        const RingBuffer<T>& realbuf = real[i];\n+        const std::deque<T>& simbuf = sim[i];\n+        compare_fn(realbuf, simbuf);\n+        for (unsigned j = 0; j < sim.size(); ++j) {\n+            assert((realbuf == real[j]) == (simbuf == sim[j]));\n+            assert(((realbuf <=> real[j]) >= 0) == (simbuf >= sim[j]));\n+            assert(((realbuf <=> real[j]) <= 0) == (simbuf <= sim[j]));\n+        }\n+        // Clear out the buffers so we can check below that no objects exist anymore.\n+        sim[i].clear();\n+        real[i].clear();\n+    }\n+\n+    if constexpr (CheckNoneLeft) {\n+        tmp = std::nullopt;\n+        T::CheckNoneExist();\n+    }\n+}\n+\n+/** Data structure with built-in tracking of all existing objects. */\n+template<size_t Size>\n+class TrackedObj\n+{\n+    static_assert(Size > 0);\n+\n+    /* Data type for map that actually stores the object data.\n+     *\n+     * The key is a pointer to the TrackedObj, the value is the uint64_t it was initialized with.\n+     * Default-constructed and moved-from objects hold an std::nullopt.\n+     */\n+    using track_map_type = std::map<const TrackedObj<Size>*, std::optional<uint64_t>>;\n+\n+private:\n+\n+    /** Actual map. */\n+    static inline track_map_type g_tracker;\n+\n+    /** Iterators into the tracker map for this object.\n+     *\n+     * This is an array of size Size, all holding the same value, to give the object configurable\n+     * size. The value is g_tracker.end() if this object is not fully initialized. */\n+    typename track_map_type::iterator m_track_entry[Size];\n+\n+    void Check() const\n+    {\n+        auto it = g_tracker.find(this);\n+        for (size_t i = 0; i < Size; ++i) {\n+            assert(m_track_entry[i] == it);\n+        }\n+    }\n+\n+    void Register()\n+    {\n+        auto [it, inserted] = g_tracker.emplace(this, std::nullopt);\n+        assert(inserted);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = it;\n+        }\n+    }\n+\n+    void Deregister()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        g_tracker.erase(m_track_entry[0]);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = g_tracker.end();\n+        }\n+    }\n+\n+    std::optional<uint64_t>& Deref()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613661502",
      "id" : 1613661502,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gLoU-",
      "original_commit_id" : "017272dff1076068d5d878dbe599fb5a3e12115c",
      "original_line" : 333,
      "original_position" : 324,
      "original_start_line" : null,
      "path" : "src/test/fuzz/ringbuffer.cpp",
      "position" : null,
      "pull_request_review_id" : 2077094091,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613661502/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T16:01:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613661502",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613663028"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613663028"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`static_assert(!std::is_trivially_copyable_v<TrackedObj<1>>)` ?",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T15:32:32Z",
      "diff_hunk" : "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach\n+        // avoids the need to compute the number of applicable commands ahead of time).\n+        while (true) {\n+            if (num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Default construct. */\n+                real.emplace_back();\n+                sim.emplace_back();\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* resize() */\n+                size_t new_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                real[idx].resize(new_size);\n+                sim[idx].resize(new_size);\n+                assert(real[idx].size() == new_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* clear() */\n+                real[idx].clear();\n+                sim[idx].clear();\n+                assert(real[idx].empty());\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Copy construct default. */\n+                real[idx] = RingBuffer<T>();\n+                sim[idx].clear();\n+                assert(real[idx].size() == 0);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Destruct. */\n+                compare_fn(real.back(), sim.back());\n+                real.pop_back();\n+                sim.pop_back();\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Copy construct. */\n+                real.emplace_back(real[idx]);\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Move construct. */\n+                RingBuffer<T> copy(real[idx]);\n+                real.emplace_back(std::move(copy));\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* swap() */\n+                swap(real[idx], real[(idx + 1) % num_buffers]);\n+                swap(sim[idx], sim[(idx + 1) % sim.size()]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Copy assign. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = real[(idx + 1) % num_buffers];\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Move assign. */\n+                RingBuffer<T> copy(real[(idx + 1) % num_buffers]);\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = std::move(copy);\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* reserve() */\n+                size_t res_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                size_t old_cap = real[idx].capacity();\n+                size_t old_size = real[idx].size();\n+                real[idx].reserve(res_size);\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == std::max(old_cap, res_size));\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* shrink_to_fit() */\n+                size_t old_size = real[idx].size();\n+                real[idx].shrink_to_fit();\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_back(*tmp);\n+                sim[idx].push_back(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_back(*tmp);\n+                real[idx].push_back(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_back() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_back(seed);\n+                real[idx].emplace_back(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_front(*tmp);\n+                sim[idx].push_front(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_front(*tmp);\n+                real[idx].push_front(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_front() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_front(seed);\n+                real[idx].emplace_front(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* front() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].front() == real[idx].front());\n+                sim[idx].front() = *tmp;\n+                real[idx].front() = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* back() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].back() == real[idx].back());\n+                sim[idx].back() = *tmp;\n+                real[idx].back() = *tmp;\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* operator[] [modifying] */\n+                tmp = T(rng());\n+                size_t pos = provider.ConsumeIntegralInRange<size_t>(0, sim[idx].size() - 1);\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx][pos] == real[idx][pos]);\n+                sim[idx][pos] = *tmp;\n+                real[idx][pos] = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Fully compare the final state. */\n+    for (unsigned i = 0; i < sim.size(); ++i) {\n+        // Make sure const getters work.\n+        const RingBuffer<T>& realbuf = real[i];\n+        const std::deque<T>& simbuf = sim[i];\n+        compare_fn(realbuf, simbuf);\n+        for (unsigned j = 0; j < sim.size(); ++j) {\n+            assert((realbuf == real[j]) == (simbuf == sim[j]));\n+            assert(((realbuf <=> real[j]) >= 0) == (simbuf >= sim[j]));\n+            assert(((realbuf <=> real[j]) <= 0) == (simbuf <= sim[j]));\n+        }\n+        // Clear out the buffers so we can check below that no objects exist anymore.\n+        sim[i].clear();\n+        real[i].clear();\n+    }\n+\n+    if constexpr (CheckNoneLeft) {\n+        tmp = std::nullopt;\n+        T::CheckNoneExist();\n+    }\n+}\n+\n+/** Data structure with built-in tracking of all existing objects. */\n+template<size_t Size>\n+class TrackedObj\n+{\n+    static_assert(Size > 0);\n+\n+    /* Data type for map that actually stores the object data.\n+     *\n+     * The key is a pointer to the TrackedObj, the value is the uint64_t it was initialized with.\n+     * Default-constructed and moved-from objects hold an std::nullopt.\n+     */\n+    using track_map_type = std::map<const TrackedObj<Size>*, std::optional<uint64_t>>;\n+\n+private:\n+\n+    /** Actual map. */\n+    static inline track_map_type g_tracker;\n+\n+    /** Iterators into the tracker map for this object.\n+     *\n+     * This is an array of size Size, all holding the same value, to give the object configurable\n+     * size. The value is g_tracker.end() if this object is not fully initialized. */\n+    typename track_map_type::iterator m_track_entry[Size];\n+\n+    void Check() const\n+    {\n+        auto it = g_tracker.find(this);\n+        for (size_t i = 0; i < Size; ++i) {\n+            assert(m_track_entry[i] == it);\n+        }\n+    }\n+\n+    void Register()\n+    {\n+        auto [it, inserted] = g_tracker.emplace(this, std::nullopt);\n+        assert(inserted);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = it;\n+        }\n+    }\n+\n+    void Deregister()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        g_tracker.erase(m_track_entry[0]);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = g_tracker.end();\n+        }\n+    }\n+\n+    std::optional<uint64_t>& Deref()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        return m_track_entry[0]->second;\n+    }\n+\n+    const std::optional<uint64_t>& Deref() const\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        return m_track_entry[0]->second;\n+    }\n+\n+public:\n+    ~TrackedObj() { Deregister(); }\n+    TrackedObj() { Register(); }\n+\n+    TrackedObj(uint64_t value)\n+    {\n+        Register();\n+        Deref() = value;\n+    }\n+\n+    TrackedObj(const TrackedObj& other)\n+    {\n+        Register();\n+        Deref() = other.Deref();\n+    }\n+\n+    TrackedObj(TrackedObj&& other)\n+    {\n+        Register();\n+        Deref() = other.Deref();\n+        other.Deref() = std::nullopt;\n+    }\n+\n+    TrackedObj& operator=(const TrackedObj& other)\n+    {\n+        Deref() = other.Deref();\n+        return *this;\n+    }\n+\n+    TrackedObj& operator=(TrackedObj&& other)\n+    {\n+        Deref() = other.Deref();\n+        other.Deref() = std::nullopt;\n+        return *this;\n+    }\n+\n+    friend bool operator==(const TrackedObj& a, const TrackedObj& b)\n+    {\n+        return a.Deref() == b.Deref();\n+    }\n+\n+    friend std::strong_ordering operator<=>(const TrackedObj& a, const TrackedObj& b)\n+    {\n+        // Libc++ 15 & 16 do not support std::optional<T>::operator<=> yet. See\n+        // https://reviews.llvm.org/D146392.\n+        if (!a.Deref().has_value() || !b.Deref().has_value()) {\n+            return a.Deref().has_value() <=> b.Deref().has_value();\n+        }\n+        return *a.Deref() <=> *b.Deref();\n+    }\n+\n+    static void CheckNoneExist()\n+    {\n+        assert(g_tracker.empty());\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(ringbuffer)\n+{\n+    // Run the test with simple uints (which are std::is_trivially_copyable_v).\n+    TestType<uint8_t, false>(buffer, 1);\n+    TestType<uint16_t, false>(buffer, 2);\n+    TestType<uint32_t, false>(buffer, 3);\n+    TestType<uint64_t, false>(buffer, 4);\n+    // Run the test with TrackedObjs (which are not).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613663028",
      "id" : 1613663028,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gLos0",
      "original_commit_id" : "017272dff1076068d5d878dbe599fb5a3e12115c",
      "original_line" : 404,
      "original_position" : 404,
      "original_start_line" : null,
      "path" : "src/test/fuzz/ringbuffer.cpp",
      "position" : null,
      "pull_request_review_id" : 2077094091,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613663028/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T16:01:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613663028",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613674426"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613674426"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.\r\n\r\n`inline` does have an effect beyond making it an inline function (in GCC and Clang it increases the eagerness of the compiler to actually inline the function), but that's the sort of optimization one should only do guided by benchmarks, which I haven't done, so I dropped the `inline` here.",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T15:37:14Z",
      "diff_hunk" : "@@ -0,0 +1,259 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_RINGBUFFER_H\n+#define BITCOIN_UTIL_RINGBUFFER_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class RingBuffer\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    inline size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613674426",
      "id" : 1613674426,
      "in_reply_to_id" : 1613608895,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gLre6",
      "original_commit_id" : "017272dff1076068d5d878dbe599fb5a3e12115c",
      "original_line" : 34,
      "original_position" : 34,
      "original_start_line" : null,
      "path" : "src/util/ringbuffer.h",
      "position" : null,
      "pull_request_review_id" : 2077266898,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613674426/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T15:37:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613674426",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613702058"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613702058"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I was slightly confused that this was called `RingBuffer` since the data structure itself doesn't act like a ring buffer i.e. will reallocate if adding items beyond capacity (I wrote `vExtraTxnForCompact` to use it before looking at the implementation and then realized I misunderstood the interface). But I now have read that `m_buffer` is the ring buffer - oops.",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T15:57:09Z",
      "diff_hunk" : "@@ -0,0 +1,259 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_RINGBUFFER_H\n+#define BITCOIN_UTIL_RINGBUFFER_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class RingBuffer",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613702058",
      "id" : 1613702058,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gLyOq",
      "original_commit_id" : "c2a4915257f7b2303cd17a9a30728157616b5ce6",
      "original_line" : 23,
      "original_position" : 23,
      "original_start_line" : null,
      "path" : "src/util/ringbuffer.h",
      "position" : null,
      "pull_request_review_id" : 2077094091,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613702058/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T16:01:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613702058",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613746327"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613746327"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Hmm, this is a good point. The `RingBuffer` class' interface isn't a ring buffer, but a deque; the implementation happens to use a ring buffer. Suggestions/bikeshedding for a better name welcome.",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T16:33:21Z",
      "diff_hunk" : "@@ -0,0 +1,259 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_RINGBUFFER_H\n+#define BITCOIN_UTIL_RINGBUFFER_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class RingBuffer",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613746327",
      "id" : 1613746327,
      "in_reply_to_id" : 1613702058,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gL9CX",
      "original_commit_id" : "c2a4915257f7b2303cd17a9a30728157616b5ce6",
      "original_line" : 23,
      "original_position" : 23,
      "original_start_line" : null,
      "path" : "src/util/ringbuffer.h",
      "position" : null,
      "pull_request_review_id" : 2077390047,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613746327/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T16:33:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613746327",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613757739"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613757739"
         }
      },
      "author_association" : "MEMBER",
      "body" : "\"Integral in Rage\" sounds like a high-school metal band.",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T16:42:55Z",
      "diff_hunk" : "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613757739",
      "id" : 1613757739,
      "in_reply_to_id" : 1613576870,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gL_0r",
      "original_commit_id" : "017272dff1076068d5d878dbe599fb5a3e12115c",
      "original_line" : 58,
      "original_position" : 58,
      "original_start_line" : null,
      "path" : "src/test/fuzz/ringbuffer.cpp",
      "position" : null,
      "pull_request_review_id" : 2077411055,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 1,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613757739/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T16:42:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613757739",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613785731"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785731"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T17:08:34Z",
      "diff_hunk" : "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613785731",
      "id" : 1613785731,
      "in_reply_to_id" : 1613576870,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gMGqD",
      "original_commit_id" : "017272dff1076068d5d878dbe599fb5a3e12115c",
      "original_line" : 58,
      "original_position" : 58,
      "original_start_line" : null,
      "path" : "src/test/fuzz/ringbuffer.cpp",
      "position" : null,
      "pull_request_review_id" : 2077454937,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785731/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T17:08:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785731",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613785818"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785818"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T17:08:40Z",
      "diff_hunk" : "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613785818",
      "id" : 1613785818,
      "in_reply_to_id" : 1613595996,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gMGra",
      "original_commit_id" : "017272dff1076068d5d878dbe599fb5a3e12115c",
      "original_line" : 61,
      "original_position" : 61,
      "original_start_line" : null,
      "path" : "src/test/fuzz/ringbuffer.cpp",
      "position" : null,
      "pull_request_review_id" : 2077455089,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785818/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T17:08:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785818",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613785897"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785897"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T17:08:45Z",
      "diff_hunk" : "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach\n+        // avoids the need to compute the number of applicable commands ahead of time).\n+        while (true) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613785897",
      "id" : 1613785897,
      "in_reply_to_id" : 1613637296,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gMGsp",
      "original_commit_id" : "017272dff1076068d5d878dbe599fb5a3e12115c",
      "original_line" : 70,
      "original_position" : 63,
      "original_start_line" : null,
      "path" : "src/test/fuzz/ringbuffer.cpp",
      "position" : null,
      "pull_request_review_id" : 2077455207,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785897/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T17:08:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785897",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613785977"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785977"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T17:08:52Z",
      "diff_hunk" : "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach\n+        // avoids the need to compute the number of applicable commands ahead of time).\n+        while (true) {\n+            if (num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Default construct. */\n+                real.emplace_back();\n+                sim.emplace_back();\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* resize() */\n+                size_t new_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                real[idx].resize(new_size);\n+                sim[idx].resize(new_size);\n+                assert(real[idx].size() == new_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* clear() */\n+                real[idx].clear();\n+                sim[idx].clear();\n+                assert(real[idx].empty());\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Copy construct default. */\n+                real[idx] = RingBuffer<T>();\n+                sim[idx].clear();\n+                assert(real[idx].size() == 0);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Destruct. */\n+                compare_fn(real.back(), sim.back());\n+                real.pop_back();\n+                sim.pop_back();\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Copy construct. */\n+                real.emplace_back(real[idx]);\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Move construct. */\n+                RingBuffer<T> copy(real[idx]);\n+                real.emplace_back(std::move(copy));\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* swap() */\n+                swap(real[idx], real[(idx + 1) % num_buffers]);\n+                swap(sim[idx], sim[(idx + 1) % sim.size()]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Copy assign. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = real[(idx + 1) % num_buffers];\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Move assign. */\n+                RingBuffer<T> copy(real[(idx + 1) % num_buffers]);\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = std::move(copy);\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* reserve() */\n+                size_t res_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                size_t old_cap = real[idx].capacity();\n+                size_t old_size = real[idx].size();\n+                real[idx].reserve(res_size);\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == std::max(old_cap, res_size));\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* shrink_to_fit() */\n+                size_t old_size = real[idx].size();\n+                real[idx].shrink_to_fit();\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_back(*tmp);\n+                sim[idx].push_back(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_back(*tmp);\n+                real[idx].push_back(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_back() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_back(seed);\n+                real[idx].emplace_back(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_front(*tmp);\n+                sim[idx].push_front(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_front(*tmp);\n+                real[idx].push_front(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_front() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_front(seed);\n+                real[idx].emplace_front(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* front() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].front() == real[idx].front());\n+                sim[idx].front() = *tmp;\n+                real[idx].front() = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* back() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].back() == real[idx].back());\n+                sim[idx].back() = *tmp;\n+                real[idx].back() = *tmp;\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* operator[] [modifying] */\n+                tmp = T(rng());\n+                size_t pos = provider.ConsumeIntegralInRange<size_t>(0, sim[idx].size() - 1);\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx][pos] == real[idx][pos]);\n+                sim[idx][pos] = *tmp;\n+                real[idx][pos] = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Fully compare the final state. */\n+    for (unsigned i = 0; i < sim.size(); ++i) {\n+        // Make sure const getters work.\n+        const RingBuffer<T>& realbuf = real[i];\n+        const std::deque<T>& simbuf = sim[i];\n+        compare_fn(realbuf, simbuf);\n+        for (unsigned j = 0; j < sim.size(); ++j) {\n+            assert((realbuf == real[j]) == (simbuf == sim[j]));\n+            assert(((realbuf <=> real[j]) >= 0) == (simbuf >= sim[j]));\n+            assert(((realbuf <=> real[j]) <= 0) == (simbuf <= sim[j]));\n+        }\n+        // Clear out the buffers so we can check below that no objects exist anymore.\n+        sim[i].clear();\n+        real[i].clear();\n+    }\n+\n+    if constexpr (CheckNoneLeft) {\n+        tmp = std::nullopt;\n+        T::CheckNoneExist();\n+    }\n+}\n+\n+/** Data structure with built-in tracking of all existing objects. */\n+template<size_t Size>\n+class TrackedObj\n+{\n+    static_assert(Size > 0);\n+\n+    /* Data type for map that actually stores the object data.\n+     *\n+     * The key is a pointer to the TrackedObj, the value is the uint64_t it was initialized with.\n+     * Default-constructed and moved-from objects hold an std::nullopt.\n+     */\n+    using track_map_type = std::map<const TrackedObj<Size>*, std::optional<uint64_t>>;\n+\n+private:\n+\n+    /** Actual map. */\n+    static inline track_map_type g_tracker;\n+\n+    /** Iterators into the tracker map for this object.\n+     *\n+     * This is an array of size Size, all holding the same value, to give the object configurable\n+     * size. The value is g_tracker.end() if this object is not fully initialized. */\n+    typename track_map_type::iterator m_track_entry[Size];\n+\n+    void Check() const\n+    {\n+        auto it = g_tracker.find(this);\n+        for (size_t i = 0; i < Size; ++i) {\n+            assert(m_track_entry[i] == it);\n+        }\n+    }\n+\n+    void Register()\n+    {\n+        auto [it, inserted] = g_tracker.emplace(this, std::nullopt);\n+        assert(inserted);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = it;\n+        }\n+    }\n+\n+    void Deregister()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        g_tracker.erase(m_track_entry[0]);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = g_tracker.end();\n+        }\n+    }\n+\n+    std::optional<uint64_t>& Deref()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613785977",
      "id" : 1613785977,
      "in_reply_to_id" : 1613661502,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gMGt5",
      "original_commit_id" : "017272dff1076068d5d878dbe599fb5a3e12115c",
      "original_line" : 333,
      "original_position" : 324,
      "original_start_line" : null,
      "path" : "src/test/fuzz/ringbuffer.cpp",
      "position" : null,
      "pull_request_review_id" : 2077455350,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785977/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T17:08:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785977",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613786034"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613786034"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In Rust they call it [`VecDeque`](https://doc.rust-lang.org/std/collections/struct.VecDeque.html), maybe that's a naming option? (It even rhymes!)",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T17:08:55Z",
      "diff_hunk" : "@@ -0,0 +1,259 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_RINGBUFFER_H\n+#define BITCOIN_UTIL_RINGBUFFER_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class RingBuffer",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613786034",
      "id" : 1613786034,
      "in_reply_to_id" : 1613702058,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gMGuy",
      "original_commit_id" : "c2a4915257f7b2303cd17a9a30728157616b5ce6",
      "original_line" : 23,
      "original_position" : 23,
      "original_start_line" : null,
      "path" : "src/util/ringbuffer.h",
      "position" : null,
      "pull_request_review_id" : 2077455436,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613786034/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T17:08:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613786034",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613786106"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613786106"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T17:09:00Z",
      "diff_hunk" : "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach\n+        // avoids the need to compute the number of applicable commands ahead of time).\n+        while (true) {\n+            if (num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Default construct. */\n+                real.emplace_back();\n+                sim.emplace_back();\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* resize() */\n+                size_t new_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                real[idx].resize(new_size);\n+                sim[idx].resize(new_size);\n+                assert(real[idx].size() == new_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* clear() */\n+                real[idx].clear();\n+                sim[idx].clear();\n+                assert(real[idx].empty());\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Copy construct default. */\n+                real[idx] = RingBuffer<T>();\n+                sim[idx].clear();\n+                assert(real[idx].size() == 0);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Destruct. */\n+                compare_fn(real.back(), sim.back());\n+                real.pop_back();\n+                sim.pop_back();\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Copy construct. */\n+                real.emplace_back(real[idx]);\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Move construct. */\n+                RingBuffer<T> copy(real[idx]);\n+                real.emplace_back(std::move(copy));\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* swap() */\n+                swap(real[idx], real[(idx + 1) % num_buffers]);\n+                swap(sim[idx], sim[(idx + 1) % sim.size()]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Copy assign. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = real[(idx + 1) % num_buffers];\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Move assign. */\n+                RingBuffer<T> copy(real[(idx + 1) % num_buffers]);\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = std::move(copy);\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* reserve() */\n+                size_t res_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                size_t old_cap = real[idx].capacity();\n+                size_t old_size = real[idx].size();\n+                real[idx].reserve(res_size);\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == std::max(old_cap, res_size));\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* shrink_to_fit() */\n+                size_t old_size = real[idx].size();\n+                real[idx].shrink_to_fit();\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_back(*tmp);\n+                sim[idx].push_back(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_back(*tmp);\n+                real[idx].push_back(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_back() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_back(seed);\n+                real[idx].emplace_back(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_front(*tmp);\n+                sim[idx].push_front(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_front(*tmp);\n+                real[idx].push_front(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_front() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_front(seed);\n+                real[idx].emplace_front(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* front() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].front() == real[idx].front());\n+                sim[idx].front() = *tmp;\n+                real[idx].front() = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* back() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].back() == real[idx].back());\n+                sim[idx].back() = *tmp;\n+                real[idx].back() = *tmp;\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* operator[] [modifying] */\n+                tmp = T(rng());\n+                size_t pos = provider.ConsumeIntegralInRange<size_t>(0, sim[idx].size() - 1);\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx][pos] == real[idx][pos]);\n+                sim[idx][pos] = *tmp;\n+                real[idx][pos] = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Fully compare the final state. */\n+    for (unsigned i = 0; i < sim.size(); ++i) {\n+        // Make sure const getters work.\n+        const RingBuffer<T>& realbuf = real[i];\n+        const std::deque<T>& simbuf = sim[i];\n+        compare_fn(realbuf, simbuf);\n+        for (unsigned j = 0; j < sim.size(); ++j) {\n+            assert((realbuf == real[j]) == (simbuf == sim[j]));\n+            assert(((realbuf <=> real[j]) >= 0) == (simbuf >= sim[j]));\n+            assert(((realbuf <=> real[j]) <= 0) == (simbuf <= sim[j]));\n+        }\n+        // Clear out the buffers so we can check below that no objects exist anymore.\n+        sim[i].clear();\n+        real[i].clear();\n+    }\n+\n+    if constexpr (CheckNoneLeft) {\n+        tmp = std::nullopt;\n+        T::CheckNoneExist();\n+    }\n+}\n+\n+/** Data structure with built-in tracking of all existing objects. */\n+template<size_t Size>\n+class TrackedObj\n+{\n+    static_assert(Size > 0);\n+\n+    /* Data type for map that actually stores the object data.\n+     *\n+     * The key is a pointer to the TrackedObj, the value is the uint64_t it was initialized with.\n+     * Default-constructed and moved-from objects hold an std::nullopt.\n+     */\n+    using track_map_type = std::map<const TrackedObj<Size>*, std::optional<uint64_t>>;\n+\n+private:\n+\n+    /** Actual map. */\n+    static inline track_map_type g_tracker;\n+\n+    /** Iterators into the tracker map for this object.\n+     *\n+     * This is an array of size Size, all holding the same value, to give the object configurable\n+     * size. The value is g_tracker.end() if this object is not fully initialized. */\n+    typename track_map_type::iterator m_track_entry[Size];\n+\n+    void Check() const\n+    {\n+        auto it = g_tracker.find(this);\n+        for (size_t i = 0; i < Size; ++i) {\n+            assert(m_track_entry[i] == it);\n+        }\n+    }\n+\n+    void Register()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613786106",
      "id" : 1613786106,
      "in_reply_to_id" : 1613660947,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gMGv6",
      "original_commit_id" : "017272dff1076068d5d878dbe599fb5a3e12115c",
      "original_line" : 313,
      "original_position" : 305,
      "original_start_line" : null,
      "path" : "src/test/fuzz/ringbuffer.cpp",
      "position" : null,
      "pull_request_review_id" : 2077455546,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613786106/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T17:09:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613786106",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613786217"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613786217"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done (and more).",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T17:09:08Z",
      "diff_hunk" : "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach\n+        // avoids the need to compute the number of applicable commands ahead of time).\n+        while (true) {\n+            if (num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Default construct. */\n+                real.emplace_back();\n+                sim.emplace_back();\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* resize() */\n+                size_t new_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                real[idx].resize(new_size);\n+                sim[idx].resize(new_size);\n+                assert(real[idx].size() == new_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* clear() */\n+                real[idx].clear();\n+                sim[idx].clear();\n+                assert(real[idx].empty());\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Copy construct default. */\n+                real[idx] = RingBuffer<T>();\n+                sim[idx].clear();\n+                assert(real[idx].size() == 0);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Destruct. */\n+                compare_fn(real.back(), sim.back());\n+                real.pop_back();\n+                sim.pop_back();\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Copy construct. */\n+                real.emplace_back(real[idx]);\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Move construct. */\n+                RingBuffer<T> copy(real[idx]);\n+                real.emplace_back(std::move(copy));\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* swap() */\n+                swap(real[idx], real[(idx + 1) % num_buffers]);\n+                swap(sim[idx], sim[(idx + 1) % sim.size()]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Copy assign. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = real[(idx + 1) % num_buffers];\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Move assign. */\n+                RingBuffer<T> copy(real[(idx + 1) % num_buffers]);\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = std::move(copy);\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* reserve() */\n+                size_t res_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                size_t old_cap = real[idx].capacity();\n+                size_t old_size = real[idx].size();\n+                real[idx].reserve(res_size);\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == std::max(old_cap, res_size));\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* shrink_to_fit() */\n+                size_t old_size = real[idx].size();\n+                real[idx].shrink_to_fit();\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_back(*tmp);\n+                sim[idx].push_back(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_back(*tmp);\n+                real[idx].push_back(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_back() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_back(seed);\n+                real[idx].emplace_back(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_front(*tmp);\n+                sim[idx].push_front(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_front(*tmp);\n+                real[idx].push_front(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_front() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_front(seed);\n+                real[idx].emplace_front(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* front() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].front() == real[idx].front());\n+                sim[idx].front() = *tmp;\n+                real[idx].front() = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* back() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].back() == real[idx].back());\n+                sim[idx].back() = *tmp;\n+                real[idx].back() = *tmp;\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* operator[] [modifying] */\n+                tmp = T(rng());\n+                size_t pos = provider.ConsumeIntegralInRange<size_t>(0, sim[idx].size() - 1);\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx][pos] == real[idx][pos]);\n+                sim[idx][pos] = *tmp;\n+                real[idx][pos] = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Fully compare the final state. */\n+    for (unsigned i = 0; i < sim.size(); ++i) {\n+        // Make sure const getters work.\n+        const RingBuffer<T>& realbuf = real[i];\n+        const std::deque<T>& simbuf = sim[i];\n+        compare_fn(realbuf, simbuf);\n+        for (unsigned j = 0; j < sim.size(); ++j) {\n+            assert((realbuf == real[j]) == (simbuf == sim[j]));\n+            assert(((realbuf <=> real[j]) >= 0) == (simbuf >= sim[j]));\n+            assert(((realbuf <=> real[j]) <= 0) == (simbuf <= sim[j]));\n+        }\n+        // Clear out the buffers so we can check below that no objects exist anymore.\n+        sim[i].clear();\n+        real[i].clear();\n+    }\n+\n+    if constexpr (CheckNoneLeft) {\n+        tmp = std::nullopt;\n+        T::CheckNoneExist();\n+    }\n+}\n+\n+/** Data structure with built-in tracking of all existing objects. */\n+template<size_t Size>\n+class TrackedObj\n+{\n+    static_assert(Size > 0);\n+\n+    /* Data type for map that actually stores the object data.\n+     *\n+     * The key is a pointer to the TrackedObj, the value is the uint64_t it was initialized with.\n+     * Default-constructed and moved-from objects hold an std::nullopt.\n+     */\n+    using track_map_type = std::map<const TrackedObj<Size>*, std::optional<uint64_t>>;\n+\n+private:\n+\n+    /** Actual map. */\n+    static inline track_map_type g_tracker;\n+\n+    /** Iterators into the tracker map for this object.\n+     *\n+     * This is an array of size Size, all holding the same value, to give the object configurable\n+     * size. The value is g_tracker.end() if this object is not fully initialized. */\n+    typename track_map_type::iterator m_track_entry[Size];\n+\n+    void Check() const\n+    {\n+        auto it = g_tracker.find(this);\n+        for (size_t i = 0; i < Size; ++i) {\n+            assert(m_track_entry[i] == it);\n+        }\n+    }\n+\n+    void Register()\n+    {\n+        auto [it, inserted] = g_tracker.emplace(this, std::nullopt);\n+        assert(inserted);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = it;\n+        }\n+    }\n+\n+    void Deregister()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        g_tracker.erase(m_track_entry[0]);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = g_tracker.end();\n+        }\n+    }\n+\n+    std::optional<uint64_t>& Deref()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        return m_track_entry[0]->second;\n+    }\n+\n+    const std::optional<uint64_t>& Deref() const\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        return m_track_entry[0]->second;\n+    }\n+\n+public:\n+    ~TrackedObj() { Deregister(); }\n+    TrackedObj() { Register(); }\n+\n+    TrackedObj(uint64_t value)\n+    {\n+        Register();\n+        Deref() = value;\n+    }\n+\n+    TrackedObj(const TrackedObj& other)\n+    {\n+        Register();\n+        Deref() = other.Deref();\n+    }\n+\n+    TrackedObj(TrackedObj&& other)\n+    {\n+        Register();\n+        Deref() = other.Deref();\n+        other.Deref() = std::nullopt;\n+    }\n+\n+    TrackedObj& operator=(const TrackedObj& other)\n+    {\n+        Deref() = other.Deref();\n+        return *this;\n+    }\n+\n+    TrackedObj& operator=(TrackedObj&& other)\n+    {\n+        Deref() = other.Deref();\n+        other.Deref() = std::nullopt;\n+        return *this;\n+    }\n+\n+    friend bool operator==(const TrackedObj& a, const TrackedObj& b)\n+    {\n+        return a.Deref() == b.Deref();\n+    }\n+\n+    friend std::strong_ordering operator<=>(const TrackedObj& a, const TrackedObj& b)\n+    {\n+        // Libc++ 15 & 16 do not support std::optional<T>::operator<=> yet. See\n+        // https://reviews.llvm.org/D146392.\n+        if (!a.Deref().has_value() || !b.Deref().has_value()) {\n+            return a.Deref().has_value() <=> b.Deref().has_value();\n+        }\n+        return *a.Deref() <=> *b.Deref();\n+    }\n+\n+    static void CheckNoneExist()\n+    {\n+        assert(g_tracker.empty());\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(ringbuffer)\n+{\n+    // Run the test with simple uints (which are std::is_trivially_copyable_v).\n+    TestType<uint8_t, false>(buffer, 1);\n+    TestType<uint16_t, false>(buffer, 2);\n+    TestType<uint32_t, false>(buffer, 3);\n+    TestType<uint64_t, false>(buffer, 4);\n+    // Run the test with TrackedObjs (which are not).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613786217",
      "id" : 1613786217,
      "in_reply_to_id" : 1613663028,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gMGxp",
      "original_commit_id" : "017272dff1076068d5d878dbe599fb5a3e12115c",
      "original_line" : 404,
      "original_position" : 404,
      "original_start_line" : null,
      "path" : "src/test/fuzz/ringbuffer.cpp",
      "position" : null,
      "pull_request_review_id" : 2077455736,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613786217/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T17:09:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613786217",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613810244"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613810244"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Renamed!",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T17:32:13Z",
      "diff_hunk" : "@@ -0,0 +1,259 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_RINGBUFFER_H\n+#define BITCOIN_UTIL_RINGBUFFER_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class RingBuffer",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613810244",
      "id" : 1613810244,
      "in_reply_to_id" : 1613702058,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gMMpE",
      "original_commit_id" : "c2a4915257f7b2303cd17a9a30728157616b5ce6",
      "original_line" : 23,
      "original_position" : 23,
      "original_start_line" : null,
      "path" : "src/util/ringbuffer.h",
      "position" : null,
      "pull_request_review_id" : 2077498512,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613810244/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T17:32:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613810244",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--85328a0da195eb286784d51f73fa0af9-->\n\nð§ At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/25390426376</sub>",
      "created_at" : "2024-05-24T17:35:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2130058565",
      "id" : 2130058565,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30161",
      "node_id" : "IC_kwDOABII585-9h1F",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2130058565/reactions"
      },
      "updated_at" : "2024-05-24T17:35:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2130058565",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613915882"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613915882"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Could do (i think 3?) memcmp here if `is_trivially_copyable_v`, but maybe it's not worth the complexity of differing offsets.",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T19:17:04Z",
      "diff_hunk" : "@@ -0,0 +1,261 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size)\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            if constexpr (std::is_trivially_constructible_v<T>) {\n+                // If T is trivially constructible, just zero-initialize the area being used.\n+                size_t first_part = std::min(m_capacity - Index(m_size), size - m_size);\n+                if (first_part) std::fill(m_buffer + Index(m_size), m_buffer + Index(m_size) + first_part, 0);\n+                if (first_part < size - m_size) std::fill(m_buffer, m_buffer + size - m_size - first_part, 0);\n+                m_size = size;\n+            } else {\n+                // Otherwise invoke the default constructor for every element separately.\n+                while (m_size < size) {\n+                    std::construct_at<T>(m_buffer + Index(m_size));\n+                    ++m_size;\n+                }\n+            }\n+        }\n+    }\n+\n+    void clear() { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at<T>(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613915882",
      "id" : 1613915882,
      "line" : 171,
      "node_id" : "PRRC_kwDOABII585gMmbq",
      "original_commit_id" : "f4d6f4a8548c63dbed72aa618d64b7ac2e7fcbad",
      "original_line" : 171,
      "original_position" : 171,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : 171,
      "pull_request_review_id" : 2077678840,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613915882/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T19:17:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613915882",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=4",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "node_id" : "MDQ6VXNlcjQxNzA0Mw==",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613922119"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613922119"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Trivially copyable does not imply a trivial `operator!=`, I think.",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T19:19:53Z",
      "diff_hunk" : "@@ -0,0 +1,261 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size)\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            if constexpr (std::is_trivially_constructible_v<T>) {\n+                // If T is trivially constructible, just zero-initialize the area being used.\n+                size_t first_part = std::min(m_capacity - Index(m_size), size - m_size);\n+                if (first_part) std::fill(m_buffer + Index(m_size), m_buffer + Index(m_size) + first_part, 0);\n+                if (first_part < size - m_size) std::fill(m_buffer, m_buffer + size - m_size - first_part, 0);\n+                m_size = size;\n+            } else {\n+                // Otherwise invoke the default constructor for every element separately.\n+                while (m_size < size) {\n+                    std::construct_at<T>(m_buffer + Index(m_size));\n+                    ++m_size;\n+                }\n+            }\n+        }\n+    }\n+\n+    void clear() { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at<T>(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613922119",
      "id" : 1613922119,
      "in_reply_to_id" : 1613915882,
      "line" : 171,
      "node_id" : "PRRC_kwDOABII585gMn9H",
      "original_commit_id" : "f4d6f4a8548c63dbed72aa618d64b7ac2e7fcbad",
      "original_line" : 171,
      "original_position" : 171,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : 171,
      "pull_request_review_id" : 2077689045,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613922119/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T19:22:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613922119",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613925002"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613925002"
         }
      },
      "author_association" : "MEMBER",
      "body" : "From https://en.cppreference.com/w/cpp/types/is_trivially_copyable:\r\n\"Objects of trivially-copyable types that are not potentially-overlapping subobjects are the only C++ objects that may be safely copied with [std::memcpy](https://en.cppreference.com/w/cpp/string/byte/memcpy) or serialized to/from binary files with [std::ofstream::write()](https://en.cppreference.com/w/cpp/io/basic_ostream/write) / [std::ifstream::read()](https://en.cppreference.com/w/cpp/io/basic_istream/read).\"\r\n\r\nI assume anything that can be memcpy'd can be memcmp'd.",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T19:22:58Z",
      "diff_hunk" : "@@ -0,0 +1,261 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size)\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            if constexpr (std::is_trivially_constructible_v<T>) {\n+                // If T is trivially constructible, just zero-initialize the area being used.\n+                size_t first_part = std::min(m_capacity - Index(m_size), size - m_size);\n+                if (first_part) std::fill(m_buffer + Index(m_size), m_buffer + Index(m_size) + first_part, 0);\n+                if (first_part < size - m_size) std::fill(m_buffer, m_buffer + size - m_size - first_part, 0);\n+                m_size = size;\n+            } else {\n+                // Otherwise invoke the default constructor for every element separately.\n+                while (m_size < size) {\n+                    std::construct_at<T>(m_buffer + Index(m_size));\n+                    ++m_size;\n+                }\n+            }\n+        }\n+    }\n+\n+    void clear() { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at<T>(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613925002",
      "id" : 1613925002,
      "in_reply_to_id" : 1613915882,
      "line" : 171,
      "node_id" : "PRRC_kwDOABII585gMoqK",
      "original_commit_id" : "f4d6f4a8548c63dbed72aa618d64b7ac2e7fcbad",
      "original_line" : 171,
      "original_position" : 171,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : 171,
      "pull_request_review_id" : 2077694876,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613925002/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T19:23:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613925002",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=4",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "node_id" : "MDQ6VXNlcjQxNzA0Mw==",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613941027"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613941027"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I certainly see why it's reasonable why trivial types would have a trivial comparison operator, but there is no guarantee for that. I think you can have a trivially-constructible type with an complex `operator==` (for such a type you'd expect that something that was memcpy'd you end up with a result that satisfies ==, but I don't think that's required, and it also doesn't work the other way around: objects could satisfy == without being bitwise identical).",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T19:31:04Z",
      "diff_hunk" : "@@ -0,0 +1,261 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size)\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            if constexpr (std::is_trivially_constructible_v<T>) {\n+                // If T is trivially constructible, just zero-initialize the area being used.\n+                size_t first_part = std::min(m_capacity - Index(m_size), size - m_size);\n+                if (first_part) std::fill(m_buffer + Index(m_size), m_buffer + Index(m_size) + first_part, 0);\n+                if (first_part < size - m_size) std::fill(m_buffer, m_buffer + size - m_size - first_part, 0);\n+                m_size = size;\n+            } else {\n+                // Otherwise invoke the default constructor for every element separately.\n+                while (m_size < size) {\n+                    std::construct_at<T>(m_buffer + Index(m_size));\n+                    ++m_size;\n+                }\n+            }\n+        }\n+    }\n+\n+    void clear() { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at<T>(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613941027",
      "id" : 1613941027,
      "in_reply_to_id" : 1613915882,
      "line" : 171,
      "node_id" : "PRRC_kwDOABII585gMskj",
      "original_commit_id" : "f4d6f4a8548c63dbed72aa618d64b7ac2e7fcbad",
      "original_line" : 171,
      "original_position" : 171,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : 171,
      "pull_request_review_id" : 2077727864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613941027/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T19:31:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613941027",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613943540"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613943540"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Ok, yeah, agreed.",
      "commit_id" : "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "created_at" : "2024-05-24T19:34:39Z",
      "diff_hunk" : "@@ -0,0 +1,261 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size)\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            if constexpr (std::is_trivially_constructible_v<T>) {\n+                // If T is trivially constructible, just zero-initialize the area being used.\n+                size_t first_part = std::min(m_capacity - Index(m_size), size - m_size);\n+                if (first_part) std::fill(m_buffer + Index(m_size), m_buffer + Index(m_size) + first_part, 0);\n+                if (first_part < size - m_size) std::fill(m_buffer, m_buffer + size - m_size - first_part, 0);\n+                m_size = size;\n+            } else {\n+                // Otherwise invoke the default constructor for every element separately.\n+                while (m_size < size) {\n+                    std::construct_at<T>(m_buffer + Index(m_size));\n+                    ++m_size;\n+                }\n+            }\n+        }\n+    }\n+\n+    void clear() { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at<T>(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613943540",
      "id" : 1613943540,
      "in_reply_to_id" : 1613915882,
      "line" : 171,
      "node_id" : "PRRC_kwDOABII585gMtL0",
      "original_commit_id" : "f4d6f4a8548c63dbed72aa618d64b7ac2e7fcbad",
      "original_line" : 171,
      "original_position" : 171,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : 171,
      "pull_request_review_id" : 2077737706,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613943540/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T19:34:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613943540",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=4",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "node_id" : "MDQ6VXNlcjQxNzA0Mw==",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1614029973"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1614029973"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Just adding for posterity because I went down a rabbit hole for this:\r\n\r\nIt seems clang's `__is_trivially_equality_comparable` builtin would do what we want here:\r\n> Returns true if comparing two objects of the provided type is known to be equivalent to comparing their object representations. Note that types containing padding bytes are never trivially equality comparable.\r\n\r\n[From libc++](https://github.com/llvm/llvm-project/blob/main/libcxx/include/__type_traits/is_equality_comparable.h#L36C1-L37C41):\r\n```c++\r\n// A type is_trivially_equality_comparable if the expression `a == b` is equivalent to `std::memcmp(&a, &b, sizeof(T))`\r\n// (with `a` and `b` being of type `T`).\r\n```\r\nNot that it's worth using here.",
      "commit_id" : "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "created_at" : "2024-05-24T21:14:50Z",
      "diff_hunk" : "@@ -0,0 +1,261 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size)\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            if constexpr (std::is_trivially_constructible_v<T>) {\n+                // If T is trivially constructible, just zero-initialize the area being used.\n+                size_t first_part = std::min(m_capacity - Index(m_size), size - m_size);\n+                if (first_part) std::fill(m_buffer + Index(m_size), m_buffer + Index(m_size) + first_part, 0);\n+                if (first_part < size - m_size) std::fill(m_buffer, m_buffer + size - m_size - first_part, 0);\n+                m_size = size;\n+            } else {\n+                // Otherwise invoke the default constructor for every element separately.\n+                while (m_size < size) {\n+                    std::construct_at<T>(m_buffer + Index(m_size));\n+                    ++m_size;\n+                }\n+            }\n+        }\n+    }\n+\n+    void clear() { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at<T>(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1614029973",
      "id" : 1614029973,
      "in_reply_to_id" : 1613915882,
      "line" : 162,
      "node_id" : "PRRC_kwDOABII585gNCSV",
      "original_commit_id" : "f4d6f4a8548c63dbed72aa618d64b7ac2e7fcbad",
      "original_line" : 162,
      "original_position" : 171,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : 162,
      "pull_request_review_id" : 2078066616,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1614029973/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T22:11:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1614029973",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=4",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "node_id" : "MDQ6VXNlcjQxNzA0Mw==",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1614066880"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1614066880"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Interesting!",
      "commit_id" : "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "created_at" : "2024-05-24T21:56:18Z",
      "diff_hunk" : "@@ -0,0 +1,261 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size)\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            if constexpr (std::is_trivially_constructible_v<T>) {\n+                // If T is trivially constructible, just zero-initialize the area being used.\n+                size_t first_part = std::min(m_capacity - Index(m_size), size - m_size);\n+                if (first_part) std::fill(m_buffer + Index(m_size), m_buffer + Index(m_size) + first_part, 0);\n+                if (first_part < size - m_size) std::fill(m_buffer, m_buffer + size - m_size - first_part, 0);\n+                m_size = size;\n+            } else {\n+                // Otherwise invoke the default constructor for every element separately.\n+                while (m_size < size) {\n+                    std::construct_at<T>(m_buffer + Index(m_size));\n+                    ++m_size;\n+                }\n+            }\n+        }\n+    }\n+\n+    void clear() { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at<T>(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1614066880",
      "id" : 1614066880,
      "in_reply_to_id" : 1613915882,
      "line" : 162,
      "node_id" : "PRRC_kwDOABII585gNLTA",
      "original_commit_id" : "f4d6f4a8548c63dbed72aa618d64b7ac2e7fcbad",
      "original_line" : 162,
      "original_position" : 171,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : 162,
      "pull_request_review_id" : 2078108333,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1614066880/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T21:56:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1614066880",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Apparently `std::is_trivially_default_constructible_v<T>` does not imply you can just memset 0 to construct the objects (or at least, I can't find evidence of that). So I've dropped that branch.",
      "created_at" : "2024-05-26T00:01:14Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2131728449",
      "id" : 2131728449,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30161",
      "node_id" : "IC_kwDOABII585_D5hB",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2131728449/reactions"
      },
      "updated_at" : "2024-05-26T00:01:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2131728449",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK.",
      "created_at" : "2024-05-27T12:12:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2133351751",
      "id" : 2133351751,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30161",
      "node_id" : "IC_kwDOABII585_KF1H",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133351751/reactions"
      },
      "updated_at" : "2024-05-27T12:12:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133351751",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> It's not a full drop-in replacement...\r\n\r\nThen, perhaps, it's a good chance to avoid `size_t` for parameter and return types in the interface?\r\n\r\nSee: [Signed and Unsigned Types in Interfaces](https://www.aristeia.com/Papers/C++ReportColumns/sep95.pdf)",
      "created_at" : "2024-05-27T12:59:30Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2133434672",
      "id" : 2133434672,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30161",
      "node_id" : "IC_kwDOABII585_KaEw",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133434672/reactions"
      },
      "updated_at" : "2024-05-27T12:59:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133434672",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1616905695"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1616905695"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: \r\n```suggestion\r\n    /** Number of objects in the container. m_size <= m_capacity. */\r\n```",
      "commit_id" : "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "created_at" : "2024-05-28T09:30:29Z",
      "diff_hunk" : "@@ -0,0 +1,252 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1616905695",
      "id" : 1616905695,
      "line" : 29,
      "node_id" : "PRRC_kwDOABII585gYAXf",
      "original_commit_id" : "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_line" : 29,
      "original_position" : 29,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : 29,
      "pull_request_review_id" : 2082248884,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1616905695/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-28T09:30:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1616905695",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1616940538"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1616940538"
         }
      },
      "author_association" : "MEMBER",
      "body" : "What is the purpose of this line here? It doesn't look like a pre-condition for the function arguments. It seems it should be used as a post-condition for `m_capacity` mutators (including this function) and `m_offset` mutators, no?",
      "commit_id" : "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "created_at" : "2024-05-28T09:55:18Z",
      "diff_hunk" : "@@ -0,0 +1,252 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1616940538",
      "id" : 1616940538,
      "line" : 39,
      "node_id" : "PRRC_kwDOABII585gYI36",
      "original_commit_id" : "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_line" : 39,
      "original_position" : 39,
      "original_start_line" : null,
      "path" : "src/util/vecdeque.h",
      "position" : 39,
      "pull_request_review_id" : 2082303692,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1616940538/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-28T09:55:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1616940538",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   }
]
