[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage\nFor detailed information about the code coverage, see the [test coverage report](https://corecheck.dev/bitcoin/bitcoin/pulls/30160).\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [instagibbs](https://github.com/bitcoin/bitcoin/pull/30160#issuecomment-2158379951), [cbergqvist](https://github.com/bitcoin/bitcoin/pull/30160#pullrequestreview-2107852785) |\n| Concept ACK | [theStack](https://github.com/bitcoin/bitcoin/pull/30160#pullrequestreview-2082445138), [hebasto](https://github.com/bitcoin/bitcoin/pull/30160#issuecomment-2147744433) |\n\nIf your review is incorrectly listed, please react with ð to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#29625](https://github.com/bitcoin/bitcoin/pull/29625) (Several randomness improvements by sipa)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "created_at" : "2024-05-23T15:42:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30160#issuecomment-2127454745",
      "id" : 2127454745,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30160",
      "node_id" : "IC_kwDOABII585-zmIZ",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2127454745/reactions"
      },
      "updated_at" : "2024-06-10T13:44:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2127454745",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1612232560"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612232560"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`std::bitset` throws for these if pos is out of range.\r\n\r\nMaybe add `Assume()`s? Or were you trying to keep the header self-contained?",
      "commit_id" : "aeef8a4dcf982cb76bca9571871196c4b25a1bdd",
      "created_at" : "2024-05-23T19:55:17Z",
      "diff_hunk" : "@@ -0,0 +1,463 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a && b\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept {\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept {\n+        IntBitSet ret;\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept { m_val |= I{1U} << pos; }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1612232560",
      "id" : 1612232560,
      "line" : 144,
      "node_id" : "PRRC_kwDOABII585gGLdw",
      "original_commit_id" : "a12b4052dad2158cf21de07fded63fb224dba915",
      "original_line" : 144,
      "original_position" : 144,
      "original_start_line" : null,
      "path" : "src/util/bitset.h",
      "position" : 144,
      "pull_request_review_id" : 2074881667,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612232560/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T19:55:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612232560",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=4",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "node_id" : "MDQ6VXNlcjQxNzA0Mw==",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1612240218"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612240218"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I know you like dense code, but...\r\n\r\nI suspect function names would make reviewing uses of this easier than operators. Especially for the non-obvious ones like `&&` that `std::bitset` doesn't support.\r\n\r\nI know that personally I'd have an easier time reviewing `a.intersects(b)`.",
      "commit_id" : "aeef8a4dcf982cb76bca9571871196c4b25a1bdd",
      "created_at" : "2024-05-23T20:03:01Z",
      "diff_hunk" : "@@ -0,0 +1,463 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a && b\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept {\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept {\n+        IntBitSet ret;\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept { m_val |= I{1U} << pos; }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept { m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos); }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept { m_val &= ~I(I{1U} << pos); }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept { return (m_val >> pos) & 1U; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator/=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const IntBitSet& a, const IntBitSet& b) noexcept { return a.m_val & b.m_val; }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1612240218",
      "id" : 1612240218,
      "line" : 172,
      "node_id" : "PRRC_kwDOABII585gGNVa",
      "original_commit_id" : "a12b4052dad2158cf21de07fded63fb224dba915",
      "original_line" : 172,
      "original_position" : 172,
      "original_start_line" : null,
      "path" : "src/util/bitset.h",
      "position" : 172,
      "pull_request_review_id" : 2074894349,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612240218/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-23T20:03:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612240218",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=4",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "node_id" : "MDQ6VXNlcjQxNzA0Mw==",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1613105680"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613105680"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Have you considered using `__int128`, `__int256` etc when available, before falling back to `MultiIntBitSet`? Maybe something for a follow-up PR.",
      "commit_id" : "3bc131a85ce826aa171f0328c014ea51b8740fed",
      "created_at" : "2024-05-24T08:44:43Z",
      "diff_hunk" : "@@ -0,0 +1,463 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a && b\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept {\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept {\n+        IntBitSet ret;\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept { m_val |= I{1U} << pos; }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept { m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos); }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept { m_val &= ~I(I{1U} << pos); }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept { return (m_val >> pos) & 1U; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator/=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const IntBitSet& a, const IntBitSet& b) noexcept { return a.m_val & b.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator/(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const IntBitSet& a, const IntBitSet& b) noexcept { return (b.m_val & ~a.m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    friend constexpr bool operator<=(const IntBitSet& a, const IntBitSet& b) noexcept { return (a.m_val & ~b.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>* ptr) noexcept : m_ptr(ptr), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept { m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS); }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept { m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) | (I{val} << (pos % LIMB_BITS)); }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept { m_val[pos / LIMB_BITS] &= ~I(I{1U} << (pos % LIMB_BITS)); }\n+    /** Retrieve a bit at the given position. */\n+    bool constexpr operator[](unsigned pos) const noexcept { return (m_val[pos / LIMB_BITS] >> (pos % LIMB_BITS)) & 1U; }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr MultiIntBitSet Singleton(unsigned i) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        ret.m_val[i / LIMB_BITS] = I{1U} << (i % LIMB_BITS);\n+        return ret;\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr MultiIntBitSet Fill(unsigned count) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        if (count) {\n+            unsigned i = 0;\n+            while (count > LIMB_BITS) {\n+                ret.m_val[i++] = ~I{0};\n+                count -= LIMB_BITS;\n+            }\n+            ret.m_val[i] = I(~I{0}) >> (LIMB_BITS - count);\n+        }\n+        return ret;\n+    }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Compute the number of 1 bits in the bitset. */\n+    unsigned constexpr Count() const noexcept\n+    {\n+        unsigned ret{0};\n+        for (I v : m_val) ret += PopCount(v);\n+        return ret;\n+    }\n+    /** Check if all bits are 0. */\n+    bool constexpr None() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if any bits are 1. */\n+    bool constexpr Any() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return true;\n+        }\n+        return false;\n+    }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    Iterator constexpr begin() const noexcept { return Iterator(&m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    IteratorEnd constexpr end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    unsigned constexpr First() const noexcept\n+    {\n+        unsigned p = 0;\n+        while (m_val[p] == 0) ++p;\n+        return std::countr_zero(m_val[p]) + p * LIMB_BITS;\n+    }\n+    /** Find the last element (requires Any()). */\n+    unsigned constexpr Last() const noexcept\n+    {\n+        unsigned p = N - 1;\n+        while (m_val[p] == 0) --p;\n+        return std::bit_width(m_val[p]) - 1 + p * LIMB_BITS;\n+    }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator|=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] |= a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator&=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] &= a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator/=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] &= ~a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Set this object's bits to be the binary XOR between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator^=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] ^= a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Check whether the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            if (a.m_val[i] & b.m_val[i]) return true;\n+        }\n+        return false;\n+    }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator&(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] & b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator|(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] | b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator/(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] & ~b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator^(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] ^ b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            if (b.m_val[i] & ~a.m_val[i]) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    friend constexpr bool operator<=(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            if (a.m_val[i] & ~b.m_val[i]) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept = default;\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(MultiIntBitSet& a, MultiIntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+} // namespace bitset_detail\n+\n+// BitSet dispatches to IntBitSet or MultiIntBitSet as appropriate for the requested minimum number\n+// of bits.\n+template<unsigned BITS>\n+using BitSet = std::conditional_t<(BITS <= 32), bitset_detail::IntBitSet<uint32_t>,\n+               std::conditional_t<(BITS <= std::numeric_limits<size_t>::digits), bitset_detail::IntBitSet<size_t>,\n+               bitset_detail::MultiIntBitSet<size_t, (BITS + std::numeric_limits<size_t>::digits - 1) / std::numeric_limits<size_t>::digits>>>;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1613105680",
      "id" : 1613105680,
      "line" : 508,
      "node_id" : "PRRC_kwDOABII585gJgoQ",
      "original_commit_id" : "aeef8a4dcf982cb76bca9571871196c4b25a1bdd",
      "original_line" : 508,
      "original_position" : 461,
      "original_start_line" : 460,
      "path" : "src/util/bitset.h",
      "position" : 508,
      "pull_request_review_id" : 2076257466,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613105680/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 507,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2024-05-28T11:52:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613105680",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/581308?v=4",
         "events_url" : "https://api.github.com/users/cbergqvist/events{/privacy}",
         "followers_url" : "https://api.github.com/users/cbergqvist/followers",
         "following_url" : "https://api.github.com/users/cbergqvist/following{/other_user}",
         "gists_url" : "https://api.github.com/users/cbergqvist/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/cbergqvist",
         "id" : 581308,
         "login" : "cbergqvist",
         "node_id" : "MDQ6VXNlcjU4MTMwOA==",
         "organizations_url" : "https://api.github.com/users/cbergqvist/orgs",
         "received_events_url" : "https://api.github.com/users/cbergqvist/received_events",
         "repos_url" : "https://api.github.com/users/cbergqvist/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/cbergqvist/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/cbergqvist/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/cbergqvist"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1613223825"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613223825"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: Superfluous `I()`",
      "commit_id" : "3bc131a85ce826aa171f0328c014ea51b8740fed",
      "created_at" : "2024-05-24T10:05:10Z",
      "diff_hunk" : "@@ -0,0 +1,463 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a && b\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept {\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept {\n+        IntBitSet ret;\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept { m_val |= I{1U} << pos; }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept { m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos); }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept { m_val &= ~I(I{1U} << pos); }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept { return (m_val >> pos) & 1U; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator/=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const IntBitSet& a, const IntBitSet& b) noexcept { return a.m_val & b.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator/(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const IntBitSet& a, const IntBitSet& b) noexcept { return (b.m_val & ~a.m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    friend constexpr bool operator<=(const IntBitSet& a, const IntBitSet& b) noexcept { return (a.m_val & ~b.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>* ptr) noexcept : m_ptr(ptr), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept { m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS); }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept { m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) | (I{val} << (pos % LIMB_BITS)); }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept { m_val[pos / LIMB_BITS] &= ~I(I{1U} << (pos % LIMB_BITS)); }\n+    /** Retrieve a bit at the given position. */\n+    bool constexpr operator[](unsigned pos) const noexcept { return (m_val[pos / LIMB_BITS] >> (pos % LIMB_BITS)) & 1U; }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr MultiIntBitSet Singleton(unsigned i) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        ret.m_val[i / LIMB_BITS] = I{1U} << (i % LIMB_BITS);\n+        return ret;\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr MultiIntBitSet Fill(unsigned count) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        if (count) {\n+            unsigned i = 0;\n+            while (count > LIMB_BITS) {\n+                ret.m_val[i++] = ~I{0};\n+                count -= LIMB_BITS;\n+            }\n+            ret.m_val[i] = I(~I{0}) >> (LIMB_BITS - count);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1613223825",
      "id" : 1613223825,
      "line" : 356,
      "node_id" : "PRRC_kwDOABII585gJ9eR",
      "original_commit_id" : "aeef8a4dcf982cb76bca9571871196c4b25a1bdd",
      "original_line" : 356,
      "original_position" : 309,
      "original_start_line" : null,
      "path" : "src/util/bitset.h",
      "position" : 356,
      "pull_request_review_id" : 2076257466,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613223825/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-28T11:52:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613223825",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/581308?v=4",
         "events_url" : "https://api.github.com/users/cbergqvist/events{/privacy}",
         "followers_url" : "https://api.github.com/users/cbergqvist/followers",
         "following_url" : "https://api.github.com/users/cbergqvist/following{/other_user}",
         "gists_url" : "https://api.github.com/users/cbergqvist/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/cbergqvist",
         "id" : 581308,
         "login" : "cbergqvist",
         "node_id" : "MDQ6VXNlcjU4MTMwOA==",
         "organizations_url" : "https://api.github.com/users/cbergqvist/orgs",
         "received_events_url" : "https://api.github.com/users/cbergqvist/received_events",
         "repos_url" : "https://api.github.com/users/cbergqvist/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/cbergqvist/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/cbergqvist/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/cbergqvist"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1613558242"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613558242"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`.Subset()` and `.Superset()`?\r\n\r\nWithout these comments, I would have to guess at the meanings (and I would have guessed wrong).",
      "commit_id" : "692e533f0b698960c0fd87b47706f7542d467f5f",
      "created_at" : "2024-05-24T14:17:56Z",
      "diff_hunk" : "@@ -0,0 +1,510 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);\n+    }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val >> pos) & 1U;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator/=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    constexpr bool Overlaps(const IntBitSet& a) noexcept { return m_val & a.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator/(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const IntBitSet& a, const IntBitSet& b) noexcept { return (b.m_val & ~a.m_val) == 0; }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1613558242",
      "id" : 1613558242,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gLPHi",
      "original_commit_id" : "797ea9aca05a6dafb70e224e6a7d89bb18294150",
      "original_line" : 212,
      "original_position" : 212,
      "original_start_line" : null,
      "path" : "src/util/bitset.h",
      "position" : null,
      "pull_request_review_id" : 2077061355,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613558242/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T14:17:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613558242",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=4",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "node_id" : "MDQ6VXNlcjQxNzA0Mw==",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1613674776"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613674776"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "692e533f0b698960c0fd87b47706f7542d467f5f",
      "created_at" : "2024-05-24T15:37:28Z",
      "diff_hunk" : "@@ -0,0 +1,463 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a && b\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept {\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept {\n+        IntBitSet ret;\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept { m_val |= I{1U} << pos; }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1613674776",
      "id" : 1613674776,
      "in_reply_to_id" : 1612232560,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gLrkY",
      "original_commit_id" : "a12b4052dad2158cf21de07fded63fb224dba915",
      "original_line" : 144,
      "original_position" : 144,
      "original_start_line" : null,
      "path" : "src/util/bitset.h",
      "position" : null,
      "pull_request_review_id" : 2077267486,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613674776/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T15:37:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613674776",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1613675392"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613675392"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Replaced with `Overlaps()`.",
      "commit_id" : "692e533f0b698960c0fd87b47706f7542d467f5f",
      "created_at" : "2024-05-24T15:37:50Z",
      "diff_hunk" : "@@ -0,0 +1,463 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a && b\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept {\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept {\n+        IntBitSet ret;\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept { m_val |= I{1U} << pos; }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept { m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos); }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept { m_val &= ~I(I{1U} << pos); }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept { return (m_val >> pos) & 1U; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator/=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const IntBitSet& a, const IntBitSet& b) noexcept { return a.m_val & b.m_val; }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1613675392",
      "id" : 1613675392,
      "in_reply_to_id" : 1612240218,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gLruA",
      "original_commit_id" : "a12b4052dad2158cf21de07fded63fb224dba915",
      "original_line" : 172,
      "original_position" : 172,
      "original_start_line" : null,
      "path" : "src/util/bitset.h",
      "position" : null,
      "pull_request_review_id" : 2077268563,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613675392/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T15:37:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613675392",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1613675918"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613675918"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Replaced with `IsSubsetOf()` and `IsSupersetOf()`.",
      "commit_id" : "692e533f0b698960c0fd87b47706f7542d467f5f",
      "created_at" : "2024-05-24T15:38:09Z",
      "diff_hunk" : "@@ -0,0 +1,510 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);\n+    }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val >> pos) & 1U;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator/=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    constexpr bool Overlaps(const IntBitSet& a) noexcept { return m_val & a.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator/(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const IntBitSet& a, const IntBitSet& b) noexcept { return (b.m_val & ~a.m_val) == 0; }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1613675918",
      "id" : 1613675918,
      "in_reply_to_id" : 1613558242,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gLr2O",
      "original_commit_id" : "797ea9aca05a6dafb70e224e6a7d89bb18294150",
      "original_line" : 212,
      "original_position" : 212,
      "original_start_line" : null,
      "path" : "src/util/bitset.h",
      "position" : null,
      "pull_request_review_id" : 2077269480,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613675918/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-24T15:38:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613675918",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1617026499"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617026499"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "It's a bit scary that `MultiIntBitSet::{First,Last}` lead to buffer over/under-reads if no bit is set. I understand that we wouldn't want to do assert for `Any` in production for performance reasons, but it's maybe worth it do it for debug builds, e.g. with somethink like the `ASSERT_IF_DEBUG` construct used in src/span.h.",
      "commit_id" : "f03f3fe27dfcaf5e3fe4744a5c85e68a1480c893",
      "created_at" : "2024-05-28T11:01:55Z",
      "diff_hunk" : "@@ -0,0 +1,510 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);\n+    }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val >> pos) & 1U;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator-=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    constexpr bool Overlaps(const IntBitSet& a) const noexcept { return m_val & a.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator-(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    constexpr bool IsSupersetOf(const IntBitSet& a) const noexcept { return (a.m_val & ~m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    constexpr bool IsSubsetOf(const IntBitSet& a) const noexcept { return (m_val & ~a.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>* ptr) noexcept : m_ptr(ptr), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS);\n+    }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) |\n+                                 (I{val} << (pos % LIMB_BITS));\n+    }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] &= ~I(I{1U} << (pos % LIMB_BITS));\n+    }\n+    /** Retrieve a bit at the given position. */\n+    bool constexpr operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val[pos / LIMB_BITS] >> (pos % LIMB_BITS)) & 1U;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr MultiIntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        MultiIntBitSet ret;\n+        ret.m_val[i / LIMB_BITS] = I{1U} << (i % LIMB_BITS);\n+        return ret;\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr MultiIntBitSet Fill(unsigned count) noexcept\n+    {\n+        Assume(count <= MAX_SIZE);\n+        MultiIntBitSet ret;\n+        if (count) {\n+            unsigned i = 0;\n+            while (count > LIMB_BITS) {\n+                ret.m_val[i++] = ~I{0};\n+                count -= LIMB_BITS;\n+            }\n+            ret.m_val[i] = I(~I{0}) >> (LIMB_BITS - count);\n+        }\n+        return ret;\n+    }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Compute the number of 1 bits in the bitset. */\n+    unsigned constexpr Count() const noexcept\n+    {\n+        unsigned ret{0};\n+        for (I v : m_val) ret += PopCount(v);\n+        return ret;\n+    }\n+    /** Check if all bits are 0. */\n+    bool constexpr None() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if any bits are 1. */\n+    bool constexpr Any() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return true;\n+        }\n+        return false;\n+    }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    Iterator constexpr begin() const noexcept { return Iterator(&m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    IteratorEnd constexpr end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    unsigned constexpr First() const noexcept\n+    {\n+        unsigned p = 0;\n+        while (m_val[p] == 0) ++p;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1617026499",
      "id" : 1617026499,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gYd3D",
      "original_commit_id" : "beb535680b85b511709240a8e1f7de59864b3524",
      "original_line" : 393,
      "original_position" : 393,
      "original_start_line" : null,
      "path" : "src/util/bitset.h",
      "position" : null,
      "pull_request_review_id" : 2082445138,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617026499/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-28T12:20:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617026499",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1617040989"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617040989"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: `ptr` could be passed as a reference to signify non-nullness. (But the member still needs to be a pointer). Not at all significant as it is a private function.",
      "commit_id" : "3bc131a85ce826aa171f0328c014ea51b8740fed",
      "created_at" : "2024-05-28T11:13:46Z",
      "diff_hunk" : "@@ -0,0 +1,510 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);\n+    }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val >> pos) & 1U;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator-=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    constexpr bool Overlaps(const IntBitSet& a) const noexcept { return m_val & a.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator-(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    constexpr bool IsSupersetOf(const IntBitSet& a) const noexcept { return (a.m_val & ~m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    constexpr bool IsSubsetOf(const IntBitSet& a) const noexcept { return (m_val & ~a.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>* ptr) noexcept : m_ptr(ptr), m_idx(0)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1617040989",
      "id" : 1617040989,
      "line" : 247,
      "node_id" : "PRRC_kwDOABII585gYhZd",
      "original_commit_id" : "3bc131a85ce826aa171f0328c014ea51b8740fed",
      "original_line" : 247,
      "original_position" : 247,
      "original_start_line" : null,
      "path" : "src/util/bitset.h",
      "position" : 247,
      "pull_request_review_id" : 2076257466,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617040989/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-28T11:52:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617040989",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/581308?v=4",
         "events_url" : "https://api.github.com/users/cbergqvist/events{/privacy}",
         "followers_url" : "https://api.github.com/users/cbergqvist/followers",
         "following_url" : "https://api.github.com/users/cbergqvist/following{/other_user}",
         "gists_url" : "https://api.github.com/users/cbergqvist/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/cbergqvist",
         "id" : 581308,
         "login" : "cbergqvist",
         "node_id" : "MDQ6VXNlcjU4MTMwOA==",
         "organizations_url" : "https://api.github.com/users/cbergqvist/orgs",
         "received_events_url" : "https://api.github.com/users/cbergqvist/received_events",
         "repos_url" : "https://api.github.com/users/cbergqvist/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/cbergqvist/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/cbergqvist/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/cbergqvist"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1617148751"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617148751"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I have not benchmarked this, but I have a hard time imagining how that can be faster, as common hardware doesn't have general-purpose registers bigger than `size_t`, so `__int128` operations get simulated using multiple variables anyway. Some architectures do have vector extensions (SSE, AVX, ...) which introduce native 128-, 256-, or 512-bit registers, but those generally only support operations of units up to 32 to 64 bits in them (including leading-zero counting, or popcount, which we need here).",
      "commit_id" : "f03f3fe27dfcaf5e3fe4744a5c85e68a1480c893",
      "created_at" : "2024-05-28T12:21:47Z",
      "diff_hunk" : "@@ -0,0 +1,463 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a && b\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept {\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept {\n+        IntBitSet ret;\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept { m_val |= I{1U} << pos; }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept { m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos); }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept { m_val &= ~I(I{1U} << pos); }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept { return (m_val >> pos) & 1U; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator/=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const IntBitSet& a, const IntBitSet& b) noexcept { return a.m_val & b.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator/(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const IntBitSet& a, const IntBitSet& b) noexcept { return (b.m_val & ~a.m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    friend constexpr bool operator<=(const IntBitSet& a, const IntBitSet& b) noexcept { return (a.m_val & ~b.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>* ptr) noexcept : m_ptr(ptr), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept { m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS); }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept { m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) | (I{val} << (pos % LIMB_BITS)); }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept { m_val[pos / LIMB_BITS] &= ~I(I{1U} << (pos % LIMB_BITS)); }\n+    /** Retrieve a bit at the given position. */\n+    bool constexpr operator[](unsigned pos) const noexcept { return (m_val[pos / LIMB_BITS] >> (pos % LIMB_BITS)) & 1U; }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr MultiIntBitSet Singleton(unsigned i) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        ret.m_val[i / LIMB_BITS] = I{1U} << (i % LIMB_BITS);\n+        return ret;\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr MultiIntBitSet Fill(unsigned count) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        if (count) {\n+            unsigned i = 0;\n+            while (count > LIMB_BITS) {\n+                ret.m_val[i++] = ~I{0};\n+                count -= LIMB_BITS;\n+            }\n+            ret.m_val[i] = I(~I{0}) >> (LIMB_BITS - count);\n+        }\n+        return ret;\n+    }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Compute the number of 1 bits in the bitset. */\n+    unsigned constexpr Count() const noexcept\n+    {\n+        unsigned ret{0};\n+        for (I v : m_val) ret += PopCount(v);\n+        return ret;\n+    }\n+    /** Check if all bits are 0. */\n+    bool constexpr None() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if any bits are 1. */\n+    bool constexpr Any() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return true;\n+        }\n+        return false;\n+    }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    Iterator constexpr begin() const noexcept { return Iterator(&m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    IteratorEnd constexpr end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    unsigned constexpr First() const noexcept\n+    {\n+        unsigned p = 0;\n+        while (m_val[p] == 0) ++p;\n+        return std::countr_zero(m_val[p]) + p * LIMB_BITS;\n+    }\n+    /** Find the last element (requires Any()). */\n+    unsigned constexpr Last() const noexcept\n+    {\n+        unsigned p = N - 1;\n+        while (m_val[p] == 0) --p;\n+        return std::bit_width(m_val[p]) - 1 + p * LIMB_BITS;\n+    }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator|=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] |= a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator&=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] &= a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator/=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] &= ~a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Set this object's bits to be the binary XOR between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator^=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] ^= a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Check whether the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            if (a.m_val[i] & b.m_val[i]) return true;\n+        }\n+        return false;\n+    }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator&(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] & b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator|(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] | b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator/(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] & ~b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator^(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] ^ b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            if (b.m_val[i] & ~a.m_val[i]) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    friend constexpr bool operator<=(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            if (a.m_val[i] & ~b.m_val[i]) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept = default;\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(MultiIntBitSet& a, MultiIntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+} // namespace bitset_detail\n+\n+// BitSet dispatches to IntBitSet or MultiIntBitSet as appropriate for the requested minimum number\n+// of bits.\n+template<unsigned BITS>\n+using BitSet = std::conditional_t<(BITS <= 32), bitset_detail::IntBitSet<uint32_t>,\n+               std::conditional_t<(BITS <= std::numeric_limits<size_t>::digits), bitset_detail::IntBitSet<size_t>,\n+               bitset_detail::MultiIntBitSet<size_t, (BITS + std::numeric_limits<size_t>::digits - 1) / std::numeric_limits<size_t>::digits>>>;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1617148751",
      "id" : 1617148751,
      "in_reply_to_id" : 1613105680,
      "line" : 517,
      "node_id" : "PRRC_kwDOABII585gY7tP",
      "original_commit_id" : "aeef8a4dcf982cb76bca9571871196c4b25a1bdd",
      "original_line" : 517,
      "original_position" : 461,
      "original_start_line" : 460,
      "path" : "src/util/bitset.h",
      "position" : 517,
      "pull_request_review_id" : 2082633346,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617148751/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 516,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2024-05-28T12:21:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617148751",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1617153576"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617153576"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't believe this is superfluous. If `I` is smaller than an `int` (e.g. `I = uint16_t`) then `~I{0}` undergoes [integer promotion](https://en.cppreference.com/w/c/language/conversion) to `int`, and right-shifting that would sign-extend, which would incorrect here. The `I(...)` around it forces it to be unsigned before the right-shift.",
      "commit_id" : "f03f3fe27dfcaf5e3fe4744a5c85e68a1480c893",
      "created_at" : "2024-05-28T12:25:11Z",
      "diff_hunk" : "@@ -0,0 +1,463 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a && b\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept {\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept {\n+        IntBitSet ret;\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept { m_val |= I{1U} << pos; }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept { m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos); }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept { m_val &= ~I(I{1U} << pos); }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept { return (m_val >> pos) & 1U; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator/=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const IntBitSet& a, const IntBitSet& b) noexcept { return a.m_val & b.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator/(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const IntBitSet& a, const IntBitSet& b) noexcept { return (b.m_val & ~a.m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    friend constexpr bool operator<=(const IntBitSet& a, const IntBitSet& b) noexcept { return (a.m_val & ~b.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>* ptr) noexcept : m_ptr(ptr), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept { m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS); }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept { m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) | (I{val} << (pos % LIMB_BITS)); }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept { m_val[pos / LIMB_BITS] &= ~I(I{1U} << (pos % LIMB_BITS)); }\n+    /** Retrieve a bit at the given position. */\n+    bool constexpr operator[](unsigned pos) const noexcept { return (m_val[pos / LIMB_BITS] >> (pos % LIMB_BITS)) & 1U; }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr MultiIntBitSet Singleton(unsigned i) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        ret.m_val[i / LIMB_BITS] = I{1U} << (i % LIMB_BITS);\n+        return ret;\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr MultiIntBitSet Fill(unsigned count) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        if (count) {\n+            unsigned i = 0;\n+            while (count > LIMB_BITS) {\n+                ret.m_val[i++] = ~I{0};\n+                count -= LIMB_BITS;\n+            }\n+            ret.m_val[i] = I(~I{0}) >> (LIMB_BITS - count);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1617153576",
      "id" : 1617153576,
      "in_reply_to_id" : 1613223825,
      "line" : 358,
      "node_id" : "PRRC_kwDOABII585gY84o",
      "original_commit_id" : "aeef8a4dcf982cb76bca9571871196c4b25a1bdd",
      "original_line" : 358,
      "original_position" : 309,
      "original_start_line" : null,
      "path" : "src/util/bitset.h",
      "position" : 358,
      "pull_request_review_id" : 2082640599,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 1,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617153576/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-28T12:25:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617153576",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1617175155"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617175155"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've added `Assume()`s in `First()` and `Last()` to avoid this.",
      "commit_id" : "f03f3fe27dfcaf5e3fe4744a5c85e68a1480c893",
      "created_at" : "2024-05-28T12:39:37Z",
      "diff_hunk" : "@@ -0,0 +1,510 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);\n+    }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val >> pos) & 1U;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator-=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    constexpr bool Overlaps(const IntBitSet& a) const noexcept { return m_val & a.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator-(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    constexpr bool IsSupersetOf(const IntBitSet& a) const noexcept { return (a.m_val & ~m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    constexpr bool IsSubsetOf(const IntBitSet& a) const noexcept { return (m_val & ~a.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>* ptr) noexcept : m_ptr(ptr), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS);\n+    }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) |\n+                                 (I{val} << (pos % LIMB_BITS));\n+    }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] &= ~I(I{1U} << (pos % LIMB_BITS));\n+    }\n+    /** Retrieve a bit at the given position. */\n+    bool constexpr operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val[pos / LIMB_BITS] >> (pos % LIMB_BITS)) & 1U;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr MultiIntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        MultiIntBitSet ret;\n+        ret.m_val[i / LIMB_BITS] = I{1U} << (i % LIMB_BITS);\n+        return ret;\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr MultiIntBitSet Fill(unsigned count) noexcept\n+    {\n+        Assume(count <= MAX_SIZE);\n+        MultiIntBitSet ret;\n+        if (count) {\n+            unsigned i = 0;\n+            while (count > LIMB_BITS) {\n+                ret.m_val[i++] = ~I{0};\n+                count -= LIMB_BITS;\n+            }\n+            ret.m_val[i] = I(~I{0}) >> (LIMB_BITS - count);\n+        }\n+        return ret;\n+    }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Compute the number of 1 bits in the bitset. */\n+    unsigned constexpr Count() const noexcept\n+    {\n+        unsigned ret{0};\n+        for (I v : m_val) ret += PopCount(v);\n+        return ret;\n+    }\n+    /** Check if all bits are 0. */\n+    bool constexpr None() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if any bits are 1. */\n+    bool constexpr Any() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return true;\n+        }\n+        return false;\n+    }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    Iterator constexpr begin() const noexcept { return Iterator(&m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    IteratorEnd constexpr end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    unsigned constexpr First() const noexcept\n+    {\n+        unsigned p = 0;\n+        while (m_val[p] == 0) ++p;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1617175155",
      "id" : 1617175155,
      "in_reply_to_id" : 1617026499,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gZCJz",
      "original_commit_id" : "beb535680b85b511709240a8e1f7de59864b3524",
      "original_line" : 393,
      "original_position" : 393,
      "original_start_line" : null,
      "path" : "src/util/bitset.h",
      "position" : null,
      "pull_request_review_id" : 2082674196,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617175155/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-28T12:39:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617175155",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1617175296"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617175296"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "f03f3fe27dfcaf5e3fe4744a5c85e68a1480c893",
      "created_at" : "2024-05-28T12:39:44Z",
      "diff_hunk" : "@@ -0,0 +1,510 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);\n+    }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val >> pos) & 1U;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator-=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    constexpr bool Overlaps(const IntBitSet& a) const noexcept { return m_val & a.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator-(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    constexpr bool IsSupersetOf(const IntBitSet& a) const noexcept { return (a.m_val & ~m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    constexpr bool IsSubsetOf(const IntBitSet& a) const noexcept { return (m_val & ~a.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>* ptr) noexcept : m_ptr(ptr), m_idx(0)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1617175296",
      "id" : 1617175296,
      "in_reply_to_id" : 1617040989,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585gZCMA",
      "original_commit_id" : "3bc131a85ce826aa171f0328c014ea51b8740fed",
      "original_line" : 247,
      "original_position" : 247,
      "original_start_line" : null,
      "path" : "src/util/bitset.h",
      "position" : null,
      "pull_request_review_id" : 2082674439,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617175296/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-28T12:39:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617175296",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1617190868"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617190868"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I'd consider SSE supporting CPUs quite common. Seems like using such instructions can offer efficiency gains but are sufficiently complex to write papers about - https://stackoverflow.com/a/42675620, something for the future maybe.",
      "commit_id" : "f03f3fe27dfcaf5e3fe4744a5c85e68a1480c893",
      "created_at" : "2024-05-28T12:50:32Z",
      "diff_hunk" : "@@ -0,0 +1,463 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a && b\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept {\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept {\n+        IntBitSet ret;\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept { m_val |= I{1U} << pos; }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept { m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos); }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept { m_val &= ~I(I{1U} << pos); }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept { return (m_val >> pos) & 1U; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator/=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const IntBitSet& a, const IntBitSet& b) noexcept { return a.m_val & b.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator/(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const IntBitSet& a, const IntBitSet& b) noexcept { return (b.m_val & ~a.m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    friend constexpr bool operator<=(const IntBitSet& a, const IntBitSet& b) noexcept { return (a.m_val & ~b.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>* ptr) noexcept : m_ptr(ptr), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept { m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS); }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept { m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) | (I{val} << (pos % LIMB_BITS)); }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept { m_val[pos / LIMB_BITS] &= ~I(I{1U} << (pos % LIMB_BITS)); }\n+    /** Retrieve a bit at the given position. */\n+    bool constexpr operator[](unsigned pos) const noexcept { return (m_val[pos / LIMB_BITS] >> (pos % LIMB_BITS)) & 1U; }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr MultiIntBitSet Singleton(unsigned i) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        ret.m_val[i / LIMB_BITS] = I{1U} << (i % LIMB_BITS);\n+        return ret;\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr MultiIntBitSet Fill(unsigned count) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        if (count) {\n+            unsigned i = 0;\n+            while (count > LIMB_BITS) {\n+                ret.m_val[i++] = ~I{0};\n+                count -= LIMB_BITS;\n+            }\n+            ret.m_val[i] = I(~I{0}) >> (LIMB_BITS - count);\n+        }\n+        return ret;\n+    }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Compute the number of 1 bits in the bitset. */\n+    unsigned constexpr Count() const noexcept\n+    {\n+        unsigned ret{0};\n+        for (I v : m_val) ret += PopCount(v);\n+        return ret;\n+    }\n+    /** Check if all bits are 0. */\n+    bool constexpr None() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if any bits are 1. */\n+    bool constexpr Any() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return true;\n+        }\n+        return false;\n+    }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    Iterator constexpr begin() const noexcept { return Iterator(&m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    IteratorEnd constexpr end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    unsigned constexpr First() const noexcept\n+    {\n+        unsigned p = 0;\n+        while (m_val[p] == 0) ++p;\n+        return std::countr_zero(m_val[p]) + p * LIMB_BITS;\n+    }\n+    /** Find the last element (requires Any()). */\n+    unsigned constexpr Last() const noexcept\n+    {\n+        unsigned p = N - 1;\n+        while (m_val[p] == 0) --p;\n+        return std::bit_width(m_val[p]) - 1 + p * LIMB_BITS;\n+    }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator|=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] |= a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator&=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] &= a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator/=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] &= ~a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Set this object's bits to be the binary XOR between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator^=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] ^= a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Check whether the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            if (a.m_val[i] & b.m_val[i]) return true;\n+        }\n+        return false;\n+    }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator&(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] & b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator|(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] | b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator/(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] & ~b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator^(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] ^ b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            if (b.m_val[i] & ~a.m_val[i]) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    friend constexpr bool operator<=(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            if (a.m_val[i] & ~b.m_val[i]) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept = default;\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(MultiIntBitSet& a, MultiIntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+} // namespace bitset_detail\n+\n+// BitSet dispatches to IntBitSet or MultiIntBitSet as appropriate for the requested minimum number\n+// of bits.\n+template<unsigned BITS>\n+using BitSet = std::conditional_t<(BITS <= 32), bitset_detail::IntBitSet<uint32_t>,\n+               std::conditional_t<(BITS <= std::numeric_limits<size_t>::digits), bitset_detail::IntBitSet<size_t>,\n+               bitset_detail::MultiIntBitSet<size_t, (BITS + std::numeric_limits<size_t>::digits - 1) / std::numeric_limits<size_t>::digits>>>;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1617190868",
      "id" : 1617190868,
      "in_reply_to_id" : 1613105680,
      "line" : 517,
      "node_id" : "PRRC_kwDOABII585gZF_U",
      "original_commit_id" : "aeef8a4dcf982cb76bca9571871196c4b25a1bdd",
      "original_line" : 517,
      "original_position" : 461,
      "original_start_line" : 460,
      "path" : "src/util/bitset.h",
      "position" : 517,
      "pull_request_review_id" : 2082699927,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617190868/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 516,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2024-05-28T12:50:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617190868",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/581308?v=4",
         "events_url" : "https://api.github.com/users/cbergqvist/events{/privacy}",
         "followers_url" : "https://api.github.com/users/cbergqvist/followers",
         "following_url" : "https://api.github.com/users/cbergqvist/following{/other_user}",
         "gists_url" : "https://api.github.com/users/cbergqvist/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/cbergqvist",
         "id" : 581308,
         "login" : "cbergqvist",
         "node_id" : "MDQ6VXNlcjU4MTMwOA==",
         "organizations_url" : "https://api.github.com/users/cbergqvist/orgs",
         "received_events_url" : "https://api.github.com/users/cbergqvist/received_events",
         "repos_url" : "https://api.github.com/users/cbergqvist/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/cbergqvist/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/cbergqvist/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/cbergqvist"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1618814697"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1618814697"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Added `std::conditional_t<(BITS <= 16), bitset_detail::IntBitSet<uint16_t>, ... ` and removed the `I()`, wrote unit test in bc36241f5a0a23d16645155eb819e94b0db2813e, and it indeed proves you are correct. Right now it cannot occur since `IntBitSet<uint32_t>` is the smallest we go, but better not to leave loaded footguns lying around.\r\n\r\n<details>\r\n<summary>Test Log</summary>\r\n\r\n```\r\n$ src/test/test_bitcoin -t bitset_tests\r\n...\r\nRunning 1 test case...\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [1 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [2 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [3 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [4 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [5 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [6 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [7 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [8 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [9 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [10 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [11 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [12 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [13 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [14 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [15 != 16]\r\n```\r\n</details>",
      "commit_id" : "f03f3fe27dfcaf5e3fe4744a5c85e68a1480c893",
      "created_at" : "2024-05-29T12:41:44Z",
      "diff_hunk" : "@@ -0,0 +1,463 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a && b\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept {\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept {\n+        IntBitSet ret;\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept { m_val |= I{1U} << pos; }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept { m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos); }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept { m_val &= ~I(I{1U} << pos); }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept { return (m_val >> pos) & 1U; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator/=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const IntBitSet& a, const IntBitSet& b) noexcept { return a.m_val & b.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator/(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const IntBitSet& a, const IntBitSet& b) noexcept { return (b.m_val & ~a.m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    friend constexpr bool operator<=(const IntBitSet& a, const IntBitSet& b) noexcept { return (a.m_val & ~b.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>* ptr) noexcept : m_ptr(ptr), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept { m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS); }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept { m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) | (I{val} << (pos % LIMB_BITS)); }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept { m_val[pos / LIMB_BITS] &= ~I(I{1U} << (pos % LIMB_BITS)); }\n+    /** Retrieve a bit at the given position. */\n+    bool constexpr operator[](unsigned pos) const noexcept { return (m_val[pos / LIMB_BITS] >> (pos % LIMB_BITS)) & 1U; }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr MultiIntBitSet Singleton(unsigned i) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        ret.m_val[i / LIMB_BITS] = I{1U} << (i % LIMB_BITS);\n+        return ret;\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr MultiIntBitSet Fill(unsigned count) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        if (count) {\n+            unsigned i = 0;\n+            while (count > LIMB_BITS) {\n+                ret.m_val[i++] = ~I{0};\n+                count -= LIMB_BITS;\n+            }\n+            ret.m_val[i] = I(~I{0}) >> (LIMB_BITS - count);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1618814697",
      "id" : 1618814697,
      "in_reply_to_id" : 1613223825,
      "line" : 358,
      "node_id" : "PRRC_kwDOABII585gfSbp",
      "original_commit_id" : "aeef8a4dcf982cb76bca9571871196c4b25a1bdd",
      "original_line" : 358,
      "original_position" : 309,
      "original_start_line" : null,
      "path" : "src/util/bitset.h",
      "position" : 358,
      "pull_request_review_id" : 2085289550,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1618814697/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-05-29T12:41:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1618814697",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/581308?v=4",
         "events_url" : "https://api.github.com/users/cbergqvist/events{/privacy}",
         "followers_url" : "https://api.github.com/users/cbergqvist/followers",
         "following_url" : "https://api.github.com/users/cbergqvist/following{/other_user}",
         "gists_url" : "https://api.github.com/users/cbergqvist/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/cbergqvist",
         "id" : 581308,
         "login" : "cbergqvist",
         "node_id" : "MDQ6VXNlcjU4MTMwOA==",
         "organizations_url" : "https://api.github.com/users/cbergqvist/orgs",
         "received_events_url" : "https://api.github.com/users/cbergqvist/received_events",
         "repos_url" : "https://api.github.com/users/cbergqvist/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/cbergqvist/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/cbergqvist/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/cbergqvist"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Added additional `Assume()`s to prevent `operator++` on iterators past the end:\r\n\r\n```diff\r\n--- a/src/util/bitset.h\r\n+++ b/src/util/bitset.h\r\n@@ -101,6 +101,7 @@ class IntBitSet\r\n         /** Progress to the next 1 bit (only if != IteratorEnd). */\r\n         constexpr Iterator& operator++() noexcept\r\n         {\r\n+            Assume(m_val != 0);\r\n             m_val &= m_val - I{1U};\r\n             if (m_val != 0) m_pos = std::countr_zero(m_val);\r\n             return *this;\r\n@@ -272,6 +273,7 @@ class MultiIntBitSet\r\n         /** Progress to the next 1 bit (only if != IteratorEnd). */\r\n         constexpr Iterator& operator++() noexcept\r\n         {\r\n+            Assume(m_idx < N);\r\n             m_val &= m_val - I{1U};\r\n             if (m_val == 0) {\r\n                 while (true) {\r\n```",
      "created_at" : "2024-05-29T15:46:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30160#issuecomment-2137732304",
      "id" : 2137732304,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30160",
      "node_id" : "IC_kwDOABII585_azTQ",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2137732304/reactions"
      },
      "updated_at" : "2024-05-29T15:46:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2137732304",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK.",
      "created_at" : "2024-06-04T14:54:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30160#issuecomment-2147744433",
      "id" : 2147744433,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30160",
      "node_id" : "IC_kwDOABII586AA_qx",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2147744433/reactions"
      },
      "updated_at" : "2024-06-04T14:54:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2147744433",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "concept ACK\r\n\r\nrequested changes were included, will continue review\r\n\r\n`git range-diff master 18ec3fc c99063e`",
      "created_at" : "2024-06-04T17:19:38Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30160#issuecomment-2148037183",
      "id" : 2148037183,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30160",
      "node_id" : "IC_kwDOABII586ACHI_",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2148037183/reactions"
      },
      "updated_at" : "2024-06-04T17:19:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2148037183",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Made a few small changes still:\r\n\r\n```diff\r\n@@ -107,7 +107,11 @@ class IntBitSet\r\n             return *this;\r\n         }\r\n         /** Get the current bit position (only if != IteratorEnd). */\r\n-        constexpr const unsigned& operator*() const noexcept { return m_pos; }\r\n+        constexpr unsigned operator*() const noexcept\r\n+        {\r\n+            Assume(m_val != 0);\r\n+            return m_pos;\r\n+        }\r\n     };\r\n \r\n public:\r\n@@ -231,6 +235,8 @@ class MultiIntBitSet\r\n     static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\r\n     /** Number of elements this set type supports. */\r\n     static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\r\n+    // No overflow allowed here.\r\n+    static_assert(MAX_SIZE / LIMB_BITS == N);\r\n     /** Array whose member integers store the bits of the set. */\r\n     std::array<I, N> m_val;\r\n     /** Dummy type to return using end(). Only used for comparing with Iterator. */\r\n@@ -293,7 +299,11 @@ class MultiIntBitSet\r\n             return *this;\r\n         }\r\n         /** Get the current bit position (only if != IteratorEnd). */\r\n-        constexpr const unsigned& operator*() const noexcept { return m_pos; }\r\n+        constexpr unsigned operator*() const noexcept\r\n+        {\r\n+            Assume(m_idx < N);\r\n+            return m_pos;\r\n+        }\r\n     };\r\n \r\n public:\r\n```",
      "created_at" : "2024-06-10T11:56:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30160#issuecomment-2158146838",
      "id" : 2158146838,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30160",
      "node_id" : "IC_kwDOABII586AorUW",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2158146838/reactions"
      },
      "updated_at" : "2024-06-10T11:56:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2158146838",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "ACK https://github.com/bitcoin/bitcoin/pull/30160/commits/47f705b33fc1381d96c99038e2110e6fe2b2f883\r\n\r\nswap coverage added, some of the nits taken, and a couple `Assume()`s added\r\n\r\nreviewed via `git range-diff master c99063e 47f705b`",
      "created_at" : "2024-06-10T13:26:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/30160#issuecomment-2158379951",
      "id" : 2158379951,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/30160",
      "node_id" : "IC_kwDOABII586ApkOv",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2158379951/reactions"
      },
      "updated_at" : "2024-06-10T13:26:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2158379951",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   }
]
